{
  "header": {
    "features": "Features",
    "news": "News",
    "faq": "FAQ",
    "faqLink": "FAQ",
    "docs": "Docs",
    "updates": "Updates",
    "selectLanguage": "Select language",
    "changeLanguageTooltip": "Change language",
    "lightMode": "Light Mode",
    "darkMode": "Dark Mode",
    "openMenu": "Open menu",
    "closeMenu": "Close menu",
    "settings": "Settings",
    "signOut": "Sign Out",
    "deleteAccount": "Delete Account",
    "deleteAccountConfirmTitle": "Confirm Account Deletion",
    "deleteAccountConfirmMessage": "Are you sure you want to delete your account? This action cannot be undone.",
    "cancel": "Cancel",
    "confirmDelete": "Confirm Deletion",
    "signIn": "Sign In"
  },
  "hero": {
    "title": "Welcome to BrainMessenger",
    "subtitle": "Your Smart Communication Platform",
    "getStarted": "Get Started",
    "learnMore": "Learn More",
    "connectSmarterTitle": "Connect Smarter with BrainMessenger",
    "connectSmarterSubtitle": "Experience the next generation of messaging with advanced features, unparalleled security, and seamless communication across all your devices.",
    "downloadButton": "Download",
    "downloadWindows": "Download for Windows",
    "downloadAndroid": "Download for Android"
  },
  "features": {
    "featuresTitle": "Key Features",
    "featuresSubtitle": "Discover what makes us unique",
    "secureMessaging": "Secure Messaging",
    "secureMessagingDesc": "End-to-end encryption for your privacy",
    "smartAssistant": "Smart Assistant",
    "smartAssistantDesc": "AI-powered help at your fingertips",
    "crossPlatform": "Cross Platform",
    "crossPlatformDesc": "Use on any device, anywhere",
    "groupChats": "Group Chats",
    "groupChatsDesc": "Connect with multiple people at once",
    "privacyFirst": "Privacy First",
    "privacyFirstDesc": "Your data is yours, always"
  },
  "news": {
    "latestNews": "Latest news",
    "readMore": "Read More"
  },
  "faq": {
    "title": "Frequently Asked Questions",
    "subtitle": "Find answers to common questions about BrainMessenger",
    "searchAlt": "Search icon",
    "searchPlaceholder": "Search questions...",
    "allQuestions": "All Questions",
    "noResults": "No questions found matching your search.",
    "categories": {
      "general": "General",
      "technical": "Technical",
      "security": "Security",
      "pricing": "Pricing",
      "generalProject": "General Project Questions",
      "technicalQuestions": "Technical Questions",
      "developmentProcesses": "Development Processes",
      "statusRoadmapFuture": "Status, Roadmap, and Future",
      "challengesOpportunitiesLimitations": "Challenges, Opportunities, and Limitations",
      "learnMoreContribute": "Learn More and Contribute"
    },
    "questionsData": {
      "generalProject": {
        "q1": {
          "question": "What is the main idea behind BrainMessenger? What makes it special?",
          "answer": "BrainMessenger is not just another messenger. Our main idea is to create a Digital ASSET (Principle 10) that simplifies complex interaction (Margulan Seisembayev's principle) and serves as a reliable tool for effective communication. We are focused on quality (Principle 3), security (Principle 5), and reliability (Principle 3), not just a set of features. We are building a SYSTEM (Principle 9) that reflects our principles and is constantly improving."
        },
        "q2": {
          "question": "What key principles underpin the development of BrainMessenger?",
          "answer": "The project is based on a set of 15 key principles (see My Key Principles), inspired by Margulan Seisembayev and IT industry best practices. The most important ones influencing code and processes are: Continuous Learning (Principle 1), Value Creation (Principle 2), Quality > Quantity (Principle 3), System and Optimization (Kaizen, Principle 9), Long-Term Thinking (Principle 8), Pragmatism and Realism (Principle 12), Persistence (Principle 13), Bias for Action (Principle 15). We strive for these principles to permeate all aspects of the project."
        },
        "q3": {
          "question": "Who is behind the project? Is it an open community or a team?",
          "answer": "Currently, the project is at an early stage and is actively being developed by one person (you), who is the driving force and bears responsibility (Principle 6) for its construction. In the future, it is planned to attract contributors and possibly form a team. The project is open for contributions (see CONTRIBUTING.md)."
        }
      },
      "technicalQuestions": {
        "q1": {
          "question": "Why was this particular technology stack chosen (TypeScript, NestJS, React/RN, PostgreSQL/Neon, GraphQL, Kafka, Redis, Cloudflare R2, etc.)?",
          "answer": "The choice of stack is based on pragmatism (Principle 12), long-term thinking (Principle 8), and the pursuit of quality (Principle 3) and scalability (NFR-14, NFR-15).\n*   TypeScript: Increases code reliability and maintainability through strong typing.\n*   NestJS: Provides a powerful, modular architecture for the Backend, simplifying the construction of scalable applications.\n*   React/React Native/Next.js: Allow building UI for different platforms from a single codebase (cross-platform) and provide good performance.\n*   PostgreSQL (Neon): A reliable, proven relational database with extensive scaling and optimization capabilities. Neon as a managed service reduces operational overhead (Pragmatism).\n*   Prisma: Chosen as a reliable ORM, providing type safety and built-in protection against SQL injection (Quality, Security).\n*   GraphQL: Allows clients to request only the data they actually need with a single query, optimizing network interaction (especially for mobile clients) and reducing data redundancy compared to REST. GraphQL also simplifies fetching related data (solving N+1 problems with DataLoader).\n*   Kafka: Chosen for reliable asynchronous task processing, which is critical for scalability and fault tolerance.\n*   Redis: High-performance In-memory store for caching, Rate Limiting, and real-time state management.\n*   Cloudflare R2: Object storage with very favorable terms (no egress fees), ideal for storing user files (Pragmatism, ASSET).\n\nThis stack allows laying a solid technical foundation (Principle 8) for future development."
        },
        "q2": {
          "question": "Why is a monolithic architecture used at the start, rather than microservices immediately?",
          "answer": "Using a monolithic architecture at the start (MVP) is a pragmatic and realistic decision (Principle 12). It allows for rapid development and iteration of basic functionality, minimizing complexity at an early stage when the team is small. Launching the MVP is more important than building an overly complex architecture. Once the MVP will be completed and the project starts to grow, a phased transition to microservices is planned (see Microservice Migration Plan)."
        },
        "q3": {
          "question": "What approaches are used to ensure security?",
          "answer": "Security is a fundamental aspect (Principle 5) and a priority (see Security Guide).\n*   Data encryption in transit (TLS 1.2+) and at rest (AES for sensitive data, encryption in R2).\n*   Strong password hashing (bcrypt/argon2).\n*   Using Prisma to prevent SQL injection.\n*   Validation of all input data on the Backend.\n*   Two-factor authentication (2FA) via email.\n*   Rate Limiting to protect against brute-force and DDoS attacks.\n*   Regular vulnerability scanning.\n*   Storing secrets in secure locations (Kubernetes Secrets)."
        },
        "q4": {
          "question": "How is real-time functionality implemented (message exchange)?",
          "answer": "Real-time functionality (message exchange) is implemented using WebSockets. The Backend (NestJS Gateway) manages WebSocket connections, and clients subscribe to chat events. Message delivery occurs via WebSocket. For scaling WebSockets in a microservice architecture, Redis Pub/Sub or Kafka will be used."
        },
        "q5": {
          "question": "Why is GraphQL used instead of REST API?",
          "answer": "GraphQL allows clients to request only the data they actually need with a single query. This optimizes network interaction (especially for mobile clients) and reduces data redundancy compared to REST. GraphQL also simplifies fetching related data (solving N+1 problems with DataLoader)."
        },
        "q6": {
          "question": "How are large volumes of data and files managed?",
          "answer": "*   Structured data (messages, users, chats): Stored in PostgreSQL (Neon). Indexes and query optimization (Prisma) are used for fast retrieval. As it grows, table partitioning and database replication are planned.\n*   Unstructured data (files, images): Stored in Cloudflare R2. Asynchronous processing (Kafka) is used for image optimization before uploading. R2 is chosen for scalability and favorable traffic rates."
        }
      },
      "developmentProcesses": {
        "q1": {
          "question": "What is the approach to project and task management?",
          "answer": "The project is managed using a planning system (see My Planning System 2025-2026) in Notion. Global goals are decomposed into stages (Roadmap), weekly planning, and a task tracker are used. An important element is the Kaizen Hour (Principle 9) for daily reflection, analyzing bottlenecks, and finding ways to improve."
        },
        "q2": {
          "question": "How is code quality ensured?",
          "answer": "Code quality is ensured through systematic approaches (Principle 3, 9):\n*   Using TypeScript with strict typing.\n*   Adhering to coding standards (ESLint, Prettier).\n*   Code review of all changes.\n*   Automated testing at different levels (Unit, Integration, E2E).\n*   Continuous Integration (CI) for automatic code and test checks on every commit/PR."
        },
        "q3": {
          "question": "What testing strategy is used?",
          "answer": "A multi-level testing strategy is used (see Testing Guide), combining manual and automated testing: Unit, Integration, API, E2E, Load, Security, Regression. Tests are integrated into CI/CD. The focus is on verifying key requirements (FRs, NFRs)."
        },
        "q4": {
          "question": "How are errors handled?",
          "answer": "Errors are handled centrally and uniformly on the Backend (NestJS Exception Filters) and converted to a standard API response format with codes (extensions.code). On the Frontend, errors are processed based on these codes, displaying a clear message to the user and suggesting an action. All errors are thoroughly logged (Winston → ELK) and sent to Sentry for tracking and analysis (see Error Specification, Monitoring Guide)."
        },
        "q5": {
          "question": "How is the project deployed?",
          "answer": "Deployment is automated through a CI/CD pipeline (GitHub Actions). Docker is used for containerization and Kubernetes for orchestration in the cloud. Infrastructure is described as code (Terraform). The process includes automatic build, testing, image publishing, and Rolling Updates in Kubernetes for zero-downtime deployment (see Deployment Guide)."
        },
        "q6": {
          "question": "How is the system monitored in production?",
          "answer": "The monitoring system is the eyes and ears of the project (Principle 9, 5). The following are used:\n*   Prometheus for collecting performance and resource metrics.\n*   Grafana for visualizing metrics and dashboards.\n*   Sentry for tracking application errors (Frontend and Backend).\n*   ELK Stack (or Kibana with Winston) for centralized logging and analysis.\n*   Alertmanager for configuring automatic alerts about problems.\nThese tools allow for proactive problem identification and optimization (see Monitoring Guide)."
        }
      },
      "statusRoadmapFuture": {
        "q1": {
          "question": "What is the current status of the project?",
          "answer": "The project is in the active development phase of the Minimum Viable Product (MVP). The main technological foundation has been laid, key UI elements and basic security have been implemented. The core messaging, file handling, and group/channel creation are in progress. (See BrainMessenger Project Requirements (MVP) Guide)."
        },
        "q2": {
          "question": "What are the next steps after completing the MVP?",
          "answer": "After completing the MVP, the next steps include adding advanced functions (audio/video calls, Premium, extended security, full set of animations and localization), further performance optimization, and preparing for scaling. A detailed plan is presented in the BrainMessenger Roadmap (see Roadmap)."
        },
        "q3": {
          "question": "Is a transition to a microservice architecture planned?",
          "answer": "Yes, the transition to microservices is part of the long-term development strategy (Principle 8). It is planned in stages, starting from Q1 2026, using the Strangler Pattern approach. This will allow components to be scaled independently, increasing fault tolerance and flexibility (see Microservice Migration Plan)."
        }
      },
      "challengesOpportunitiesLimitations": {
        "q1": {
          "question": "What are the main technical challenges (pitfalls) in the project?",
          "answer": "*   Implementing reliable real-time functionality (WebSockets): Managing thousands of simultaneous connections, reliable message delivery, managing online/offline status.\n*   Scaling the database with large data volumes: Managing the growth of the messages table (partitioning), optimizing complex queries.\n*   Handling and delivering files: Efficient uploading, image optimization, secure downloading from Cloudflare R2.\n*   Transitioning to microservices: Increased operational complexity, configuring inter-service communication (Kafka, GraphQL Federation), data migration.\n*   Maintaining high quality and performance: Continuous optimization at all levels (Backend, Frontend, Infrastructure) as load and functionality grow."
        },
        "q2": {
          "question": "What opportunities and advantages does the project's architecture and stack provide?",
          "answer": "*   High scalability: The chosen technologies (NestJS, Kubernetes, Kafka, Redis, Neon, R2) allow the application to be scaled horizontally to support a large number of users.\n*   Reliability and fault tolerance: Using reliable services, asynchronous processing (Kafka), monitoring, and, in the future, microservices increases the system's resilience to failures.\n*   High performance: GraphQL, caching, query optimization, asynchronous processing contribute to the application's fast operation.\n*   Cross-platform compatibility: React Native and Next.js allow creating applications for all major platforms from a single codebase (for UI).\n*   Code quality and maintainability: TypeScript, NestJS, Prisma, coding standards, testing simplify development and reduce the number of defects.\n*   Cost-effectiveness (at the start): Using free/affordable tiers (Neon, R2) and proven open-source solutions.\n*   Rich ecosystem: Using popular technologies with a large community and many ready-made libraries."
        },
        "q3": {
          "question": "What are the project's limitations at the current stage (MVP)?",
          "answer": "*   Limited set of features compared to the vision (no calls, Premium, enhanced security).\n*   Limited multilingualism and accessibility options (expansion planned).\n*   The architecture is currently monolithic, which imposes limitations on independent scaling of individual parts.\n*   There may be performance limitations under load significantly exceeding the target for MVP (~1000 simultaneous users) before implementing deep optimizations and microservices."
        }
      }
    }
  },
  "docs": {
    "general": {
      "title": "BrainMessenger - Your Digital Asset for Effective Communication",
      "subtitle": "Introduction: Building a System of Value",
      "introduction": {
        "title": "Introduction: Building a System of Value",
        "content": "Welcome to the BrainMessenger repository. This is not just another messenger. It is a purposeful project aimed at creating a <strong>reliable, scalable, and secure SYSTEM</strong> (Principle 9) that will become a <strong>key digital ASSET</strong> (Principle 10) for every user. Our main goal is to <strong>simplify complexity</strong> (Margulan Seisembayev's principle), providing intuitive and powerful tools for effective communication and interaction in the modern digital world.<br/><br/>BrainMessenger is built upon a <strong>strong foundation</strong> (Principle 8) of deep principles, conscious planning, and <strong>continuous learning</strong> (Principle 1). Every line of code, every decision made – this is a <strong>long-term investment</strong> (Principle 8) in the <strong>quality</strong> (Principle 3) and <strong>value</strong> (Principle 2) of our product."
      },
      "visionAndMission": {
        "title": "Vision and Mission: Our Long-Term View",
        "visionTitle": "Our Vision:",
        "visionContent": "To create a leading digital asset for communication that helps millions of users worldwide effectively exchange information, build communities, and achieve their goals.",
        "missionTitle": "Our Mission:",
        "missionContent": "To simplify complex interaction by providing a reliable, secure, and user-friendly messenger built on principles of quality, transparency, and continuous improvement."
      },
      "keyPrinciples": {
        "title": "Key Principles: The Foundation of Our System",
        "intro": "Our actions and decisions are guided by a set of key principles that serve as the <strong>foundation</strong> (Principle 8) of the entire BrainMessenger project. These are not just words, but <strong>personal algorithms and standards (Kaizen, Principle 9)</strong>, developed through experience and reflection (Principle 1):",
        "principles": [
          "<strong>Continuous Learning and Growth (Principle 1):</strong> The process of creating BrainMessenger is a proving ground for deep learning in technology, architecture, and user psychology. We learn at every step, turning mistakes into lessons.",
          "<strong>Creating Value (Principle 2):</strong> The user's benefit is at the core of everything. We build something that genuinely solves problems and makes life better.",
          "<strong>Quality Over Quantity (Principle 3):</strong> We strive to do things well, not just quickly. Reliability, thoughtfulness, and attention to detail are our priorities.",
          "<strong>Mindfulness and Presence (Principle 4):</strong> Being attentive to the process, users, and the team.",
          "<strong>Health as a Foundation (Principle 5):</strong> The physical and mental well-being of the team (and future users) is the basis for productivity and sustainability.",
          "<strong>Responsibility and Proactivity (Principle 6):</strong> We take responsibility for the outcome and act preemptively.",
          "<strong>Integrity (Principle 7):</strong> Our words align with our actions.",
          "<strong>Long-term Thinking (Principle 8):</strong> We invest time and effort with a view to the future.",
          "<strong>System and Optimization (Principle 9):</strong> We build processes and architecture as a system, constantly seeking ways to increase efficiency (Kaizen).",
          "<strong>Creating Wealth > Earning Money (Principle 10):</strong> Focusing on creating an ASSET (BrainMessenger) that brings value and works in the long term.",
          "<strong>Flexibility and Adaptability (Principle 11):</strong> Willingness to change tactics and tools while maintaining the vision.",
          "<strong>Pragmatism and Realism (Principle 12):</strong> Making decisions based on real data and capabilities.",
          "<strong>Persistence (Principle 13):</strong> Not giving up in the face of difficulties, extracting lessons from failures.",
          "<strong>Using External Expertise and Feedback (Principle 14):</strong> We learn from others, listen to constructive criticism.",
          "<strong>Bias for Action (Principle 15):</strong> In the early stages, it's more important to start doing and get feedback than to plan endlessly."
        ],
        "outro": "These principles, inspired by the philosophy of Margulan Seisembayev and the practices of leading IT companies, shape our culture and development approach."
      },
      "aboutMVP": {
        "title": "About the BrainMessenger Project (MVP Focus)",
        "intro": "Our current focus – on the development of the <strong>Minimum Viable Product (MVP)</strong>. MVP – this is the first, <strong>pragmatic</strong> (Principle 12) step towards realizing our vision. We are building a <strong>solid technical foundation</strong> (Principle 8) that will allow us to quickly and efficiently develop the product in the future.",
        "featuresTitle": "The MVP includes basic but <strong>high-quality and reliable</strong> (Principle 3) features that provide key <strong>value</strong> (Principle 2):",
        "features": [
          "<strong>Basic Messaging:</strong> Sending and receiving text messages in personal chats and groups/channels.",
          "<strong>File Sharing:</strong> Uploading and downloading files (with image optimization).",
          "<strong>Channels and Groups:</strong> Basic creation of groups/channels, joining public channels, and reading content.",
          "<strong>Basic Account Management:</strong> Registration, login/logout, profile editing (name, avatar), basic security settings.",
          "<strong>Core UI Settings:</strong> Choosing the theme (Light/Dark), basic notification and language settings.",
          "<strong>Basic Security:</strong> Data encryption (TLS, password hashing, basic measures against SQLi/XSS/DDoS), email confirmation during registration.",
          "<strong>Adaptive UI:</strong> An interface adapted for mobile (Android, iOS) and web platforms.",
          "<strong>Basic Multilingualism:</strong> Support for several interface languages (English, Russian, and others as per DocLocIn.md)."
        ],
        "outro": "Functionality beyond the MVP (audio/video calls, advanced security/privacy features, premium subscription, full animation set, AI integrations) is planned for subsequent stages of the Roadmap."
      },
      "howWeBuild": {
        "title": "How We Build: The Story of Creation and the Kaizen Process",
        "intro": "The process of creating BrainMessenger is a living story, based on our principles. We build it <strong>systematically</strong> (Principle 9), step by step, documenting each stage and continuously seeking opportunities for <strong>improvement (Kaizen)</strong>.",
        "steps": [
          "<strong>Mindful Planning (Principle 4):</strong> The project began with a clear definition of global goals and their decomposition into achievable stages (Roadmap).",
          "<strong>Choosing the Foundation (Principle 8, 12):</strong> We carefully selected the technology stack – reliable and <strong>pragmatic</strong> tools (TypeScript, NestJS, React/RN, PostgreSQL/Neon, Cloudflare R2, Kafka, Redis) that form a <strong>solid technical foundation</strong>.",
          "<strong>Building the MVP Core:</strong> Implementation started with the basic, critical parts of the system (Authentication, Basic UI, Infrastructure, File Handling). We apply <strong>Bias for Action</strong> (Principle 15), focusing on building working components, even if they are minimal for now.",
          "<strong>Continuous Learning and Applying Knowledge (Principle 1):</strong> Every new task, especially related to learning or integrating technologies (as seen in the <a href=\"https://www.notion.so/2025-2026-1576e78881b7435e9c3c2cf174e61b91?pvs=4\" target=\"_blank\" rel=\"noopener noreferrer\">Video Tracker</a> and tasks), is viewed as an opportunity for growth. We document this process through videos and reflection (Kaizen-Hour).",
          "<strong>Systemic Approach to Quality (Principle 3, 9):</strong> We integrate testing early in the development cycle (Unit tests), configure CI/CD pipelines for automated checks, and use monitoring (Prometheus, Grafana, Sentry) and logging (Winston, ELK) tools for continuous control over the <strong>system's health</strong> (Principle 5) in real time.",
          "<strong>Documentation as Part of the Knowledge System:</strong> The entire development process, architectural decisions, standards, and requirements are carefully documented. This is not just a formality, but part of creating a <strong>knowledge system</strong> that accelerates onboarding, simplifies support, and enables informed decision-making in the future."
        ],
        "outro": "We are building BrainMessenger as a living, evolving organism, constantly adapting and improving based on our principles and feedback from the development process and future users."
      },
      "technologyStack": {
        "title": "Technology Stack: Our Tools for Creating the Asset",
        "intro": "We have chosen a stack that is <strong>pragmatic</strong> (Principle 12), <strong>reliable</strong> (Principle 3), and <strong>scalable</strong> (Principle 8) to create our <strong>digital ASSET</strong>.",
        "stack": [
          "<strong>Language:</strong> <a href=\"https://www.typescriptlang.org/\" target=\"_blank\" rel=\"noopener noreferrer\">TypeScript</a> - Static typing to enhance code quality and reliability.",
          "<strong>Backend:</strong> <a href=\"https://nodejs.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Node.js</a>, <a href=\"https://nestjs.com/\" target=\"_blank\" rel=\"noopener noreferrer\">NestJS</a> - Efficient and structured framework for server logic and GraphQL API.",
          "<strong>Frontend:</strong> <a href=\"https://react.dev/\" target=\"_blank\" rel=\"noopener noreferrer\">React</a>, <a href=\"https://nextjs.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Next.js</a> (Web), <a href=\"https://reactnative.dev/\" target=\"_blank\" rel=\"noopener noreferrer\">React Native</a> (Mobile/Desktop) - Cross-platform UI development focusing on performance.",
          "<strong>API:</strong> <a href=\"https://graphql.org/\" target=\"_blank\" rel=\"noopener noreferrer\">GraphQL</a> - Flexible interaction between client and server.",
          "<strong>Real-time:</strong> WebSockets - Instant message delivery.",
          "<strong>Database:</strong> <a href=\"https://www.postgresql.org/\" target=\"_blank\" rel=\"noopener noreferrer\">PostgreSQL</a> (via <a href=\"https://neon.tech/\" target=\"_blank\" rel=\"noopener noreferrer\">Neon</a>) - Reliable and scalable database. Neon as a managed service reduces operational overhead (Pragmatism).",
          "<strong>ORM:</strong> <a href=\"https://www.prisma.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Prisma</a> - Type-safe and reliable database interaction, protection against SQL injection (Quality, Security).",
          "<strong>Caching:</strong> <a href=\"https://redis.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Redis</a> - High-performance caching and state management.",
          "<strong>Queues:</strong> <a href=\"https://kafka.apache.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Kafka</a> - Reliable asynchronous task processing.",
          "<strong>File Storage:</strong> <a href=\"https://www.cloudflare.com/developer/r2/\" target=\"_blank\" rel=\"noopener noreferrer\">Cloudflare R2</a> - Object storage with favorable pricing and no egress fees (Pragmatism, ASSET).",
          "<strong>Notifications:</strong> <a href=\"https://firebase.google.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Firebase</a> - Managed service for push notifications.",
          "<strong>Email/2FA:</strong> <a href=\"https://developers.google.com/gmail/api\" target=\"_blank\" rel=\"noopener noreferrer\">Gmail API</a> - Reliable delivery of transactional emails (Confirmation codes, 2FA).",
          "<strong>Payments:</strong> <a href=\"https://stripe.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Stripe</a>, Cryptomus (Beyond MVP) - ASSET monetization, Pragmatism.",
          "<strong>Testing:</strong> Jest, Cypress, Detox, k6, OWASP ZAP/Burp Suite (plan) - Comprehensive approach to ensuring quality.",
          "<strong>Deployment:</strong> <a href=\"https://vercel.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Vercel</a> (Web), Docker, <a href=\"https://kubernetes.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Kubernetes</a> - Automated and scalable deployment.",
          "<strong>Monitoring:</strong> Prometheus, Grafana, Sentry (plan) - System visibility and Kaizen analysis."
        ]
      },
      "architecture": {
        "title": "Architecture: The Evolution of the System",
        "intro": "Currently, BrainMessenger is implemented as a <strong>monolithic application based on NestJS</strong>. This is a <strong>pragmatic</strong> (Principle 12) decision for the MVP, allowing us to quickly launch the product and validate core hypotheses.",
        "future": "In the future, as the project grows and the load increases, we plan a phased transition to a <strong>microservice architecture</strong> using the <strong>Strangler Pattern</strong>. This is a <strong>long-term strategy</strong> (Principle 8) that will enable independent scaling and development of individual components (chats, calls, AI, payments), increasing the system's overall <strong>reliability and flexibility</strong> (Principle 3, 11).",
        "interaction": "Interaction between components will be via <strong>GraphQL API</strong> (synchronously) and <strong>Kafka</strong> (asynchronously), using <strong>Apollo Federation</strong> (in the future) to build a unified API schema from multiple microservices."
      },
      "projectStatus": {
        "title": "Project Status: Current Stage (MVP)",
        "content": "At this time, the project is in the active development stage of the <strong>MVP</strong> (as per the <a href=\"https://www.notion.so/MVP-11a2a21315e54eb3b3c90171b4c7493d?pvs=4\" target=\"_blank\" rel=\"noopener noreferrer\">MVP Requirements Instruction</a>). We are focused on completing the core messaging functionality, file handling, group/channel creation, and basic settings, while simultaneously strengthening the <strong>technical foundation</strong> (Principle 8) and embedding <strong>continuous learning</strong> and <strong>Kaizen</strong> processes into our daily work.",
        "progress": "Progress is documented through tasks, code in the repository, and video recordings that showcase our journey and the <strong>process of creation</strong> (Principle 1)."
      },
      "gettingStarted": {
        "title": "Getting Started (For Developers)",
        "intro": "Want to join us in building this digital ASSET? Here's how to get started:",
        "steps": [
          "Clone the repository:<br/>```bash<br/>git clone <URL of your repository><br/>cd BrainMessenger<br/>```",
          "Install dependencies:<br/>```bash<br/>npm install # Turborepo will install dependencies for all packages<br/>```",
          "Set up environment variables: Copy `.env.example` to `.env` and fill in the necessary data for integrations (Neon, R2, Firebase, etc.). <strong>Do not commit your `.env` file!</strong><br/>```bash<br/>cp .env.example .env<br/># Fill in .env<br/>```",
          "Set up the database: Run a local PostgreSQL or use a Neon instance, then apply Prisma migrations.<br/>```bash<br/>cd backend<br/>npx prisma migrate dev --name initial_setup # Or npx prisma migrate deploy for production<br/>cd ..<br/>```",
          "Start services in development mode:<br/>```bash<br/>turbo run dev # This will start backend and frontend dev servers<br/># Or navigate to specific packages and run their dev scripts:<br/># cd backend && npm run start:dev<br/># cd packages/web && npm run dev<br/># cd packages/mobile-desktop && npm run android / npm run windows<br/>```"
        ],
        "outro": "More detailed instructions on local setup and development can be found in the <a href=\"link_to_development_guide_doc\" target=\"_blank\" rel=\"noopener noreferrer\">Development Guide</a>."
      },
      "documentationSystem": {
        "title": "Documentation: Our System of Knowledge",
        "intro": "This README provides a high-level overview. All detailed information about the project is contained within our <strong>comprehensive system of documentation</strong>. Exploring these documents is part of the <strong>learning</strong> process (Principle 1) and understanding the <strong>system</strong> (Principle 9):",
        "links": [
          "<a href=\"docs/AllRequirements/Docs/Planning/DocReq.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Requirements Documentation</strong></a>: What we are building (functional and non-functional requirements).",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocDevIn.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Development Guide</strong></a>: How we write code (structure, standards, tools, CI/CD process).",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocTech.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Technical Documentation</strong></a>: High-level overview of the architecture and stack.",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocSpec.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>API Specification</strong></a>: How components interact (GraphQL API description).",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocInt.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Integrations Documentation</strong></a>: How we use external services (Neon, R2, Firebase, Stripe, etc.) as <strong>levers</strong>.",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocSecurity.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Security Guide</strong></a>: How we protect the ASSET and data (principles, methods, tools, process).",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocPer.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Performance Guide</strong></a>: How we make the system fast (metrics, techniques, optimization tools).",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocMonLog.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Monitoring and Logging Guide</strong></a>: How we see the system's state (metrics, logs, alerts).",
          "<a href=\"docs/AllRequirements/Docs/Design/Design/DocUI.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>UI Documentation</strong></a>: What the application looks like and why (layouts, components, design principles).",
          "<a href=\"docs/AllRequirements/Docs/Sound/DocSound.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Audio Guide</strong></a>: How audio is used to enhance UX.",
          "<a href=\"docs/AllRequirements/Docs/Support/DocSupport.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Support and Maintenance Guide</strong></a>: How we support the system and users after release.",
          "<a href=\"docs/AllRequirements/Docs/Testing/DocSpecError.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Error Specification</strong></a>: How we handle and report errors.",
          "<a href=\"docs/AllRequirements/Docs/Testing/DocTesting.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Testing Guide</strong></a>: How we verify quality and reliability.",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocMigrationMicro.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Microservice Migration Plan</strong></a>: Our long-term architectural evolution strategy.",
          "<a href=\"docs/AllRequirements/Docs/Planning/DocReq.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>MVP Requirements Instruction</strong></a>: Detailed analysis of MVP requirements and implementation status."
        ]
      },
      "contribution": {
        "title": "Contribution",
        "content": "We welcome contributions to the building of this digital ASSET! If you have ideas, suggestions, or want to help with the code, please refer to the <a href=\"CONTRIBUTING.md\" target=\"_blank\" rel=\"noopener noreferrer\">Contribution Guide</a> (if available)."
      }
    },
    "design": {
      "title": "Документация Дизайна BrainMessenger",
      "subtitle": "Система Качества и Ценности",
      "section1": {
        "title": "1. Введение: Дизайн как Фундамент Ценности",
        "name": "BrainMessenger Design System",
        "description": "Эта дизайн-система определяет визуальные и функциональные стандарты для интерфейса BrainMessenger. Наша цель — создать интерфейс, который не просто выглядит хорошо, но и является <strong>интуитивно понятным, эффективным и доступным</strong> (Принцип 2: Создание Ценности), опираясь на принципы <strong>качества > количества</strong> (Принцип 3) и <strong>прагматизма</strong> (Принцип 12) в выборе решений.",
        "goal": "Обеспечить <strong>единообразие, надежность и позитивный пользовательский опыт</strong> на всех платформах (Windows, Android, веб), делая BrainMessenger <strong>полезным АКТИВОМ</strong> (Принцип 10) для пользователей.",
        "principles_title": "Принципы, которыми руководствуется дизайн:",
        "principles": [
          "<strong>Создание Ценности (Принцип 2):</strong> Дизайн должен быть функциональным и решать задачи пользователя максимально удобно и эффективно.",
          "<strong>Качество > Количество (Принцип 3):</strong> Фокус на отточенности ключевых элементов, а не на множестве непродуманных деталей. Дизайн должен быть <strong>надежным</strong> и <strong>продуманным</strong>.",
          "<strong>Прагматизм и Реализм (Принцип 12):</strong> Выбор дизайнерских решений, реализуемых с учетом технических ограничений (например, оптимизация анимаций).",
          "<strong>Целостность (Принцип 7):</strong> Визуальная и функциональная целостность на всех платформах.",
          "<strong>Здоровье как Фундамент (Принцип 5):</strong> Внимание к доступности (WCAG), чтобы дизайн не создавал излишней нагрузки (зрительной, когнитивной) на пользователя."
        ]
      },
      "section2": {
        "title": "2. Цветовая палитра: Визуальный язык BrainMessenger",
        "intro": "Цвета разделены для Light и Dark режимов, поддерживая переключение темы (функция \"Night Mode\"). Все цвета заданы в HEX.",
        "light_mode_title": "2.1. Light Mode",
        "light_mode_table": [
          ["Категория", "Цвет (HEX)", "Назначение"],
          ["<strong>Primary Gradient</strong>", "`#A7F43A` → `#00C853`", "Основной градиент для акцентных элементов (кнопки \"Get Started\", иконки)"],
          ["<strong>Accent</strong>", "`#FF6347`", "Акцентные элементы (ошибки, важные сообщения)"],
          ["<strong>Secondary</strong>", "`#00BFFF`", "Второстепенные кнопки, ссылки, интерактивные элементы"],
          ["<strong>Success</strong>", "`#96C93D`", "Подтверждение, успешные действия"],
          ["<strong>Background</strong>", "`#FFFFFF`", "Основной фон"],
          ["<strong>Surface</strong>", "`#F0F0F0`", "Карточки, панели, фоны сообщений"],
          ["<strong>Text Primary</strong>", "`#333333`", "Основной текст"],
          ["<strong>Text Secondary</strong>", "`#4D4D4D`", "Вторичный текст, подсказки, метаданные"],
          ["<strong>Disabled</strong>", "`#B0B0B0`", "Неактивные элементы"],
          ["<strong>Border</strong>", "`#E8E8D9`", "Границы, разделители"]
        ],
        "dark_mode_title": "2.2. Dark Mode",
        "dark_mode_table": [
          ["Категория", "Цвет (HEX)", "Назначение"],
          ["<strong>Primary Gradient</strong>", "`#F2F047` → `#1ED94F`", "Основной градиент для акцентных элементов"],
          ["<strong>Accent</strong>", "`#FF6347`", "Акцентные элементы (ошибки)"],
          ["<strong>Secondary</strong>", "`#00BFFF`", "Второстепенные кнопки, ссылки"],
          ["<strong>Success</strong>", "`#96C93D`", "Подтверждение, успешные действия"],
          ["<strong>Background</strong>", "`#1A1A1A`", "Основной фон"],
          ["<strong>Surface</strong>", "`#333333`", "Карточки, панели, фоны сообщений"],
          ["<strong>Text Primary</strong>", "`#FFFFFF`", "Основной текст"],
          ["<strong>Text Secondary</strong>", "`#D9E8D9`", "Вторичный текст, подсказки"],
          ["<strong>Disabled</strong>", "`#4D4D4D`", "Неактивные элементы"],
          ["<strong>Border</strong>", "`#B0B0B0`", "Границы, разделители"]
        ],
        "premium_colors_title": "2.3. Цвета Премиум-Функций (Визуальное выделение Ценности)",
        "premium_colors": [
          "<strong>Premium Accent:</strong> `#FFD600` (Золотой)",
          "<strong>Premium Secondary:</strong> `#2196F3` (Синий)",
          "Используются для визуального выделения премиум-функций (например, в анимациях нейронных связей, специальных элементах UI), подчеркивая их <strong>дополнительную ценность</strong> (Принцип 2, 10)."
        ],
        "color_application_title": "2.4. Применение Цветов (Примеры)",
        "color_application": [
          {
            "title": "Welcome Screen (из скриншота):",
            "items": [
              "Фон: `#1A1A1A` (Dark Mode).",
              "Кнопка \"Get Started\": Градиент `#F2F047` → `#1ED94F`.",
              "Иконка чата: `#F2F047` (обводка) с белым символом внутри.",
              "Текст: `#FFFFFF` (Welcome to Brain Messenger), `#D9E8D9` (подсказка)."
            ]
          },
          {
            "title": "Переключение темы:",
            "items": [
              "Реализовано через глобальный флаг `themeMode` (`Light`/`Dark`).",
              "Пример в React Native:\n```jsx\nimport { useColorScheme } from 'react-native';\nconst themeMode = useColorScheme() === 'dark' ? 'Dark' : 'Light';\nconst backgroundColor = themeMode === 'Dark' ? '#1A1A1A' : '#FFFFFF'; // Пример выбора фона\n```"
            ]
          }
        ],
        "usage_recommendations_title": "2.5. Рекомендации по Использованию Цветов",
        "usage_recommendations": [
          "<strong>Градиенты:</strong> Используйте `#A7F43A` → `#00C853` или `#F2F047` → `#1ED94F` (в зависимости от темы) для ключевых действий и акцентных элементов, привлекающих внимание к <strong>ценности</strong> (Принцип 2).",
          "<strong>Темная тема:</strong> Используйте `#1A1A1A` или `#212121` как основной фон для снижения нагрузки на глаза (связь с Принципом 5: Здоровье).",
          "<strong>Контраст:</strong> Всегда проверяйте контрастность текста и элементов для обеспечения <strong>доступности</strong> (WCAG 2.1 AA) и соответствия Принципу 7 (Целостность). Используйте инструменты вроде WebAIM Contrast Checker."
        ]
      },
      "section3": {
        "title": "3. Типографика: Читаемость как Основа Эффективности",
        "intro": "Выбор шрифта и его применение основаны на обеспечении максимальной читаемости и доступности, что критически важно для эффективного усвоения информации и снижения когнитивной нагрузки (связь с Принципом 5: Здоровье и Принципом 2: Ценность).",
        "primary_font_title": "3.1. Основной шрифт",
        "primary_font": [
          "<strong>Семейство:</strong> Roboto (Google Fonts)",
          "<strong>Запасной:</strong> Sans-serif",
          "<strong>Причина:</strong> Высокая читаемость на разных размерах экрана, широкая поддержка символов (мультиязычность), открытая лицензия и доступность."
        ],
        "sizes_styles_title": "3.2. Размеры и стили (Шкала для Иерархии)",
        "sizes_styles_table": [
          ["Уровень", "Размер", "Начертание", "Использование"],
          ["H1 (Заголовок)", "24px", "Bold", "Основные заголовки экранов (например, \"Чаты\")"],
          ["H2 (Подзаголовок)", "18px", "Medium", "Второстепенные заголовки, названия групп"],
          ["Body", "16px", "Regular", "Основной текст сообщений, список чатов"],
          ["Caption", "14px", "Regular", "Подписи под фото, время сообщений, мелкий текст"],
          ["Button", "16px", "Medium", "Текст кнопок действий"]
        ],
        "notes_title": "Примечания:",
        "notes": [
          "<strong>Высота строки (Line Height):</strong> Минимум 1.5 для основного текста для улучшения читаемости.",
          "<strong>Кастомизация (Принцип 2):</strong> Пользователь может выбрать альтернативный шрифт в настройках (например, Open Sans) для адаптации под свои предпочтения.",
          "<strong>Доступность:</strong> Соблюдение контраста и минимального размера шрифта для соответствия WCAG."
        ]
      },
      "section4": {
        "title": "4. Анимации: Оптимизация и Смысл (Принцип 12: Прагматизм)",
        "intro": "Анимации в BrainMessenger используются для улучшения пользовательского опыта, предоставления визуальной обратной связи и придания интерфейсу живости. Однако они должны быть <strong>прагматичными, оптимизированными</strong> (<2 ГБ RAM), и <strong>не создавать излишней нагрузки</strong> (связь с Принципом 5: Здоровье).",
        "principles_title": "4.1. Принципы Анимаций",
        "principles": [
          "<strong>Смысл:</strong> Каждая анимация должна иметь четкую цель – объяснить переход, привлечь внимание к важному, подтвердить действие.",
          "<strong>Плавность:</strong> Использование `ease-in-out` или `ease-out` для натурального движения.",
          "<strong>Оптимизация:</strong> Анимации не должны замедлять интерфейс или потреблять много ресурсов. Длительность подобрана для баланса между плавностью и скоростью.",
          "<strong>Доступность:</strong> Избегание слишком быстрых или мигающих анимаций, которые могут вызвать дискомфорт или приступы у чувствительных пользователей."
        ],
        "list_title": "4.2. Список Анимаций (Примеры)",
        "list_table": [
          ["Название", "Описание", "Триггер", "Параметры", "Связь с Принципами", "Цвета (Light/Dark)"],
          ["Переключение слайдов", "Сдвиг слайдов (Welcome Screen)", "Свайп/клик по стрелке", "0.3 сек, slide left/right", "P2 (Онбординг)", "#96C93D / #96C93D"],
          ["Открытие чата", "Чат появляется снизу вверх", "Клик по чату в списке", "0.3 сек, ease-in-out", "P2 (Навигация)", "#00BFFF / #00BFFF"],
          ["Нажатие кнопки", "Визуальный фидбек при клике (уменьшение)", "Клик по кнопке", "0.2 сек, scale", "P2 (Фидбек)", "Градиент #F2F047→#1ED94F"],
          ["Отправка сообщения", "Сообщение появляется с плавным появлением", "Клик \"Отправить\"", "0.3 сек, fade-in", "P2 (Фидбек)", "#96C93D / #96C93D"],
          ["Переход между экранами", "Сдвиг экрана вправо/влево (базовая навигация)", "Навигация", "0.3 сек, slide", "P2 (Навигация)", "#B0B0B0 / #4D4D4D"],
          ["Анимация иконок (Morph)", "Преобразование иконки (например, mute → unmute)", "Клик (переключение состояния)", "0.4 сек, morph", "P2 (Состояние)", "#FF6347 / #FF6347"],
          ["Волны при нажатии (Ripple)", "Радиальные волны от точки нажатия (фидбек)", "Клик по кнопке/элементу", "0.3 сек, ripple", "P2 (Фидбек)", "#F2F047 / #F2F047"],
          ["Глитч-эффект (Premium)", "Искажение текста для премиум (визуализация)", "Активация подписки", "0.2 сек, glitch", "P2, P10 (Выделение)", "#FF6347 / #FF6347"],
          ["Нейронные связи (Premium)", "Пульсирующие линии (визуализация Актива)", "Премиум-экран", "0.5 сек, pulse", "P2, P10 (Выделение)", "#96C93D / #96C93D"]
        ],
        "implementation_examples_title": "4.3. Примеры Реализации (Фрагменты кода)",
        "css_ripple_title": "CSS для Ripple-эффекта:",
        "css_ripple_code": ".ripple {\n  background: linear-gradient(45deg, #F2F047, #1ED94F); /* Или другие цвета/градиент */\n  border-radius: 50%;\n  animation: ripple 0.3s ease-out;\n}\n@keyframes ripple {\n  to { transform: scale(2); opacity: 0; }\n}",
        "rn_icon_title": "React Native для анімованої іконки:",
        "rn_icon_code": "import Animated from 'react-native-reanimated'; // Пример библиотеки\nimport Icon from 'react-native-vector-icons/MaterialIcons'; // Пример библиотеки\n\nconst color = themeMode === 'Dark' ? '#FFFFFF' : '#333333';\n// Создание анімованого компонента Icon\nconst AnimatedIcon = Animated.createAnimatedComponent(Icon);\n\n// Пример использования с анимацией scale (припускаючи, что 'scale' - это Animated.Value)\n<AnimatedIcon name=\"volume-up\" color={color} style={{ transform: [{ scale: scale }] }} />"
      },
      "section5": {
        "title": "5. Выравнивание и Сетка: Структура и Порядок (Принцип 9: Система)",
        "intro": "Использование последовательной системы выравнивания и модульной сетки — это основа для создания <strong>системного, легко поддерживаемого и визуально гармоничного</strong> интерфейса (Принцип 9: Система).",
        "base_grid": "<strong>Базовая Сетка:</strong> 8px (базовый шаг для определения размеров элементов, отступов, интервалов). Все значения должны быть кратны 8 (или 4 для очень мелких элементов).",
        "alignment_title": "<strong>Выравнивание:</strong>",
        "alignment": [
          "Используется принцип <strong>визуальной иерархии</strong>: более важные элементы располагаются выше или визуально доминируют.",
          "<strong>Вертикальный поток:</strong> Контент на экранах организуется сверху вниз: Заголовок → Поле ввода → Кнопка действия.",
          "<strong>Горизонтальное выравнивание:</strong> Элементы в контейнерах выравниваются по левому краю (для LTR) или правому краю (для RTL), если нет необходимости в центрировании (например, заголовки в шапке).",
          "<strong>Отступы (Padding/Margin):</strong> Используются значения из шкалы, кратной 8px (8, 16, 24, 32, 40, 48 px и т.д.) для создания четких интервалов между элементами и группами элементов."
        ],
        "adaptability_title": "<strong>Адаптивность и Отзывчивость:</strong>",
        "adaptability": [
          "Дизайн адаптируется под различные размеры экрана для обеспечения <strong>ценности</strong> (Принцип 2) на любом устройстве.",
          "<strong>Мобильные устройства:</strong> 320px–767px (Обычно одноколоночный макет).",
          "<strong>Планшеты:</strong> 768px–1023px (Возможно, двухколоночный макет, боковые панели).",
          "<strong>Десктоп:</strong> 1024px+ (Широкий макет, многоколоночный дизайн, боковые панели)."
        ]
      },
      "section6": {
        "title": "6. Принципы Доступности (WCAG 2.1 AA): Дизайн для Всех (Принцип 5: Здоровье, Принцип 7: Целостность)",
        "intro": "<strong>Доступность — это не опция, а фундаментальное требование</strong> (схоже с Принципом 5: Здоровье как Фундамент) для создания <strong>целостного</strong> (Принцип 7) и <strong>ценного</strong> (Принцип 2) продукта, которым могут пользоваться все, независимо от их способностей или используемых технологий. Мы стремимся соответствовать уровню WCAG 2.1 AA.",
        "principles": [
          "<strong>Контрастность Цветов:</strong> Текстовые элементы должны иметь минимальный контраст 4.5:1 (для обычного текста) и 3:1 (для крупного текста или иконок) по отношению к фону. Это проверяется для обеих тем (Light/Dark).",
          "<strong>Навигация с Клавиатуры:</strong> Все интерактивные элементы (кнопки, ссылки, поля ввода) должны быть доступны для навигации с помощью клавиатуры (Tab, Shift+Tab) и активации (Enter, Space).",
          "<strong>Поддержка Экранных Читалок (Screen Readers):</strong> Использование семантической разметки (HTML) и ARIA-атрибутов для предоставления контекста и информации пользователям экранных читалок (например, описания для иконок, состояния элементов).",
          "<strong>Визуальный Индикатор Фокуса:</strong> Для пользователей клавиатуры должен быть четкий и видимый индикатор текущего сфокусированного элемента (например, синяя обводка `#007BFF`).",
          "<strong>Обработка Ошибок:</strong> Сообщения об ошибках должны быть четкими, понятными и легко определяемыми пользователями, включая пользователей экранных читалок.",
          "<strong>Поддержка RTL (Справа Налево):</strong> Дизайн адаптируется для языков с направлением письма справа налево (например, арабский), включая зеркальное отображение макета, иконок и текста (см. DocLocIn.md)."
        ]
      },
      "section7": {
        "title": "7. Примечания и Рекомендации",
        "notes": [
          "<strong>Кастомизация Пользователем:</strong> Помните, что некоторые аспекты дизайна (цвета чатов, шрифты) пользователь может изменять в настройках. Дизайн системы должен учитывать эту гибкость.",
          "<strong>Тестирование на Реальных Устройствах:</strong> Все компоненты дизайна необходимо тестировать на разнообразных устройствах, с различными разрешениями экрана и в разных условиях освещения, чтобы убедиться в их эффективности и доступности.",
          "<strong>Живая Документация:</strong> Эта дизайн-система — живой документ. Она будет дополняться новыми компонентами, шаблонами и рекомендациями по мере развития продукта, отражая принципы <strong>непрерывного совершенствования</strong> (Принцип 1) и <strong>системного подхода</strong> (Принцип 9).",
          "<strong>Дизайн как часть Процесса Кайдзен:</strong> Дизайн-решения анализируются и улучшаются на основе обратной связи и реального использования, интегрируясь в общий процесс Кайдзен (Принцип 9, 14)."
        ]
      }
    },
    "localizationGuide": {
      "title": "Руководство по Локализации BrainMessenger",
      "subtitle": "Доступность и Масштабирование",
      "section1": {
        "title": "1. Введение: Расширение Ценности через Доступность",
        "name": "BrainMessenger Design System",
        "description": "Это руководство описывает процесс локализации BrainMessenger — ключевой шаг для обеспечения доступности и ценности (Принцип 2) продукта для широкой аудитории по всему миру. Мы рассматриваем локализацию не просто как перевод строк, а как систематический процесс (Принцип 9) адаптации интерфейса и контента, который позволит нам масштабировать наше влияние (Принцип 2, 8).",
        "goal": "Сделать BrainMessenger понятным и удобным для пользователей из разных культур, начиная с базового набора языков и создавая надежную систему (Принцип 9) для легкого добавления новых в будущем.",
        "current_status": "Базовая поддержка английского языка (MVP). Идет планирование и подготовка к добавлению новых языков в рамках текущих этапов разработки (см. Дорожную карту).",
        "principles_title": "Принципы, которыми руководствуется локализация:",
        "principles": [
          "Создание Ценности (Принцип 2): Локализация напрямую повышает ценность продукта для неанглоязычных пользователей.",
          "Система и Оптимизация (Принцип 9): Процесс локализации строится как четкая, повторяемая система для эффективности.",
          "Прагматизм и Реализм (Принцип 12): Выбор начального набора языков основывается на потенциальном охвате и ресурсах.",
          "Внешняя Экспертиза и Обратная Связь (Принцип 14): Привлечение профессиональных переводчиков и сбор обратной связи от пользователей на разных языках."
        ]
      },
      "section2": {
        "title": "2. Цели Локализации",
        "goals": [
          "Обеспечить поддержку минимум 5 ключевых языков (Английский, Испанский, Французский, Русский, Арабский) для старта MVP — (Требование NFR-11, соответствующее Принципу 12: Прагматизм).",
          "Реализовать адаптацию пользовательского интерфейса для языков с направлением письма справа налево (RTL), таких как арабский (Принцип 2: Доступность).",
          "Поддерживать единообразие терминологии и стиля во всех переводах, используя централизованные инструменты (Принцип 9: Система).",
          "Создать эффективный и простой процесс добавления новых языков по мере роста базы пользователей и поступления запросов (Принцип 9: Масштабирование, Принцип 12: Прагматизм, Принцип 14: Обратная связь)."
        ]
      },
      "section3": {
        "title": "3. Инструменты и Технологии: Надежный Фундамент (Принцип 8, 9)",
        "intro": "Выбор инструментов основан на прагматизме (Принцип 12), надежности и поддержке системного подхода (Принцип 9).",
        "tools_table": [
          ["Инструмент", "Назначение", "Установка/Конфигурация"],
          ["i18next", "Основная библиотека для управления переводами в Frontend (React Native). Поддерживает интерполяцию, контексты.", "npm install i18next react-i18next"],
          ["react-intl", "Библиотека для локализованного форматирования дат, чисел, валют в Frontend.", "npm install react-intl"],
          ["Transifex", "Профессиональная платформа для управления переводами, привлечения переводчиков и обеспечения качества перевода.", "Регистрация на transifex.com"],
          ["rtlcss", "Утилита для автоматической трансформации CSS-стилей для поддержки RTL-языков.", "npm install -g rtlcss (глобально) или npm install rtlcss --save-dev"],
          ["JSON файлы", "Формат хранения переводов.", "Стандартный."]
        ]
      },
      "section4": {
        "title": "4. Структура Файлов Переводов: Порядок в Системе (Принцип 9)",
        "intro": "Переводы организованы в четкой файловой структуре для удобства управления (Принцип 9: Система).",
        "location_title": "4.1. Расположение",
        "location_content": "Файлы переводов хранятся в директории locales внутри frontend/src:\n\nfrontend/\n├── src/\n│ ├── locales/\n│ │ ├── en.json # Английский (базовый)\n│ │ ├── es.json # Испанский\n│ │ ├── fr.json # Французский\n│ │ ├── ru.json # Русский\n│ │ ├── ar.json # Арабский (пример RTL)\n│ └── index.ts # Конфигурация i18next",
        "format_title": "4.2. Формат JSON: Контекст и Гибкость",
        "format_content": "Ключи: Используется camelCase. Ключи должны быть описательными и отражать контекст использования строки (например, sendButton вместо просто send).\n\nЗначения: Содержат переводимый текст. Поддерживается интерполяция для вставки динамических данных (например, имена пользователей).",
        "format_example": "Пример en.json:\n\n```json\n{\n  \"welcomeTitle\": \"Welcome to BrainMessenger!\",\n  \"sendButton\": \"Send\",\n  \"errors\": {\n    \"unauthorized\": \"Please log in again to continue.\",\n    \"notFound\": \"The requested item could not be found.\"\n  },\n  \"chat\": {\n    \"newMessageNotification\": \"New message from {{name}}\",\n    \"unreadCount\": \"{{count}} unread messages\"\n  },\n  \"settings\": {\n    \"language\": \"Language\",\n    \"theme\": \"Theme\"\n  }\n}\n```",
        "rtl_flag_title": "4.3. RTL-флаг: Адаптация Интерфейса",
        "rtl_flag_content": "Для языков с направлением справа налево в начало соответствующего JSON-файла добавляется метаданные для индикации:",
        "rtl_flag_example": "```json\n{\n  \"rtl\": true,\n  \"welcomeTitle\": \"مرحبًا بك في BrainMessenger!\"\n  // ... остальные переводы\n}\n```\n\nЭтот флаг используется Frontend-приложением для соответствующей адаптации стилей и макета."
      },
      "section5": {
        "title": "5. Настройка Локализации: Интеграция в Систему (Принцип 9)",
        "intro": "Локализация интегрируется как в Frontend (для отображения переведенного UI), так и в Backend (для возврата локализованных ошибок или уведомлений).",
        "frontend_title": "5.1. Frontend (React Native): Использование i18next",
        "frontend_init_title": "Инициализация i18next:",
        "frontend_init_code": "В главном файле приложения или файла конфигурации (frontend/src/index.ts или подобном):\n\n```jsx\nimport i18n from 'i18next'\nimport { initReactI18next } from 'react-i18next'\n\n// Импорт всех файлов локалей\nimport en from './locales/en.json'\nimport es from './locales/es.json'\nimport fr from './locales/fr.json'\nimport ru from './locales/ru.json'\nimport ar from './locales/ar.json'\n\n// Определение ресурсов\nconst resources = {\n  en: { translation: en },\n  es: { translation: es },\n  fr: { translation: fr },\n  ru: { translation: ru },\n  ar: { translation: ar },\n};\n\ni18n\n  .use(initReactI18next) // Подключение react-i18next\n  .init({\n    resources,\n    lng: 'en', // Язык по умолчанию при первом запуске (может определяться по системным настройкам или выбору пользователя)\n    fallbackLng: 'en', // Резервный язык, если текущий перевод отсутствует\n    interpolation: {\n      escapeValue: false // Позволяет использовать HTML теги в переводах (осторожно!)\n    }\n  });\n\nexport default i18n;\n```",
        "frontend_usage_title": "Использование перевода в компонентах:",
        "frontend_usage_code": "Используйте хук useTranslation для доступа к функции t и объекту i18n.\n\n```jsx\nimport { useTranslation } from 'react-i18next';\nimport { Text, Button, View } from 'react-native';\n\nconst WelcomeScreen = () => {\n  const { t, i18n } = useTranslation(); // Получаем функцию t и объект i18n\n\n  return (\n    <View>\n      {/* Использование простого перевода */}\n      <Text>{t('welcomeTitle')}</Text>\n      \n      {/* Использование перевода с интерполяцией */}\n      {/* Предполагается, что где-то есть состояние unreadCount */}\n      <Text>{t('chat.unreadCount', { count: 5 })}</Text> \n\n      {/* Использование перевода для текста кнопки */}\n      <Button title={t('sendButton')} onPress={sendMessage} />\n      \n      {/* Пример смены языка */}\n      <Button title={t('settings.language')} onPress={() => i18n.changeLanguage('ar')} />\n    </View>\n  );\n};\n```",
        "frontend_change_title": "Смена языка:",
        "frontend_change_content": "Язык меняется вызовом i18n.changeLanguage('код_языка'). Обычно это делается в настройках пользователя.",
        "backend_title": "5.2. Backend (NestJS): Локализация Ошибок и Уведомлений",
        "backend_intro": "Backend может возвращать локализованные сообщения об ошибках или уведомления, опираясь на язык, переданный Frontend (например, в заголовке Accept-Language или настройках пользователя).",
        "backend_code": "Использование локализованных сообщений при выбрасывании ошибок:\n\n```typescript\nimport { HttpException, HttpStatus } from '@nestjs/common';\nimport { t } from 'i18next'; // Предполагается, что i18next инициализирован и в Backend\n\n// В сервисе или контроллере\nif (!user) {\n  // Определяем язык пользователя (например, из request.headers['accept-language'])\n  const userLang = determineUserLanguage(request); \n  throw new HttpException(t('errors.unauthorized', { lng: userLang }), HttpStatus.UNAUTHORIZED);\n}\n```",
        "backend_note": "Локаль пользователя определяется из заголовка Accept-Language (стандартный подход) или сохраняется в профиле пользователя в базе данных после его выбора в настройках приложения.",
        "rtl_adaptation_title": "5.3. RTL-адаптация (Справа Налево): Зеркальное Отображение Системы",
        "rtl_adaptation_intro": "Для языков с RTL (арабский, иврит и др.) необходимо зеркально отобразить макет и некоторые элементы интерфейса.",
        "rtl_css_title": "Стили (CSS/CSS-in-JS):",
        "rtl_css_code": "Используйте rtlcss в процессе сборки или условные стили в коде. rtlcss автоматически преобразует свойства вроде margin-left, padding-right, text-align: left и т.п. в их RTL-эквиваленты (margin-right, padding-left, text-align: right).\n\n```css\n/* Исходный CSS для LTR */\n.message-bubble {\n  margin-left: 10px;\n  text-align: left;\n}\n/* После обработки rtlcss для RTL */\n.message-bubble {\n  margin-right: 10px;\n  text-align: right;\n}\n```",
        "rtl_rn_title": "React Native:",
        "rtl_rn_code": "React-Native имеет встроенную поддержку RTL через I18nManager.\n\n```jsx\nimport { I18nManager } from 'react-native';\nimport i18n from './index'; // Ваш файл инициализации i18next\n\n// В главном файле приложения, перед рендером\nconst isRTL = i18n.language === 'ar' || i18n.language === 'he'; // Проверяем, является ли текущий язык RTL\n\n// ForceRTL может потребовать перезагрузки приложения для полной силы\nif (isRTL !== I18nManager.isRTL) {\n  I18nManager.forceRTL(isRTL);\n  // Optional: Restart the app to apply RTL layout fully\n  // RNRestart.Restart(); \n}\n\n// Некоторые стили могут требовать ручной адаптации, если auto-conversion недостаточно\nconst containerStyle = {\n  flexDirection: isRTL ? 'row-reverse' : 'row',\n  textAlign: isRTL ? 'right' : 'left',\n};\n```",
        "rtl_icons_title": "Иконки:",
        "rtl_icons_content": "Некоторые иконки (например, стрелки \"назад\", \"далее\") должны быть зеркально отображены для RTL. Это можно делать условно в коде или использовать RTL-ready наборы иконок."
      },
      "section6": {
        "title": "6. Процесс Добавления Нового Языка: Масштабируемая Система (Принцип 9)",
        "intro": "Процесс добавления нового языка построен как четкая, повторяемая последовательность действий для обеспечения эффективности (Принцип 9).",
        "file_title": "Создание базового файла перевода:",
        "file_content": "Скопируйте актуальный en.json (или другой наиболее полный файл) в frontend/src/locales/<code>.json, где <code> — двухбуквенный код нового языка (например, de.json для немецкого).\nДобавьте rtl: true в начало файла, если новый язык RTL.",
        "transifex_title": "Загрузка на платформу переводов (Transifex):",
        "transifex_content": "Загрузите новый файл <code>.json в проект BrainMessenger на Transifex. Система автоматически определит, какие строки нуждаются в переводе.",
        "process_title": "Организация процесса перевода:",
        "process_content": "Назначьте переводчиков (профессионалов или проверенных участников сообщества, Принцип 14) для нового языка в Transifex.\nОтвечайте на их вопросы по контексту строк.\nКонтролируйте прогресс перевода в Transifex.",
        "export_title": "Экспорт и Интеграция перевода:",
        "export_content": "После завершения перевода экспортируйте готовый файл <code>.json из Transifex.\nПоместите его обратно в директорию frontend/src/locales/.\nИмпортируйте новый ресурс в файле инициализации i18next (frontend/src/index.ts) и добавьте его в объект resources.",
        "ui_title": "Добавление опции выбора языка в UI:",
        "ui_content": "Добавьте новый язык в список доступных языков в разделе \"Настройки\" > \"Язык\".",
        "testing_title": "Тестирование:",
        "testing_intro": "Критически важный шаг (Принцип 3: Качество). Переключите язык в настройках приложения.",
        "testing_scenarios": [
          "Корректность перевода всех строк в UI.",
          "Отсутствие обрезки текста (некоторые языки длиннее английского).",
          "Корректное отображение UI для RTL-языков (зеркальность, выравнивание).",
          "Интерполяция и Форматирование: Проверьте экраны, где используются динамические данные (имена, счетчики, даты, числа), убедитесь, что они форматируются правильно для текущей локали.",
          "Локализованные ошибки: Инициируйте различные ошибки (неправильный логин, отсутствие элемента), проверьте, что сообщения об ошибках приходят на выбранном языке."
        ]
      },
      "section7": {
        "title": "7. Поддерживаемые Языки (Начальный Список и План)",
        "intro": "Начальный список языков, выбранный по прагматическим соображениям (Принцип 12) и потенциальному охвату.",
        "languages_table": [
          ["Код", "Язык", "Направление", "Статус", "План (Q 2025)"],
          ["en", "Английский", "LTR", "Реализован (Базовый)", "-"],
          ["es", "Испанский", "LTR", "В плане (Q3)", "Q3"],
          ["fr", "Французский", "LTR", "В плане (Q3)", "Q3"],
          ["ru", "Русский", "LTR", "В плане (Q3)", "Q3"],
          ["ar", "Арабский", "RTL", "В плане (Q3, требуется RTL)", "Q3"]
        ],
        "expansion_note": "Расширение списка: Новые языки будут добавляться на основе обратной связи (Принцип 14) и анализа потенциальной ценности (Принцип 2) для роста аудитории (например, если >10% запросов о поддержке нового языка)."
      },
      "section8": {
        "title": "8. Рекомендации: Лучшие Практики Локализации",
        "dev_title": "8.1. Для Разработчиков (Пишем Код, Готовый к Миру)",
        "dev_points": [
          "Не хардкодьте строки! Все строки, которые видит пользователь, должны быть вынесены в файлы локализации и использоваться через функцию t('ключ') (Принцип 9: Система).",
          "Используйте интерполяцию для строк с переменными данными (t('chat.newMessageNotification', { name: user.name })), а не конкатенацию строк в коде.",
          "Учитывайте плюрализацию (формы единственного/множественного числа) при работе со счетчиками ({{count}} unread messages). i18next и react-intl поддерживают это.",
          "Используйте react-intl для всех операций с датами, числами, валютами, чтобы их формат был корректным для каждой локали (Принцип 3: Качество, Принцип 2: Ценность).",
          "Тестируйте UI с длинными переводами (например, немецкий, который часто длиннее английского) и RTL-языками, чтобы убедиться, что макет не ломается и текст не обрезается (Принцип 3: Качество)."
        ],
        "design_title": "8.2. Для Дизайнеров (Рисуем Макеты, Гибкие к Языкам)",
        "design_points": [
          "Учитывайте, что текст на других языках может быть на 30% (и более) длиннее английского. Оставляйте достаточно пространства в компонентах.",
          "Проектируйте макеты с учетом зеркального отображения для RTL. Иконки направлений, расположение текста и элементов должны меняться (Принцип 2: Доступность)."
        ],
        "translator_title": "8.3. Для Переводчиков (Создаем Понятный Контент)",
        "translator_points": [
          "Сохраняйте контекст. Одно и то же английское слово может переводиться по-разному в зависимости от того, где оно используется (например, \"Send\" для сообщения или для заявки). Платформы вроде Transifex помогают добавлять контекстные комментарии.",
          "Придерживайтесь последовательной терминологии, используйте глоссарий, если он есть.",
          "Сохраняйте тон приложения (дружелюбный, но профессиональный, особенно в системных сообщениях и ошибках).",
          "Используйте возможности интерполяции и плюрализации в файлах перевода."
        ]
      },
      "section9": {
        "title": "9. Форматирование (Даты, Числа, Валюты): Детали, Создающие Качество (Принцип 3)",
        "intro": "Корректное отображение локализованных данных критически важно для качества (Принцип 3) и удобства (Принцип 2).",
        "dates_title": "Даты и Время:",
        "dates_code": "```jsx\nimport { FormattedDate, FormattedTime } from 'react-intl';\n\n// Отобразит дату в формате, соответствующем текущей локали\n<FormattedDate value={new Date()} /> // Например, \"3/14/2025\" (en-US) или \"14.3.2025\" (de-DE)\n<FormattedDate value={new Date()} weekday=\"long\" year=\"numeric\" month=\"long\" day=\"numeric\" /> // \"Friday, March 14, 2025\"\n\n// Отобразит время\n<FormattedTime value={new Date()} /> // Например, \"3:00:00 PM\" (en-US) или \"15:00:00\" (de-DE)\n```",
        "numbers_title": "Числа и Валюты:",
        "numbers_code": "```jsx\nimport { FormattedNumber, FormattedCurrency } from 'react-intl';\n\n// Отобразит число с локальным разделителем тысяч и десятичным знаком\n<FormattedNumber value={1234.56} /> // \"1,234.56\" (en-US) или \"1.234,56\" (de-DE)\n\n// Отобразит число как процент\n<FormattedNumber value={0.75} style=\"percent\" /> // \"75%\"\n\n// Отобразит число как валюту (требует кода валюты)\n<FormattedCurrency value={123.45} currency=\"USD\" /> // \"$123.45\" (en-US)\n```\n\nДля работы с react-intl необходимо обернуть ваше приложение в IntlProvider и загрузить соответствующие данные локали (react-intl/locale-data)."
      },
      "section10": {
        "title": "10. Тестирование Локализации: Гарантия Качества (Принцип 3, 9)",
        "intro": "Тестирование — неотъемлемая часть системы обеспечения качества (Принцип 3, 9).",
        "scenarios_title": "Сценарии Тестирования:",
        "scenarios_points": [
          "Переключение языка: Убедитесь, что смена языка в настройках мгновенно (или после перезапуска, если требуется I18nManager) применяет новый перевод и RTL-макет.",
          "Отображение всех строк: Проверьте основные экраны и диалоги, чтобы убедиться, что все видимые пользователю строки переведены.",
          "Длинный текст: Проверьте UI с языками, известными своей длиной (например, немецкий, русский), чтобы убедиться, что текст не обрезается, элементы не накладываются друг на друга.",
          "RTL-интерфейс: Тщательно проверьте UI на арабском (или другом RTL-языке): направление текста, выравнивание элементов, отображение иконок направлений, положение скроллбаров.",
          "Интерполяция и Форматирование: Проверьте экраны, где используются динамические данные (имена, счетчики, даты, числа), убедитесь, что они форматируются правильно для текущей локали.",
          "Локализованные ошибки: Инициируйте различные ошибки (неправильный логин, отсутствие элемента), проверьте, что сообщения об ошибках приходят на выбранном языке."
        ],
        "tools_title": "Инструменты:",
        "tools_points": [
          "Ручное тестирование: Основной метод. Тестирование на реальных устройствах с разными локалями.",
          "Автоматизированные тесты (Cypress/detox): Можно написать тесты, которые проверяют наличие определенных ключей перевода на странице или даже делают скриншоты UI для сравнения LTR/RTL макетов (Принцип 9: Система)."
        ],
        "criteria_title": "Критерии Успеха Тестирования:",
        "criteria_points": [
          "100% пользовательских строк переведены.",
          "Отсутствие обрезки или наложения текста в UI.",
          "Корректное и полное RTL-отображение для соответствующих языков.",
          "Правильное локализованное форматирование дат, чисел, валют."
        ]
      },
      "section11": {
        "title": "11. Примечания",
        "notes": [
          "План: Полная реализация поддержки 5 ключевых языков запланирована на Q3 2025 (см. Дорожную карту), после завершения этапа построения технологического фундамента и начала разработки MVP.",
          "Масштабирование: Система разработана так, чтобы добавление новых языков в будущем было эффективным (Принцип 9). Основные затраты — это сам перевод.",
          "Ограничения: Технические логи, сообщения сервера для отладки не переводятся. Локализация касается только пользовательского интерфейса и сообщений, предназначенных для конечного пользователя."
        ]
      }
    },
    "userGuide": {
      "title": "BrainMessenger User Guide",
      "subtitle": "Your Hub for Effective Communication and Growth",
      "introduction": {
        "title": "1. Introduction: Welcome to Your Interaction System",
        "p1": "<strong>Welcome to BrainMessenger!</strong>",
        "p2": "BrainMessenger is not just a messenger, but <strong>your personal system</strong> for secure, convenient, and <strong>effective communication and interaction</strong> (Principle 2: Value Creation, Principle 9: System). We created this <strong>digital ASSET</strong> (Principle 10) to <strong>simplify complexity</strong> (Margulan), providing you with a reliable tool for connecting with others and organizing your communication.",
        "p3": "This guide is your compass in the world of BrainMessenger. It is structured so you can quickly master key functions and use the application as <strong>effectively</strong> as possible (Principle 9).",
        "p4": "<strong>For whom:</strong> BrainMessenger is designed for a wide audience and is available on all major platforms: iOS (version 13+), Android (version 9+), as well as a full-fledged web version for modern browsers (Chrome, Firefox, Safari, Edge). We strive for maximum <strong>accessibility</strong> (Principle 5) for everyone.",
        "p5": "<strong>How to start:</strong> The most <strong>pragmatic</strong> (Principle 12) way is to install the application from the respective app store or open the website `https://brainmessenger.com`."
      },
      "gettingStarted": {
        "title": "2. Getting Started: First Steps in the BrainMessenger System",
        "p1": "Your registration and login process is designed as a <strong>simple and secure system</strong> (Principle 9, 5).",
        "registration": {
          "title": "2.1. Registration: Creating Your Profile in the System",
          "steps": [
            "1. Open the application or go to the website.",
            "2. Click the <strong>\"Get Started\"</strong> (Register) button on the welcome screen.",
            "3. Follow the step-by-step instructions:",
            "<strong>Enter Email:</strong> Your active email address (e.g., `user@example.com`). It will be used for notifications, login, and access recovery. Make sure the email format is correct.",
            "<strong>Create Password:</strong> Come up with a <strong>strong password</strong> (minimum 8 characters, including at least one digit and one special character, e.g., `MyStrongP@ss!1`). The security of your account is part of our <strong>foundation</strong> (Principle 5, 8).",
            "<strong>Enter Name:</strong> Your display name in BrainMessenger.",
            "<strong>Confirm Email:</strong> We will send an 8-digit confirmation code to the specified email (see API Specification, DocInt). Check your mail (including the \"Spam\" folder). Enter the code in the application.",
            "4. Click the confirmation button at each step."
          ],
          "result": "*Result:* Your account has been successfully created. You become part of the <strong>BrainMessenger system</strong>."
        },
        "login": {
          "title": "2.2. Login: Accessing Your Interaction Network",
          "steps": [
            "1. On the welcome screen, select <strong>\"Log In\"</strong> (Sign In).",
            "2. Enter your registered email and password.",
            "3. Click <strong>\"Log In\"</strong> (Sign In)."
          ],
          "note": "*Note:* If you have two-factor authentication (2FA) enabled for additional security (see section 3.5), you will need to enter an additional code received by email after entering your password."
        },
        "logout": {
          "title": "2.3. Logout: Ending Your Current Session",
          "steps": [
            "1. Open the main menu (usually a \"burger\" icon or your avatar in the top corner).",
            "2. Go to the <strong>\"Settings\"</strong> section.",
            "3. Scroll down and select <strong>\"Log Out\"</strong>.",
            "4. Confirm your action if required."
          ]
        }
      },
      "mainFunctions": {
        "title": "3. Key Functions: Tools for Effective Communication (Principle 2)",
        "p1": "BrainMessenger provides a set of <strong>tools</strong> (Principle 10) for various types of communication, focused on providing you with <strong>value</strong> (Principle 2).",
        "chatsAndMessages": {
          "title": "3.1. Chats and Messages: Your Personal Communication System Space",
          "sections": [
            "<strong>View chats:</strong> The main screen displays a <strong>systematically organized</strong> (Principle 9) list of all your chats (personal, group, channels). Chats with new messages are always at the top.",
            "<strong>Creating a new chat:</strong>",
            "1. Click the <strong>\"+\"</strong> icon (usually in the top right corner).",
            "2. Select <strong>\"New Chat\"</strong> or \"New Group\", \"New Channel\".",
            "3. Select contacts or add participants, specify a name (for groups/channels).",
            "4. Click <strong>\"Create\"</strong>.",
            "<strong>Sending a message:</strong>",
            "1. Open the desired chat.",
            "2. Enter text in the message input field at the bottom.",
            "3. Click the <strong>\"Send\"</strong> icon.",
            "<strong>Sending files:</strong>",
            "1. In the message input field, click the paperclip icon.",
            "2. Select a file (photo, video, document). The maximum file size for upload is 100 MB.",
            "3. Click <strong>\"Send\"</strong>. Files are securely stored in Cloudflare R2 (see DocInt).",
            "<strong>Searching chats and messages:</strong> Use the search bar at the top of the Main screen. Searching is fast and <strong>effective</strong> (Principle 9).",
            "<strong>Archiving chats:</strong> To remove a chat from the main list without deleting it, swipe it left (on mobile) or use the context menu and select <strong>\"Archive\"</strong>. Access to the archive is through the main menu. Part of your workspace <strong>organization system</strong> (Principle 9)."
          ]
        },
        "calls": {
          "title": "3.2. Calls and Video Calls: Direct Interaction",
          "sections": [
            "<strong>Start a call:</strong> In an open chat, click the phone (audio) or camera (video) icon.",
            "<strong>Conferences:</strong> Create a group chat and use the \"Start Call\" function.",
            "<strong>Call history:</strong> View a list of all past calls in the <strong>\"Calls\"</strong> section of the main menu.",
            "<strong>Quality settings:</strong> During a call, you can select video/audio quality (low, medium, high) for <strong>pragmatic</strong> (Principle 12) use of internet traffic."
          ]
        },
        "filesAndMedia": {
          "title": "3.3. Files and Media: Centralized Access to Exchange",
          "sections": [
            "<strong>Viewing files from chat:</strong> In an open chat, go to the chat information (click on the name/avatar in the header) and select the <strong>\"Media\"</strong> section. All files you have exchanged in this chat are collected here. You can filter them by type."
          ]
        },
        "contacts": {
          "title": "3.4. Contacts: Managing Your Connection Network",
          "sections": [
            "<strong>Contact list:</strong> Available in the <strong>\"Contacts\"</strong> section of the main menu.",
            "<strong>Search and add:</strong> Search for existing users or add new ones by email/phone."
          ]
        },
        "settings": {
          "title": "3.5. Settings: Adapting the System to Yourself (Principle 2)",
          "p1": "The \"Settings\" section allows you to personalize BrainMessenger, making it more <strong>valuable and convenient</strong> specifically for you.",
          "sections": [
            "<strong>Profile:</strong> Change name, photo, email, password. Configure security settings (e.g., enable <strong>two-factor authentication (2FA)</strong> for additional account protection). Related to <strong>responsibility</strong> (Principle 6) for your data security.",
            "<strong>Notifications:</strong> Configure notification types, sounds, vibration.",
            "<strong>Appearance (Theme):</strong> Select <strong>\"Light\"</strong> or <strong>\"Dark\"</strong> theme. Dark theme can reduce eye strain (related to Principle 5: Health).",
            "<strong>Language:</strong> Select the interface language from the list of available languages. Changes apply quickly. Right-to-left (RTL) languages are supported, making the application <strong>accessible</strong> (Principle 2, 5) for different regions (see DocLocIn).",
            "<strong>Battery and Animation Settings:</strong> Enable or disable interface animations. This is a <strong>pragmatic</strong> (Principle 12) solution for saving battery life and device resources (Principle 5).",
            "<strong>Chat Settings (Customization):</strong> In each chat, you can change its visual appearance (background colors, fonts), which adds <strong>value</strong> (Principle 2) through personalization."
          ]
        },
        "premiumSubscription": {
          "title": "3.6. Premium Subscription: Additional Features and Support for Asset Development (Principle 2, 10)",
          "p1": "Premium subscription provides access to advanced features that enhance the <strong>value</strong> (Principle 2) of your experience, and is a way to support the <strong>long-term development</strong> (Principle 8) of BrainMessenger as a <strong>digital Asset</strong> (Principle 10).",
          "sections": [
            "<strong>Benefits:</strong> Familiarize yourself with exclusive Premium features in the <strong>\"Settings\" → \"Premium\"</strong> section.",
            "<strong>Purchase:</strong> Select a tariff plan and subscribe through a secure payment system (Stripe, see DocInt).",
            "<strong>Payment history:</strong> View information about your transactions."
          ]
        }
      },
      "faq": {
        "title": "4. Frequently Asked Questions (FAQ): Quick Answers from the Knowledge System",
        "p1": "This section contains answers to typical questions, based on our <strong>accumulated experience</strong> (Principle 1, 14).",
        "q1": {
          "question": "Q: What should I do if I didn't receive a confirmation code during registration?",
          "answer": "A: Check your \"Spam\" folder in your email. If there is no code, return to the code entry screen and click <strong>\"Resend Code\"</strong>."
        },
        "q2": {
          "question": "Q: How to restore password?",
          "answer": "A: On the login screen, click <strong>\"Forgot Password?\"</strong> and follow the instructions sent to your email."
        },
        "q3": {
          "question": "Q: How to delete my account and data?",
          "answer": "A: You can initiate account deletion in <strong>\"Settings\" → \"Profile\"</strong> by selecting <strong>\"Delete Account\"</strong>. Your data will be securely deleted in accordance with the privacy policy (see DocSecurity)."
        },
        "q4": {
          "question": "Q: Does BrainMessenger support end-to-end encryption?",
          "answer": "A: Yes, the security and <strong>integrity</strong> (Principle 7) of your data is our priority. All personal chats use end-to-end encryption."
        }
      },
      "tips": {
        "title": "5. Useful Tips: Optimizing Your Experience (Principle 9)",
        "p1": "A few tips for more <strong>effective</strong> (Principle 9) use of BrainMessenger:",
        "sections": [
          "<strong>Use onboarding:</strong> The first screen with a slider contains useful information about the application.",
          "<strong>Optimize performance on your device:</strong> If the application runs slowly or consumes a lot of battery, try disabling animations in <strong>\"Settings\" → \"Battery & Animations\"</strong>. This is a <strong>pragmatic</strong> step to preserve your device's <strong>health</strong> (Principle 5).",
          "<strong>Keep chats organized:</strong> Use the archiving function to hide less relevant dialogues.",
          "<strong>Explore settings:</strong> Explore all options in \"Settings\" to fully adapt the application to yourself."
        ]
      },
      "support": {
        "title": "6. Support: We Are Ready to Assist (Principle 2, 14)",
        "p1": "If you have questions or problems, please contact us. Your <strong>feedback</strong> helps us <strong>improve the system</strong> (Principle 9).",
        "sections": [
          "<strong>Via the app:</strong> Open the main menu, select <strong>\"Support\"</strong> → <strong>\"Contact Us\"</strong>.",
          "<strong>By email:</strong> You can also write to us directly at `support@brainmessenger.com`."
        ],
        "p2": "We strive to respond to requests quickly and provide you with the most useful <strong>assistance</strong> (Margulan)."
      }
    },
    "devGuide": {
      "title": "Руководство по Разработке BrainMessenger",
      "subtitle": "Применение Принципов в Коде",
      "introduction": {
        "title": "1. Введение: Процесс Разработки как Система Совершенствования",
        "description": "Этот документ является вашим путеводителем по процессу разработки BrainMessenger. Мы строим этот проект не хаотично, а как <strong>целостную систему</strong> (Принцип 9), где каждый участник команды (или вы сами) действует в соответствии с <strong>четкими стандартами и принципами</strong>, стремясь к <strong>постоянному совершенствованию</strong> (Принцип 1, 9). Этот процесс напрямую влияет на <strong>качество</strong> (Принцип 3) конечного продукта и его превращение в <strong>ценный АКТИВ</strong> (Принцип 10).",
        "goal": "Обеспечить <strong>единый, эффективный и масштабируемый</strong> процесс разработки, упростить онбординг новых участников и поддерживать высокий уровень <strong>качества кода и архитектуры</strong> на каждом этапе, включая глубокое изучение и применение технологий (как видно по трекеру видео).",
        "audience": "Все, кто пишет код или управляет процессом разработки BrainMessenger (Frontend, Backend, Mobile, Desktop, DevOps разработчики).",
        "principles_title": "Принципы, которыми руководствуется процесс разработки:",
        "principles": [
          "<strong>Система и Оптимизация (Принцип 9):</strong> Структура репозитория, стандарты кодирования, CI/CD, использование инструментов — все направлено на создание эффективной и предсказуемой системы. <strong>Кайдзен</strong> применяется к самому процессу разработки.",
          "<strong>Качество > Количество (Принцип 3):</strong> Приоритет отдается написанию чистого, тестируемого и поддерживаемого кода, даже если это занимает больше времени на старте.",
          "<strong>Постоянное Обучение (Принцип 1):</strong> Процесс разработки включает изучение новых технологий, их прагматичное применение и рефлексию над полученным опытом (как документируется в видео трекере и Кайдзен-часах).",
          "<strong>Прагматизм и Реализм (Принцип 12):</strong> Выбор инструментов и подходов, подходящих для текущего этапа проекта, без излишней сложности.",
          "<strong>Долгосрочное Мышление (Принцип 8):</strong> Архитектурные решения принимаются с прицелом на будущее масштабирование и поддерживаемость. Код пишется так, чтобы его было легко развивать.",
          "<strong>Ответственность и Проактивность (Принцип 6):</strong> Каждый разработчик несет ответственность за качество своего кода, тесты и активно участвует в улучшении процессов."
        ]
      },
      "repoStructure": {
        "title": "2. Структура Репозитория: Монорепо как Система Организации Кода",
        "description": "Проект организован как <strong>монорепозиторий</strong>, используя <strong>Turborepo</strong> для управления пакетами. Это — сознательный выбор, призванный повысить <strong>эффективность</strong> (Принцип 9) за счет переиспользования кода и <strong>оптимизации</strong> (Принцип 9) процессов сборки и тестирования.",
        "core_title": "<code>core</code>:",
        "core_content": "Содержит код, который является <strong>ядром системы</strong> (Принцип 9) и может быть использован на любой платформе (API-клиент, общие утилиты, бизнес-логика, не связанная с UI/сервером). Переиспользование повышает <strong>эффективность</strong> (Принцип 9) и <strong>согласованность</strong> (Принцип 7).",
        "mobile_desktop_title": "<code>mobile-desktop</code>:",
        "mobile_desktop_content": "Содержит код для <strong>клиентского Актива</strong> (Принцип 10) на мобильных и десктопных платформах.",
        "web_title": "<code>web</code>:",
        "web_content": "Содержит код для <strong>клиентского Актива</strong> на веб-платформе.",
        "backend_title": "<code>backend</code>:",
        "backend_content": "Содержит код <strong>серверной части системы</strong>, обрабатывающей запросы, взаимодействующей с БД и внешними сервисами. Это критически важный <strong>рычаг</strong> (Маргулан) для работы всего приложения.",
        "infrastructure_title": "<code>infrastructure</code>:",
        "infrastructure_content": "Содержит конфигурации для <strong>развертывания системы</strong> (Принцип 9) на облачных ресурсах.",
        "docs_title": "<code>docs</code>:",
        "docs_content": "Содержит <strong>документацию — часть системы знаний</strong> (Принцип 1), необходимую для эффективной работы и онбординга.",
        "turbo_title": "<code>turbo.json</code>:",
        "turbo_content": "Определяет, как Turborepo управляет задачами (сборка, тестирование, линтинг) по всему монорепо, используя <strong>кэширование и параллельное выполнение</strong> для <strong>оптимизации</strong> (Принцип 9) времени разработки."
      },
      "techStack": {
        "title": "3. Технологический Стек: Инструменты для Построения Фундамента (Принцип 8)",
        "intro": "Выбор стека основывается на <strong>прагматизме, надежности и потенциале для долгосрочного развития</strong> (Принцип 8, 12). Мы используем <strong>проверенные технологии</strong>, которые позволяют быстро строить, но при этом закладывать <strong>прочный фундамент</strong> (Принцип 8).",
        "table": [
          ["Компонент", "Технология", "Версия", "Назначение", "Связь с Принципами"],
          ["Frontend: Mobile", "React Native", "0.72+", "Создание UI для Android из единой кодовой базы.", "P9 (Система), P12 (Прагматизм), P2 (Ценность - кроссплатформа)."],
          ["Frontend: Desktop", "React Native for Windows (RNW)", "0.72+", "Создание UI для Windows из единой кодовой базы.", "P9 (Система), P12 (Прагматизм), P2 (Ценность - кроссплатформа)."],
          ["Frontend: Web", "Next.js, Tailwind CSS", "14.x", "Веб-приложение с SSR/SSG для SEO и производительности, утилитарная стилизация.", "P2 (Ценность), P9 (Система - фреймворк), P12 (Прагматизм)."],
          ["Frontend: Общее", "TypeScript", "5.x", "Строгая статическая типизация для повышения <strong>качества и надежности</strong> кода.", "P3 (Качество), P9 (Система - предсказуемость)."],
          ["Backend", "Node.js, NestJS", "22.x, 10.x", "Серверная логика, GraphQL API, высокая производительность Node.js, модульность NestJS.", "P9 (Система - модульность), P8 (Долгосрочное - масштабируемость Node.js)."],
          ["ORM", "Prisma", "5.x", "Удобная и безопасная работа с базой данных (PostgreSQL).", "P3 (Качество - безопасность запросов), P9 (Система - абстракция БД)."],
          ["База данных", "PostgreSQL (Neon)", "15.x", "Основное хранилище структурированных данных. Надежная реляционная СУБД.", "P8 (Долгосрочное), P9 (Система), P12 (Прагматизм)."],
          ["Хранилище Файлов", "Cloudflare R2 (S3-совместимое)", "-", "Хранение медиафайлов и бинарных данных. Выгодно и масштабируемо.", "P10 (Активы), P12 (Прагматизм), P8 (Долгосрочное)."],
          ["Кэширование", "Redis", "7.x", "Кэширование данных, Rate Limiting, управление присутствием WebSocket.", "P9 (Система - эффективность), P3 (Качество - снижение нагрузки), P5 (Здоровье - отзывчивость)."],
          ["Асинхронность", "Kafka", "3.x", "Надежная асинхронная обработка фоновых задач (обработка изображений).", "P9 (Система - разделение ответственности), P3 (Качество - надежность)."],
          ["Оркестрация", "Kubernetes", "1.24+", "Управление контейнерами, автоматическое масштабирование, самовосстановление.", "P8 (Долгосрочное), P9 (Система - управление сложностью), P3 (Качество - отказоустойчивость)."],
          ["Инфраструктура", "Terraform", "1.5+", "Автоматизация создания и управления инфраструктурой (IaC).", "P9 (Система - автоматизация), P3 (Качество - предсказуемость инфраструктуры)."],
          ["Тестирование", "Jest, Cypress, Detox", "-", "Модульные, интеграционные, E2E-тесты для обеспечения <strong>качества</strong>.", "P3 (Качество), P9 (Система - автоматизация проверки)."],
          ["Профилирование", "V8 Profiler, Chrome DevTools", "-", "Инструменты для <strong>измерения и оптимизации производительности</strong>.", "P1 (Обучение), P9 (Система - Кайдзен), P13 (Настойчивость)."],
          ["Мониторинг Kafka", "Kafdrop", "-", "Визуальный мониторинг очередей Kafka.", "P9 (Система), P5 (Здоровье - системы, видимость проблем)."]
        ]
      },
      "codingStandards": {
        "title": "4. Стандарты Кодирования: Дисциплина как Основа Качества (Принцип 3, 9)",
        "intro": "Соблюдение стандартов кодирования — это проявление <strong>дисциплины</strong> и часть <strong>системы обеспечения качества</strong>. Это делает код предсказуемым, легко читаемым и поддерживаемым другими разработчиками (или вами самими в будущем).",
        "generalPrinciples": {
          "title": "4.1. Общие Принципы",
          "principles": [
            "<strong>DRY (Don’t Repeat Yourself):</strong> Избегайте дублирования кода. Используйте общие функции, компоненты, хуки в пакете <code>core</code>.",
            "<strong>KISS (Keep It Simple, Stupid):</strong> Стремитесь к простоте решений. Не усложняйте без необходимости. <strong>Упрощать сложное</strong> (Маргулан) применимо и к коду.",
            "<strong>Именование:</strong> Используйте английский язык для всех идентификаторов (переменные, функции, классы), комментариев. Будьте последовательны.",
            "<strong>Комментарии:</strong> Обязательны для:",
            "Сложной бизнес-логики (например, обработка платежей, управление WebSocket-соединениями).",
            "Интеграций с внешними сервисами (где могут быть неочевидные детали API).",
            "Критических участков кода (аутентификация, шифрование, работа с множествами).",
            "Неочевидных решений или обходных путей (с объяснением почему)."
          ]
        },
        "namingConventions": {
          "title": "4.2. Конвенции Именования",
          "conventions": [
            "<strong>Переменные и функции:</strong> <code>camelCase</code> (например, <code>getUserProfile</code>, <code>chatMessage</code>).",
            "<strong>Классы и модули:</strong> <code>PascalCase</code> (например, <code>UserService</code>, <code>ChatModule</code>).",
            "<strong>Константы:</strong> <code>UPPER_SNAKE_CASE</code> (например, <code>MAX_FILE_SIZE</code>, <code>DEFAULT_TIMEOUT</code>).",
            "<strong>Файлы и папки:</strong> <code>kebab-case</code> (например, <code>user-service.ts</code>, <code>chat-screen.tsx</code>, <code>image-processing</code>).",
            "<strong>API Endpoints (в контексте GraphQL):</strong> Резолверы и их поля именуются согласно доменной модели, часто следуя REST-подобной логике (например, query <code>getUser</code>, mutation <code>sendMessage</code>)."
          ]
        },
        "formattingLinting": {
          "title": "4.3. Форматирование и Линтинг: Автоматизация Поддержания Порядка",
          "intro": "Используйте автоматические инструменты для обеспечения единообразного форматирования и соблюдения базовых правил кодирования. Это часть <strong>системы автоматизации качества</strong> (Принцип 9).",
          "prettier_title": "<strong>Форматирование:</strong> <strong>Prettier</strong> — автоматический форматтер кода.",
          "prettier_content": "Настройте <code>.prettierrc</code> в корне проекта. Рекомендуемые настройки: 2 пробела для отступов, отсутствие точек с запятой в конце строк, одинарные кавычки для строк.",
          "prettier_code": "```json\n{\n  \"tabWidth\": 2,\n  \"semi\": false,\n  \"singleQuote\": true,\n  \"trailingComma\": \"es5\"\n}\n```",
          "eslint_title": "<strong>Линтинг:</strong> <strong>ESLint</strong> — статический анализатор кода для выявления проблем.",
          "eslint_content": "Используйте конфигурацию вроде Airbnb или Standard, адаптированную для TypeScript, React/React Native, NestJS. Настройте правила в <code>.eslintrc.js</code>.\nИнтегрируйте ESLint в ваш редактор кода для получения обратной связи в реальном времени."
        },
        "codeStructure": {
          "title": "4.4. Структура Кода: Модульность и Четкие Границы",
          "intro": "Код организован модульно внутри каждого пакета, следуя принципам <strong>системности</strong> (Принцип 9) и разделения ответственности.",
          "corePackage": {
            "title": "Core (<code>packages/core</code>):",
            "points": [
              "<code>api/</code>: Код для взаимодействия с GraphQL API BrainMessenger (Apollo Client).",
              "<code>hooks/</code>: Переиспользуемые хуки для React/React Native.",
              "<code>utils/</code>: Чистые функции-утилиты, не зависящие от конкретной платформы."
            ]
          },
          "mobileDesktopPackage": {
            "title": "Mobile-Desktop (<code>packages/mobile-desktop</code>):",
            "points": [
              "<code>components/</code>: Небольшие, переиспользуемые UI-компоненты (<code>Button</code>, <code>MessageBubble</code>).",
              "<code>screens/</code>: Компоненты, представляющие целые экраны (<code>ChatScreen</code>, <code>SettingsScreen</code>).",
              "<code>theme/</code>: Файлы с цветовыми схемами и типографикой, определенные в DocDesign.",
              "<code>platform/</code>: Код, специфичный для Android или Windows (например, работа с нативными модулями)."
            ]
          },
          "webPackage": {
            "title": "Web (<code>packages/web</code>):",
            "points": [
              "<code>pages/</code>: Компоненты страниц Next.js.",
              "<code>components/</code>: UI-компоненты для веба (могут переиспользовать логику из <code>core/hooks</code> или <code>core/utils</code>).",
              "<code>styles/</code>: Файлы стилей (Tailwind CSS)."
            ]
          },
          "backendPackage": {
            "title": "Backend (<code>backend</code>):",
            "points": [
              "Структура NestJS: Модули (<code>auth</code>, <code>user</code>, <code>chat</code>, <code>message</code>), сервисы (<code>AuthService</code>, <code>UserService</code>), контроллеры (для REST, если есть) или резолверы (для GraphQL), DTO (Data Transfer Objects), Entities (определенные Prisma).",
              "<code>src/</code>: Исходный код.",
              "<code>test/</code>: Тесты."
            ]
          }
        }
      },
      "libraries": {
        "title": "5. Используемые Библиотеки: Выбор Правильных Инструментов (Принцип 12)",
        "intro": "Мы выбираем библиотеки, которые решают задачи <strong>прагматично</strong> (Принцип 12), обеспечивают <strong>качество</strong> (Принцип 3) и хорошо интегрируются в нашу <strong>систему</strong> (Принцип 9).",
        "common": {
          "title": "5.1. Общие (Core)",
          "libs": [
            "<code>@apollo/client</code> (и связанные): Клиент GraphQL для выполнения запросов к Backend API. Используется в <code>core</code> и импортируется в <code>mobile-desktop</code> и <code>web</code>. Обеспечивает <strong>эффективность</strong> (Принцип 9) за счет управления кэшем."
          ]
        },
        "mobileDesktop": {
          "title": "5.2. Mobile-Desktop (React Native)",
          "libs": [
            "<code>react-native-reanimated</code>, <code>moti</code>, <code>lottie-react-native</code>: Библиотеки для создания <strong>плавных и производительных анимаций</strong> (см. DocDesign). Связано с Принципом 3 (Качество UI) и Принципом 5 (Здоровье - снижение нагрузки).",
            "<code>@react-navigation/native</code> (и связанные): Навигация между экранами приложения. <strong>Системное</strong> (Принцип 9) управление переходами.",
            "<code>react-native-sound</code>: Базовая библиотека для воспроизведения звуков (сообщения, звонки). См. Документацию звуков."
          ]
        },
        "web": {
          "title": "5.3. Web (Next.js)",
          "libs": [
            "<code>next</code>, <code>react</code>, <code>react-dom</code>: Основа веб-приложения. Next.js обеспечивает <strong>систему</strong> (Принцип 9) для SSR, SSG, маршрутизации и <strong>оптимизации</strong> (см. DocOptimizationIn).",
            "<code>tailwindcss</code>: Утилитарный CSS-фреймворк для быстрой и <strong>прагматичной</strong> (Принцип 12) стилизации.",
            "<code>framer-motion</code>: Библиотека для <strong>качественных</strong> (Принцип 3) анимаций в вебе."
          ]
        },
        "backend": {
          "title": "5.4. Backend (NestJS)",
          "libs": [
            "<code>@nestjs/*</code>: Основные пакеты NestJS (core, common, platform-express/fastify, graphql, typeorm/prisma, jwt, passport, websockets и т.д.). Обеспечивают <strong>модульную, масштабируемую систему</strong> (Принцип 9).",
            "<code>@nestjs/prisma</code>: Интеграция NestJS и Prisma.",
            "<code>graphql</code>, <code>@nestjs/graphql</code>, <code>apollo-server-express</code>: Реализация GraphQL API.",
            "<code>@prisma/client</code>: Клиент Prisma ORM для взаимодействия с Neon (PostgreSQL).",
            "<code>@aws-sdk/client-s3</code>, <code>@aws-sdk/s3-request-presigner</code>: Работа с Cloudflare R2 (S3-совместимый).",
            "<code>ioredis</code>: Клиент Redis для кэширования и других задач.",
            "<code>kafkajs</code>: Клиент Kafka для асинхронных задач.",
            "<code>firebase-admin</code>: SDK для Firebase (Push-уведомления).",
            "<code>stripe</code>: SDK для Stripe (Платежи).",
            "<code>googleapis</code>: SDK для Google APIs (Gmail API).",
            "<code>bcrypt</code> или <code>argon2</code>: Библиотека для <strong>безопасного</strong> (Принцип 3, 5) хэширования паролей."
          ]
        },
        "crossPackage": {
          "title": "5.5. Общие (Cross-Package)",
          "libs": [
            "<code>typescript</code>: Язык разработки.",
            "<code>winston</code> или <code>pino</code>: Библиотека для <strong>структурированного логирования</strong> (Принцип 9).",
            "<code>@sentry/node</code>, <code>@sentry/react</code>, <code>@sentry/react-native</code>: Клиенты Sentry для <strong>отслеживания ошибок</strong> в продакшене (часть системы <strong>качества</strong> и <strong>Кайдзен</strong>).",
            "<code>core-js</code>, <code>regenerator-runtime</code>: Полифиллы для поддержки современных возможностей JavaScript в старых средах (например, новые методы Set в ES2024).",
            "<code>zod</code> или <code>class-validator</code>/<code>class-transformer</code>: Библиотеки для <strong>валидации данных</strong>, обеспечения <strong>качества</strong> (Принцип 3) на входе в систему."
          ]
        },
        "setMethods": {
          "title": "5.6. Работа с Множествами (Set) в ES2024+: Пример Применения Новых Знаний (Принцип 1)",
          "intro": "<strong>Постоянное обучение</strong> (Принцип 1) и применение <strong>прагматичных</strong> (Принцип 12) инструментов языка — это часть нашей философии. Новые методы объекта <code>Set</code> в ECMAScript 2024 (поддержка в Node.js 22+, современных браузерах) предоставляют <strong>более чистый, читаемый и часто более эффективный</strong> (Принцип 9) способ работы с уникальными наборами данных по сравнению с ручными циклами или преобразованиями в массивы.",
          "areas": {
            "title": "Области применения в BrainMessenger:",
            "points": [
              "Управление списками пользователей в групповых чатах (добавление/удаление участников).",
              "Отслеживание уникальных активных сессий или соединений WebSocket.",
              "Управление правами доступа (проверка, входит ли набор разрешений в доступные).",
              "Синхронизация списков (например, контактов, чатов) между клиентом и сервером, определение добавленных/удаленных элементов."
            ]
          },
          "keys": {
            "title": "Ключевые Методы (из ES2024):",
            "points": [
              "<code>union(iterable)</code>: Возвращает новое <code>Set</code> со всеми уникальными элементами из текущего <code>Set</code> и переданного итерируемого объекта.",
              "<code>intersection(iterable)</code>: Возвращает новое <code>Set</code> с элементами, присутствующими в <strong>обоих</strong> множествах.",
              "<code>difference(iterable)</code>: Возвращает новое <code>Set</code> с элементами, присутствующими в текущем <code>Set</code>, но <strong>не</strong> в переданном итерируемом объекте.",
              "<code>symmetricDifference(iterable)</code>: Возвращает новое <code>Set</code> с элементами, которые есть в <strong>одном</strong>, но не в <strong>обоих</strong> множествах.",
              "<code>isSubsetOf(iterable)</code>: Проверяет, являются ли все элементы текущего <code>Set</code> подмножеством переданного итерируемого объекта (<code>true</code> или <code>false</code>).",
              "<code>isSupersetOf(iterable)</code>: Проверяет, содержит ли текущий <code>Set</code> все элементы переданного итерируемого объекта (<code>true</code> или <code>false</code>).",
              "<code>isDisjointFrom(iterable)</code>: Проверяет, не имеют ли текущий <code>Set</code> и переданный итерируемый объект общих элементов (<code>true</code> или <code>false</code>)."
            ]
          },
          "examples": {
            "title": "Примеры Использования в Коде (TypeScript):",
            "code": "```typescript\n// backend/src/chat/chat.service.ts (пример управления участниками группы)\nasync updateGroupMembers(groupId: string, currentMemberIds: Set<string>, newMemberIds: Set<string>) {\n  // Принцип 9: Оптимизация и ясность\n  const addedMembers = newMemberIds.difference(currentMemberIds);\n  const removedMembers = currentMemberIds.difference(newMemberIds);\n  const unchangedMembers = currentMemberIds.intersection(newMemberIds); // Для проверки\n\n  console.log('Added:', addedMembers);\n  console.log('Removed:', removedMembers);\n\n  // Выполнить операции добавления/удаления в БД через Prisma\n  if (addedMembers.size > 0) {\n    await this.prisma.userChat.createMany({\n      data: Array.from(addedMembers).map(userId => ({ groupId, userId })),\n    });\n  }\n  if (removedMembers.size > 0) {\n    await this.prisma.userChat.deleteMany({\n      where: {\n        groupId: groupId,\n        userId: { in: Array.from(removedMembers) },\n      },\n    });\n  }\n\n  // Проверка прав: Убедиться, что текущий пользователь имеет право изменять состав группы\n  const requiredPermission = new Set(['manage_members']);\n  const userPermissions = new Set(await this.getUserPermissions(userId, groupId)); // Получить права пользователя\n  const hasPermission = requiredPermission.isSubsetOf(userPermissions); // Проверка через новый метод\n  if (!hasPermission) {\n      throw new ForbiddenException(\"Недостаточно прав для изменения состава группы.\");\n  }\n}\n\n// frontend/src/hooks/useChats.ts (пример синхронизации списка чатов)\nfunction useSyncChats(localChats: Set<string>, serverChats: string[]) {\n    // Принцип 9: Эффективность синхронизации\n    const serverChatsSet = new Set(serverChats);\n    const newChats = serverChatsSet.difference(localChats);\n    const removedChats = localChats.difference(serverChatsSet);\n\n    console.log('Новые чаты:', newChats);\n    console.log('Удаленные чаты:', removedChats);\n\n    // Обновить локальное состояние/UI на основе newChats и removedChats\n    // ...\n}\n",
            "recommendations": [
              "Применяйте их для операций с уникальными наборами данных. Они разработаны специально для этого и часто более производительны, чем аналогичные операции с массивами, особенно для больших объемов данных.",
              "Учитывайте совместимость: Новые методы доступны в Node.js 22+ и современных браузерах. Если вам нужно поддерживать старые среды, используйте полифиллы (core-js/proposals/set-methods-v2).",
              "Типизация в TypeScript: Всегда указывайте тип элементов в Set (например, Set<string>, Set<number>) для лучшей проверки типов и автодополнения."
            ]
          }
        }
      },
      "devProcess": {
        "title": "6. Процесс Разработки: Наша Система Рабочего Потока (Принцип 9)",
        "intro": "Четкий процесс разработки обеспечивает системность, качество и предсказуемость (Принцип 9).",
        "envSetup": {
          "title": "6.1. Установка Окружения: Подготовка к Работе",
          "intro": "Клонируйте репозиторий:",
          "cloneRepo": {
            "title": "Клонируйте репозиторий:",
            "code": "```bash\ngit clone <https://github.com/xAI/BrainMessenger.git> # Пример\ncd BrainMessenger\n```"
          },
          "installDeps": {
            "title": "Установите зависимости:",
            "code": "```bash\nnpm install\n```"
          },
          "envVars": {
            "title": "Настройте переменные окружения:",
            "code": "```bash\ncp .env.example .env\n# Заполните .env данными для Neon, R2, Redis, Kafka, API Gateways, Stripe, Firebase, Gmail API\n```",
            "note": "Важно иметь рабочие локальные или тестовые инстансы БД, Redis, Kafka или использовать их облачные версии для разработки."
          },
          "prismaClient": {
            "title": "Сгенерируйте Prisma Client:",
            "code": "```bash\ncd backend\nnpx prisma generate\ncd ..\n```"
          },
          "localDb": {
            "title": "Настройте локальную БД (если не используете облачную):",
            "code": "```bash\ncd backend\nnpx prisma migrate dev --name initial_setup\ncd ..\n```"
          }
        },
        "localRun": {
          "title": "6.2. Локальный Запуск: Активация Системы для Разработки",
          "intro": "Используйте команды turbo run или специфические команды пакетов.",
          "runAll": {
            "title": "Запуск всех сервисов (Backend, Web) для разработки:",
            "code": "```bash\nturbo run dev # Запустит dev-серверы для всех пакетов с задачей 'dev' в turbo.json\n```"
          },
          "runBackend": {
            "title": "Отдельный запуск Backend:",
            "code": "```bash\ncd backend\nnpm run start:dev # или npm run start:debug для отладки\n```"
          },
          "runMobileDesktop": {
            "title": "Отдельный запуск Mobile-Desktop (React Native):",
            "code": "```bash\ncd packages/mobile-desktop\nnpm run android # для запуска на Android эмуляторе/устройстве\nnpm run windows # для запуска на Windows\n```"
          },
          "runWeb": {
            "title": "Отдельный запуск Web (Next.js):",
            "code": "```bash\ncd packages/web\nnpm run dev\n```"
          }
        },
        "commitsBranches": {
          "title": "6.3. Коммиты и Ветки: Структура Развития Кода (Принцип 9)",
          "intro": "Мы используем четкую стратегию веток и стандарты для коммитов для поддержания порядка (Принцип 9) и ясной истории изменений (Принцип 7).",
          "mainBranches": {
            "title": "Основная ветка разработки:",
            "points": [
              "<code>develop</code>. Все новые функции и исправления интегрируются сюда.",
              "Стабильная ветка: <code>main</code>. Только проверенный код из <code>develop</code> (через релизные PR)."
            ]
          },
          "workBranches": {
            "title": "Ветки для работы:",
            "points": [
              "<code>feature/<название_фичи></code>: Для разработки новой функциональности (например, <code>feature/graphql-auth</code>).",
              "<code>fix/<название_исправления></code>: Для исправления ошибок (например, <code>fix/chat-message-scroll</code>).",
              "<code>refactor/<название></code>: Для рефакторинга кода."
            ]
          },
          "commitFormat": {
            "title": "Формат коммитов:",
            "example": "Используйте Conventional Commits. Это упрощает генерацию changelog и понимание цели каждого коммита.\n\nПример:\n\n<code>feat(backend/auth): add JWT authentication</code> (новая функция в модуле аутентификации backend)\n\n<code>fix(mobile/chat): resolve message display bug on scroll</code> (исправление бага отображения сообщений в мобильном чате)\n\n<code>docs(roadmap): update Q3 2025 plan</code> (обновление документации)\n\n<code>chore(deps): update prisma to 5.x</code> (рутинная задача, обновление зависимости)",
            "structure": "Структура: <code>тип(scope): описание</code>\n\n<code>тип</code>: <code>feat</code>, <code>fix</code>, <code>docs</code>, <code>chore</code>, <code>style</code>, <code>refactor</code>, <code>test</code>, <code>ci</code>, <code>perf</code>, <code>build</code>\n\n<code>scope</code>: Необязательно, указывает пакет или область (<code>backend</code>, <code>web</code>, <code>mobile-desktop</code>, <code>core</code>, <code>auth</code>, <code>chat</code>, <code>ui</code>, <code>infra</code> и т.п.)."
          }
        },
        "prCodeReview": {
          "title": "6.4. Pull Request (PR) и Код-Ревью: Коллективное Обеспечение Качества (Принцип 3, 14)",
          "intro": "Каждый Pull Request — это возможность получить обратную связь (Принцип 14), улучшить код и обеспечить качество (Принцип 3) перед интеграцией в основную ветку.",
          "prDescription": {
            "title": "Описание PR:",
            "points": [
              "Четко опишите, какую проблему решает PR или какую функцию добавляет.",
              "Ссылайтесь на соответствующую задачу в Jira (например, [BM-123]) или другое место отслеживания задач.",
              "Опишите основные изменения и любые потенциальные риски или вопросы."
            ]
          },
          "prRequirements": {
            "title": "Требования к PR:",
            "points": [
              "Код должен соответствовать стандартам кодирования (линтер, форматтер).",
              "Все тесты должны проходить (<code>npm test</code>). Настройте проверку в GitHub Actions.",
              "Должно быть минимум 1 одобрение (аппрув) от другого разработчика (или от вас самого, если работаете в одиночку, но стремитесь к идеалу код-ревью).",
              "Для нетривиальных изменений может потребоваться ревью от более опытного разработчика или архитектора."
            ]
          }
        },
        "testing": {
          "title": "6.5. Тестирование: Проверка Надежности Системы (Принцип 3)",
          "intro": "Тестирование — неотъемлемая часть процесса обеспечения качества (Принцип 3). Мы используем многоуровневый подход.",
          "runAllTests": {
            "title": "Запуск всех тестов:",
            "code": "```bash\nnpm run test # Запустит тесты для всех пакетов (unit, integration)\n```"
          },
          "testTypes": {
            "title": "Виды тестов:",
            "points": [
              "Модульные тесты (Unit Tests): Тестирование отдельных функций или классов изолированно (Jest). Фокус: Корректность мелких частей кода.",
              "Интеграционные тесты (Integration Tests): Тестирование взаимодействия между несколькими компонентами (например, сервис -> БД, API -> сервис) (Jest). Фокус: Правильность связей между частями системы.",
              "E2E-тесты (End-to-End Tests): Тестирование пользовательских сценариев в приложении (Cypress для Web, Detox для React Native). Фокус: Работа системы в целом с точки зрения пользователя."
            ]
          },
          "ciCdTests": {
            "title": "Настройте автоматический запуск тестов в CI/CD (GitHub Actions) на каждый PR и пуш в develop.",
            "content": "Настройте автоматический запуск тестов в CI/CD (GitHub Actions) на каждый PR и пуш в develop."
          }
        }
      },
      "devRecommendations": {
        "title": "7. Рекомендации по Разработке: Лучшие Практики Построения Актива",
        "intro": "Применяйте эти рекомендации для создания качественного, поддерживаемого кода, который станет основой вашего цифрового Актива (Принцип 3, 10).",
        "corePackage": {
          "title": "7.1. Core Пакет: Переиспользование для Эффективности",
          "points": [
            "API-клиент (<code>@apollo/client</code>): Используйте его для всех запросов GraphQL из Frontend. Настройте кэширование (InMemoryCache) и обработку ошибок. Это снижает дублирование кода и обеспечивает единый способ взаимодействия с API.",
            "Общие Хуки/Утилиты: Выносите сюда логику, которая повторяется на разных платформах (форматирование данных, валидация, работа с токенами)."
          ]
        },
        "mobileDesktop": {
          "title": "7.2. Mobile-Desktop (React Native)",
          "points": [
            "Функциональные Компоненты: Используйте React Hooks и функциональные компоненты. Разделяйте компоненты на \"умные\" (с логикой) и \"глупые\" (только UI).",
            "Стилизация: Используйте StyleSheet.create для производительности или библиотеки вроде styled-components / NativeBase для системности.",
            "Нативная Оптимизация: Изучите специфику RNW и RN (например, работа с нативными модулями для повышения производительности критических участков, анимации на нативном потоке с Reanimated)."
          ]
        },
        "web": {
          "title": "7.3. Web (Next.js)",
          "points": [
            "Маршрутизация и Fetching: Используйте возможности Next.js (File-system routing, getStaticProps, getServerSideProps, getStaticPaths) для оптимизации загрузки страниц (SSR/SSG) и SEO (Принцип 2).",
            "Стилизация: Tailwind CSS ускоряет разработку UI. Следуйте принципам из DocDesign.",
            "Оптимизация Изображений: Используйте next/image для автоматической оптимизации изображений."
          ]
        },
        "backend": {
          "title": "7.4. Backend (NestJS)",
          "points": [
            "GraphQL API: Следуйте принципам GraphQL (запрашивать только нужное). Используйте DataLoader для решения проблемы N+1 (см. DocOptimizationIn).",
            "Prisma: Используйте ORM для всех взаимодействий с БД. Это обеспечивает безопасность (защита от SQL-инъекций - Принцип 3, 5) и типизацию.",
            "Сервисы: Выносите основную бизнес-логику в сервисы. Контроллеры/Резолверы должны быть тонкими (только обработка запроса и вызов сервиса).",
            "Интеграции: Взаимодействие с внешними сервисами (R2, Firebase, Stripe, Gmail API) должно быть инкапсулировано в отдельных сервисах (например, StorageService, NotificationService). Это делает код более модульным и тестируемым (Принцип 9).",
            "Обработка Ошибок: Используйте фильтры исключений NestJS для централизованной обработки ошибок и возврата стандартизированных ответов API (см. DocSpec). Логируйте ошибки подробно (Winston, Sentry)."
          ]
        },
        "security": {
          "title": "7.5. Безопасность: Защита Вашего Актива (Принцип 3, 5, 10)",
          "intro": "Безопасность — это не фича, а фундаментальный аспект качества (Принцип 3), напрямую связанный со здоровьем системы (Принцип 5) и защитой цифрового актива (Принцип 10: ваш продукт и данные пользователей).",
          "points": [
            "Аутентификация: Используйте JWT для stateless аутентификации с короткоживущими access-токенами и refresh-токенами. Надежно храните секрет JWT.",
            "Хэширование Паролей: Никогда не храните пароли в открытом виде. Используйте надежные алгоритмы хэширования (bcrypt, argon2).",
            "Валидация Ввода: Строго валидируйте все входящие данные на Backend (например, с помощью class-validator и DTO).",
            "Защита от Атак: Внедрите Rate Limiting (<code>@nestjs/throttler</code>) для защиты от перебора паролей или DDoS на уровне API. Используйте helmet для установки безопасных HTTP-заголовков.",
            "Шифрование Чувствительных Данных: Шифруйте данные перед сохранением в R2 (см. DocInt). Надежно храните ключ шифрования отдельно от данных.",
            "2FA: Реализуйте двухфакторную аутентификацию как опцию для пользователей."
          ]
        }
      },
      "optimization": {
        "title": "8. Оптимизация Проекта: Постоянное Улучшение (Принцип 9, 1)",
        "content": "Оптимизация — это итеративный процесс (Принцип 9: Кайдзен), основанный на измерении и обучении (Принцип 1). См. подробное Руководство по оптимизации BrainMessenger."
      },
      "deployProcess": {
        "title": "9. Процесс Деплоя: Доставка Системы Пользователям (Принцип 9)",
        "intro": "Процесс деплоя должен быть автоматизированным, надежным и предсказуемым (Принцип 9, 3).",
        "points": [
          "Контейнеризация (Docker): Создайте Docker-образы для Backend и других сервисов. Используйте многоступенчатую сборку для оптимизации размера образов (см. Руководство по оптимизации CI/CD).",
          "Оркестрация (Kubernetes): Развертывайте контейнеры в Kubernetes. Используйте манифесты в папке <code>infrastructure/k8s</code>. K8s обеспечивает автоматическое масштабирование, самовосстановление и управление нагрузкой.",
          "Инфраструктура как Код (Terraform): Управляйте облачными ресурсами (кластер K8s, сети) с помощью Terraform (<code>infrastructure/main.tf</code>). Это делает инфраструктуру версионируемой и воспроизводимой.",
          "CI/CD (GitHub Actions): Настройте автоматические пайплайны для сборки, тестирования и деплоя (см. Руководство по оптимизации CI/CD)."
        ],
        "process": "Процесс: Код пушится в <code>develop</code> → CI/CD запускает тесты и сборку → После успешного прохождения тестов и ревью, PR мержится в <code>develop</code> → (опционально) автоматический деплой dev/staging окружения → Релизный PR из <code>develop</code> в <code>main</code> → Деплой продакшена."
      },
      "devCommands": {
        "title": "10. Полезные Команды Разработчика: Инструментарий Системы",
        "table": [
          ["Команда", "Описание", "Расположение"],
          ["<code>npm install</code>", "Устанавливает зависимости для всех пакетов (Turborepo).", "Корень"],
          ["<code>turbo run <task></code>", "Запускает задачу (build, test, lint, dev) для всех пакетов или по фильтру.", "Корень"],
          ["<code>npm run lint</code>", "Запускает линтеры для всех пакетов.", "Корень"],
          ["<code>npm run format</code>", "Форматирует код всех пакетов (Prettier).", "Корень"],
          ["<code>npm run build</code>", "Собирает продакшен-версии всех пакетов.", "Корень"],
          ["<code>npm run test</code>", "Запускает тесты для всех пакетов.", "Корень"],
          ["<code>cd backend && npx prisma migrate dev --name <name></code>", "Создает и применяет новую миграцию БД.", "Корень/backend"],
          ["<code>cd backend && npx prisma studio</code>", "Запускает графический интерфейс для просмотра БД.", "Корень/backend"],
          ["<code>cd backend && npm run start:dev</code>", "Запускает backend в режиме разработки.", "Корень/backend"],
          ["<code>cd packages/web && npm run dev</code>", "Запускает веб-приложение в режиме разработки.", "Корень/packages/web"],
          ["<code>cd packages/mobile-desktop && npm run android</code>", "Запускает мобильное приложение на Android.", "Корень/packages/mobile-desktop"],
          ["<code>cd packages/mobile-desktop && npm run windows</code>", "Запускает десктоп на Windows.", "Корень/packages/mobile-desktop"],
          ["<code>cd infrastructure && terraform plan</code>", "Показывает план изменений инфраструктуры.", "Корень/infrastructure"],
          ["<code>cd infrastructure && terraform apply</code>", "Применяет изменения инфраструктуры.", "Корень/infrastructure"]
        ]
      },
      "notes": {
        "title": "11. Примечания: Постоянное Обучение и Кайдзен",
        "points": [
          "Онбординг: Новые разработчики должны начать с изучения этой документации, а также Технической документации (общий обзор), Документации дизайна (визуальные стандарты) и Руководства по оптимизации (как писать производительный код).",
          "Живой Документ: Эта документация является живым документом. Она будет обновляться по мере развития проекта, изучения новых технологий и улучшения процессов. Ваши предложения по улучшению приветствуются! (Принцип 1, 14).",
          "Совместимость ECMAScript 2024: Убедитесь, что используете Node.js 22+ (для backend) и актуальные версии браузеров/React Native (для frontend) для полной поддержки новых методов Set. При необходимости используйте полифиллы.",
          "Вопросы и Обратная Связь: Если что-то непонятно, или вы видите возможность улучшить процесс — задавайте вопросы в командном чате (#dev-team в Slack или другом инструменте) и предлагайте изменения. Это часть Силы Взаимодействия и Содействия (Маргулан), которая делает систему сильнее."
        ]
      }
    },
    "integrationsGuide": {
      "title": "Документация Интеграций BrainMessenger",
      "subtitle": "Построение Надежной Системы с Внешними Рычагами",
      "introduction": {
        "title": "1. Введение: Интеграции как Часть Фундамента Системы",
        "description": "Этот документ описывает, как BrainMessenger интегрируется с ключевыми внешними сервисами. Мы выбираем эти интеграции <strong>прагматично</strong> (Принцип 12), рассматривая их как <strong>рычаги</strong> (принцип Маргулана), которые позволяют нам не изобретать колесо, а использовать <strong>надежные и масштабируемые</strong> (Принцип 8, 9) сторонние решения для ускорения разработки и обеспечения <strong>качества</strong> (Принцип 3) нашего продукта. Эти интеграции являются неотъемлемой частью нашего <strong>технологического фундамента</strong> (Принцип 8).",
        "principlesTitle": "Принципы, которыми руководствуется выбор и настройка интеграций:",
        "principles": [
          "<strong>Система и Оптимизация (Принцип 9):</strong> Интеграции должны быть частью единой, хорошо продуманной системы, где каждый компонент выполняет свою роль эффективно.",
          "<strong>Прагматизм и Реализм (Принцип 12):</strong> Выбор сервисов с учетом текущих потребностей, бюджета (бесплатные/доступные тарифы на старте) и простоты интеграции.",
          "<strong>Долгосрочное Мышление (Принцип 8):</strong> Выбор сервисов, способных масштабироваться вместе с ростом проекта.",
          "<strong>Качество > Количество (Принцип 3):</strong> Фокус на надежности и производительности интеграций, даже если их список на старте небольшой.",
          "<strong>Создание Ценности (Принцип 2):</strong> Каждая интеграция должна добавлять реальную ценность для конечного пользователя (например, надежное хранение файлов, мгновенные уведомления)."
        ]
      },
      "overview": {
        "title": "2. Обзор Ключевых Интеграций: Наши Внешние Компоненты Системы",
        "table": [
          ["Сервис", "Назначение", "Роль в BrainMessenger", "Основные функции", "Связь с Принципами"],
          ["<strong>Neon</strong>", "Управляемый PostgreSQL БД", "Хранение всех <strong>структурированных данных</strong> (пользователи, чаты, сообщения, метаданные файлов). Фундамент данных.", "Хостинг PostgreSQL, масштабирование, доступ через строку подключения.", "P8 (Долгосрочное), P9 (Система), P12 (Прагматизм - бесплатный тариф)."],
          ["<strong>Cloudflare R2</strong>", "Облачное Хранилище (S3-совместимое)", "Хранение всех <strong>неструктурированных данных</strong> (файлы пользователей, аватарки, записи звонков, зашифрованные метаданные). Хранилище Активов.", "Надежное хранение объектов, CDN-доставка, отсутствие платы за исходящий трафик.", "P8 (Долгосрочное), P10 (Активы), P12 (Прагматизм - бесплатный тариф, нет платы за трафик), P3 (Качество - CDN)."],
          ["<strong>Firebase</strong>", "Push-уведомления", "Мгновенная доставка уведомлений пользователям на мобильные устройства.", "Отправка push-уведомлений (FCM).", "P2 (Ценность - информирование), P9 (Система - надежная доставка), P12 (Прагматизм - готовое решение)."],
          ["<strong>Stripe</strong>", "Платежная Система", "Обработка платежей за Premium-подписку. Доступ к платежам как к рычагу создания Ценности/Богатства.", "Прием платежей, управление подписками.", "P2 (Ценность - премиум), P10 (Богатство/Активы), P9 (Система - автоматизация платежей)."],
          ["<strong>Gmail API</strong>", "Сервис отправки email", "Отправка критически важных email (коды подтверждения для регистрации и 2FA).", "Отправка транзакционных email.", "P3 (Качество - надежная доставка email), P9 (Система - часть аутентификации), P5 (Здоровье - безопасность пользователя)."]
        ]
      },
      "neonIntegration": {
        "title": "3. Интеграция с Neon: Фундамент Структурированных Данных",
        "generalInfo": {
          "title": "3.1. Общая Информация",
          "description": "Neon предоставляет управляемый сервис PostgreSQL. Мы используем его как <strong>основное хранилище структурированных данных</strong>, таких как информация о пользователях, чатах, сообщениях и метаданных файлов.",
          "advantages": [
            "<strong>Прагматизм (P12):</strong> Бесплатный тариф на старте (30 ГБ) полностью покрывает начальные потребности.",
            "<strong>Система и Долгосрочное Мышление (P9, P8):</strong> Управляемый сервис снижает операционную нагрузку, автоматическое масштабирование и репликация доступны на платных планах, обеспечивая готовность к росту.",
            "<strong>Качество (P3):</strong> Надежность и производительность PostgreSQL как проверенной СУБД."
          ],
          "role": "Роль: Ядро, к которому обращается Backend для всех CRUD-операций над метаданными."
        },
        "configuration": {
          "title": "3.2. Конфигурация: Подключение к Системе Данных",
          "steps": [
            "1. <strong>Регистрация и Создание Проекта:</strong>",
            "Создайте аккаунт на `https://neon.tech`.",
            "Создайте новый проект (например, `brainmessenger-prod`) в консоли Neon.",
            "2. <strong>Настройка Базы Данных:</strong>",
            "Neon автоматически предоставляет инстанс PostgreSQL.",
            "<strong>Примените схему базы данных:</strong> Используйте Prisma Migrate для инициализации структуры таблиц (см. `database/schema.prisma` и Руководство по разработке).",
            "3. <strong>Переменные Окружения:</strong>",
            "Получите <strong>строку подключения</strong> (Connection Details) из консоли Neon (Settings → Connection Details).",
            "Добавьте в ваш `.env` файл:"
          ],
          "envExample": "```env\n# Строка подключения к базе данных Neon\nDATABASE_URL=postgresql://<user>:<password>@<neon-host>/<dbname>?sslmode=require\n```",
          "note1": "*Примечание:* Используйте `sslmode=require` для безопасного соединения.",
          "backendCode": "4. <strong>Подключение Backend (NestJS + Prisma):</strong>\nPrisma использует `DATABASE_URL` для подключения. Убедитесь, что Prisma Client сгенерирован (`npx prisma generate`).\nИспользуйте `PrismaService` (из `nestjs-prisma`) для всех операций с БД.\n```typescript\n// backend/src/app.module.ts (или db.module.ts)\nimport { Module } from '@nestjs/common';\nimport { PrismaService } from 'nestjs-prisma'; // Убедитесь, что PrismaModule импортирован в app.module\n\n@Module({\n  providers: [PrismaService], // PrismaService доступен для инъекции\n  exports: [PrismaService],\n})\nexport class DbModule {}\n```"
        },
        "interactionScenarios": {
          "title": "3.3. Методы и Сценарии Взаимодействия: API Данных",
          "description": "Все взаимодействия с Neon происходят через Prisma ORM в Backend, что обеспечивает <strong>типизацию, безопасность и системность</strong> (Принцип 3, 9).",
          "signup": {
            "title": "Сценарий: Регистрация пользователя:",
            "interaction": "<strong>Взаимодействие:</strong> Backend получает данные пользователя → Использует `PrismaService` для создания новой записи в таблице `users`.",
            "code": "<strong>Пример кода (Backend Service):</strong>\n```typescript\n// backend/src/auth/auth.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { PrismaService } from 'nestjs-prisma';\nimport { Prisma } from '@prisma/client'; // Импорт типов Prisma\n\n@Injectable()\nexport class AuthService {\n  constructor(private prisma: PrismaService) {}\n\n  async signUp(data: Prisma.UserCreateInput) {\n    // Пример: пароль должен быть захэширован ДО сохранения\n    const hashedPassword = await hashPassword(data.password); // Использование утилиты для хэширования\n    return this.prisma.user.create({\n      data: {\n        email: data.email,\n        name: data.name,\n        password: hashedPassword, // Сохраняем захэшированный пароль\n        // ... другие поля по схеме\n      },\n    });\n  }\n}\n```",
            "result": "<strong>Результат:</strong> Данные пользователя надежно сохранены в Neon."
          },
          "getChats": {
            "title": "Сценарий: Получение списка чатов пользователя:",
            "interaction": "<strong>Взаимодействие:</strong> Frontend запрашивает чаты через GraphQL API → Backend использует `PrismaService` для выполнения запроса к таблице `chats` (возможно, с фильтрацией по `userId` и `include` для метаданных).",
            "code": "<strong>Пример кода (Backend Service):</strong>\n```typescript\n// backend/src/chat/chat.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { PrismaService } from 'nestjs-prisma';\n\n@Injectable()\nexport class ChatService {\n  constructor(private prisma: PrismaService) {}\n\n  async getUserChats(userId: string) {\n    // Используем индексы @@index([userId]) для оптимизации (Принцип 9, Оптимизация)\n    return this.prisma.chat.findMany({\n      where: {\n        users: { // Предполагается связь Many-to-Many с таблицей UserChat\n          some: {\n            userId: userId,\n          },\n        },\n      },\n      select: { // Выбираем только необходимые поля (Принцип 9, Оптимизация)\n        id: true,\n        name: true,\n        type: true,\n        // ... другие нужные поля\n      },\n      orderBy: { // Сортировка по дате последнего сообщения для актуальности (Принцип 2, Ценность)\n        lastMessageAt: 'desc',\n      },\n    });\n  }\n}\n```"
          },
          "saveMessage": {
            "title": "Сценарий: Сохранение сообщения:",
            "interaction": "<strong>Взаимодействие:</strong> Пользователь отправляет сообщение → Frontend отправляет его через GraphQL API → Backend использует `PrismaService` для создания новой записи в таблице `messages`, связывая ее с `chatId` и `userId`.",
            "code": "<strong>Пример кода (Backend Service):</strong>\n```typescript\n// backend/src/message/message.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { PrismaService } from 'nestjs-prisma';\nimport { Prisma } from '@prisma/client';\n\n@Injectable()\nexport class MessageService {\n  constructor(private prisma: PrismaService) {}\n\n  async createMessage(data: Prisma.MessageCreateInput) {\n    // Используем транзакцию, если нужно обновить дату последнего сообщения в чате\n    return this.prisma.$transaction(async (tx) => {\n      const message = await tx.message.create({ data });\n      await tx.chat.update({\n        where: { id: data.chatId },\n        data: { lastMessageAt: message.createdAt }, // Обновляем время последнего сообщения\n      });\n      return message;\n    });\n  }\n}\n```"
          }
        },
        "errorHandling": {
          "title": "3.4. Обработка Ошибок Интеграции: Поддержание Качества Системы",
          "description": "Надежная система должна уметь обрабатывать ошибки внешних зависимостей (Принцип 3: Качество).",
          "connectionError": {
            "title": "Connection Error:",
            "cause": "Причина: Невозможно установить соединение с Neon. Неверная строка подключения (`DATABASE_URL`), проблемы с сетью, недоступность сервиса Neon.",
            "solution": "Решение: Проверить переменную окружения `DATABASE_URL`, статус сервиса Neon. Логировать ошибку на Backend (Sentry/Winston)."
          },
          "queryError": {
            "title": "Database Query Error:",
            "cause": "Причина: Ошибка выполнения запроса к БД (например, нарушение уникальности, неверный тип данных). Ошибка в логике Backend, несоответствие схемы БД.",
            "solution": "Решение: Отладить запрос в Backend, проверить логи Prisma. Логировать ошибку."
          },
          "rateLimitError": {
            "title": "Rate Limit Exceeded (на платных тарифах):",
            "cause": "Причина: Превышены лимиты на количество запросов или вычислительные ресурсы в Neon. Высокая нагрузка, неоптимизированные запросы, недостаточный тарифный план.",
            "solution": "Решение: Оптимизировать запросы (см. Руководство по оптимизации), рассмотреть переход на более высокий тарифный план Neon."
          }
        }
      },
      "r2Integration": {
        "title": "4. Интеграция с Cloudflare R2: Хранилище Цифровых Активов",
        "generalInfo": {
          "title": "4.1. Общая Информация",
          "description": "Cloudflare R2 — это сервис объектного хранилища, совместимый с S3 API. Мы используем его для хранения <strong>всех файлов пользователей</strong>, таких как изображения, видео, документы, а также зашифрованные данные.",
          "advantages": [
            "<strong>Прагматизм (P12), Создание Богатства/Активов (P10):</strong> <strong>Отсутствие платы за исходящий трафик</strong> — критически важное преимущество для мессенджера, где пользователи активно обмениваются файлами. Бесплатный тариф 10 ГБ на старте.",
            "<strong>Качество (P3):</strong> Высокая производительность и надежность благодаря глобальной сети Cloudflare.",
            "<strong>Долгосрочное Мышление (P8), Система (P9):</strong> S3-совместимый API позволяет легко использовать стандартные библиотеки и инструменты, обеспечивая гибкость в будущем."
          ],
          "role": "Роль: Децентрализованное хранилище для крупных бинарных объектов, снижающее нагрузку на основную базу данных."
        },
        "configuration": {
          "title": "4.2. Конфигурация: Подключение к Хранилищу Активов",
          "steps": [
            "1. <strong>Создание Бакета:</strong>",
            "Войдите в Cloudflare Dashboard → R2.",
            "Нажмите <strong>\"Create Bucket\"</strong>.",
            "Назовите бакет (например, `brainmessenger-files`). Название должно быть уникальным в рамках всех аккаунтов Cloudflare.",
            "<strong>Настройки:</strong> Включите шифрование в покое (Encryption at rest) — это часть нашей <strong>системы безопасности</strong> (Принцип 3, 5). Ограничьте публичный доступ к бакету, доступ будет осуществляться через подписанные URL (если требуется) или через Backend.",
            "2. <strong>Ключи Доступа:</strong>",
            "В Cloudflare Dashboard перейдите в R2 → Manage R2 API Tokens.",
            "Создайте новый API-токен. Предоставьте ему минимально необходимые разрешения (например, Read and Write to specific buckets).",
            "Скопируйте `Access Key ID` и `Secret Access Key`.",
            "3. <strong>Переменные Окружения:</strong>",
            "Добавьте в ваш `.env` файл:"
          ],
          "envExample": "```env\n# Cloudflare R2 Credentials\nR2_ENDPOINT=<Your R2 Endpoint> # Формат: https://<account-id>.r2.cloudflarestorage.com\nR2_ACCESS_KEY=<Your Access Key ID>\nR2_SECRET_KEY=<Your Secret Access Key>\nR2_BUCKET=brainmessenger-files # Название вашего бакета\n\n# Ключ шифрования для конфиденциальных данных (важно для P3, P5, P10)\nENCRYPTION_KEY=<Your 32-byte (256-bit) hex or base64 encryption key> # Сгенерируйте надежный ключ!\n```",
          "note": "*Примечание:* <strong>Не коммитьте эти ключи в Git!</strong> (Принцип 3, 5, 6). Используйте `.env.example` без чувствительных данных. <strong>ENCRYPTION_KEY</strong> должен быть сгенерирован надежно и храниться в безопасности.",
          "backendCode": "4. <strong>Подключение Backend (`@aws-sdk/client-s3`):</strong>\nR2 совместим с S3 API, поэтому можно использовать стандартный AWS SDK для S3.\nУстановите SDK: `npm install @aws-sdk/client-s3`.\nИнициализируйте S3 Client в вашем Backend-сервисе (например, `StorageService`).\n```typescript\n// backend/src/storage/storage.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3';\nimport { getSignedUrl } from '@aws-sdk/s3-request-presigner'; // Для подписанных URL\nimport { createCipheriv, randomBytes, createDecipheriv } from 'crypto'; // Для шифрования\n\n@Injectable()\nexport class StorageService {\n  private r2: S3Client;\n  private encryptionKey: Buffer; // Ключ для шифрования\n\n  constructor() {\n    this.r2 = new S3Client({\n      region: 'auto', // R2 не использует регионы в классическом понимании\n      endpoint: process.env.R2_ENDPOINT,\n      credentials: {\n        accessKeyId: process.env.R2_ACCESS_KEY,\n        secretAccessKey: process.env.R2_SECRET_KEY,\n      },\n    });\n    // Важно: ENCRYPTION_KEY должен быть Buffer 32 байт для aes-256-cbc\n    this.encryptionKey = Buffer.from(process.env.ENCRYPTION_KEY, 'hex'); // Или 'base64'\n    if (this.encryptionKey.length !== 32) {\n         // Логировать ошибку или выбросить исключение - ключ неверной длины\n         console.error(\"Invalid ENCRYPTION_KEY length. Must be 32 bytes for aes-256-cbc.\");\n         // process.exit(1); // Возможно, стоит остановить приложение\n    }\n  }\n\n  // Утилита для шифрования (часть системы безопасности - P3, P5)\n  private encrypt(data: string): { encrypted: string, iv: string } {\n    const iv = randomBytes(16); // Initialization Vector, 16 байт для aes-256-cbc\n    const cipher = createCipheriv('aes-256-cbc', this.encryptionKey, iv);\n    let encrypted = cipher.update(data, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    return { encrypted, iv: iv.toString('hex') };\n  }\n\n  // Утилита для дешифрования\n  private decrypt(encrypted: string, iv: string): string {\n      const decipher = createDecipheriv('aes-256-cbc', this.encryptionKey, Buffer.from(iv, 'hex'));\n      let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n      decrypted += decipher.final('utf8');\n      return decrypted;\n  }\n\n  // ... методы для работы с R2 (загрузка, скачивание, удаление)\n}\n```"
        },
        "interactionScenarios": {
          "title": "4.3. Методы и Сценарии Взаимодействия: API Хранилища",
          "description": "Взаимодействие с R2 осуществляется через Backend, что позволяет контролировать доступ, обрабатывать файлы (например, оптимизация изображений перед загрузкой) и управлять метаданными в БД (Принцип 9: Система).",
          "uploadFile": {
            "title": "Сценарий: Загрузка файла пользователем:",
            "interaction": "<strong>Взаимодействие:</strong> Пользователь прикрепляет файл в чате → Frontend отправляет файл на Backend → Backend (`StorageService`) загружает файл в R2 → Backend сохраняет метаданные файла (URL, тип, размер) в Neon → Backend отправляет сообщение в чат с ссылкой на файл.",
            "code": "<strong>Пример кода (Backend Service):</strong>\n```typescript\n// backend/src/storage/storage.service.ts (продолжение)\n// ... S3Client и encryptionKey инициализация ...\n\nasync uploadFile(fileBuffer: Buffer, fileName: string, mimeType: string): Promise<string> {\n  const key = `uploads/${Date.now()}-${fileName}`; // Уникальный ключ файла\n  const params = {\n    Bucket: process.env.R2_BUCKET,\n    Key: key,\n    Body: fileBuffer,\n    ContentType: mimeType, // Важно для отдачи файла\n  };\n  const command = new PutObjectCommand(params);\n  await this.r2.send(command); // Асинхронная загрузка\n\n  // Возвращаем URL для сохранения в БД. R2 позволяет прямые ссылки, если настроен публичный домен.\n  // ИЛИ генерируем подписанный URL для ограниченного доступа (более безопасно).\n  // Пример прямой ссылки (требует настройки Public Access URL в CF Dashboard):\n  // const publicUrl = `${process.env.R2_ENDPOINT.replace('.r2.cloudflarestorage.com', '.r2.dev')}/${process.env.R2_BUCKET}/${key}`;\n  // Для своего домена (предпочтительно):\n  const fileUrl = `https://r2.brainmessenger.com/${key}`; // Ваш настроенный домен Cloudflare Workers/Pages\n\n  return fileUrl;\n}\n\n//backend/src/chat/chat.service.ts (интеграция uploadFile)\n// ... constructor с StorageService ...\nasync sendFileMessage(chatId: string, userId: string, file: Express.Multer.File): Promise<Message> {\n   // Опционально: обработка изображения перед загрузкой (см. DocOptimizationIn)\n   // const processedFileBuffer = await this.imageProcessingService.processImage(file.buffer, 800, 600); // Пример\n   const fileUrl = await this.storageService.uploadFile(file.buffer, file.originalname, file.mimetype);\n\n   // Создаем сообщение в БД со ссылкой на файл\n   return this.prisma.message.create({\n     data: {\n       chatId,\n       userId,\n       content: '[File]', // Или другое обозначение файла\n       fileUrl: fileUrl, // Сохраняем ссылку на файл в БД\n       // fileMetadata: { type: file.mimetype, size: file.size }, // Опционально: сохранение метаданных в JSON поле или отдельной таблице\n     },\n   });\n}\n```",
            "result": "<strong>Результат:</strong> Файл надежно хранится в R2, ссылка на него доступна в БД для отображения в чате."
          },
          "sensitiveData": {
            "title": "Сценарий: Хранение конфиденциальных данных (например, зашифрованные метаданные):",
            "interaction": "<strong>Взаимодействие:</strong> При регистрации или обновлении профиля Backend шифрует чувствительные данные (например, резервные email, секретные вопросы) и сохраняет их в R2 в отдельном бакете или папке.",
            "code": "<strong>Пример кода (Backend Service):</strong>\n```typescript\n// backend/src/storage/storage.service.ts (продолжение)\n// ... методы encrypt/decrypt ...\n\nasync storeSensitiveData(userId: string, sensitiveInfo: any): Promise<string> {\n   const encryptedData = {};\n   for (const key in sensitiveInfo) {\n       if (sensitiveInfo.hasOwnProperty(key)) {\n           const { encrypted, iv } = this.encrypt(JSON.stringify(sensitiveInfo[key])); // Шифруем каждое поле или весь объект\n           encryptedData[key] = { encrypted, iv };\n       }\n   }\n\n   const key = `sensitive/${userId}/metadata.json`;\n   const params = {\n       Bucket: process.env.R2_BUCKET, // Или отдельный бакет для чувствительных данных\n       Key: key,\n       Body: JSON.stringify(encryptedData),\n       ContentType: 'application/json',\n   };\n   const command = new PutObjectCommand(params);\n   await this.r2.send(command);\n   return `https://r2.brainmessenger.com/${key}`; // Ссылка для внутреннего использования\n}\n\n// backend/src/user/user.service.ts (интеграция storeSensitiveData)\n// ... constructor с StorageService ...\nasync createUserWithSensitiveData(userData: any, sensitiveData: any) {\n    // Создаем пользователя в БД\n    const user = await this.prisma.user.create({ data: userData });\n    // Сохраняем зашифрованные данные в R2\n    const sensitiveDataUrl = await this.storageService.storeSensitiveData(user.id, sensitiveData);\n    // Сохраняем ссылку на зашифрованные данные в БД (опционально)\n    await this.prisma.user.update({\n        where: { id: user.id },\n        data: { sensitiveDataUrl: sensitiveDataUrl } // Добавить поле sensitiveDataUrl в схему Prisma\n    });\n    return user;\n}\n```",
            "result": "<strong>Результат:</strong> Конфиденциальные данные надежно зашифрованы и хранятся отдельно от основной БД в R2. Доступ к ним возможен только через Backend с использованием ключа шифрования."
          },
          "getFile": {
            "title": "Сценарий: Получение файла (для отображения или скачивания):",
            "interaction": "<strong>Взаимодействие:</strong> Frontend получает URL файла из метаданных сообщения (из Neon) → Frontend (или Backend, если требуется аутентификация/подписанные URL) использует этот URL для скачивания файла напрямую из R2.",
            "code": "<strong>Реализация:</strong> Если бакет R2 настроен с Public Access URL (через Cloudflare Workers/Pages), Frontend может обращаться напрямую. Если доступ ограничен, Backend может генерировать временные подписанные URL через `@aws-sdk/s3-request-presigner`.\n```typescript\n// backend/src/storage/storage.service.ts (продолжение)\n// ... S3Client инициализация ...\n\n// Метод для генерации подписанного URL (более безопасный подход для приватных файлов)\nasync getSignedFileUrl(fileKey: string): Promise<string> {\n    const command = new GetObjectCommand({\n        Bucket: process.env.R2_BUCKET,\n        Key: fileKey,\n    });\n    // Сгенерировать подписанный URL, действительный, например, 60 секунд\n    const signedUrl = await getSignedUrl(this.r2, command, { expiresIn: 60 });\n    return signedUrl;\n}\n```"
          }
        },
        "errorHandling": {
          "title": "4.4. Обработка Ошибок Интеграции: Хранилище Активов",
          "forbidden": {
            "title": "403 Forbidden:",
            "cause": "Причина: Ошибка доступа к бакету R2. Неверные ключи доступа (`R2_ACCESS_KEY`, `R2_SECRET_KEY`), неверные разрешения токена, попытка доступа к приватному файлу без аутентификации/подписанного URL.",
            "solution": "Решение: Проверить переменные окружения, разрешения токена R2. Убедиться, что логика доступа (публичный URL vs подписанный URL) реализована корректно. Логировать ошибку."
          },
          "notFound": {
            "title": "404 Not Found:",
            "cause": "Причина: Файл отсутствует в R2. Неверный ключ файла (`Key`), файл был удален.",
            "solution": "Решение: Проверить ключ файла, который был сохранен в Neon. Убедиться, что файл действительно был загружен. Логировать ошибку."
          },
          "tooManyRequests": {
            "title": "429 Too Many Requests:",
            "cause": "Причина: Превышен лимит запросов к R2 API. Высокая частота запросов загрузки/скачивания.",
            "solution": "Решение: Внедрить Rate Limiting на Backend (см. Руководство по оптимизации). Оптимизировать логику работы с файлами."
          },
          "encryptionError": {
            "title": "Encryption/Decryption Error:",
            "cause": "Причина: Ошибка шифрования/дешифрования. Неверный ключ шифрования (`ENCRYPTION_KEY`), поврежденный IV, поврежденные зашифрованные данные.",
            "solution": "Решение: Убедиться, что используется правильный ключ (`ENCRYPTION_KEY`), который совпадает с ключом, использованным при шифровании. Проверить целостность данных и IV. Логировать критическую ошибку."
          }
        }
      },
      "neonR2Interaction": {
        "title": "5. Взаимодействие Neon и Cloudflare R2: Оптимизация Хранения Данных (Принцип 9, 12)",
        "description": "Мы используем Neon и R2 совместно, чтобы создать оптимизированную систему хранения данных, где каждый сервис выполняет свою лучшую функцию (Принцип 9).",
        "scenario": [
          "<strong>Neon (PostgreSQL):</strong> Хранит <strong>структурированные метаданные</strong>, которые часто запрашиваются и по которым выполняются сложные запросы (пользователи, чаты, текстовые сообщения, ссылки на файлы).",
          "<strong>Cloudflare R2:</strong> Хранит <strong>неструктурированные бинарные данные</strong> большого размера (файлы), которые реже запрашиваются и не требуют сложной логики выборки по содержимому).",
          "<strong>Сценарий комплексного взаимодействия:</strong>",
          "1. Пользователь отправляет файл через чат (Frontend -> Backend).",
          "2. Backend (`StorageService`) <strong>загружает файл в Cloudflare R2</strong> (используя S3 API). Получает URL файла (или ключ).",
          "3. Backend (`ChatService`) <strong>сохраняет метаданные сообщения в Neon через Prisma</strong>, включая полученный URL/ключ файла.",
          "4. Когда другой пользователь открывает чат, Backend (`ChatService`) <strong>получает список сообщений из Neon через Prisma</strong>, включая URL/ключи файлов.",
          "5. Frontend отображает список сообщений и использует URL/ключи для <strong>скачивания файлов напрямую из R2</strong> (или через Backend, если требуется аутентификация)."
        ],
        "advantagesTitle": "Преимущества такого разделения:",
        "advantages": [
          "<strong>Оптимизация производительности БД:</strong> PostgreSQL не \"засоряется\" большими бинарными данными, что улучшает скорость текстовых запросов (Принцип 9).",
          "<strong>Снижение стоимости:</strong> R2 предлагает очень выгодные тарифы для хранения больших объемов данных без платы за исходящий трафик, что <strong>прагматично</strong> (Принцип 12) и способствует созданию <strong>актива</strong> (Принцип 10).",
          "<strong>Масштабируемость:</strong> Каждый сервис масштабируется независимо в соответствии со своим типом нагрузки (Neon для транзакций, R2 для объема/трафика файлов).",
          "<strong>Надежность:</strong> Разделение ответственности между сервисами повышает общую отказоустойчивость системы."
        ]
      },
      "otherIntegrations": {
        "title": "6. Другие Интеграции: Расширение Функционала Системы (Принцип 2, 12)",
        "description": "Эти интеграции добавляют <strong>ценность</strong> (Принцип 2) и используют <strong>прагматичные, готовые решения</strong> (Принцип 12).",
        "firebase": {
          "title": "6.1. Firebase (Push-уведомления)",
          "purpose": "Назначение: Мгновенная доставка уведомлений о новых сообщениях, звонках и системных событиях пользователям мобильных приложений.",
          "role": "Роль: <strong>Критически важный компонент системы уведомлений</strong> (Принцип 9) для поддержания вовлеченности пользователей и оперативного информирования (Принцип 2).",
          "configuration": "Конфигурация: Переменная окружения: `FIREBASE_CREDENTIALS_PATH` (путь к JSON-файлу учетных данных сервисного аккаунта Firebase). <strong>Храните этот файл безопасно!</strong>",
          "example": "Используется библиотека `firebase-admin` в Backend NestJS. Пример использования: Отправка уведомления при получении нового сообщения (см. Руководство по оптимизации для батчинга и тем)."
        },
        "stripe": {
          "title": "6.2. Stripe (Платежи)",
          "purpose": "Назначение: Обработка подписок на Premium-функционал BrainMessenger.",
          "role": "Роль: <strong>Финансовый рычаг</strong> для поддержки развития проекта (Принцип 10: Создание Богатства) и предоставления дополнительной <strong>ценности</strong> (Принцип 2) премиум-пользователям.",
          "configuration": "Конфигурация: Переменная окружения: `STRIPE_SECRET_KEY`.",
          "example": "Используется библиотека `stripe` в Backend NestJS. Пример использования: Создание сессии оплаты при попытке оформить подписку. Обработка вебхуков для подтверждения успешной оплаты."
        },
        "gmailApi": {
          "title": "6.3. Gmail API (Отправка Email)",
          "purpose": "Назначение: Отправка транзакционных email, таких как коды подтверждения для регистрации и двухфакторной аутентификации (2FA), уведомления о сбросе пароля.",
          "role": "Роль: <strong>Критически важный компонент системы аутентификации и безопасности</strong> (Принцип 9, 5).",
          "configuration": "Конфигурация: Требует настройки сервисного аккаунта Google Cloud и получения учетных данных (см. Техническую документацию, раздел 10.1). Переменные окружения для учетных данных сервисного аккаунта или API-ключей.",
          "example": "Пример использования: Вызов API для отправки письма с кодом подтверждения после ввода email при регистрации или включении 2FA (см. Спецификацию API, раздел 2.4)."
        }
      },
      "recommendations": {
        "title": "7. Рекомендации по Интеграциям: Поддержание Здоровья Системы (Принцип 3, 5, 9)",
        "intro": "Чтобы интеграции оставались <strong>надежными, безопасными и эффективными</strong> (Принцип 3, 9), следуйте этим рекомендациям, связанным с поддержанием \"здоровья\" системы (Принцип 5, применительно к технике):",
        "security": {
          "title": "Безопасность:",
          "points": [
            "<strong>Никогда не коммитьте ключи и секреты в Git.</strong> Используйте переменные окружения и системы управления секретами в продакшен-окружении (например, Kubernetes Secrets, HashiCorp Vault).",
            "Регулярно проводите <strong>ротацию API-токенов</strong> (R2, Firebase, Gmail, Stripe) для повышения безопасности.",
            "Используйте <strong>принцип минимальных привилегий</strong> при создании API-токенов: давайте им только те разрешения, которые действительно необходимы."
          ]
        },
        "scaling": {
          "title": "Масштабирование:",
          "points": [
            "<strong>Мониторьте использование ресурсов</strong> (место в Neon/R2, запросы к API Firebase/Stripe) через консоли соответствующих сервисов. Будьте готовы перейти на платный тариф при росте нагрузки (Принцип 8, 12).",
            "Используйте <strong>оптимизационные подходы</strong> (например, батчинг запросов к Firebase, индексирование в Neon, см. Руководство по оптимизации), чтобы отложить необходимость перехода на более дорогие тарифы."
          ]
        },
        "monitoring": {
          "title": "Мониторинг и Логирование:",
          "points": [
            "Настройте <strong>логирование ошибок интеграций</strong> в NestJS (Winston, Sentry).",
            "Используйте <strong>системы мониторинга</strong> (Prometheus/Grafana) для отслеживания метрик запросов к внешним сервисам (задержки, количество ошибок) — это часть <strong>Кайдзен</strong> (Принцип 9), позволяющая выявлять проблемы на ранней стадии."
          ]
        },
        "errorHandling": {
          "title": "Обработка Ошибок:",
          "points": [
            "Реализуйте <strong>грамотную обработку ошибок</strong> от внешних сервисов на Backend. Логируйте их подробно.",
            "Для критически важных операций (например, регистрация, платежи) предусмотрите механизмы <strong>повторных попыток (retries)</strong> или <strong>компенсирующих действий</strong> (например, отметка платежа как незавершенного) при временных сбоях внешних сервисов."
          ]
        },
        "documentation": {
          "title": "Документация:",
          "content": "Поддерживайте эту документацию в актуальном состоянии, отражая изменения в используемых сервисах или добавлении новых интеграций (Принцип 1: Обучение, Принцип 9: Система)."
        }
      }
    },
    "optimizationGuide": {
      "title": "Руководство по Оптимизации BrainMessenger (Принцип Кайдзен в Действии)",
      "subtitle": "Введение: Оптимизация как Непрерывный Процесс Улучшения",
      "introduction": {
        "title": "1. Введение: Оптимизация как Непрерывный Процесс Улучшения",
        "description": "Этот документ подробно описывает подходы, инструменты и техники, которые мы используем для оптимизации производительности BrainMessenger. Оптимизация — это не одноразовая задача, а <strong>непрерывный процесс улучшения</strong> (Принцип 1, 9: Кайдзен), который позволяет нам обеспечить <strong>высокое качество, надежность и масштабируемость</strong> (Принцип 3, 8) приложения.",
        "goalTitle": "Цель:",
        "goalContent": "Идентифицировать и устранять узкие места в производительности на всех уровнях системы (Frontend, Backend, База данных, Инфраструктура), чтобы BrainMessenger оставался <strong>быстрым, отзывчивым и эффективным</strong> (Принцип 2) даже при значительной нагрузке (цель — 1 миллион активных пользователей), поддерживая <strong>здоровье системы</strong> (Принцип 5, применительно к технике).",
        "audienceTitle": "Аудитория:",
        "audienceContent": "Backend, Frontend, Mobile, Desktop и DevOps разработчики, сфокусированные на производительности и масштабировании.",
        "principlesTitle": "Принципы, которыми руководствуется оптимизация:",
        "principles": [
          "<strong>Система и Оптимизация (Принцип 9: Кайдзен):</strong> Оптимизация является ключевым аспектом нашей системы разработки. Используется цикличный подход: Измерение → Анализ → Улучшение → Проверка.",
          "<strong>Качество > Количество (Принцип 3):</strong> Лучше иметь несколько критически важных оптимизаций, чем много мелких, не дающих значительного эффекта.",
          "<strong>Прагматизм и Реализм (Принцип 12):</strong> Оптимизируем то, что действительно влияет на производительность и пользовательский опыт, основываясь на реальных данных, а не на догадках.",
          "<strong>Постоянное Обучение (Принцип 1):</strong> Изучение новых техник и инструментов оптимизации, анализ результатов и уроков.",
          "<strong>Настойчивость (Принцип 13):</strong> Оптимизация может быть сложной. Требуется упорство для выявления и решения глубоких проблем производительности.",
          "<strong>Здоровье как Фундамент (Принцип 5):</strong> Оптимизация системы (например, снижение потребления памяти/CPU) напрямую влияет на \"здоровье\" серверов и устройств пользователей.",
          "<strong>Внешняя Экспертиза (Принцип 14):</strong> Использование стандартных инструментов (Prometheus, Grafana, V8 Profiler), изучение опыта других команд (Google, Next.js и т.д.)."
        ]
      },
      "generalPrinciple": {
        "title": "2. Общий Принцип Оптимизации (Цикл Кайдзен)",
        "intro": "Наш подход к оптимизации следует <strong>циклу Кайдзен (Принцип 9)</strong>:",
        "step1": {
          "title": "1. Измерение (Measure):",
          "content": "Соберите данные о производительности. Используйте инструменты мониторинга (Prometheus, Sentry), профилирования (V8 Profiler), анализа бандлов (Webpack Bundle Analyzer, `@next/bundle-analyzer`)."
        },
        "step2": {
          "title": "2. Анализ (Analyze):",
          "content": "Определите <strong>узкие места (bottlenecks)</strong> на основе собранных данных. Где система тратит больше всего времени или ресурсов?"
        },
        "step3": {
          "title": "3. Улучшение (Improve):",
          "content": "Примените конкретные техники оптимизации, описанные в этом руководстве, для устранения выявленных узких мест."
        },
        "step4": {
          "title": "4. Проверка (Verify):",
          "content": "Снова измерьте производительность после внесенных изменений. Убедитесь, что оптимизация дала ожидаемый эффект и не вызвала регрессий (не ухудшила другие аспекты)."
        },
        "step5": {
          "title": "5. Повторение:",
          "content": "Производительность может меняться с ростом нагрузки и функционала. Повторяйте цикл Кайдзен непрерывно."
        }
      },
      "imageProcessing": {
        "title": "3. Оптимизация Обработки Изображений: Эффективность и Скорость (Принцип 9, 2)",
        "intro": "Обработка изображений может быть ресурсоемкой. <strong>Оптимизация этого процесса напрямую влияет на скорость загрузки контента и отзывчивость приложения</strong> (Принцип 2: Ценность).",
        "libraryTitle": "Библиотека:",
        "libraryContent": "`sharp` (на базе `libvips`). Выбран как <strong>прагматичное</strong> (Принцип 12) и <strong>высокопроизводительное</strong> (Принцип 9) решение для Node.js.",
        "applicationAreasTitle": "Области применения:",
        "applicationAreasContent": "Изменение размера, сжатие, конвертация формата для аватаров, изображений в чатах.",
        "keyTechniqueTitle": "Ключевая техника:",
        "keyTechniqueContent": "<strong>Асинхронная обработка</strong> в фоновом режиме через Kafka.",
        "implementationStepsTitle": "Шаги по внедрению (Backend):",
        "step1": {
          "title": "1. Установите `sharp`:",
          "content": "Убедитесь, что `libvips` установлен в вашей операционной системе или Docker-образе.",
          "code": "```bash\\nnpm install sharp\\n```"
        },
        "step2": {
          "title": "2. Создайте сервис обработки изображений:",
          "content": "Инкапсулируйте логику в отдельном сервисе (часть <strong>системы</strong> - Принцип 9).",
          "code": "```typescript\\n// backend/src/image-processing/image-processing.service.ts\\nimport { Injectable } from '@nestjs/common';\\nimport sharp from 'sharp';\\n\\n@Injectable()\\nexport class ImageProcessingService {\\n  // Метод для изменения размера, сжатия и конвертации в WebP\\n  async processImage(buffer: Buffer, width: number, height?: number): Promise<Buffer> {\\n    // resize({ width, height, withoutEnlargement: true }) - избегаем увеличения, если исходник меньше\\n    // webp({ quality: 80 }) - сжатие в формат WebP (хорошее сжатие при сохранении качества)\\n    // withMetadata({ orientation: true }) - сохраняем ориентацию из EXIF, остальное удаляем (экономия размера - Принцип 9)\\n    return sharp(buffer)\\n      .resize(width, height, { withoutEnlargement: true })\\n      .webp({ quality: 80 })\\n      .withMetadata({ orientation: true })\\n      .toBuffer();\\n  }\\n\\n  // Метод для простого изменения размера\\n  async resizeImage(buffer: Buffer, width: number, height?: number): Promise<Buffer> {\\n       return sharp(buffer)\\n           .resize(width, height, { withoutEnlargement: true })\\n           .toBuffer();\\n  }\\n\\n   // Метод для конвертации в определенный формат\\n   async convertToFormat(buffer: Buffer, format: keyof sharp.Format): Promise<Buffer> {\\n       return sharp(buffer).toFormat(format).toBuffer();\\n   }\\n}\\n```"
        },
        "step3": {
          "title": "3. Интеграция с загрузкой файлов (Backend Controller/Service):",
          "content": "",
          "code": "```typescript\\n// backend/src/upload/upload.controller.ts (пример обработки загрузки аватара)\\nimport { Controller, Post, UploadedFile, UseInterceptors, Body, Inject } from '@nestjs/common';\\nimport { FileInterceptor } from '@nestjs/platform-express';\\nimport { ImageProcessingService } from '../image-processing/image-processing.service';\\nimport { StorageService } from '../storage/storage.service';\\nimport { UserService } from '../user/user.service';\\n\\n@Controller('upload')\\nexport class UploadController {\\n  constructor(\\n    private imageProcessingService: ImageProcessingService,\\n    private storageService: StorageService,\\n    private userService: UserService,\\n    // ... инъекция Kafka продюсера для асинхронной обработки\\n  ) {}\\n\\n  @Post('avatar')\\n  @UseInterceptors(FileInterceptor('file')) // 'file' - имя поля формы\\n  async uploadAvatar(@UploadedFile() file: Express.Multer.File, @Body('userId') userId: string) {\\n    // Оптимизация: Обработка изображения перед загрузкой в R2\\n    const processedImageBuffer = await this.imageProcessingService.processImage(file.buffer, 300, 300); // Изменить размер и сжать\\n    const fileName = `avatars/${userId}-${Date.now()}.webp`; // Уникальное имя файла в папке avatars\\n    const mimeType = 'image/webp'; // Соответствует формату WebP\\n\\n    // Загрузка обработанного файла в Cloudflare R2\\n    const avatarUrl = await this.storageService.uploadFile(processedImageBuffer, fileName, mimeType);\\n\\n    // Обновление ссылки на аватар в профиле пользователя в Neon\\n    await this.userService.updateUserAvatar(userId, avatarUrl);\\n\\n    // Возвращаем URL аватара клиенту\\n    return { avatarUrl };\\n  }\\n\\n  @Post('chat-image')\\n  @UseInterceptors(FileInterceptor('file'))\\n  async uploadChatImage(@UploadedFile() file: Express.Multer.File, @Body('chatId') chatId: string, @Body('userId') userId: string) {\\n      // Отправка задачи на обработку изображения в Kafka для асинхронной обработки (Принцип 9)\\n      const taskPayload = { fileBuffer: file.buffer.toString('base64'), fileName: file.originalname, mimeType: file.mimetype, chatId, userId };\\n      // Предполагается, что у вас есть Kafka продюсер сервис\\n      // await this.kafkaProducerService.sendMessage('image-processing-topic', JSON.stringify(taskPayload));\\n\\n      // Немедленный ответ клиенту, что файл принят в обработку\\n      return { status: 'processing', originalFileName: file.originalname };\\n\\n      // ИЛИ, если синхронная обработка приемлема для небольших файлов:\\n      /*\\n      const processedImageBuffer = await this.imageProcessingService.processImage(file.buffer, 800); // Изменить размер\\n      const fileName = `chat-images/${chatId}-${Date.now()}.webp`;\\n      const mimeType = 'image/webp';\\n      const imageUrl = await this.storageService.uploadFile(processedImageBuffer, fileName, mimeType);\\n\\n      // Создание сообщения типа 'image' в чате\\n      // await this.chatService.sendImageMessage(chatId, userId, imageUrl);\\n\\n      return { imageUrl };\\n      */\\n  }\\n}\\n```"
        },
        "step4": {
          "title": "4. Асинхронность через Kafka (для тяжелых задач):",
          "content": "Для обработки изображений в чатах (которые могут быть большими) используйте <strong>Kafka</strong> (см. раздел 8) для <strong>асинхронной обработки</strong>. Backend быстро принимает файл от клиента и ставит задачу в очередь Kafka. Отдельный воркер (consumer Kafka) забирает задачу, обрабатывает изображение с помощью `sharp`, загружает в R2 и только после этого создает сообщение в чате через API. Это <strong>снижает время ответа API</strong> (Принцип 9) и улучшает пользовательский опыт."
        }
      },
      "dbOptimization": {
        "title": "4. Оптимизация Базы Данных (Neon/PostgreSQL): Ускорение Доступа к Данным (Принцип 9, 8)",
        "intro": "База данных часто становится узким местом. Оптимизация запросов и структуры БД критически важна для <strong>долгосрочной производительности</strong> (Принцип 8) и <strong>эффективности системы</strong> (Принцип 9).",
        "platformTitle": "Платформа:",
        "platformContent": "Neon (управляемый PostgreSQL).",
        "toolTitle": "Инструмент:",
        "toolContent": "Prisma ORM.",
        "analysisToolTitle": "Инструмент анализа:",
        "analysisToolContent": "`EXPLAIN ANALYZE` в SQL-клиенте Neon или `prisma.queryRaw` с `EXPLAIN ANALYZE`.",
        "monitoringToolTitle": "Инструмент мониторинга:",
        "monitoringToolContent": "Prometheus + `postgres_exporter` (см. раздел 14).",
        "indexing": {
          "title": "4.1. Индексация: Ускорение Поиска и Фильтрации",
          "intro": "Индексы позволяют базе данных быстрее находить нужные строки.",
          "whenTitle": "Когда использовать:",
          "whenContent": "На полях, которые часто используются в `WHERE`, `JOIN`, `ORDER BY`.",
          "applicationAreasTitle": "Области применения в BrainMessenger:",
          "applicationAreasContent": "`userId`, `chatId`, `createdAt` (в таблице `Message`), `email` (в таблице `User`), поля для поиска.",
          "prismaTitle": "Реализация (Prisma):",
          "prismaContent": "Добавляйте `@index` в `schema.prisma`.",
          "prismaCode": "```prisma\\n// schema.prisma\\nmodel Message {\\n  id        String   @id @default(cuid())\\n  content   String\\n  createdAt DateTime @default(now()) @map(\\\"created_at\\\") // Пример @map для snake_case в БД\\n  chatId    String @map(\\\"chat_id\\\")\\n  userId    String @map(\\\"user_id\\\")\\n  chat      Chat     @relation(fields: [chatId], references: [id])\\n  user      User     @relation(fields: [userId], references: [id])\\n\\n  // Комбинированный индекс для быстрых запросов сообщений в чате по времени\\n  @@index([chatId, createdAt])\\n  // Индекс для быстрого получения сообщений по пользователю (например, для статистики)\\n  @@index([userId])\\n  // Индекс для поиска по содержимому (если требуется полнотекстовый поиск - рассмотреть tsearch)\\n  // @@index([content]) // Только для простых фильтров LIKE\\n}\\n\\nmodel User {\\n    id    String @id @default(cuid())\\n    email String @unique // Уникальный индекс для быстрого поиска по email (логин, регистрация)\\n    name  String\\n    // ... другие поля\\n}\\n\\nmodel Chat {\\n   id          String @id @default(cuid())\\n   lastMessageAt DateTime? @map(\\\"last_message_at\\\") // Для сортировки чатов (нужен индекс)\\n   // ... другие поля\\n   @@index([lastMessageAt]) // Индекс для сортировки списка чатов\\n}\\n```",
          "applicationTitle": "Применение:",
          "applicationContent": "После изменения `schema.prisma` выполните миграцию (`npx prisma migrate dev`)."
        },
        "queryOptimization": {
          "title": "4.2. Оптимизация Запросов (Prisma): Пишем Эффективный Код Взаимодействия с БД",
          "intro": "",
          "selectFieldsTitle": "Выбирайте только нужные поля (`select`):",
          "selectFieldsContent": "Не запрашивайте `SELECT *`. Указывайте поля, которые вам действительно нужны. Это уменьшает объем данных, передаваемых по сети и обрабатываемых БД.",
          "selectFieldsCode": "```typescript\\n// Плохо\\nconst user = await prisma.user.findUnique({ where: { id: userId } }); // Выберет все поля\\n\\n// Хорошо (если нужен только email и name)\\nconst user = await prisma.user.findUnique({\\n  where: { id: userId },\\n  select: {\\n    email: true,\\n    name: true,\\n  },\\n});\\n```",
          "nPlus1Title": "Избегайте N+1 проблем (`include`):",
          "nPlus1Content": "Если вам нужны связанные данные (например, автор сообщения при получении списка сообщений), используйте `include` или `select` со вложенными полями вместо выполнения отдельного запроса для каждого элемента.",
          "nPlus1Code": "```typescript\\n// Плохо (N+1 проблема - отдельный запрос за каждым пользователем)\\nconst messages = await prisma.message.findMany({ where: { chatId: chatId } });\\nfor (const message of messages) {\\n  const sender = await prisma.user.findUnique({ where: { id: message.userId } });\\n  // ... использовать sender\\n}\\n\\n// Хорошо (используем include для получения автора сообщения одним запросом)\\nconst messagesWithSender = await prisma.message.findMany({\\n  where: { chatId: chatId },\\n  include: {\\n    user: { // Включаем данные пользователя, связанного с сообщением через поле 'user' в модели Message\\n      select: { id: true, name: true, avatarUrl: true } // Выбираем только нужные поля пользователя\\n    },\\n  },\\n  orderBy: { createdAt: 'asc' }, // Пример: сообщения в хронологическом порядке\\n  take: 50, // Пример: пагинация\\n});\\n```",
          "paginationTitle": "Пагинация (`skip`, `take`, `cursor`):",
          "paginationContent": "Для получения больших списков (сообщения в чате, список чатов) используйте пагинацию, чтобы не загружать все данные сразу. `cursor`-пагинация предпочтительнее для бесконечной прокрутки.",
          "paginationCode": "```typescript\\n// Пример пагинации с take и skip\\nconst messages = await prisma.message.findMany({\\n    where: { chatId: chatId },\\n    orderBy: { createdAt: 'asc' },\\n    skip: (page - 1) * pageSize, // Пропустить N сообщений\\n    take: pageSize, // Взять M сообщений\\n});\\n\\n// Пример Cursor-based пагинации (для \\\"показать еще\\\")\\nconst messages = await prisma.message.findMany({\\n    where: { chatId: chatId },\\n    orderBy: { createdAt: 'asc' },\\n    cursor: { id: lastMessageId }, // Начать после последнего сообщения\\n    skip: 1, // Пропустить само последнее сообщение\\n    take: pageSize,\\n});\\n```"
        },
        "prismaAccelerate": {
          "title": "4.3. Prisma Accelerate: Глобальный Кэш и Пул Соединений",
          "intro": "Prisma Accelerate предоставляет глобальную сеть серверов (Edge locations), которые кэшируют результаты запросов и управляют пулом соединений к вашей БД Neon.",
          "whenTitle": "Когда использовать:",
          "whenContent": "Для снижения задержки запросов (latency) для пользователей по всему миру и оптимизации использования пула соединений БД.",
          "implementationTitle": "Реализация:",
          "implementationContent": "Настраивается в консоли Prisma. Ваша `DATABASE_URL` заменяется на URL Prisma Accelerate."
        },
        "materializedViews": {
          "title": "4.4. Материализованные Представления: Кэширование Сложных Агрегаций",
          "intro": "Материализованные представления — это по сути кэшированные результаты сложных запросов или агрегаций (например, количество сообщений в чате, последние активные пользователи в группе). Они хранятся на диске и могут быть быстро прочитаны.",
          "whenTitle": "Когда использовать:",
          "whenContent": "Для запросов, которые выполняются часто, но требуют сложных вычислений (JOINs, GROUP BY, агрегатные функции) над большими таблицами, и данные в которых не должны быть абсолютно актуальными каждую миллисекунду.",
          "applicationAreasTitle": "Области применения:",
          "applicationAreasContent": "Статистика чатов (общее количество сообщений, участников), списки \"топ\" пользователей (например, по количеству отправленных сообщений).",
          "implementationTitle": "Реализация (SQL, через Prisma `queryRaw` или SQL-клиент Neon):",
          "implementationContent": "```sql\\n-- Создать материализованное представление для подсчета сообщений в каждом чате\\nCREATE MATERIALIZED VIEW chat_message_counts AS\\nSELECT\\n    \\\"chatId\\\",\\n    COUNT(*) as \\\"messageCount\\\"\\nFROM \\\"Message\\\"\\nGROUP BY \\\"chatId\\\";\\n\\n-- Создать индекс на представлении для быстрого поиска по chatId (необязательно, но часто полезно)\\nCREATE INDEX idx_chat_message_counts_chat_id ON chat_message_counts (\\\"chatId\\\");\\n```",
          "updateTitle": "Обновление:",
          "updateContent": "Материализованные представления нужно <strong>периодически обновлять</strong>, чтобы отразить изменения в базовых таблицах. Это делается командой `REFRESH MATERIALIZED VIEW <view_name>;`. Частота обновления зависит от того, насколько актуальными должны быть данные (например, раз в час, раз в день).",
          "updateCode": "```sql\\n-- Обновить представление (может блокировать чтение во время выполнения)\\nREFRESH MATERIALIZED VIEW chat_message_counts;\\n\\n-- Обновить представление без блокировки чтения (для больших представлений)\\nREFRESH MATERIALIZED VIEW CONCURRENTLY chat_message_counts; -- Требует уникального индекса\\n```",
          "usageTitle": "Использование в Prisma:",
          "usageContent": "Запрашивайте как обычную таблицу.",
          "usageCode": "```typescript\\nconst chatStats = await prisma.chatMessageCounts.findMany({\\n  select: { chatId: true, messageCount: true },\\n  where: { chatId: 'some-chat-id' },\\n});\\n```"
        },
        "partitioning": {
          "title": "4.5. Партиционирование Таблиц: Разделение Больших Объемов Данных",
          "intro": "Партиционирование физически разделяет очень большие таблицы (например, `Message`) на более мелкие части (партиции) на основе значения в определенном столбце (например, `createdAt` или `chatId`).",
          "whenTitle": "Когда использовать:",
          "whenContent": "Когда таблица становится настолько большой (миллиарды строк), что индексы уже не справляются, и запросы начинают замедляться из-за необходимости сканировать слишком много данных.",
          "applicationAreasTitle": "Области применения:",
          "applicationAreasContent": "Таблица `Message` — идеальный кандидат для партиционирования по времени создания (`createdAt`) или по ID чата (`chatId`).",
          "implementationTitle": "Реализация (SQL, через Prisma `queryRaw` или SQL-клиент Neon):",
          "implementationContent": "PostgreSQL поддерживает нативное партиционирование.",
          "implementationCode": "```sql\\n-- Создать главную партиционированную таблицу по диапазону дат\\nCREATE TABLE messages (\\n    id TEXT NOT NULL,\\n    content TEXT NOT NULL,\\n    created_at TIMESTAMP WITH TIME ZONE NOT NULL,\\n    chat_id TEXT NOT NULL,\\n    user_id TEXT NOT NULL,\\n    PRIMARY KEY (id, created_at) -- Ключ партиционирования должен быть частью первичного ключа\\n) PARTITION BY RANGE (created_at); -- Партиционируем по диапазону поля created_at\\n\\n-- Создать партиции (например, по месяцам)\\nCREATE TABLE messages_2025_03 PARTITION OF messages\\n    FOR VALUES FROM ('2025-03-01 00:00:00+00') TO ('2025-04-01 00:00:00+00');\\n\\nCREATE TABLE messages_2025_04 PARTITION OF messages\\n    FOR VALUES FROM ('2025-04-01 00:00:00+00') TO ('2025-05-01 00:00:00+00');\\n\\n-- ... создавать новые партиции по мере необходимости (автоматически или вручную)\\n\\n-- Создать индексы для партиционированной таблицы (применяются ко всем партициям)\\nCREATE INDEX ON messages (\\\"chat_id\\\", \\\"created_at\\\");\\nCREATE INDEX ON messages (\\\"user_id\\\");\\n```",
          "advantagesTitle": "Преимущества:",
          "advantagesContent": "Запросы, включающие фильтр по ключу партиционирования (например, `WHERE created_at BETWEEN ...`), будут сканировать только нужные партиции, что значительно ускоряет их выполнение. Управление старыми данными (удаление) становится проще (можно просто удалить старые партиции).",
          "prismaRelationTitle": "Связь с Prisma:",
          "prismaRelationContent": "Prisma работает с партиционированной таблицей как с обычной."
        }
      },
      "graphqlOptimization": {
        "title": "5. Оптимизация GraphQL API (NestJS + Prisma): Эффективная Передача Данных",
        "intro": "GraphQL сам по себе является инструментом <strong>оптимизации</strong> (Принцип 9) по сравнению с REST (клиент запрашивает только нужные данные). Однако и его можно оптимизировать.",
        "analysisToolTitle": "Инструмент анализа:",
        "analysisToolContent": "`graphql-query-complexity` для защиты от сложных запросов.",
        "dataloader": {
          "title": "5.1. DataLoader: Решение Проблемы N+1 в GraphQL",
          "intro": "DataLoader — это утилита, которая помогает решить проблему N+1 запросов при работе с графами данных. Если у вас есть список объектов, и для каждого объекта нужно подтянуть связанный с ним объект (например, список сообщений и для каждого сообщения его автора), DataLoader соберет все ID связанных объектов и сделает один пакетный запрос к БД.",
          "whenTitle": "Когда использовать:",
          "whenContent": "В резолверах GraphQL, когда вам нужно получить связанные объекты для списка родительских объектов.",
          "applicationAreasTitle": "Области применения:",
          "applicationAreasContent": "Получение данных автора для каждого сообщения в чате, получение списка участников для каждого чата в списке чатов пользователя.",
          "implementationTitle": "Реализация:",
          "implementationContent": "Создайте отдельные DataLoader для каждого типа объекта, который нужно подтягивать. Интегрируйте их в контекст GraphQL запроса.",
          "implementationCode": "```typescript\\n// backend/src/graphql/loaders/user.loader.ts\\nimport { Injectable, Scope } from '@nestjs/common';\\nimport DataLoader from 'dataloader';\\nimport { PrismaService } from 'nestjs-prisma';\\nimport { User } from '@prisma/client'; // Импорт модели Prisma\\n\\n// Scope.REQUEST - важно, чтобы DataLoader был уникален для каждого запроса GraphQL\\n@Injectable({ scope: Scope.REQUEST })\\nexport class UserLoader {\\n  private loader: DataLoader<string, User>;\\n\\n  constructor(private prisma: PrismaService) {\\n    // Создаем новый DataLoader. Функция batchLoadFn принимает массив ключей (user IDs)\\n    this.loader = new DataLoader<string, User>(\\n      async (ids: readonly string[]) => {\\n        // Выполняем ОДИН запрос к БД, чтобы получить ВСЕх пользователей по их ID\\n        const users = await this.prisma.user.findMany({\\n          where: {\\n            id: { in: Array.from(ids) }, // Array.from(ids) для совместимости с Prisma\\n          },\\n        });\\n\\n        // Важно: Вернуть массив результатов, упорядоченный по исходному массиву ids\\n        const userMap = new Map(users.map(user => [user.id, user]));\\n        return ids.map(id => userMap.get(id)); // Возвращаем пользователей в том же порядке, что и запросили\\n      },\\n      { cache: true } // Включаем кэширование внутри запроса GraphQL\\n    );\\n  }\\n\\n  // Метод для загрузки одного пользователя по ID\\n  load(id: string): Promise<User> {\\n    return this.loader.load(id);\\n  }\\n\\n  // Метод для загрузки списка пользователей по ID\\n  loadMany(ids: string[]): Promise<(Error | User)[]> {\\n      return this.loader.loadMany(ids);\\n  }\\n}\\n```\\nИнтегрируйте лоадеры в контекст GraphQL (`backend/src/graphql/graphql.module.ts` или `app.module.ts`):\\n```typescript\\n// backend/src/graphql/graphql.module.ts\\nimport { Module } from '@nestjs/common';\\nimport { GraphQLModule } from '@nestjs/graphql';\\nimport { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';\\nimport { UserLoader } from './loaders/user.loader'; // Импорт лоадера\\n// ... другие импорты резолверов и модулей\\n\\n@Module({\\n  imports: [\\n    GraphQLModule.forRoot<ApolloDriverConfig>({\\n      driver: ApolloDriver,\\n      // ... другие настройки GraphQL (schema path, context, etc.)\\n      context: ({ req, connection }) => {\\n        // Создаем контекст для каждого запроса\\n        const context = { req }; // Добавляем объект запроса\\n         if (connection) {\\n           // Для WebSocket (подписки)\\n           // context.loaders = new Loaders(); // Если лоадеры создаются здесь\\n         } else {\\n           // Для HTTP запросов (queries/mutations)\\n           // Создаем лоадеры и добавляем их в контекст\\n           context.loaders = {\\n              userLoader: new UserLoader(/* зависимости */), // Нужно инжектить PrismaService\\n              // ... другие лоадеры\\n           };\\n           // Пример инъекции зависимостей в лоадер (может потребовать FactoryProvider)\\n           // context.loaders = {\\n           //     userLoader: req.loaders.userLoader, // Если используете Request-scoped провайдеры NestJS\\n           // };\\n         }\\n        return context;\\n      },\\n      // plugins: [complexityPlugin], // Плагин для анализа сложности запросов\\n    }),\\n    // ... импорт других модулей\\n  ],\\n   providers: [UserLoader], // Добавляем лоадер как провайдер (для Request scope)\\n})\\nexport class GraphqlModule {}\\n```",
          "usageTitle": "Используйте лоадеры в резолверах:",
          "usageContent": "",
          "usageCode": "```typescript\\n// backend/src/message/message.resolver.ts\\nimport { Resolver, ResolveField, Parent, Context } from '@nestjs/graphql';\\nimport { Message } from '@prisma/client'; // Импорт модели Prisma\\nimport { UserLoader } from '../graphql/loaders/user.loader'; // Импорт лоадера\\n\\n@Resolver('Message') // Указываем GraphQL тип, к которому относится резолвер\\nexport class MessageResolver {\\n  @ResolveField('user') // Определяем резолвер для поля 'user' в типе Message\\n  async resolveUser(@Parent() message: Message, @Context() context: any) {\\n    // Используем userLoader из контекста для загрузки пользователя по message.userId\\n    // DataLoader автоматически соберет все message.userId в текущем запросе и загрузит их батчем\\n    return context.loaders.userLoader.load(message.userId);\\n  }\\n}\\n```"
        },
        "queryComplexityAnalysis": {
          "title": "5.2. Анализ Сложности Запросов: Защита от \"Тяжелых\" Запросов",
          "intro": "GraphQL позволяет клиенту запрашивать данные произвольной вложенности, что может привести к очень \"тяжелым\" запросам, сильно нагружающим сервер и БД.",
          "toolTitle": "Инструмент:",
          "toolContent": "`graphql-query-complexity`.",
          "whenTitle": "Когда использовать:",
          "whenContent": "Всегда включайте защиту от сложности в продакшене.",
          "principleTitle": "Принцип работы:",
          "principleContent": "Плагин анализирует запрос до его выполнения и вычисляет его \"сложность\" (например, как сумму \"стоимости\" каждого поля). Если сложность превышает заданный порог, запрос отклоняется.",
          "implementationTitle": "Реализация:",
          "implementationContent": "Настройте плагин в NestJS GraphQLModule (см. Руководство по разработке)."
        },
        "persistedQueries": {
          "title": "5.3. Persisted Queries: Кэширование Запросов на Уровне Сети",
          "intro": "Persisted Queries позволяют клиенту отправлять на сервер не полный текст GraphQL запроса, а только его хэш. Сервер по этому хэшу находит полный запрос (если он ему знаком) и выполняет его.",
          "whyTitle": "Почему:",
          "whyContent": "Уменьшает объем данных, передаваемых по сети, что ускоряет запросы, особенно на мобильных устройствах. Улучшает эффективность кэширования на CDN.",
          "whenTitle": "Когда использовать:",
          "whenContent": "Для часто повторяющихся запросов из клиента.",
          "implementationTitle": "Реализация:",
          "implementationContent": "Требует поддержки как на стороне клиента (Apollo Client поддерживает), так и на стороне сервера (Apollo Server поддерживает). На сервере нужно хранить соответствие хэшей и запросов (например, в Redis)."
        }
      },
      "backendLogicOptimization": {
        "title": "6. Оптимизация Backend Логики (NestJS): Эффективность Кода",
        "intro": "",
        "toolsTitle": "Инструменты:",
        "toolsContent": "Профилирование Node.js (V8 Profiler), обнаружение утечек памяти (`heapdump`).",
        "whenTitle": "Когда использовать:",
        "whenContent": "Для выявления \"горячих\" участков кода, потребляющих много CPU или памяти, и диагностики проблем с памятью.",
        "processTitle": "Процесс:",
        "processContent": "Используйте инструменты профилирования для <strong>измерения</strong> (Шаг 1 Кайдзен). Анализируйте результаты (Шаг 2). Вносите изменения в код (Шаг 3). Повторите (Шаг 4).",
        "recommendationsTitle": "Рекомендации:",
        "recommendationsContent": "Избегайте синхронных операций, блокирующих основной поток Node.js. Используйте асинхронные API. Оптимизируйте циклы, работу с большими массивами/объектами."
      },
      "caching": {
        "title": "7. Кэширование (Redis): Снижение Нагрузки на БД и Ускорение (Принцип 9)",
        "intro": "Кэширование позволяет хранить часто запрашиваемые данные в быстрой памяти (Redis), чтобы не обращаться к более медленной БД (Neon) при каждом запросе. Это ключевой <strong>рычаг</strong> для повышения <strong>эффективности системы</strong> (Принцип 9).",
        "libraryTitle": "Библиотека:",
        "libraryContent": "`ioredis`, `@nestjs/cache-manager`, `cache-manager-redis-store`.",
        "patternTitle": "Pаттерн:",
        "patternContent": "Cache-Aside (чтение из кэша, если нет — чтение из БД и запись в кэш).",
        "applicationAreasTitle": "Области применения:",
        "applicationAreasContent": "Часто запрашиваемые, относительно редко изменяющиеся данные (профили пользователей, настройки приложения, результаты сложных запросов/агрегаций, материализованных представлений).",
        "implementationTitle": "Реализация:",
        "implementationContent": "Настройте Redis в NestJS и используйте его в сервисах.",
        "invalidationTitle": "Ключевой аспект:",
        "invalidationContent": "<strong>Инвалидация кэша</strong>. При изменении данных в БД, удаляйте соответствующие ключи из Redis, чтобы клиенты не получали устаревшие данные."
      },
      "asyncProcessing": {
        "title": "8. Асинхронная Обработка (Kafka): Надежность и Отзывчивость (Принцип 9, 2)",
        "intro": "Используйте <strong>Kafka</strong> для выполнения задач, которые не требуют немедленного ответа пользователю (отправка email, обработка изображений, нотификации, аналитика).",
        "libraryTitle": "Библиотека:",
        "libraryContent": "`kafkajs`.",
        "whyTitle": "Почему:",
        "whyContent": "Kafka — <strong>надежная распределенная система очередей</strong>, гарантирующая доставку сообщений и позволяющая масштабировать обработку задач независимо от основного API (воркеры-консьюмеры).",
        "applicationAreasTitle": "Области применения:",
        "applicationAreasContent": [
          "Обработка изображений/видео после загрузки.",
          "Отправка больших объемов push-уведомлений.",
          "Генерация отчетов или статистики.",
          "Архивирование старых сообщений/файлов."
        ],
        "patternTitle": "Паттерн:",
        "patternContent": "<strong>Producer-Consumer</strong>. Backend-API ставит задачи в топик Kafka (Producer). Отдельные сервисы/воркеры (Consumer) читают задачи из топика и выполняют их в фоновом режиме.",
        "partitioningTitle": "Партиционирование в Kafka:",
        "partitioningContent": "Используйте ключи сообщений (например, `userId`, `chatId`), чтобы сообщения, относящиеся к одному пользователю/чату, попадали в одну партицию. Это гарантирует порядок обработки внутри партиции, что может быть важно для некоторых задач.",
        "monitoringTitle": "Мониторинг:",
        "monitoringContent": "Используйте <strong>Kafdrop</strong> для визуального мониторинга топиков, сообщений и состояния консьюмер-групп."
      },
      "pushNotificationsOptimization": {
        "title": "9. Оптимизация Push-уведомлений (Firebase FCM): Эффективная Доставка Информации (Принцип 2)",
        "intro": "Push-уведомления — важный канал связи с пользователем (Принцип 2: Ценность). Оптимизация их доставки важна для пользовательского опыта.",
        "platformTitle": "Платформа:",
        "platformContent": "Firebase Cloud Messaging (FCM).",
        "techniquesTitle": "Техники:",
        "techniquesContent": [
          "<strong>Батчинг:</strong> Отправляйте несколько уведомлений одним вызовом API FCM (`sendMulticast`) для снижения сетевых накладных расходов.",
          "<strong>Темы (Topics):</strong> Используйте темы для массовых рассылок (например, уведомление о новом сообщении в канале), чтобы FCM управлял списком подписчиков.",
          "<strong>Data Messages:</strong> Используйте Data Messages для полного контроля над отображением уведомления на клиенте и возможности прикреплять кастомные данные."
        ]
      },
      "clientApiDbInteraction": {
        "title": "10. Оптимизация Взаимодействия Клиент-API-БД: Сокращение Пути Данных (Принцип 9)",
        "intro": "",
        "clientLevelTitle": "На Уровне Клиента:",
        "clientLevelContent": "Используйте библиотеки для управления состоянием и кэширования данных, полученных по сети (`@apollo/client`, `react-query`/`@tanstack/react-query`). Это позволяет избежать повторных запросов за одними и теми же данными и быстро показывать кэшированные данные.",
        "networkLevelTitle": "На Уровне Сети:",
        "networkLevelContent": "Включите современные протоколы (HTTP/2, HTTP/3) и сжатие (Gzip/Brotli) на вашем API Gateway или Backend сервере для уменьшения объема передаваемых данных и снижения задержки.",
        "backendLevelTitle": "На Уровне Backend:",
        "backendLevelContent": "Оптимизируйте взаимодействие с БД (раздел 4) и внешними сервисами (раздел 7)."
      },
      "authenticationOptimization": {
        "title": "11. Оптимизация Аутентификации: Быстрота и Безопасность",
        "intro": "",
        "statelessJwtTitle": "Stateless (JWT):",
        "statelessJwtContent": "Использование JWT снижает нагрузку на сервер, так как ему не нужно хранить состояние сессий пользователей.",
        "rateLimitingTitle": "Rate Limiting (`@nestjs/throttler`):",
        "rateLimitingContent": "Защита эндпоинтов аутентификации от Brute Force атак, что также снижает нагрузку.",
        "secureHeadersTitle": "Безопасные Заголовки (`helmet`):",
        "secureHeadersContent": "Добавление HTTP-заголовков для защиты от XSS, CSRF и других атак."
      },
      "chatWebSocketOptimization": {
        "title": "12. Оптимизация Чатов (WebSocket): Низкая Задержка и Масштабирование",
        "intro": "WebSocket используется для обмена сообщениями в реальном времени. <strong>Оптимизация WebSocket-соединений критична для отзывчивости чатов</strong> (Принцип 2).",
        "libraryTitle": "Библиотека:",
        "libraryContent": "NestJS Gateways (`@nestjs/websockets`), Socket.IO (если нужна кросс-браузерная совместимость и fallback).",
        "techniquesTitle": "Техники:",
        "techniquesContent": [
          "<strong>Бинарные Форматы:</strong> Передача сообщений в бинарном формате (например, MessagePack) вместо текстового JSON может уменьшить объем данных.",
          "<strong>Батчинг Сообщений:</strong> Буферизируйте сообщения на клиенте и сервере и отправляйте их пачками (например, каждые 50 мс), а не по одному. Снижает количество пакетов.",
          "<strong>Управление Присутствием:</strong> Используйте Redis для быстрого отслеживания статуса онлайн/офлайн пользователей. Heartbeats (пинг-понг) для поддержания соединения и обнаружения отключений.",
          "<strong>Вертикальное/Горизонтальное Масштабирование:</strong> NestJS Gateways могут работать в кластерном режиме. Используйте Redis или другой Pub/Sub механизм (например, Kafka) для обмена сообщениями между инстансами Backend, чтобы сообщения доставлялись всем подписчикам, независимо от того, к какому инстансу Backend они подключены."
        ]
      },
      "animationsOptimization": {
        "title": "13. Оптимизация Анимаций: Плавность и Производительность (Принцип 3, 5)",
        "intro": "Производительные анимации делают интерфейс <strong>качественным</strong> (Принцип 3) и снижают нагрузку на устройство (Принцип 5: Здоровье).",
        "mobileDesktopTitle": "Mobile-Desktop (React Native):",
        "mobileDesktopContent": "Используйте `react-native-reanimated` для анимаций, которые выполняются на нативном потоке, не блокируя поток JavaScript.",
        "webTitle": "Web (Next.js):",
        "webContent": "Используйте `framer-motion` для декларативного создания плавных анимаций.",
        "docDesignTitle": "DocDesign:",
        "docDesignContent": "В DocDesign описаны принципы и параметры анимаций, включая возможность их отключения пользователем (Принцип 12: Прагматизм)."
      },
      "monitoring": {
        "title": "14. Мониторинг с Prometheus и Grafana: Измерение как Основа Кайдзен (Принцип 9)",
        "intro": "Система мониторинга — это ваши <strong>глаза</strong> и <strong>измерительные инструменты</strong> (Шаг 1 Кайдзен).",
        "toolsTitle": "Инструменты:",
        "toolsContent": "Prometheus (сбор метрик), Grafana (визуализация), Alertmanager (уведомления об аномалиях).",
        "whenTitle": "Когда использовать:",
        "whenContent": "Всегда. Настройте мониторинг на всех уровнях: Backend (задержки API, ошибки), БД (время запросов, нагрузка), Redis (попадания в кэш, использование памяти), Kafka (количество сообщений в топиках, лаг консьюмеров), Инфраструктура (CPU, RAM, сеть).",
        "implementationTitle": "Реализация:",
        "implementationContent": "См. подробные шаги по настройке в Руководстве по разработке (раздел 14).",
        "principleTitle": "Принцип:",
        "principleContent": "Используйте метрики для <strong>выявления узких мест</strong> (Шаг 2 Кайдзен) и оценки <strong>эффективности</strong> (Принцип 9) ваших оптимизаций. Настройте <strong>алерты</strong> для проактивного обнаружения проблем."
      },
      "ciCdOptimization": {
        "title": "15. Оптимизация CI/CD: Ускорение Цикла Разработки (Принцип 9)",
        "intro": "Эффективный CI/CD пайплайн ускоряет доставку кода, что является частью <strong>оптимизации всего процесса разработки</strong> (Принцип 9).",
        "toolsTitle": "Инструменты:",
        "toolsContent": "Turborepo (кэширование, параллелизация), GitHub Actions (автоматизация).",
        "techniquesTitle": "Техники:",
        "techniquesContent": [
          "<strong>Кэширование с Turborepo:</strong> Кэшируйте результаты сборки и тестов между запусками в CI и локально.",
          "<strong>Параллельное выполнение:</strong> Запускайте задачи (lint, build, test) для разных пакетов или частей тестов параллельно.",
          "<strong>Оптимизация Docker-образов:</strong> Используйте многоступенчатую сборку и `.dockerignore` для уменьшения размера образов и ускорения сборки/деплоя."
        ]
      },
      "frontendOptimization": {
        "title": "16. Оптимизация Фронтенда: Быстрота и Отзывчивость для Пользователя (Принцип 2, 3)",
        "intro": "Фронтенд должен быть <strong>быстрым и отзывчивым</strong>, чтобы пользователь ощутил <strong>ценность</strong> (Принцип 2) продукта.",
        "webTechniquesTitle": "Техники (Web - Next.js):",
        "webTechniquesContent": [
          "<strong>Code Splitting / Dynamic Imports:</strong> Загружайте код только тогда, когда он нужен (`next/dynamic`).",
          "<strong>SSR/SSG:</strong> Используйте серверный рендеринг или генерацию статики для ускорения первой отрисовки и SEO (`getStaticProps`, `getServerSideProps`).",
          "<strong>Оптимизация Изображений:</strong> Используйте `next/image` или `<picture>` и современные форматы (WebP).",
          "<strong>Анализ Бандла:</strong> Используйте `@next/bundle-analyzer` для выявления самых тяжелых модулей."
        ],
        "reactNativeTechniquesTitle": "Техники (React Native):",
        "reactNativeTechniquesContent": [
          "<strong>Ленивая Загрузка:</strong> Используйте `React.lazy` и `Suspense` для экранов и компонентов, которые не нужны при старте.",
          "<strong>Производительные Списки:</strong> Используйте `FlatList` или `SectionList` с правильной настройкой (`getItemLayout`, `windowSize`) для больших списков сообщений или чатов.",
          "<strong>Оптимизация Изображений:</strong> Используйте `react-native-fast-image`.",
          "<strong>Профилирование:</strong> Используйте Performance Monitor в Debugger Menu React Native для выявления узких мест UI."
        ],
        "generalTechniquesTitle": "Общие техники:",
        "generalTechniquesContent": [
          "Удаление неиспользуемого кода (Tree Shaking), замена тяжелых библиотек на легкие аналоги (например, `dayjs` вместо `moment`), сжатие бандлов (Gzip/Brotli)."
        ]
      },
      "dbScaling": {
        "title": "17. Масштабирование Базы Данных (Репликация и Шардинг): Подготовка к Росту (Принцип 8)",
        "intro": "Эти техники становятся актуальными при значительном росте объема данных и нагрузки. Они являются частью <strong>долгосрочной стратегии масштабирования</strong> (Принцип 8).",
        "replicationTitle": "Репликация (Master-Slave):",
        "replicationContent": "Создание копий БД только для чтения (read replicas). Позволяет распределить нагрузку на чтение.",
        "shardingTitle": "Шардинг:",
        "shardingContent": "Разделение данных большой таблицы на части (шарды) по определенному ключу (`chatId`, `userId`), распределяя их по разным серверам. Позволяет масштабировать как чтение, так и запись. Реализуется логически (в приложении) или с помощью расширений (Citus для PostgreSQL).",
        "whenToApplyTitle": "Когда применять:",
        "whenToApplyContent": "Основываясь на <strong>измерениях</strong> нагрузки и производительности БД (Принцип 9), а не заранее."
      },
      "notes": {
        "title": "18. Примечания: Непрерывный Кайдзен в Оптимизации",
        "prioritizationTitle": "Приоритезация:",
        "prioritizationContent": "Начинайте оптимизацию с тех мест, которые приносят наибольший эффект на текущем этапе проекта (Принцип 12). Для MVP это может быть скорость загрузки Frontend, производительность основных API-запросов.",
        "automationTitle": "Автоматизация:",
        "automationContent": "Максимально автоматизируйте процессы измерения и проверки оптимизаций (CI/CD, алерты в мониторинге) — это часть <strong>Системы</strong> (Принцип 9).",
        "documentationNotesTitle": "Документирование:",
        "documentationNotesContent": "Фиксируйте проведенные оптимизации, их эффект и уроки в этой документации или в задачах/коммитах (Принцип 1: Обучение, Принцип 9: Кайдзен).",
        "cultureTitle": "Культура:",
        "cultureContent": "Создайте культуру, где каждый разработчик несет ответственность за производительность своего кода и активно участвует в поиске и устранении узких мест (Принцип 6)."
      }
    },
    "apiSpec": {
      "title": "Спецификация API BrainMessenger (Интерфейс Системы)",
      "subtitle": "Интерфейс Системы",
      "generalInfo": {
        "title": "1. Общая Информация: API как Точка Взаимодействия с Системой",
        "description": "Этот документ описывает GraphQL API BrainMessenger — <strong>основной интерфейс</strong> (Принцип 9), через который клиентские приложения (Web, Mobile, Desktop) взаимодействуют с серверной частью системы и получают доступ к данным и функциональности. GraphQL выбран за его <strong>эффективность и гибкость</strong> (Принцип 9, 2), позволяя клиентам запрашивать только те данные, которые им необходимы.",
        "projectNameTitle": "Название проекта:",
        "projectNameContent": "BrainMessenger",
        "apiPurposeTitle": "Цель:",
        "apiPurposeContent": "Предоставить четкое и полное описание доступных запросов (Queries) и мутаций (Mutations), их входных и выходных данных, а также правил аутентификации и форматов ошибок. Это обеспечивает <strong>системность</strong> (Принцип 9) взаимодействия между Frontend и Backend и повышает <strong>качество</strong> (Принцип 3) разработки.",
        "baseUrlTitle": "Базовый URL:",
        "baseUrlContent": "`https://api.brainmessenger.com/graphql` (адрес API Gateway, который перенаправляет запросы на Backend Service).",
        "requestFormatTitle": "Формат запросов:",
        "requestFormatContent": "GraphQL-запросы (POST-запросы с `Content-Type: application/json` и телом в формате GraphQL).",
        "authenticationTitle": "Аутентификация:",
        "authenticationContent": "Для большинства методов требуется передать JWT-токен в заголовке `Authorization: Bearer <token>`. Токен получается после успешного логина. Это часть нашей <strong>системы безопасности</strong> (Принцип 3, 5).",
        "relatedDocsTitle": "Связь с другими документами:",
        "relatedDocsContent": [
          "DocTech.md: Общая архитектура системы, включая Backend и API Gateway.",
          "DocDevIn.md: Детали реализации Backend на NestJS и GraphQL.",
          "DocInt.md: Описание интеграций, которые Backend использует (Neon, R2, Firebase и др.).",
          "DocOptimizationIn.md: Подходы к оптимизации производительности API."
        ]
      },
      "graphqlSchema": {
        "title": "2. Схема GraphQL: Структура Доступных Данных и Операций",
        "description": "Полная схема GraphQL доступна по адресу API через инструменты интроспекции (например, GraphQL Playground, Apollo Studio). Ниже приведены основные типы и операции.",
        "dataTypes": {
          "title": "2.1. Типы Данных (Schemas): Описание Структуры Информации",
          "user": {
            "title": "User:",
            "code": "type User {\n  id: ID!\n  email: String!\n  name: String!\n  avatarUrl: String # URL аватара пользователя (хранится в R2)\n  createdAt: DateTime!\n  updatedAt: DateTime!\n  # ... другие поля (например, статус онлайн/оффлайн)\n}"
          },
          "chat": {
            "title": "Chat:",
            "code": "type Chat {\n  id: ID!\n  name: String! # Название чата (для групп/каналов)\n  type: String! # Тип чата (\"personal\", \"group\", \"channel\")\n  users: [User!] # Список участников чата\n  messages(pagination: PaginationInput): [Message!] # Сообщения в чате (с пагинацией)\n  lastMessageAt: DateTime # Время последнего сообщения (для сортировки списка чатов)\n  createdAt: DateTime!\n  updatedAt: DateTime!\n  # ... другие поля (например, фото группы/канала, описание)\n}"
          },
          "message": {
            "title": "Message:",
            "code": "type Message {\n  id: ID!\n  content: String! # Текст сообщения (для текстовых сообщений)\n  fileUrl: String # URL файла, если сообщение является файлом (хранится в R2)\n  fileMetadata: JSON # Метаданные файла (тип, размер, имя) (хранится в Neon/R2)\n  sender: User! # Отправитель сообщения\n  chat: Chat! # Чат, которому принадлежит сообщение\n  createdAt: DateTime! # Время отправки сообщения\n  updatedAt: DateTime!\n  # ... другие поля (например, статус прочтения, реакции)\n}"
          },
          "paginationInput": {
            "title": "PaginationInput:",
            "code": "input PaginationInput {\n  take: Int # Максимальное количество элементов\n  skip: Int # Пропустить элементов (для offset-based пагинации)\n  cursor: String # Курсор (ID) для cursor-based пагинации\n}"
          },
          "authPayload": {
            "title": "AuthPayload:",
            "code": "type AuthPayload {\n  token: String! # JWT токен доступа\n  user: User! # Данные аутентифицированного пользователя\n}"
          },
          "dateTimeJson": {
            "title": "DateTime, JSON:",
            "content": "Стандартные скалярные типы или кастомные скаляры, определенные на Backend."
          }
        },
        "operations": {
          "title": "2.2. Операции (Queries и Mutations): Доступ к Функционалу Системы",
          "authentication": {
            "title": "2.2.1. Аутентификация (Authentication)",
            "registerUser": {
              "title": "`mutation registerUser(input: RegisterInput!): AuthPayload!`",
              "description": "Регистрирует нового пользователя в системе.",
              "input": "`RegisterInput`: `{ email: String!, password: String!, name: String! }` (password min 8 chars, digit, special char - см. валидацию).",
              "authRequired": "Требуется аутентификация: Нет.",
              "scenario": "Сценарий: Пользователь заполняет форму регистрации.",
              "errors": "Ошибки: `400 Bad Request` (неверный формат данных/валидация), `409 Conflict` (email уже используется)."
            },
            "loginUser": {
              "title": "`mutation loginUser(input: LoginInput!): AuthPayload!`",
              "description": "Аутентифицирует пользователя по email и паролю.",
              "input": "`LoginInput`: `{ email: String!, password: String! }`.",
              "authRequired": "Требуется аутентификация: Нет.",
              "scenario": "Сценарий: Пользователь вводит учетные данные для входа.",
              "errors": "Ошибки: `401 Unauthorized` (неверный email или пароль)."
            },
            "logoutUser": {
              "title": "`mutation logoutUser: Boolean!`",
              "description": "Инвалидирует текущий JWT токен на сервере (если реализовано хранение токенов или их черных списков).",
              "authRequired": "Требуется аутентификация: Да (используется текущий токен).",
              "scenario": "Сценарий: Пользователь нажимает \"Выйти\".",
              "returns": "Возвращает: `true` при успешном выходе.",
              "errors": "Ошибки: `401 Unauthorized` (токен недействителен)."
            }
          },
          "user": {
            "title": "2.2.2. Пользователь (User)",
            "getUser": {
              "title": "`query getUser(id: ID!): User`",
              "description": "Получает данные пользователя по его уникальному ID.",
              "authRequired": "Требуется аутентификация: Да (для доступа к любым данным пользователя, кроме, возможно, публичного профиля).",
              "scenario": "Сценарий: Просмотр профиля пользователя.",
              "errors": "Ошибки: `404 Not Found` (пользователь с таким ID не найден)."
            },
            "getCurrentUser": {
              "title": "`query getCurrentUser: User!`",
              "description": "Получает данные текущего аутентифицированного пользователя.",
              "authRequired": "Требуется аутентификация: Да.",
              "scenario": "Сценарий: Загрузка профиля текущего пользователя при старте приложения.",
              "errors": "Ошибки: `401 Unauthorized`."
            },
            "updateUser": {
              "title": "`mutation updateUser(id: ID!, input: UserInput!): User!`",
              "description": "Обновляет данные профиля пользователя.",
              "input": "`UserInput`: `{ name: String, email: String, password: String, avatarUrl: String }`. Поля опциональны.",
              "authRequired": "Требуется аутентификация: Да (и пользователь должен быть владельцем профиля или иметь права администратора).",
              "scenario": "Сценарий: Пользователь редактирует свой профиль.",
              "errors": "Ошибки: `400 Bad Request` (неверный формат данных), `401 Unauthorized`, `403 Forbidden` (нет прав на редактирование этого пользователя), `404 Not Found`."
            },
            "deleteUser": {
              "title": "`mutation deleteUser(id: ID!): Boolean!`",
              "description": "Удаляет аккаунт пользователя.",
              "authRequired": "Требуется аутентификация: Да (и пользователь должен быть владельцем аккаунта).",
              "scenario": "Сценарий: Пользователь решает удалить свою учетную запись.",
              "returns": "Возвращает: `true` при успешном удалении.",
              "errors": "Ошибки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            }
          },
          "chats": {
            "title": "2.2.3. Чаты (Chats)",
            "getChats": {
              "title": "`query getChats: [Chat!]!`",
              "description": "Получает список всех чатов, в которых участвует текущий пользователь.",
              "authRequired": "Требуется аутентификация: Да.",
              "scenario": "Сценарий: Загрузка списка чатов на главном экране.",
              "errors": "Ошибки: `401 Unauthorized`."
            },
            "getChat": {
              "title": "`query getChat(id: ID!): Chat`",
              "description": "Получает данные конкретного чата по ID.",
              "authRequired": "Требуется аутентификация: Да (и пользователь должен быть участником этого чата).",
              "scenario": "Сценарий: Открытие конкретного чата.",
              "errors": "Ошибки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            },
            "createChat": {
              "title": "`mutation createChat(input: CreateChatInput!): Chat!`",
              "description": "Создает новый чат.",
              "input": "`CreateChatInput`: `{ type: String!, name: String, userIds: [ID!]! }`. `type` может быть \"personal\", \"group\", \"channel\". `name` обязателен для \"group\" и \"channel\". `userIds` включает ID создателя и других участников (для \"personal\" и \"group\").",
              "authRequired": "Требуется аутентификация: Да.",
              "scenario": "Сценарий: Пользователь создает новый чат или группу.",
              "errors": "Ошибки: `400 Bad Request` (неверный тип, отсутствуют userIds и т.п.), `401 Unauthorized`, `403 Forbidden` (нет прав на создание такого типа чата)."
            },
            "getMessages": {
              "title": "`query getMessages(chatId: ID!, pagination: PaginationInput): [Message!]!`",
              "description": "Получает список сообщений для заданного чата. Поддерживает пагинацию.",
              "authRequired": "Требуется аутентификация: Да (и пользователь должен быть участником чата).",
              "scenario": "Сценарий: Открытие чата, подгрузка старых сообщений при прокрутке.",
              "errors": "Ошибки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            },
            "sendMessage": {
              "title": "`mutation sendMessage(chatId: ID!, content: String!, fileUrl: String, fileMetadata: JSON): Message!`",
              "description": "Отправляет новое сообщение в чат. Может содержать текст или ссылку на файл.",
              "input": "`chatId`: ID чата. `content`: Текст сообщения. `fileUrl`: URL файла в R2 (опционально). `fileMetadata`: Метаданные файла (опционально).",
              "authRequired": "Требуется аутентификация: Да (и пользователь должен быть участником чата).",
              "scenario": "Сценарий: Пользователь отправляет текстовое сообщение или файл.",
              "errors": "Ошибки: `400 Bad Request`, `401 Unauthorized`, `403 Forbidden` (нет прав писать в этот чат), `404 Not Found` (чат не найден)."
            },
            "deleteMessage": {
              "title": "`mutation deleteMessage(messageId: ID!): Boolean!`",
              "description": "Удаляет сообщение.",
              "authRequired": "Требуется аутентификация: Да (и пользователь должен быть отправителем сообщения или иметь права администратора чата).",
              "scenario": "Сценарий: Пользователь удаляет свое сообщение.",
              "returns": "Возвращает: `true` при успешном удалении.",
              "errors": "Ошибки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            }
          },
          "externalIntegrations": {
            "title": "2.2.4. Внешние Интеграции (через API Backend)",
            "sendVerificationCode": {
              "title": "`mutation sendVerificationCode(email: String!): Boolean!`",
              "description": "Запускает процесс отправки кода подтверждения на указанный email (используя Gmail API). Используется при регистрации или сбросе пароля.",
              "authRequired": "Требуется аутентификация: Нет.",
              "scenario": "Сценарий: Пользователь вводит email на экране регистрации/восстановления пароля.",
              "returns": "Возвращает: `true` при успешной постановке задачи на отправку.",
              "errors": "Ошибки: `400 Bad Request` (неверный формат email), `429 Too Many Requests` (защита от спама)."
            },
            "verifyEmailCode": {
              "title": "`mutation verifyEmailCode(email: String!, code: String!): Boolean!`",
              "description": "Проверяет код подтверждения, полученный по email.",
              "authRequired": "Требуется аутентификация: Нет.",
              "scenario": "Сценарий: Пользователь вводит код из email.",
              "returns": "Возвращает: `true` при успешной проверке.",
              "errors": "Ошибки: `400 Bad Request` (неверный код или email), `404 Not Found` (для данного email нет активного кода)."
            },
            "enableTwoFactorAuth": {
              "title": "`mutation enableTwoFactorAuth(userId: ID!): Boolean!`",
              "description": "Включает/отключает двухфакторную аутентификацию для пользователя. Требует предварительной верификации email. Код для 2FA отправляется на email (Gmail API) при каждом логине после включения.",
              "authRequired": "Требуется аутентификация: Да (пользователь должен управлять своим аккаунтом).",
              "scenario": "Сценарий: Пользователь настраивает безопасность аккаунта.",
              "errors": "Ошибки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`, `400 Bad Request` (email не верифицирован)."
            },
            "disableTwoFactorAuth": {
              "title": "`mutation disableTwoFactorAuth(userId: ID!): Boolean!`",
              "description": "Включает/отключает двухфакторную аутентификацию для пользователя. Требует предварительной верификации email. Код для 2FA отправляется на email (Gmail API) при каждом логине после включения.",
              "authRequired": "Требуется аутентификация: Да (пользователь должен управлять своим аккаунтом).",
              "scenario": "Сценарий: Пользователь настраивает безопасность аккаунта.",
              "errors": "Ошибки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`, `400 Bad Request` (email не верифицирован)."
            },
            "sendTwoFactorCode": {
              "title": "`mutation sendTwoFactorCode(userId: ID!): Boolean!`",
              "description": "Отправляет код двухфакторной аутентификации на email пользователя.",
              "authRequired": "Требуется аутентификация: Частичная (например, после ввода пароля, но до ввода 2FA кода). Логика зависит от флоу аутентификации.",
              "scenario": "Сценарий: Пользователь входит в аккаунт с включенной 2FA.",
              "errors": "Ошибки: `404 Not Found` (пользователь не найден или 2FA не включена), `429 Too Many Requests`."
            },
            "createPaymentSession": {
              "title": "`mutation createPaymentSession(input: PaymentInput!): PaymentSessionPayload!`",
              "description": "Создает сессию оплаты через Stripe для оформления Premium подписки.",
              "input": "`PaymentInput`: `{ planId: ID!, returnUrl: String! }` (ID выбранного тарифного плана, URL для редиректа после оплаты).",
              "authRequired": "Требуется аутентификация: Да.",
              "scenario": "Сценарий: Пользователь нажимает \"Подписаться\" на Premium экране.",
              "errors": "Ошибки: `400 Bad Request` (неверный planId), `401 Unauthorized`."
            }
          }
        }
      },
      "errorHandling": {
        "title": "3. Обработка Ошибок API: Ясная Обратная Связь (Принцип 3, 14)",
        "description": "API возвращает стандартизированные ошибки для <strong>ясной обратной связи</strong> (Принцип 14) с клиентом и поддержания <strong>качества</strong> (Принцип 3).",
        "errorFormatTitle": "Формат ошибок (в соответствии со спецификацией GraphQL):",
        "errorFormatCode": "{\n  \"data\": null, // Обычно null при ошибках верхнего уровня\n  \"errors\": [\n    {\n      \"message\": \"Описание ошибки (может быть локализовано - см. DocLocIn)\",\n      \"locations\": [...], // Расположение ошибки в запросе\n      \"path\": [...],      // Путь к полю, вызвавшему ошибку\n      \"extensions\": {\n        \"code\": \"КОД_ОШИБКИ\", // Стандартизированный код ошибки (например, \"UNAUTHENTICATED\", \"FORBIDDEN\", \"BAD_USER_INPUT\", \"NOT_FOUND\")\n        \"http\": { // Если применимо, HTTP статус код\n          \"status\": 401,\n          \"headers\": {}\n        },\n         \"details\": {} // Дополнительные детали об ошибке (опционально)\n      }\n    }\n    // ... могут быть другие ошибки\n  ]\n}",
        "keyErrorCodesTitle": "Ключевые коды ошибок (extensions.code):",
        "keyErrorCodesList": [
          "`UNAUTHENTICATED`: Требуется аутентификация, но токен отсутствует или недействителен (`HTTP 401`).",
          "`FORBIDDEN`: Аутентификация пройдена, но у пользователя нет прав на выполнение операции (`HTTP 403`).",
          "`BAD_USER_INPUT`: Ошибка валидации входных данных (`HTTP 400`). Детали могут быть в `extensions.details`.",
          "`NOT_FOUND`: Запрошенный ресурс не найден (`HTTP 404`).",
          "`CONFLICT`: Конфликт данных (например, попытка зарегистрировать email, который уже существует) (`HTTP 409`).",
          "`INTERNAL_SERVER_ERROR`: Неожиданная ошибка на сервере (`HTTP 500`).",
          "`RATE_LIMITED`: Превышен лимит запросов (`HTTP 429`)."
        ],
        "localizationErrorsTitle": "Локализация ошибок:",
        "localizationErrorsContent": "Сообщения об ошибках (`message`) могут быть локализованы на стороне Backend на основе заголовка `Accept-Language` или предпочтений пользователя (см. DocLocIn)."
      },
      "notes": {
        "title": "4. Примечания",
        "dataTypes": {
          "title": "Типы данных:",
          "list": [
            "`ID`: Уникальный идентификатор ресурса (обычно строка).",
            "`String`: Текстовая строка.",
            "`Int`, `Float`: Числа.",
            "`Boolean`: Логическое значение (`true`/`false`).",
            "`DateTime`: Дата и время в формате ISO 8601 (например, \"2025-03-14T10:30:00Z\").",
            "`JSON`: Кастомный скаляр для передачи произвольных JSON-объектов (например, для `fileMetadata`).",
            "`!` в конце типа означает, что поле <strong>не может быть null</strong>."
          ]
        },
        "pagination": {
          "title": "Пагинация:",
          "content": "Для списков, которые могут быть длинными (`messages`), используйте пагинацию для эффективной загрузки данных (Принцип 9)."
        },
        "validation": {
          "title": "Валидация:",
          "content": "Backend выполняет строгую валидацию всех входных данных (через DTO и `class-validator`), возвращая ошибки `BAD_USER_INPUT` при их некорректности. Это часть <strong>системы обеспечения качества</strong> (Принцип 3)."
        },
        "security": {
          "title": "Безопасность:",
          "content": "Все запросы, работающие с чувствительными данными или изменяющие состояние системы (кроме регистрации/логина), требуют аутентификации."
        },
        "testingTools": {
          "title": "Инструменты тестирования API:",
          "content": "Используйте GraphQL Playground (часто доступен по адресу `/graphql` в dev-режиме Backend), Postman или Apollo Studio для отправки запросов и тестирования API."
        }
      }
    },
    "technicalDocs": {
      "title": "BrainMessenger Technical Documentation (System and Foundation)",
      "subtitle": "General Information: Architecture of a Digital Asset",
      "generalInfo": {
        "title": "1. General Information: Architecture of a Digital Asset",
        "description": "BrainMessenger is a modern messenger built as a <strong>reliable, scalable, and secure system</strong> (Principle 9), which serves as a <strong>key digital ASSET</strong> (Principle 10). This document provides a high-level overview of the project's <strong>technical foundation</strong> (Principle 8), describing the main components, technologies, and their interaction.",
        "projectNameTitle": "Project Name:",
        "projectNameContent": "BrainMessenger",
        "purposeTitle": "Purpose:",
        "purposeContent": "To provide a general understanding of BrainMessenger's structure, the technology stack used, and the principles underlying its construction, for all team members and stakeholders.",
        "principlesTitle": "Principles reflected in the technical structure:",
        "principlesList": [
          "<strong>System and Optimization (Principle 9):</strong> The project is designed as a set of interconnected, optimized components.",
          "<strong>Long-Term Thinking (Principle 8):</strong> Selection of technologies and architecture considering future scaling and development needs.",
          "<strong>Quality > Quantity (Principle 3):</strong> Use of proven, reliable solutions and focus on code and infrastructure quality.",
          "<strong>Pragmatism and Realism (Principle 12):</strong> Use of ready-made services (Neon, R2, Firebase) where justified, instead of building everything from scratch.",
          "<strong>Value Creation (Principle 2):</strong> The technical structure aims to provide key messenger functions (communication, files, calls) at a high level."
        ]
      },
      "techStack": {
        "title": "2. Technology Stack: Tools for Building the System",
        "description": "We use a modern and flexible set of technologies, allowing us to effectively build and scale BrainMessenger.",
        "frontend": {
          "title": "Frontend (Client Applications):",
          "list": [
            "<strong>React Native (Android, Windows Desktop):</strong> A single codebase for mobile and desktop applications. Chosen for cross-platform compatibility and a large set of ready-made libraries.",
            "<strong>Next.js (Web):</strong> React-framework for web application with SSR/SSG support for performance and SEO.",
            "<strong>TypeScript:</strong> Strict typing for all Frontend code. Increases reliability and simplifies refactoring."
          ]
        },
        "backend": {
          "title": "Backend (Server Logic):",
          "list": [
            "<strong>Node.js:</strong> High-performance JavaScript/TypeScript runtime environment.",
            "<strong>NestJS:</strong> Modular framework for Node.js. Provides a structured architecture (modules, services, controllers/resolvers) and TypeScript support.",
            "<strong>GraphQL:</strong> API protocol. Allows clients to request exactly the data they need, reducing redundancy."
          ]
        },
        "databaseCaching": {
          "title": "Database and Caching:",
          "list": [
            "<strong>PostgreSQL (via Neon):</strong> Reliable relational DBMS. Used as the main storage for structured data (users, chats, messages, metadata). Neon provides a managed service with scaling and replication features.",
            "<strong>Prisma ORM:</strong> Tool for interacting with PostgreSQL from NestJS. Provides typing and query security.",
            "<strong>Redis:</strong> In-memory data store. Used for caching, Rate Limiting, managing WebSocket connection state (user presence)."
          ]
        },
        "fileStorage": {
          "title": "File Storage:",
          "list": [
            "<strong>Cloudflare R2:</strong> Object storage, compatible with S3 API. Used for storing user files (photos, videos, documents, avatars, call recordings), encrypted data. Chosen for low cost and no egress fees."
          ]
        },
        "asyncProcessing": {
          "title": "Asynchronous Processing:",
          "list": [
            "<strong>Kafka:</strong> Distributed message queue system. Used for reliable asynchronous task processing (e.g., image processing, sending notifications) outside the main API thread."
          ]
        },
        "infrastructureDeployment": {
          "title": "Infrastructure and Deployment:",
          "list": [
            "<strong>Docker:</strong> Application containerization. Provides isolation and portability.",
            "<strong>Kubernetes:</strong> Container orchestration. Manages deployment, scaling, and self-healing of services in a cluster.",
            "<strong>Terraform:</strong> Infrastructure as Code (IaC). Automates the creation and management of cloud resources."
          ]
        },
        "testingMonitoringLogging": {
          "title": "Testing, Monitoring, Logging:",
          "list": [
            "<strong>Jest, Cypress, Detox:</strong> Tools for unit, integration, and E2E testing.",
            "<strong>Prometheus, Grafana:</strong> Monitoring system. Collection and visualization of performance metrics and system status.",
            "<strong>Winston, Sentry:</strong> Logging and error tracking system."
          ]
        }
      },
      "architecture": {
        "title": "3. Project Architecture: Interconnection of System Components",
        "description": "BrainMessenger's architecture follows the principles of <strong>modularity and separation of concerns</strong> (Principle 9).",
        "clientApplications": {
          "title": "Client Applications (Frontend):",
          "list": [
            "Web (Next.js), Mobile & Desktop (React Native).",
            "Contain the user interface and user interaction logic.",
            "Interact with the Backend exclusively via <strong>GraphQL API</strong>.",
            "Can directly download files from Cloudflare R2 (if public access) or via Backend (if authentication or URL signing is required)."
          ]
        },
        "apiGateway": {
          "title": "API Gateway (In the future):",
          "content": "Single entry point for all client requests. Can perform authentication, Rate Limiting, routing to the necessary Backend services. At startup, the Backend itself acts as the Gateway."
        },
        "backendService": {
          "title": "Backend Service (NestJS):",
          "list": [
            "Main server component.",
            "Contains <strong>BrainMessenger's business logic</strong> (user management, chats, messages, calls, payments).",
            "Provides <strong>GraphQL API</strong> for client applications.",
            "Interacts with the <strong>Database (Neon/PostgreSQL via Prisma)</strong> for reading/writing structured data.",
            "Interacts with <strong>File Storage (Cloudflare R2)</strong> for uploading/retrieving files (via AWS SDK).",
            "Interacts with <strong>Cache (Redis)</strong> for fast operations.",
            "Queues tasks in <strong>Queue (Kafka)</strong> for asynchronous processing.",
            "Uses external services (Firebase, Stripe, Gmail API)."
          ]
        },
        "database": {
          "title": "Database (Neon/PostgreSQL):",
          "content": "Stores structured data. Scales independently."
        },
        "fileStorage": {
          "title": "File Storage (Cloudflare R2):",
          "content": "Stores unstructured binary data. Scales by volume."
        },
        "caching": {
          "title": "Caching (Redis):",
          "content": "Fast access to temporary data."
        },
        "messageQueue": {
          "title": "Message Queue (Kafka):",
          "content": "Buffering and reliable message delivery between services for asynchronous processing."
        },
        "workers": {
          "title": "Workers (Kafka Consumers):",
          "list": [
            "Separate services that read tasks from Kafka and perform heavy or long operations (image processing, sending large mailings).",
            "Scale independently."
          ]
        },
        "externalServices": {
          "title": "External Services (Firebase, Stripe, Gmail API):",
          "list": [
            "Provide specialized functionality (notifications, payments, email).",
            "Used by the Backend service."
          ]
        },
        "mermaidDiagram": {
          "title": "Architecture Diagram:",
          "code": "graph TD\n    A[Frontend Web (Next.js)] -->|GraphQL API| B(API Gateway / Backend);\n    A -->|Direct File Access (Opt.)| E(Cloudflare R2);\n    F[Frontend Mobile/Desktop (React Native)] -->|GraphQL API| B;\n    F -->|Direct File Access (Opt.)| E;\n    B -->|Prisma Queries/Mutations| C(Neon/PostgreSQL);\n    B -->|AWS SDK (S3 API)| E;\n    B -->|ioredis| D(Redis Cache);\n    B -->|kafkajs Producer| G(Kafka Queue);\n    B -->|Firebase Admin SDK| H(Firebase FCM);\n    B -->|Stripe SDK| I(Stripe);\n    B -->|Google APIs Client| J(Gmail API);\n    G -->|kafkajs Consumer| K(Kafka Workers);\n    K -->|sharp| K; % Image processing\n    K -->|AWS SDK (S3 API)| E;\n    K -->|GraphQL API / Other Service Calls| B; % Report completion, send chat message\n    C -->|Replication (for scaling)| C;\n    C -->|Partitioning/Sharding (for scaling)| C;\n    E -->|CDN| A; % File delivery to Frontend\n    Prometheus(Prometheus) -->|Scrape Metrics| B;\n    Prometheus -->|Scrape Metrics| C;\n    Prometheus -->|Scrape Metrics| D;\n    Prometheus -->|Scrape Metrics| G;\n    Grafana(Grafana) -->|Visualize Metrics| Prometheus;\n    Sentry(Sentry) -->|Error Reports| B;\n    Sentry -->|Error Reports| A;"
        }
      },
      "api": {
        "title": "4. API: Interaction Interface",
        "description": "BrainMessenger's API is implemented using GraphQL with NestJS.",
        "endpointTitle": "Endpoint:",
        "endpointContent": "`/graphql`",
        "structureTitle": "Structure:",
        "structureContent": "Defined by the GraphQL Schema (User, Chat, Message types, etc.) and a set of Queries (for data retrieval) and Mutations (for data modification).",
        "authenticationTitle": "Authentication:",
        "authenticationContent": "JWT tokens in the `Authorization: Bearer <token>` header.",
        "externalApiIntegrationsTitle": "External API Integrations:",
        "externalApiIntegrationsContent": "Interaction with external services (Gmail, Stripe) is done via the Backend, which provides corresponding Mutations in the GraphQL API (see API Specification).",
        "keyFunctionalAreas": {
          "title": "Key functional areas of the API:",
          "list": [
            "Authentication (registration, login, logout, 2FA).",
            "User management (get/update/delete profile).",
            "Chat management (create, get list, get chat data).",
            "Message handling (send text messages, send files, get history).",
            "Contact management.",
            "Application settings (theme, notifications, language).",
            "Premium subscription management.",
            "File management (upload to R2 via Backend).",
            "(In the future) Calls and video calls (call session management)."
          ]
        },
        "detailedSpecTitle": "Detailed API specification is described in:",
        "detailedSpecContent": "DocSpec.md"
      },
      "database": {
        "title": "5. Database (Neon/PostgreSQL): Main Data Storage",
        "description": "",
        "technologyTitle": "Technology:",
        "technologyContent": "PostgreSQL 15.x.",
        "hostingTitle": "Hosting:",
        "hostingContent": "Neon.",
        "roleTitle": "Role:",
        "roleContent": "Relational database for all structured data.",
        "keyTables": {
          "title": "Key tables (defined in backend/prisma/schema.prisma):",
          "list": [
            "User: User information (id, email, password_hash, name, avatarUrl, createdAt, updatedAt, is2FaEnabled).",
            "Chat: Chat information (id, type, name, createdAt, updatedAt, lastMessageAt).",
            "UserChat: Linking table for Many-to-Many relationship between User and Chat (userId, chatId, joinedAt, lastReadMessageId).",
            "Message: Messages in chats (id, chatId, senderId, content, fileUrl, fileMetadata (JSON), createdAt, updatedAt).",
            "Contact: User's contact list (id, userId, contactId).",
            "Transaction: Payment history (for Premium) (id, userId, amount, currency, status, provider, createdAt).",
            "Code: Temporary codes (for email verification, 2FA) (id, userId/email, code, type, expiresAt)."
          ]
        },
        "interactionTitle": "Interaction:",
        "interactionContent": "Backend only via Prisma ORM.",
        "optimizationScalingTitle": "Optimization and Scaling:",
        "optimizationScalingContent": "Indexes, Prisma query optimization, materialized views, partitioning, replication are used (see DocOptimizationIn)."
      },
      "fileStorage": {
        "title": "6. File Storage (Cloudflare R2): Storage for Media and Binary Assets",
        "description": "",
        "technologyTitle": "Technology:",
        "technologyContent": "Object storage, S3-compatible API.",
        "hostingTitle": "Hosting:",
        "hostingContent": "Cloudflare R2.",
        "roleTitle": "Role:",
        "roleContent": "Storage for all unstructured data (user files, avatars, call recordings).",
        "interactionTitle": "Interaction:",
        "interactionContent": "Backend uploads files, Backend or Frontend retrieves files (directly or via signed URLs).",
        "structureTitle": "Structure:",
        "structureContent": "Files are organized by folders/keys (e.g., `avatars/`, `chat-images/`, `sensitive-data/`).",
        "securityTitle": "Security:",
        "securityContent": "Encryption at rest, restricted access, encryption of sensitive data at the application level before upload (see DocInt, DocSecurity)."
      },
      "projectStructure": {
        "title": "7. Project Structure (Monorepository): Code Organization",
        "description": "The project is organized as a monorepository using Turborepo.",
        "purposeTitle": "Purpose:",
        "purposeContent": "To simplify managing multiple applications/packages (backend, web, mobile-desktop, core) and code reuse.",
        "packages": {
          "title": "Packages:",
          "list": [
            "core: Common code.",
            "backend: Server logic.",
            "web: Web application.",
            "mobile-desktop: Mobile/desktop application (React Native).",
            "Infrastructure: Configuration files for deployment (infrastructure/).",
            "Documentation: Project documentation (docs/)."
          ]
        },
        "detailedDescriptionTitle": "Detailed description of the monorepository structure can be found in:",
        "detailedDescriptionContent": "DocDevIn.md (section 2)."
      },
      "security": {
        "title": "8. Security: Fundamental Aspect of the System",
        "description": "Security is built in at all levels (see more in BrainMessenger Security Guide).",
        "authenticationTitle": "Authentication:",
        "authenticationContent": "JWT, 2FA via email.",
        "authorizationTitle": "Authorization:",
        "authorizationContent": "Access rights verification for resources on the Backend.",
        "encryptionTitle": "Encryption:",
        "encryptionContent": "TLS/SSL for data transfer, password hashing (bcrypt/argon2), encryption of sensitive data at the application level before storing in R2.",
        "validationTitle": "Validation:",
        "validationContent": "Strict input data validation on the Backend.",
        "attackProtectionTitle": "Protection against Attacks:",
        "attackProtectionContent": "Rate Limiting, secure HTTP headers.",
        "principleTitle": "Principle:",
        "principleContent": "Security is a continuous process of learning (Principle 1) and improvement (Principle 9), based on responsibility (Principle 6)."
      },
      "deployment": {
        "title": "9. Deployment: Delivering the System to Users",
        "description": "The deployment process is automated.",
        "containerizationTitle": "Containerization:",
        "containerizationContent": "Docker images for Backend, Kafka Consumers.",
        "orchestrationTitle": "Orchestration:",
        "orchestrationContent": "Kubernetes manages containers in the cloud.",
        "iacTitle": "Infrastructure as Code:",
        "iacContent": "Terraform (IaC). Automates the creation and management of cloud resources.",
        "ciCdTitle": "CI/CD:",
        "ciCdContent": "GitHub Actions automates build, testing, and deployment.",
        "webAppDeploymentTitle": "Web application can be deployed separately (e.g., on Vercel or Cloudflare Pages).",
        "webAppDeploymentContent": "",
        "detailedDescriptionTitle": "Detailed description of the deployment process can be found in:",
        "detailedDescriptionList": [
          "DocDevIn.md (section 9)",
          "Deployment Guide"
        ]
      },
      "monitoringLogging": {
        "title": "10. Monitoring and Logging: Visibility into System State",
        "description": "",
        "monitoringTitle": "Monitoring:",
        "monitoringList": [
          "Collection and visualization of performance and system health metrics (CPU, RAM, API/DB latencies, errors).",
          "Tools: Prometheus, Grafana. Allows early problem detection (Principle 9: Kaizen)."
        ],
        "loggingTitle": "Logging:",
        "loggingList": [
          "Collection of structured logs from all components (Backend, workers).",
          "Tools: Winston (for Node.js), Sentry (for error tracking)."
        ],
        "detailedDescriptionTitle": "Detailed description can be found in:",
        "detailedDescriptionList": [
          "BrainMessenger Optimization Guide (section 14)",
          "Monitoring Guide"
        ]
      },
      "externalApiIntegrations": {
        "title": "11. External API Integrations: Using External Levers",
        "description": "The Backend interacts with several external services via their APIs.",
        "gmailApiTitle": "Gmail API:",
        "gmailApiContent": "Sending transactional emails (confirmation, 2FA).",
        "stripeTitle": "Stripe:",
        "stripeContent": "Payment processing and subscriptions.",
        "firebaseFCMTitle": "Firebase FCM:",
        "firebaseFCMContent": "Sending push notifications to mobile devices.",
        "principleTitle": "Principle:",
        "principleContent": "Using these services is a pragmatic (Principle 12) way to quickly add functionality, using ready-made, reliable (Principle 3) solutions.",
        "detailedDescriptionTitle": "Detailed description of integrations can be found in:",
        "detailedDescriptionContent": "DocInt.md"
      },
      "notes": {
        "title": "12. Notes",
        "description": "This documentation provides a high-level overview of the BrainMessenger technical system. For a more detailed understanding of individual parts, refer to related documents:",
        "apiSpecLinkTitle": "API Specification:",
        "apiSpecLinkContent": "DocSpec.md",
        "devGuideLinkTitle": "Development Guide:",
        "devGuideLinkContent": "DocDevIn.md",
        "optimizationGuideLinkTitle": "Optimization Guide:",
        "optimizationGuideLinkContent": "DocOptimizationIn.md",
        "integrationsDocsLinkTitle": "Integrations Documentation:",
        "integrationsDocsLinkContent": "DocInt.md",
        "designDocsLinkTitle": "Design Documentation:",
        "designDocsLinkContent": "DocDesign.md",
        "userGuideLinkTitle": "User Guide:",
        "userGuideLinkContent": "DocUser.md",
        "longTermInvestmentTitle": "Development and maintenance of this technical system is a long-term investment (Principle 8) and a continuous process of learning and improvement (Principle 1, 9)."
      }
    }
  }
}
