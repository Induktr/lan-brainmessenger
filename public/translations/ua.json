{
  "header": {
      "features": "Функції",
      "news": "Новини",
      "faq": "FAQ",
      "faqLink": "Поширені запитання",
      "docs": "Документація",
      "updates": "Оновлення",
      "selectLanguage": "Вибрати мову",
      "changeLanguageTooltip": "Змінити мову",
      "lightMode": "Світла тема",
      "darkMode": "Темна тема",
      "openMenu": "Відкрити меню",
      "closeMenu": "Закрити меню",
      "settings": "Налаштування",
      "signOut": "Вийти",
      "deleteAccount": "Видалити обліковий запис",
      "deleteAccountConfirmTitle": "Підтвердити видалення облікового запису",
      "deleteAccountConfirmMessage": "Ви впевнені, що бажаєте видалити свій обліковий запис? Цю дію неможливо скасувати.",
      "cancel": "Скасувати",
      "confirmDelete": "Підтвердити видалення",
      "signIn": "Увійти"
    },
    "hero": {
      "title": "Ласкаво просимо до BrainMessenger",
      "subtitle": "Ваша розумна платформа для спілкування",
      "getStarted": "Почати",
      "learnMore": "Дізнатися більше",
      "connectSmarterTitle": "Спілкуйтесь розумніше з BrainMessenger",
      "connectSmarterSubtitle": "Відчуйте нове покоління обміну повідомленнями з розширеними функціями, неперевершеною безпекою та безперебійним зв'язком на всіх ваших пристроях.",
      "downloadButton": "Завантажити",
      "downloadAndroid": "Завантажити для Android"
    },
    "features": {
      "featuresTitle": "Ключові функції",
      "featuresSubtitle": "Відкрийте для себе, що робить нас унікальними",
      "secureMessaging": "Безпечні повідомлення",
      "secureMessagingDesc": "Наскрізне шифрування для вашої конфіденційності",
      "smartAssistant": "Розумний помічник",
      "smartAssistantDesc": "Допомога на базі ШІ завжди під рукою",
      "crossPlatform": "Кросплатформенність",
      "crossPlatformDesc": "Використовуйте на будь-якому пристрої, будь-де",
      "groupChats": "Групові чати",
      "groupChatsDesc": "Спілкуйтесь з кількома людьми одночасно",
      "privacyFirst": "Конфіденційність насамперед",
      "privacyFirstDesc": "Ваші дані належать вам, завжди"
    },
    "news": {
      "latestNews": "Останні новини",
      "readMore": "Читати далі",
      "previousButton": "Попередня новина",
      "nextButton": "Наступна новина",
      "pauseAutoplay": "Призупинити автовідтворення",
      "playAutoplay": "Відтворити автовідтворення"
    },
    "roadmap": {
      "title": {
        "section": "Дорожня карта",
        "projectLaunch": "Запуск проєкту",
        "enhancedSecurity": "Покращена безпека",
        "advancedCollaboration": "Розширена співпраця",
        "mobileEnhancement": "Покращення мобільної версії",
        "aiIntegration": "Інтеграція ШІ",
        "globalExpansion": "Глобальне розширення",
        "enterpriseSolutions": "Корпоративні рішення",
        "futureInnovation": "Майбутні інновації"
      },
      "subtitle": {
        "section": "Наше бачення майбутнього"
      },
      "status": {
        "completed": "Завершено",
        "inProgress": "У процесі",
        "upcoming": "Майбутні"
      },
      "description": {
        "projectLaunch": "Початковий запуск BrainMessenger з основними функціями.",
        "enhancedSecurity": "Посилення протоколів безпеки та функцій.",
        "advancedCollaboration": "Впровадження розширених інструментів для співпраці.",
        "mobileEnhancement": "Покращення досвіду використання мобільного застосунку.",
        "aiIntegration": "Інтеграція функцій на базі ШІ для розумнішого спілкування.",
        "globalExpansion": "Розширення охоплення BrainMessenger по всьому світу.",
        "enterpriseSolutions": "Розробка рішень для корпоративних клієнтів.",
        "futureInnovation": "Дослідження та впровадження майбутніх технологій."
      },
      "features": {
        "secureMessagingInfrastructure": "Інфраструктура безпечного обміну повідомленнями",
        "crossPlatformCompatibility": "Кросплатформна сумісність",
        "basicUserInterface": "Базовий користувацький інтерфейс",
        "endToEndEncryption": "Наскрізне шифрування",
        "twoFactorAuthentication": "Двофакторна автентифікація",
        "fileSharingCapabilities": "Можливості обміну файлами",
        "teamWorkspaces": "Командні робочі простори",
        "realTimeCollaboration": "Співпраця в реальному часі",
        "advancedFileSharing": "Розширений обмін файлами",
        "nativeMobileApps": "Нативні мобільні застосунки",
        "offlineFunctionality": "Офлайн-функціонал",
        "pushNotifications": "Push-сповіщення",
        "smartMessageCategorization": "Розумна категоризація повідомлень",
        "automatedResponses": "Автоматичні відповіді",
        "contentAnalysis": "Аналіз контенту",
        "multiLanguageSupport": "Багатомовна підтримка",
        "regionalDataCenters": "Регіональні центри обробки даних",
        "culturalAdaptations": "Культурні адаптації",
        "advancedAdminControls": "Розширені елементи керування адміністратора",
        "customIntegrations": "Користувацькі інтеграції",
        "enterpriseSupport": "Корпоративна підтримка",
        "emergingTechnologies": "Новітні технології",
        "communityDrivenFeatures": "Функції, розроблені спільнотою",
        "platformExpansion": "Розширення платформи"
      },
      "date": {
        "jan2024": "Січень 2024",
        "mar2024": "Березень 2024",
        "jun2024": "Червень 2024",
        "sep2024": "Вересень 2024",
        "nov2024": "Листопад 2024",
        "jan2025": "Січень 2025",
        "mar2025": "Березень 2025",
        "jun2025": "Червень 2025",
        "beyond2025": "Після 2025"
      }
    },
  "faq": {
      "title": "Часто задавані питання",
      "subtitle": "Знайдіть відповіді на поширені питання про BrainMessenger",
      "searchAlt": "Іконка пошуку",
      "searchPlaceholder": "Шукати питання...",
      "allQuestions": "Усі питання",
      "noResults": "Питань за вашим запитом не знайдено.",
      "categories": {
        "general": "Загальні",
        "technical": "Технічні",
        "security": "Безпека",
        "pricing": "Ціни",
        "generalProject": "Загальні питання щодо проєкту",
        "technicalQuestions": "Технічні питання",
        "developmentProcesses": "Процеси розробки",
        "statusRoadmapFuture": "Статус, дорожня карта та майбутнє",
        "challengesOpportunitiesLimitations": "Виклики, можливості та обмеження",
        "learnMoreContribute": "Дізнатися більше та зробити внесок"
      },
      "questionsData": {
        "generalProject": {
          "q1": {
            "question": "Яка основна ідея BrainMessenger? Що робить його особливим?",
            "answer": "BrainMessenger — це не просто черговий месенджер. Наша основна ідея — створити Цифровий АКТИВ (Принцип 10), який спрощує складну взаємодію (принцип Маргулана Сейсембаєва) та слугує надійним інструментом для ефективної комунікації. Ми зосереджені на якості (Принцип 3), безпеці (Принцип 5) та надійності (Принцип 3), а не просто на наборі функцій. Ми будуємо СИСТЕМУ (Принцип 9), яка відображає наші принципи та постійно покращується."
          },
          "q2": {
            "question": "Які ключові принципи лежать в основі розробки BrainMessenger?",
            "answer": "Проєкт базується на наборі з 15 ключових принципів (див. Мої ключові принципи), натхненних Маргуланом Сейсембаєвим та найкращими практиками IT-індустрії. Найважливіші, що впливають на код та процеси: Безперервне навчання (Принцип 1), Створення цінності (Принцип 2), Якість > Кількість (Принцип 3), Система та оптимізація (Кайдзен, Принцип 9), Довгострокове мислення (Принцип 8), Прагматизм та реалізм (Принцип 12), Наполегливість (Принцип 13), Схильність до дії (Принцип 15). Ми прагнемо, щоб ці принципи пронизували всі аспекти проєкту."
          },
          "q3": {
            "question": "Хто стоїть за проєктом? Це відкрита спільнота чи команда?",
            "answer": "Наразі проєкт перебуває на ранній стадії та активно розробляється однією особою (вами), яка є рушійною силою та несе відповідальність (Принцип 6) за його побудову. У майбутньому планується залучення контриб'юторів та, можливо, формування команди. Проєкт відкритий для внесків (див. CONTRIBUTING.md)."
          }
        },
        "technicalQuestions": {
          "q1": {
            "question": "Чому було обрано саме цей технологічний стек (TypeScript, NestJS, React/RN, PostgreSQL/Neon, GraphQL, Kafka, Redis, Cloudflare R2 тощо)?",
            "answer": "Вибір стека базується на прагматизмі (Принцип 12), довгостроковому мисленні (Принцип 8) та прагненні до якості (Принцип 3) та масштабованості (НФВ-14, НФВ-15).\n*   TypeScript: Збільшує надійність та підтримуваність коду завдяки строгій типізації.\n*   NestJS: Надає потужну, модульну архітектуру для бекенду, спрощуючи побудову масштабованих додатків.\n*   React/React Native/Next.js: Дозволяють створювати UI для різних платформ з єдиної кодової бази (крос-платформність) та забезпечують хорошу продуктивність.\n*   PostgreSQL (Neon): Надійна, перевірена реляційна база даних з широкими можливостями масштабування та оптимізації. Neon як керований сервіс зменшує операційні витрати (Прагматизм).\n*   Prisma: Обрано як надійний ORM, що забезпечує типобезпеку та вбудований захист від SQL-ін'єкцій (Якість, Безпека).\n*   GraphQL: Дозволяє клієнтам запитувати лише ті дані, які їм дійсно потрібні, одним запитом, оптимізуючи мережеву взаємодію (особливо для мобільних клієнтів) та зменшуючи надлишковість даних порівняно з REST. GraphQL також спрощує отримання пов'язаних даних (вирішуючи N+1 проблеми з DataLoader).\n*   Kafka: Обрано для надійної асинхронної обробки завдань, що критично важливо для масштабованості та відмовостійкості.\n*   Redis: Високопродуктивне In-memory сховище для кешування, Rate Limiting та управління станом у реальному часі.\n*   Cloudflare R2: Об'єктне сховище з дуже вигідними умовами (без плати за вихідний трафік), ідеально підходить для зберігання файлів користувачів (Прагматизм, АКТИВ).\n\nЦей стек дозволяє закласти міцну технічну основу (Принцип 8) для майбутнього розвитку."
          },
          "q2": {
            "question": "Чому на старті використовується монолітна архітектура, а не відразу мікросервіси?",
            "answer": "Використання монолітної архітектури на старті (MVP) — це прагматичне та реалістичне рішення (Принцип 12). Воно дозволяє швидко розробляти та ітерувати базовий функціонал, мінімізуючи складність на ранній стадії, коли команда невелика. Запуск MVP важливіший, ніж побудова надмірно складної архітектури. Після завершення MVP та зростання проєкту планується поетапний перехід до мікросервісів (див. План міграції на мікросервіси)."
          },
          "q3": {
            "question": "Які підходи використовуються для забезпечення безпеки?",
            "answer": "Безпека є фундаментальним аспектом (Принцип 5) та пріоритетом (див. Посібник з безпеки).\n*   Шифрування даних при передачі (TLS 1.2+) та в стані спокою (AES для чутливих даних, шифрування в R2).\n*   Надійне хешування паролів (bcrypt/argon2).\n*   Використання Prisma для запобігання SQL-ін'єкціям.\n*   Валідація всіх вхідних даних на бекенді.\n*   Двофакторна автентифікація (2FA) через електронну пошту.\n*   Обмеження швидкості запитів (Rate Limiting) для захисту від брутфорс- та DDoS-атак.\n*   Регулярне сканування на вразливості.\n*   Зберігання секретів у захищених місцях (Kubernetes Secrets)."
          },
          "q4": {
            "question": "Як реалізовано функціональність реального часу (обмін повідомленнями)?",
            "answer": "Функціональність реального часу (обмін повідомленнями) реалізована з використанням WebSockets. Бекенд (NestJS Gateway) керує WebSocket-з'єднаннями, а клієнти підписуються на події чату. Доставка повідомлень відбувається через WebSocket. Для масштабування WebSockets у мікросервісній архітектурі буде використовуватися Redis Pub/Sub або Kafka."
          },
          "q5": {
            "question": "Чому використовується GraphQL замість REST API?",
            "answer": "GraphQL дозволяє клієнтам запитувати лише ті дані, які їм дійсно потрібні, одним запитом. Це оптимізує мережеву взаємодію (особливо для мобільних клієнтів) та зменшує надлишковість даних порівняно з REST. GraphQL також спрощує отримання пов'язаних даних (вирішуючи N+1 проблеми з DataLoader)."
          },
          "q6": {
            "question": "Як керуються великі обсяги даних та файлів?",
            "answer": "*   Структуровані дані (повідомлення, користувачі, чати): Зберігаються в PostgreSQL (Neon). Для швидкого отримання використовуються індекси та оптимізація запитів (Prisma). У міру зростання планується партиціонування таблиць та реплікація бази даних.\n*   Неструктуровані дані (файли, зображення): Зберігаються в Cloudflare R2. Для оптимізації зображень перед завантаженням використовується асинхронна обробка (Kafka). R2 обрано через масштабованість та вигідні тарифи на трафік."
          }
        },
        "developmentProcesses": {
          "q1": {
            "question": "Який підхід використовується до управління проєктом та завданнями?",
            "answer": "Управління проєктом ведеться за допомогою системи планування (див. Моя система планування 2025-2026) у Notion. Використовується декомпозиція глобальних цілей на етапи (Roadmap), тижневе планування та трекер завдань. Важливим елементом є Година Кайдзен (Принцип 9) для щоденної рефлексії, аналізу вузьких місць та пошуку шляхів покращення."
          },
          "q2": {
            "question": "Як забезпечується якість коду?",
            "answer": "Якість коду забезпечується системними підходами (Принцип 3, 9):\n*   Використання TypeScript із суворою типізацією.\n*   Дотримання стандартів кодування (ESLint, Prettier).\n*   Code review всіх змін.\n*   Автоматизоване тестування на різних рівнях (Unit, Integration, E2E).\n*   Безперервна інтеграція (CI) для автоматичної перевірки коду та тестів при кожному комміті/PR."
          },
          "q3": {
            "question": "Яка стратегія тестування використовується?",
            "answer": "Використовується багаторівнева стратегія тестування (див. Посібник з тестування), що поєднує ручне та автоматизоване тестування: Unit, Integration, API, E2E, Load, Security, Regression. Тести інтегровані в CI/CD. Фокус робиться на перевірці ключових вимог (ФВ, НФВ)."
          },
          "q4": {
            "question": "Як обробляються помилки?",
            "answer": "Помилки обробляються централізовано та уніфіковано на бекенді (NestJS Exception Filters) та перетворюються на стандартний формат відповіді API з кодами (extensions.code). На фронтенді помилки обробляються на основі цих кодів, відображаючи користувачеві зрозуміле повідомлення та пропонуючи дію. Усі помилки ретельно логуються (Winston → ELK) та відправляються до Sentry для відстеження та аналізу (див. Специфікація помилок, Посібник з моніторингу)."
          },
          "q5": {
            "question": "Як відбувається розгортання проєкту?",
            "answer": "Розгортання автоматизовано через CI/CD пайплайн (GitHub Actions). Для контейнеризації використовується Docker, а для оркестрації в хмарі — Kubernetes. Інфраструктура описана як код (Terraform). Процес включає автоматичну збірку, тестування, публікацію образів та Rolling Updates у Kubernetes для розгортання без простою (див. Посібник з розгортання)."
          },
          "q6": {
            "question": "Як система моніториться у продакшені?",
            "answer": "Система моніторингу — це очі та вуха проєкту (Принцип 9, 5). Використовуються:\n*   Prometheus для збору метрик продуктивності та ресурсів.\n*   Grafana для візуалізації метрик та дашбордів.\n*   Sentry для відстеження помилок додатків (фронтенд та бекенд).\n*   ELK Stack (або Kibana з Winston) для централізованого логування та аналізу.\n*   Alertmanager для налаштування автоматичних сповіщень про проблеми.\nЦі інструменти дозволяють завчасно виявляти проблеми та проводити оптимізацію (див. Посібник з моніторингу)."
          }
        },
        "statusRoadmapFuture": {
          "q1": {
            "question": "Який поточний статус проєкту?",
            "answer": "Проєкт перебуває в активній фазі розробки Мінімально життєздатного продукту (MVP). Закладено основний технологічний фундамент, реалізовано ключові елементи UI та базову безпеку. У процесі реалізації знаходиться основний функціонал обміну повідомленнями, роботи з файлами та створення груп/каналів. (Див. Посібник з вимог до проєкту BrainMessenger (MVP))."
          },
          "q2": {
            "question": "Які наступні кроки після завершення MVP?",
            "answer": "Після завершення MVP наступні кроки включають додавання розширених функцій (аудіо/відеодзвінки, Преміум, розширена безпека, повний набір анімацій та локалізації), подальшу оптимізацію продуктивності та підготовку до масштабування. Детальний план представлений у Дорожній карті BrainMessenger (див. Roadmap)."
          },
          "q3": {
            "question": "Чи планується перехід на мікросервісну архітектуру?",
            "answer": "Так, перехід на мікросервіси є частиною довгострокової стратегії розвитку (Принцип 8). Він планується поетапно, починаючи з 1 кварталу 2026 року, з використанням підходу Strangler Pattern. Це дозволить незалежно масштабувати компоненти, підвищуючи відмовостійкість та гнучкість (див. План міграції на мікросервіси)."
          }
        },
        "challengesOpportunitiesLimitations": {
          "q1": {
            "question": "Які основні технічні виклики (підводні камені) у проєкті?",
            "answer": "*   Реалізація надійної функціональності реального часу (WebSockets): Керування тисячами одночасних підключень, надійна доставка повідомлень, керування статусом онлайн/оффлайн.\n*   Масштабування бази даних при великих обсягах даних: Керування зростанням таблиці повідомлень (партиціонування), оптимізація складних запитів.\n*   Обробка та доставка файлів: Ефективне завантаження, оптимізація зображень, безпечне завантаження з Cloudflare R2.\n*   Перехід до мікросервісів: Збільшення операційної складності, налаштування міжсервісної комунікації (Kafka, GraphQL Federation), міграція даних.\n*   Підтримка високої якості та продуктивності: Безперервна оптимізація на всіх рівнях (бекенд, фронтенд, інфраструктура) у міру зростання навантаження та функціоналу."
          },
          "q2": {
            "question": "Які можливості та переваги надає архітектура та стек проєкту?",
            "answer": "*   Висока масштабованість: Обрані технології (NestJS, Kubernetes, Kafka, Redis, Neon, R2) дозволяють горизонтально масштабувати додаток для підтримки великої кількості користувачів.\n*   Надійність та відмовостійкість: Використання надійних сервісів, асинхронна обробка (Kafka), моніторинг та, у майбутньому, мікросервіси підвищують стійкість системи до відмов.\n*   Висока продуктивність: GraphQL, кешування, оптимізація запитів, асинхронна обробка сприяють швидкій роботі програми.\n*   Крос-платформність: React Native та Next.js дозволяють створювати додатки для всіх основних платформ з єдиної кодової бази (для UI).\n*   Якість коду та підтримуваність: TypeScript, NestJS, Prisma, стандарти кодування, тестування спрощують розробку та зменшують кількість дефектів.\n*   Економічна ефективність (на старті): Використання безкоштовних/доступних тарифів (Neon, R2) та перевірених рішень з відкритим вихідним кодом.\n*   Багата екосистема: Використання популярних технологій з великою спільнотою та багатьма готовими бібліотеками."
          },
          "q3": {
            "question": "Які обмеження проєкту на поточному етапі (MVP)?",
            "answer": "*   Обмежений набір функцій порівняно з баченням (немає дзвінків, Преміум, посиленої безпеки).\n*   Обмежені можливості багатомовності та доступності (планується розширення).\n*   Архітектура наразі монолітна, що накладає обмеження на незалежне масштабування окремих частин.\n*   Можуть бути обмеження щодо продуктивності при навантаженні, що значно перевищує цільову для MVP (~1000 одночасних користувачів), до впровадження глибоких оптимізацій та мікросервісів."
          }
        },
        "learnMoreContribute": {
          "q1": {
            "question": "Де я можу отримати більш детальну інформацію про проєкт?",
            "answer": "Більш детальну інформацію можна знайти в нашій документації (посилання буде додано пізніше) та на сторінці проєкту на GitHub (якщо проєкт відкритий)."
          },
          "q2": {
            "question": "Як я можу долучитися до розробки проєкту або зробити свій внесок?",
            "answer": "Ми завжди раді новим учасникам! Зв'яжіться з нами через контактну форму на сайті або через GitHub (якщо проєкт відкритий), щоб обговорити можливі варіанти співпраці."
          },
          "q3": {
            "question": "Де я можу поставити додаткові запитання?",
            "answer": "Додаткові запитання можна поставити через контактну форму на сайті, в нашому ком'юніті (посилання буде додано) або створивши issue на GitHub (якщо проєкт відкритий)."
          }
        }
  },
  "docs": {
    "general": {
      "title": "BrainMessenger - Ваш Цифровий Актив для Ефективної Комунікації",
      "subtitle": "Вступ: Побудова Системи Цінності",
      "introduction": {
        "title": "Вступ: Побудова Системи Цінності",
        "content": "Ласкаво просимо до репозиторію BrainMessenger. Це не просто черговий месенджер. Це цілеспрямований проект, що має на меті створення <strong>надійної, масштабованої та безпечної СИСТЕМИ</strong> (Принцип 9), яка стане <strong>ключовим цифровим АКТИВОМ</strong> (Принцип 10) для кожного користувача. Наша головна мета — <strong>спрощувати складність</strong> (принцип Маргулана Сейсембаєва), надаючи інтуїтивно зрозумілі та потужні інструменти для ефективного спілкування та взаємодії в сучасному цифровому світі.<br/><br/>BrainMessenger будується на <strong>міцному фундаменті</strong> (Принцип 8) глибоких принципів, усвідомленого планування та <strong>безперервного навчання</strong> (Принцип 1). Кожен рядок коду, кожне прийняте рішення – це <strong>довгострокова інвестиція</strong> (Принцип 8) у <strong>якість</strong> (Принцип 3) та <strong>цінність</strong> (Принцип 2) нашого продукту."
      },
      "visionAndMission": {
        "title": "Бачення та Місія: Наш Довгостроковий Погляд",
        "visionTitle": "Наше Бачення:",
        "visionContent": "Створити провідний цифровий актив для комунікації, який допоможе мільйонам користувачів по всьому світу ефективно обмінюватися інформацією, будувати спільноти та досягати своїх цілей.",
        "missionTitle": "Наша Місія:",
        "missionContent": "Спрощувати складну взаємодію, надаючи надійний, безпечний та зручний месенджер, побудований на принципах якості, прозорості та безперервного вдосконалення."
      },
      "keyPrinciples": {
        "title": "Ключові Принципи: Фундамент Нашої Системи",
        "intro": "Наші дії та рішення керуються набором ключових принципів, які слугують <strong>фундаментом</strong> (Принцип 8) всього проекту BrainMessenger. Це не просто слова, а <strong>особисті алгоритми та стандарти (Кайдзен, Принцип 9)</strong>, вироблені через досвід та рефлексію (Принцип 1):",
        "principles": [
          "<strong>Безперервне Навчання та Зростання (Принцип 1):</strong> Процес створення BrainMessenger – це полігон для глибокого навчання в технологіях, архітектурі та психології користувача. Ми навчаємось на кожному кроці, перетворюючи помилки на уроки.",
          "<strong>Створення Цінності (Принцип 2):</strong> Користь користувача лежить в основі всього. Ми будуємо те, що по-справжньому вирішує проблеми та робить життя кращим.",
          "<strong>Якість понад Кількість (Принцип 3):</strong> Ми прагнемо робити речі добре, а не просто швидко. Надійність, продуманість та увага до деталей – наші пріоритети.",
          "<strong>Усвідомленість та Присутність (Принцип 4):</strong> Бути уважним до процесу, користувачів та команди.",
          "<strong>Здоров'я як Фундамент (Принцип 5):</strong> Фізичне та ментальне благополуччя команди (та майбутніх користувачів) – основа продуктивності та стійкості.",
          "<strong>Відповідальність та Проактивність (Принцип 6):</strong> Ми беремо на себе відповідальність за результат і діємо на випередження.",
          "<strong>Цілісність (Принцип 7):</strong> Наші слова відповідають нашим діям.",
          "<strong>Довгострокове Мислення (Принцип 8):</strong> Ми інвестуємо час та зусилля з прицілом на майбутнє.",
          "<strong>Система та Оптимізація (Принцип 9):</strong> Ми будуємо процеси та архітектуру як систему, постійно шукаємо способи підвищення ефективності (Кайдзен).",
          "<strong>Створення Багатства > Заробляння Грошей (Принцип 10):</strong> Фокус на створенні АКТИВУ (BrainMessenger), який приносить цінність та працює в довгостроковій перспективі.",
          "<strong>Гнучкість та Адаптивність (Принцип 11):</strong> Готовність змінювати тактику та інструменти, зберігаючи бачення.",
          "<strong>Прагматизм та Реалізм (Принцип 12):</strong> Прийняття рішень на основі реальних даних та можливостей.",
          "<strong>Наполегливість (Принцип 13):</strong> Не здаватися перед труднощами, витягуючи уроки з невдач.",
          "<strong>Використання Зовнішньої Експертизи та Зворотного Зв'язку (Принцип 14):</strong> Ми вчимося у інших, прислухаємося до конструктивної критики.",
          "<strong>Схильність до Дії (Принцип 15):</strong> На ранніх етапах важливіше почати робити та отримувати зворотний зв'язок, ніж безкінечно планувати."
        ],
        "outro": "Ці принципи, натхненні філософією Маргулана Сейсембаєва та практиками провідних IT-компаній, формують нашу культуру та підхід до розробки."
      },
      "aboutMVP": {
        "title": "Про Проект BrainMessenger (Фокус на MVP)",
        "intro": "Наш поточний фокус – на розробці <strong>Мінімально Життєздатного Продукту (MVP)</strong>. MVP – це перший, <strong>прагматичний</strong> (Принцип 12) крок до реалізації нашого бачення. Ми будуємо <strong>міцний технічний фундамент</strong> (Принцип 8), який дозволить нам швидко та ефективно розвивати продукт у майбутньому.",
        "featuresTitle": "MVP включає базові, але <strong>високоякісні та надійні</strong> (Принцип 3) функції, що надають ключову <strong>цінність</strong> (Принцип 2):",
        "features": [
          "<strong>Базове Листування:</strong> Надсилання та отримання текстових повідомлень у особистих чатах та групах/каналах.",
          "<strong>Обмін Файлами:</strong> Завантаження та завантаження файлів (з оптимізацією зображень).",
          "<strong>Канали та Групи:</strong> Базове створення груп/каналів, приєднання до публічних каналів та читання контенту.",
          "<strong>Базове Управління Обліковим Записом:</strong> Реєстрація, вхід/вихід, редагування профілю (ім'я, аватар), базові налаштування безпеки.",
          "<strong>Основні Налаштування UI:</strong> Вибір теми (Світла/Темна), базові налаштування сповіщень та мови.",
          "<strong>Базова Безпека:</strong> Шифрування даних (TLS, хешування паролів, базові заходи проти SQLi/XSS/DDoS), підтвердження електронної пошти під час реєстрації.",
          "<strong>Адаптивний UI:</strong> Інтерфейс, адаптований для мобільних (Android, iOS) та веб-платформ.",
          "<strong>Базова Багатомовність:</strong> Підтримка кількох мов інтерфейсу (англійська, російська та інші згідно з DocLocIn.md)."
        ],
        "outro": "Функціональність за межами MVP (аудіо/відеодзвінки, розширені функції безпеки/приватності, преміум-підписка, повний набір анімацій, інтеграції зі ШІ) планується на наступні етапи Дорожньої карти."
      },
      "howWeBuild": {
        "title": "Як Ми Будуємо: Історія Створення та Процес Кайдзен",
        "intro": "Процес створення BrainMessenger – це жива історія, заснована на наших принципах. Ми будуємо його <strong>системно</strong> (Принцип 9), крок за кроком, документуючи кожен етап та безперервно шукаючи можливості для <strong>покращення (Кайдзен)</strong>.",
        "steps": [
          "<strong>Усвідомлене Планування (Принцип 4):</strong> Проект розпочався з чіткого визначення глобальних цілей та їх декомпозиції на досяжні етапи (Дорожня карта).",
          "<strong>Вибір Фундаменту (Принцип 8, 12):</strong> Ми ретельно відібрали технологічний стек – надійні та <strong>прагматичні</strong> інструменти (TypeScript, NestJS, React/RN, PostgreSQL/Neon, Cloudflare R2, Kafka, Redis), які формують <strong>міцний технічний фундамент</strong>.",
          "<strong>Побудова Ядра MVP:</strong> Реалізація розпочалася з базових, критично важливих частин системи (Аутентифікація, Базовий UI, Інфраструктура, Робота з файлами). Ми застосовуємо <strong>Схильність до Дії</strong> (Принцип 15), фокусуючись на створенні працюючих компонентів, нехай поки й мінімальних.",
          "<strong>Безперервне Навчання та Застосування Знань (Принцип 1):</strong> Кожне нове завдання, особливо пов'язане з вивченням або інтеграцією технологій (як видно у <a href=\"https://www.notion.so/2025-2026-1576e78881b7435e9c3c2cf174e61b91?pvs=4\" target=\"_blank\" rel=\"noopener noreferrer\">Video Tracker</a> та завданнях), розглядається як можливість для зростання. Ми документуємо цей процес через відео та рефлексію (Кайдзен-Година).",
          "<strong>Системний Підхід до Якості (Принцип 3, 9):</strong> Ми інтегруємо тестування на ранніх етапах циклу розробки (Unit-тести), налаштовуємо CI/CD пайплайни для автоматичних перевірок, використовуємо інструменти моніторингу (Prometheus, Grafana, Sentry) та логування (Winston, ELK) для постійного контролю за <strong>здоров'ям системи</strong> (Принцип 5) у реальному часі.",
          "<strong>Документація як Частина Системи Знань:</strong> Весь процес розробки, архітектурні рішення, стандарти та вимоги ретельно документуються. Це не просто формальність, а частина створення <strong>системи знань</strong>, яка прискорює онбординг, спрощує підтримку та дозволяє приймати обґрунтовані рішення в майбутньому."
        ],
        "outro": "Ми будуємо BrainMessenger як живий організм, що розвивається, постійно адаптуючись та покращуючись на основі наших принципів та зворотного зв'язку від процесу розробки та майбутніх користувачів."
      },
      "technologyStack": {
        "title": "Технологічний Стек: Наші Інструменти для Створення Активу",
        "intro": "Ми обрали стек, який є <strong>прагматичним</strong> (Принцип 12), <strong>надійним</strong> (Принцип 3) та <strong>масштабованим</strong> (Принцип 8) для створення нашого <strong>цифрового АКТИВУ</strong>.",
        "stack": [
          "<strong>Мова:</strong> <a href=\"https://www.typescriptlang.org/\" target=\"_blank\" rel=\"noopener noreferrer\">TypeScript</a> - Статична типізація для підвищення якості та надійності коду.",
          "<strong>Бекенд:</strong> <a href=\"https://nodejs.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Node.js</a>, <a href=\"https://nestjs.com/\" target=\"_blank\" rel=\"noopener noreferrer\">NestJS</a> - Ефективний та структурований фреймворк для серверної логіки та GraphQL API.",
          "<strong>Фронтенд:</strong> <a href=\"https://react.dev/\" target=\"_blank\" rel=\"noopener noreferrer\">React</a>, <a href=\"https://nextjs.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Next.js</a> (Веб), <a href=\"https://reactnative.dev/\" target=\"_blank\" rel=\"noopener noreferrer\">React Native</a> (Мобільні/Десктоп) - Кроссплатформна розробка UI з фокусом на продуктивність.",
          "<strong>API:</strong> <a href=\"https://graphql.org/\" target=\"_blank\" rel=\"noopener noreferrer\">GraphQL</a> - Гнучка взаємодія між клієнтом та сервером.",
          "<strong>Реальний час:</strong> WebSockets - Миттєва доставка повідомлень.",
          "<strong>База даних:</strong> <a href=\"https://www.postgresql.org/\" target=\"_blank\" rel=\"noopener noreferrer\">PostgreSQL</a> (через <a href=\"https://neon.tech/\" target=\"_blank\" rel=\"noopener noreferrer\">Neon</a>) - Надійна та масштабована база даних. Neon як керований сервіс знижує операційні витрати (Прагматизм).",
          "<strong>ORM:</strong> <a href=\"https://www.prisma.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Prisma</a> - Типобезпечна та надійна взаємодія з БД, захист від SQL-ін'єкцій (Якість, Безпека).",
          "<strong>Кешування:</strong> <a href=\"https://redis.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Redis</a> - Високопродуктивне кешування та управління станом.",
          "<strong>Черги:</strong> <a href=\"https://kafka.apache.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Kafka</a> - Надійна асинхронна обробка завдань.",
          "<strong>Зберігання файлів:</strong> <a href=\"https://www.cloudflare.com/developer/r2/\" target=\"_blank\" rel=\"noopener noreferrer\">Cloudflare R2</a> - Об'єктне сховище з вигідними цінами та без плати за вихідний трафік (Прагматизм, АКТИВ).",
          "<strong>Сповіщення:</strong> <a href=\"https://firebase.google.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Firebase</a> - Керований сервіс для Push-сповіщень.",
          "<strong>Електронна пошта/2FA:</strong> <a href=\"https://developers.google.com/gmail/api\" target=\"_blank\" rel=\"noopener noreferrer\">Gmail API</a> - Надійна доставка транзакційних листів (коди підтвердження, 2FA).",
          "<strong>Платежі:</strong> <a href=\"https://stripe.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Stripe</a>, Cryptomus (За межами MVP) - Монетизація АКТИВУ, Прагматизм.",
          "<strong>Тестування:</strong> Jest, Cypress, Detox, k6, OWASP ZAP/Burp Suite (план) - Комплексний підхід до забезпечення якості.",
          "<strong>Розгортання:</strong> <a href=\"https://vercel.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Vercel</a> (Веб), Docker, <a href=\"https://kubernetes.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Kubernetes</a> - Автоматизоване та масштабоване розгортання.",
          "<strong>Моніторинг:</strong> Prometheus, Grafana, Sentry (план) - Видимість системи та аналіз Кайдзен."
        ]
      },
      "architecture": {
        "title": "Архітектура: Еволюція Системи",
        "intro": "Наразі BrainMessenger реалізовано як <strong>монолітну програму на базі NestJS</strong>. Це <strong>прагматичне</strong> (Принцип 12) рішення для MVP, що дозволяє швидко запустити продукт та перевірити основні гіпотези.",
        "future": "У майбутньому, у міру зростання проекту та збільшення навантаження, ми плануємо поетапний перехід до <strong>мікросервісної архітектури</strong> з використанням <strong>Strangler Pattern</strong>. Це <strong>довгострокова стратегія</strong> (Принцип 8), яка дозволить незалежно масштабувати та розвивати окремі компоненти (чати, дзвінки, ШІ, платежі), підвищуючи загальну <strong>надійність та гнучкість</strong> системи (Принцип 3, 11).",
        "interaction": "Взаємодія між компонентами здійснюватиметься через <strong>GraphQL API</strong> (синхронно) та <strong>Kafka</strong> (асинхронно), використовуючи <strong>Apollo Federation</strong> (у майбутньому) для побудови єдиної схеми API з багатьох мікросервісів."
      },
      "projectStatus": {
        "title": "Статус Проекту: Поточний Етап (MVP)",
        "content": "На даний момент проект перебуває на активній стадії розробки <strong>MVP</strong> (згідно з <a href=\"https://www.notion.so/MVP-11a2a21315e54eb3b3c90171b4c7493d?pvs=4\" target=\"_blank\" rel=\"noopener noreferrer\">Інструкцією щодо вимог MVP</a>). Ми зосереджені на завершенні основної функціональності обміну повідомленнями, обробки файлів, створення груп/каналів та базових налаштувань, одночасно зміцнюючи <strong>технічний фундамент</strong> (Принцип 8) та впроваджуючи процеси <strong>безперервного навчання</strong> та <strong>Кайдзен</strong> у нашу щоденну роботу.",
        "progress": "Прогрес документується через завдання, код у репозиторії та відеозаписи, які демонструють наш шлях та <strong>процес створення</strong> (Принцип 1)."
      },
      "gettingStarted": {
        "title": "Початок Роботи (Для Розробників)",
        "intro": "Хочете приєднатися до нас у створенні цього цифрового АКТИВУ? Ось як почати:",
        "steps": [
          "Клонуйте репозиторій:<br/>```bash<br/>git clone <URL of your repository><br/>cd BrainMessenger<br/>```",
          "Встановіть залежності:<br/>```bash<br/>npm install # Turborepo встановить залежності для всіх пакетів<br/>```",
          "Налаштуйте змінні середовища: Скопіюйте `.env.example` у `.env` та заповніть необхідні дані для інтеграцій (Neon, R2, Firebase тощо). <strong>Не коммітьте ваш файл `.env`!</strong><br/>```bash<br/>cp .env.example .env<br/># Заповніть .env<br/>```",
          "Налаштуйте базу даних: Запустіть локальний PostgreSQL або використовуйте інстанс Neon, потім застосуйте міграції Prisma.<br/>```bash<br/>cd backend<br/>npx prisma migrate dev --name initial_setup # Або npx prisma migrate deploy для продакшну<br/>cd ..<br/>```",
          "Запустіть сервіси в режимі розробки:<br/>```bash<br/>turbo run dev # Це запустить бекенд та фронтенд сервери розробки<br/># Або перейдіть до конкретних пакетів та запустіть їхні скрипти розробки:<br/># cd backend && npm run start:dev<br/># cd packages/web && npm run dev<br/># cd packages/mobile-desktop && npm run android / npm run windows<br/>```"
        ],
        "outro": "Більш детальні інструкції щодо локального налаштування та розробки можна знайти в <a href=\"link_to_development_guide_doc\" target=\"_blank\" rel=\"noopener noreferrer\">Керівництві з Розробки</a>."
      },
      "documentationSystem": {
        "title": "Документація: Наша Система Знань",
        "intro": "Цей README надає загальний огляд. Вся детальна інформація про проект міститься в нашій <strong>комплексній системі документації</strong>. Вивчення цих документів є частиною процесу <strong>навчання</strong> (Принцип 1) та розуміння <strong>системи</strong> (Принцип 9):",
        "links": [
          "<a href=\"docs/AllRequirements/Docs/Planning/DocReq.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Документація Вимог</strong></a>: Що ми будуємо (функціональні та нефункціональні вимоги).",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocDevIn.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Керівництво з Розробки</strong></a>: Як ми пишемо код (структура, стандарти, інструменти, процес CI/CD).",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocTech.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Технічна Документація</strong></a>: Високорівневий огляд архітектури та стеку.",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocSpec.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Специфікація API</strong></a>: Як компоненти взаємодіють (опис GraphQL API).",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocInt.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Документація Інтеграцій</strong></a>: Як ми використовуємо зовнішні сервіси (Neon, R2, Firebase, Stripe тощо) як <strong>важелі</strong>.",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocSecurity.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Керівництво з Безпеки</strong></a>: Як ми захищаємо АКТИВ та дані (принципи, методи, інструменти, процес).",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocPer.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Керівництво з Продуктивності</strong></a>: Як ми робимо систему швидкою (метрики, техніки, інструменти оптимізації).",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocMonLog.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Керівництво з Моніторингу та Логування</strong></a>: Як ми бачимо стан системи (метрики, логи, сповіщення).",
          "<a href=\"docs/AllRequirements/Docs/Design/Design/DocUI.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Документація UI</strong></a>: Як виглядає програма і чому (макети, компоненти, принципи дизайну).",
          "<a href=\"docs/AllRequirements/Docs/Sound/DocSound.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Аудіо Керівництво</strong></a>: Як аудіо використовується для покращення UX.",
          "<a href=\"docs/AllRequirements/Docs/Support/DocSupport.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Керівництво з Підтримки та Обслуговування</strong></a>: Як ми підтримуємо систему та користувачів після релізу.",
          "<a href=\"docs/AllRequirements/Docs/Testing/DocSpecError.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Специфікація Помилок</strong></a>: Як ми обробляємо та повідомляємо про помилки.",
          "<a href=\"docs/AllRequirements/Docs/Testing/DocTesting.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Керівництво з Тестування</strong></a>: Як ми перевіряємо якість та надійність.",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocMigrationMicro.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>План Міграції на Мікросервіси</strong></a>: Наша довгострокова стратегія архітектурної еволюції.",
          "<a href=\"docs/AllRequirements/Docs/Planning/DocReq.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Інструкція щодо Вимог MVP</strong></a>: Детальний аналіз вимог MVP та статусу реалізації."
        ]
      },
      "contribution": {
        "title": "Внесок",
        "content": "Ми вітаємо внесок у створення цього цифрового АКТИВУ! Якщо у вас є ідеї, пропозиції або ви хочете допомогти з кодом, будь ласка, зверніться до <a href=\"CONTRIBUTING.md\" target=\"_blank\" rel=\"noopener noreferrer\">Керівництва з Внеску</a> (якщо доступно)."
      }
    },
    "design": {
      "title": "Документація Дизайну BrainMessenger",
      "subtitle": "Система Якості та Цінності",
      "section1": {
        "title": "1. Вступ: Дизайн як Фундамент Цінності",
        "name": "Система Дизайну BrainMessenger",
        "description": "Ця дизайн-система визначає візуальні та функціональні стандарти для інтерфейсу BrainMessenger. Наша мета — створити інтерфейс, який не просто виглядає добре, але й є <strong>інтуїтивно зрозумілим, ефективним та доступним</strong> (Принцип 2: Створення Цінності), спираючись на принципи <strong>якості > кількості</strong> (Принцип 3) та <strong>прагматизму</strong> (Принцип 12) у виборі рішень.",
        "goal": "Забезпечити <strong>одноманітність, надійність та позитивний досвід користувача</strong> на всіх платформах (Windows, Android, веб), роблячи BrainMessenger <strong>корисним АКТИВОМ</strong> (Принцип 10) для користувачів.",
        "principles_title": "Принципи, якими керується дизайн:",
        "principles": [
          "<strong>Створення Цінності (Принцип 2):</strong> Дизайн має бути функціональним і вирішувати завдання користувача максимально зручно та ефективно.",
          "<strong>Якість > Кількість (Принцип 3):</strong> Фокус на відточеності ключових елементів, а не на безлічі непродуманих деталей. Дизайн має бути <strong>надійним</strong> та <strong>продуманим</strong>.",
          "<strong>Прагматизм та Реалізм (Принцип 12):</strong> Вибір дизайнерських рішень, що реалізуються з урахуванням технічних обмежень (наприклад, оптимізація анімацій).",
          "<strong>Цілісність (Принцип 7):</strong> Візуальна та функціональна цілісність на всіх платформах.",
          "<strong>Здоров'я як Фундамент (Принцип 5):</strong> Увага до доступності (WCAG), щоб дизайн не створював зайвого навантаження (зорового, когнітивного) на користувача."
        ]
      },
      "section2": {
        "title": "2. Колірна палітра: Візуальна мова BrainMessenger",
        "intro": "Кольори розділені для Light та Dark режимів, підтримуючи перемикання теми (функція \"Нічний режим\"). Усі кольори задані в HEX.",
        "light_mode_title": "2.1. Light Mode",
        "light_mode_table": [
          ["Категорія", "Колір (HEX)", "Призначення"],
          ["<strong>Primary Gradient</strong>", "`#A7F43A` → `#00C853`", "Основний градієнт для акцентних елементів (кнопки \"Get Started\", іконки)"],
          ["<strong>Accent</strong>", "`#FF6347`", "Акцентні елементи (помилки, важливі повідомлення)"],
          ["<strong>Secondary</strong>", "`#00BFFF`", "Другорядні кнопки, посилання, інтерактивні елементи"],
          ["<strong>Success</strong>", "`#96C93D`", "Підтвердження, успішні дії"],
          ["<strong>Background</strong>", "`#FFFFFF`", "Основний фон"],
          ["<strong>Surface</strong>", "`#F0F0F0`", "Картки, панелі, фони повідомлень"],
          ["<strong>Text Primary</strong>", "`#333333`", "Основний текст"],
          ["<strong>Text Secondary</strong>", "`#4D4D4D`", "Вторинний текст, підказки, метадані"],
          ["<strong>Disabled</strong>", "`#B0B0B0`", "Неактивні елементи"],
          ["<strong>Border</strong>", "`#E8E8D9`", "Межі, роздільники"]
        ],
        "dark_mode_title": "2.2. Dark Mode",
        "dark_mode_table": [
          ["Категорія", "Колір (HEX)", "Призначення"],
          ["<strong>Primary Gradient</strong>", "`#F2F047` → `#1ED94F`", "Основний градієнт для акцентних елементів"],
          ["<strong>Accent</strong>", "`#FF6347`", "Акцентні елементи (помилки)"],
          ["<strong>Secondary</strong>", "`#00BFFF`", "Другорядні кнопки, посилання"],
          ["<strong>Success</strong>", "`#96C93D`", "Підтвердження, успішні дії"],
          ["<strong>Background</strong>", "`#1A1A1A`", "Основний фон"],
          ["<strong>Surface</strong>", "`#333333`", "Картки, панелі, фони повідомлень"],
          ["<strong>Text Primary</strong>", "`#FFFFFF`", "Основний текст"],
          ["<strong>Text Secondary</strong>", "`#D9E8D9`", "Вторинний текст, підказки"],
          ["<strong>Disabled</strong>", "`#4D4D4D`", "Неактивні елементи"],
          ["<strong>Border</strong>", "`#B0B0B0`", "Межі, роздільники"]
        ],
        "premium_colors_title": "2.3. Кольори Преміум-Функцій (Візуальне виділення Цінності)",
        "premium_colors": [
          "<strong>Premium Accent:</strong> `#FFD600` (Золотий)",
          "<strong>Premium Secondary:</strong> `#2196F3` (Синій)",
          "Використовуються для візуального виділення преміум-функцій (наприклад, в анімаціях нейронних зв'язків, спеціальних елементах UI), підкреслюючи їх <strong>додаткову цінність</strong> (Принцип 2, 10)."
        ],
        "color_application_title": "2.4. Застосування Кольорів (Приклади)",
        "color_application": [
          {
            "title": "Welcome Screen (зі скріншота):",
            "items": [
              "Фон: `#1A1A1A` (Dark Mode).",
              "Кнопка \"Get Started\": Градієнт `#F2F047` → `#1ED94F`.",
              "Іконка чату: `#F2F047` (обведення) з білим символом всередині.",
              "Текст: `#FFFFFF` (Welcome to Brain Messenger), `#D9E8D9` (підказка)."
            ]
          },
          {
            "title": "Перемикання теми:",
            "items": [
              "Реалізовано через глобальний прапор `themeMode` (`Light`/`Dark`).",
              "Приклад у React Native:\n```jsx\nimport { useColorScheme } from 'react-native';\nconst themeMode = useColorScheme() === 'dark' ? 'Dark' : 'Light';\nconst backgroundColor = themeMode === 'Dark' ? '#1A1A1A' : '#FFFFFF'; // Приклад вибору фону\n```"
            ]
          }
        ],
        "usage_recommendations_title": "2.5. Рекомендації щодо Використання Кольорів",
        "usage_recommendations": [
          "<strong>Градієнти:</strong> Використовуйте `#A7F43A` → `#00C853` або `#F2F047` → `#1ED94F` (залежно від теми) для ключових дій та акцентних елементів, що привертають увагу до <strong>цінності</strong> (Принцип 2).",
          "<strong>Темна тема:</strong> Використовуйте `#1A1A1A` або `#212121` як основний фон для зниження навантаження на очі (зв'язок з Принципом 5: Здоров'я).",
          "<strong>Контраст:</strong> Завжди перевіряйте контрастність тексту та елементів для забезпечення <strong>доступності</strong> (WCAG 2.1 AA) та відповідності Принципу 7 (Цілісність). Використовуйте інструменти на кшталт WebAIM Contrast Checker."
        ]
      },
      "section3": {
        "title": "3. Типографіка: Читабельність як Основа Ефективності",
        "intro": "Вибір шрифту та його застосування ґрунтуються на забезпеченні максимальної читабельності та доступності, що є критично важливим для ефективного засвоєння інформації та зниження когнітивного навантаження (зв'язок з Принципом 5: Здоров'я та Принципом 2: Цінність).",
        "primary_font_title": "3.1. Основний шрифт",
        "primary_font": [
          "<strong>Сімейство:</strong> Roboto (Google Fonts)",
          "<strong>Запасний:</strong> Sans-serif",
          "<strong>Причина:</strong> Висока читабельність на різних розмірах екрану, широка підтримка символів (багатомовність), відкрита ліцензія та доступність."
        ],
        "sizes_styles_title": "3.2. Розміри та стилі (Шкала для Ієрархії)",
        "sizes_styles_table": [
          ["Рівень", "Розмір", "Начертання", "Використання"],
          ["H1 (Заголовок)", "24px", "Bold", "Основні заголовки екранів (наприклад, \"Чати\")"],
          ["H2 (Підзаголовок)", "18px", "Medium", "Другорядні заголовки, назви груп"],
          ["Body", "16px", "Regular", "Основний текст повідомлень, список чатів"],
          ["Caption", "14px", "Regular", "Підписи під фото, час повідомлень, дрібний текст"],
          ["Button", "16px", "Medium", "Текст кнопок дій"]
        ],
        "notes_title": "Примітки:",
        "notes": [
          "<strong>Висота рядка (Line Height):</strong> Мінімум 1.5 для основного тексту для покращення читабельності.",
          "<strong>Кастомізація (Принцип 2):</strong> Користувач може вибрати альтернативний шрифт у налаштуваннях (наприклад, Open Sans) для адаптації під свої вподобання.",
          "<strong>Доступність:</strong> Дотримання контрасту та мінімального розміру шрифту для відповідності WCAG."
        ]
      },
      "section4": {
        "title": "4. Анімації: Оптимізація та Зміст (Принцип 12: Прагматизм)",
        "intro": "Анімації в BrainMessenger використовуються для покращення користувацького досвіду, надання візуального зворотного зв'язку та надання інтерфейсу жвавості. Однак вони повинні бути <strong>прагматичними, оптимізованими</strong> (<2 ГБ RAM), і <strong>не створювати зайвого навантаження</strong> (зв'язок з Принципом 5: Здоров'я).",
        "principles_title": "4.1. Принципи Анімацій",
        "principles": [
          "<strong>Зміст:</strong> Кожна анімація повинна мати чітку мету – пояснити перехід, привернути увагу до важливого, підтвердити дію.",
          "<strong>Плавність:</strong> Використання `ease-in-out` або `ease-out` для натурального руху.",
          "<strong>Оптимізація:</strong> Анімації не повинні уповільнювати інтерфейс або споживати багато ресурсів. Тривалість підібрана для балансу між плавністю та швидкістю.",
          "<strong>Доступність:</strong> Уникнення занадто швидких або миготливих анімацій, які можуть викликати дискомфорт або напади у чутливих користувачів."
        ],
        "list_title": "4.2. Список Анімацій (Приклади)",
        "list_table": [
          ["Назва", "Опис", "Тригер", "Параметри", "Зв'язок з Принципами", "Кольори (Light/Dark)"],
          ["Перемикання слайдів", "Зсув слайдів (Welcome Screen)", "Свайп/клік по стрілці", "0.3 сек, slide left/right", "P2 (Онбординг)", "#96C93D / #96C93D"],
          ["Відкриття чату", "Чат з'являється знизу вгору", "Клік по чату в списку", "0.3 сек, ease-in-out", "P2 (Навігація)", "#00BFFF / #00BFFF"],
          ["Натискання кнопки", "Візуальний фідбек при кліку (зменшення)", "Клік по кнопці", "0.2 сек, scale", "P2 (Фідбек)", "Градиент #F2F047→#1ED94F"],
          ["Надсилання повідомлення", "Повідомлення з'являється з плавним згасанням", "Клік \"Відправити\"", "0.3 сек, fade-in", "P2 (Фідбек)", "#96C93D / #96C93D"],
          ["Перехід між екранами", "Зсув екрану вправо/вліво (базова навігація)", "Навігація", "0.3 сек, slide", "P2 (Навігація)", "#B0B0B0 / #4D4D4D"],
          ["Анімація іконок (Morph)", "Перетворення іконки (наприклад, mute → unmute)", "Клік (перемикання стану)", "0.4 сек, morph", "P2 (Стан)", "#FF6347 / #FF6347"],
          ["Хвилі при натисканні (Ripple)", "Радіальні хвилі від точки натискання (фідбек)", "Клік по кнопці/елементу", "0.3 сек, ripple", "P2 (Фідбек)", "#F2F047 / #F2F047"],
          ["Глітч-ефект (Premium)", "Спотворення тексту для преміум (візуалізація)", "Активація підписки", "0.2 сек, glitch", "P2, P10 (Виділення)", "#FF6347 / #FF6347"],
          ["Нейронні зв'язки (Premium)", "Пульсуючі лінії (візуалізація Активу)", "Преміум-екран", "0.5 сек, pulse", "P2, P10 (Виділення)", "#96C93D / #96C93D"]
        ],
        "implementation_examples_title": "4.3. Приклади Реалізації (Фрагменти коду)",
        "css_ripple_title": "CSS для Ripple-ефекту:",
        "css_ripple_code": ".ripple {\n  background: linear-gradient(45deg, #F2F047, #1ED94F); /* Або інші кольори/градієнт */\n  border-radius: 50%;\n  animation: ripple 0.3s ease-out;\n}\n@keyframes ripple {\n  to { transform: scale(2); opacity: 0; }\n}",
        "rn_icon_title": "React Native для анімованої іконки:",
        "rn_icon_code": "import Animated from 'react-native-reanimated'; // Приклад бібліотеки\nimport Icon from 'react-native-vector-icons/MaterialIcons'; // Приклад бібліотеки\n\nconst color = themeMode === 'Dark' ? '#FFFFFF' : '#333333';\n// Створення анімованого компонента Icon\nconst AnimatedIcon = Animated.createAnimatedComponent(Icon);\n\n// Приклад використання з анімацією scale (припускаючи, що 'scale' - це Animated.Value)\n<AnimatedIcon name=\"volume-up\" color={color} style={{ transform: [{ scale: scale }] }} />"
      },
      "section5": {
        "title": "5. Вирівнювання та Сітка: Структура та Порядок (Принцип 9: Система)",
        "intro": "Використання послідовної системи вирівнювання та модульної сітки — це основа для створення <strong>системного, легко підтримуваного та візуально гармонійного</strong> інтерфейсу (Принцип 9: Система).",
        "base_grid": "<strong>Базова Сітка:</strong> 8px (базовий крок для визначення розмірів елементів, відступів, інтервалів). Усі значення повинні бути кратні 8 (або 4 для дуже дрібних елементів).",
        "alignment_title": "<strong>Вирівнювання:</strong>",
        "alignment": [
          "Використовується принцип <strong>візуальної ієрархії</strong>: важливіші елементи розташовуються вище або візуально домінують.",
          "<strong>Вертикальний потік:</strong> Контент на екранах організовується зверху вниз: Заголовок → Поле введення → Кнопка дії.",
          "<strong>Горизонтальне вирівнювання:</strong> Елементи в контейнерах вирівнюються за лівим краєм (для LTR) або правим краєм (для RTL), якщо немає необхідності в центруванні (наприклад, заголовки в шапці).",
          "<strong>Відступи (Padding/Margin):</strong> Використовуються значення зі шкали, кратної 8px (8, 16, 24, 32, 40, 48 px тощо) для створення чітких інтервалів між елементами та групами елементів."
        ],
        "adaptability_title": "<strong>Адаптивність та Чуйність:</strong>",
        "adaptability": [
          "Дизайн адаптується під різні розміри екрану для забезпечення <strong>цінності</strong> (Принцип 2) на будь-якому пристрої.",
          "<strong>Мобільні пристрої:</strong> 320px–767px (Зазвичай одноколонковий макет).",
          "<strong>Планшети:</strong> 768px–1023px (Можливо, двоколонковий макет, бічні панелі).",
          "<strong>Десктоп:</strong> 1024px+ (Широкий макет, багатоколонковий дизайн, бічні панелі)."
        ]
      },
      "section6": {
        "title": "6. Принципи Доступності (WCAG 2.1 AA): Дизайн для Всіх (Принцип 5: Здоров'я, Принцип 7: Цілісність)",
        "intro": "<strong>Доступність — це не опція, а фундаментальна вимога</strong> (схоже з Принципом 5: Здоров'я як Фундамент) для створення <strong>цілісного</strong> (Принцип 7) та <strong>цінного</strong> (Принцип 2) продукту, яким можуть користуватися всі, незалежно від їхніх здібностей або використовуваних технологій. Ми прагнемо відповідати рівню WCAG 2.1 AA.",
        "principles": [
          "<strong>Контрастність Кольорів:</strong> Текстові елементи повинні мати мінімальний контраст 4.5:1 (для звичайного тексту) та 3:1 (для великого тексту або іконок) по відношенню до фону. Це перевіряється для обох тем (Light/Dark).",
          "<strong>Навігація з Клавіатури:</strong> Усі інтерактивні елементи (кнопки, посилання, поля введення) повинні бути доступними для навігації за допомогою клавіатури (Tab, Shift+Tab) та активації (Enter, Space).",
          "<strong>Підтримка Екранних Читалок (Screen Readers):</strong> Використання семантичної розмітки (HTML) та ARIA-атрибутів для надання контексту та інформації користувачам екранних читалок (наприклад, описи для іконок, стани елементів).",
          "<strong>Візуальний Індикатор Фокусу:</strong> Для користувачів клавіатури має бути чіткий та видимий індикатор поточного сфокусованого елемента (наприклад, синя обводка `#007BFF`).",
          "<strong>Обробка Помилок:</strong> Повідомлення про помилки повинні бути чіткими, зрозумілими та легко визначальними користувачами, включаючи користувачів екранних читалок.",
          "<strong>Підтримка RTL (Справа Наліво):</strong> Дизайн адаптується для мов з напрямком письма справа наліво (наприклад, арабська), включаючи дзеркальне відображення макета, іконок та тексту (див. DocLocIn.md)."
        ]
      },
      "section7": {
        "title": "7. Примітки та Рекомендації",
        "notes": [
          "<strong>Кастомізація Користувачем:</strong> Пам'ятайте, що деякі аспекти дизайну (кольори чатів, шрифти) користувач може змінювати в налаштуваннях. Дизайн системи має враховувати цю гнучкість.",
          "<strong>Тестування на Реальних Пристроях:</strong> Усі компоненти дизайну необхідно тестувати на різноманітних пристроях, з різними роздільними здатностями екрану та в різних умовах освітлення, щоб переконатися в їх ефективності та доступності.",
          "<strong>Жива Документація:</strong> Ця дизайн-система — живий документ. Вона буде доповнюватися новими компонентами, шаблонами та рекомендаціями в міру розвитку продукту, відображаючи принципи <strong>безперервного вдосконалення</strong> (Принцип 1) та <strong>системного підходу</strong> (Принцип 9).",
          "<strong>Дизайн як частина Процесу Кайдзен:</strong> Дизайн-рішення аналізуються та покращуються на основі зворотного зв'язку та реального використання, інтегруючись у загальний процес Кайдзен (Принцип 9, 14)."
        ]
      }
    },
    "localizationGuide": {
      "title": "Руководство по Локализации BrainMessenger",
      "subtitle": "Доступность и Масштабирование",
      "section1": {
        "title": "1. Введение: Расширение Ценности через Доступность",
        "name": "BrainMessenger Design System",
        "description": "Это руководство описывает процесс локализации BrainMessenger — ключевой шаг для обеспечения доступности и ценности (Принцип 2) продукта для широкой аудитории по всему миру. Мы рассматриваем локализацию не просто как перевод строк, а как систематический процесс (Принцип 9) адаптации интерфейса и контента, который позволит нам масштабировать наше влияние (Принцип 2, 8).",
        "goal": "Сделать BrainMessenger понятным и удобным для пользователей из разных культур, начиная с базового набора языков и создавая надежную систему (Принцип 9) для легкого добавления новых в будущем.",
        "current_status": "Базовая поддержка английского языка (MVP). Идет планирование и подготовка к добавлению новых языков в рамках текущих этапов разработки (см. Дорожную карту).",
        "principles_title": "Принципы, которыми руководствуется локализация:",
        "principles": [
          "Создание Ценности (Принцип 2): Локализация напрямую повышает ценность продукта для неанглоязычных пользователей.",
          "Система и Оптимизация (Принцип 9): Процесс локализации строится как четкая, повторяемая система для эффективности.",
          "Прагматизм и Реализм (Принцип 12): Выбор начального набора языков основывается на потенциальном охвате и ресурсах.",
          "Внешняя Экспертиза и Обратная Связь (Принцип 14): Привлечение профессиональных переводчиков и сбор обратной связи от пользователей на разных языках."
        ]
      },
      "section2": {
        "title": "2. Цели Локализации",
        "goals": [
          "Обеспечить поддержку минимум 5 ключевых языков (Английский, Испанский, Французский, Русский, Арабский) для старта MVP — (Требование NFR-11, соответствующее Принципу 12: Прагматизм).",
          "Реализовать адаптацию пользовательского интерфейса для языков с направлением письма справа налево (RTL), таких как арабский (Принцип 2: Доступность).",
          "Поддерживать единообразие терминологии и стиля во всех переводах, используя централизованные инструменты (Принцип 9: Система).",
          "Создать эффективный и простой процесс добавления новых языков по мере роста базы пользователей и поступления запросов (Принцип 9: Масштабирование, Принцип 12: Прагматизм, Принцип 14: Обратная связь)."
        ]
      },
      "section3": {
        "title": "3. Инструменты и Технологии: Надежный Фундамент (Принцип 8, 9)",
        "intro": "Выбор инструментов основан на прагматизме (Принцип 12), надежности и поддержке системного подхода (Принцип 9).",
        "tools_table": [
          ["Инструмент", "Назначение", "Установка/Конфигурация"],
          ["i18next", "Основная библиотека для управления переводами в Frontend (React Native). Поддерживает интерполяцию, контексты.", "npm install i18next react-i18next"],
          ["react-intl", "Библиотека для локализованного форматирования дат, чисел, валют в Frontend.", "npm install react-intl"],
          ["Transifex", "Профессиональная платформа для управления переводами, привлечения переводчиков и обеспечения качества перевода.", "Регистрация на transifex.com"],
          ["rtlcss", "Утилита для автоматической трансформации CSS-стилей для поддержки RTL-языков.", "npm install -g rtlcss (глобально) или npm install rtlcss --save-dev"],
          ["JSON файлы", "Формат хранения переводов.", "Стандартный."]
        ]
      },
      "section4": {
        "title": "4. Структура Файлов Переводов: Порядок в Системе (Принцип 9)",
        "intro": "Переводы организованы в четкой файловой структуре для удобства управления (Принцип 9: Система).",
        "location_title": "4.1. Расположение",
        "location_content": "Файлы переводов хранятся в директории locales внутри frontend/src:\n\nfrontend/\n├── src/\n│ ├── locales/\n│ │ ├── en.json # Английский (базовый)\n│ │ ├── es.json # Испанский\n│ │ ├── fr.json # Французский\n│ │ ├── ru.json # Русский\n│ │ ├── ar.json # Арабский (пример RTL)\n│ └── index.ts # Конфигурация i18next",
        "format_title": "4.2. Формат JSON: Контекст и Гибкость",
        "format_content": "Ключи: Используется camelCase. Ключи должны быть описательными и отражать контекст использования строки (например, sendButton вместо просто send).\n\nЗначения: Содержат переводимый текст. Поддерживается интерполяция для вставки динамических данных (например, имена пользователей).",
        "format_example": "Пример en.json:\n\n```json\n{\n  \"welcomeTitle\": \"Welcome to BrainMessenger!\",\n  \"sendButton\": \"Send\",\n  \"errors\": {\n    \"unauthorized\": \"Please log in again to continue.\",\n    \"notFound\": \"The requested item could not be found.\"\n  },\n  \"chat\": {\n    \"newMessageNotification\": \"New message from {{name}}\",\n    \"unreadCount\": \"{{count}} unread messages\"\n  },\n  \"settings\": {\n    \"language\": \"Language\",\n    \"theme\": \"Theme\"\n  }\n}\n```",
        "rtl_flag_title": "4.3. RTL-флаг: Адаптация Интерфейса",
        "rtl_flag_content": "Для языков с направлением справа налево в начало соответствующего JSON-файла добавляется метаданные для индикации:",
        "rtl_flag_example": "```json\n{\n  \"rtl\": true,\n  \"welcomeTitle\": \"مرحبًا بك في BrainMessenger!\"\n  // ... остальные переводы\n}\n```\n\nЭтот флаг используется Frontend-приложением для соответствующей адаптации стилей и макета."
      },
      "section5": {
        "title": "5. Настройка Локализации: Интеграция в Систему (Принцип 9)",
        "intro": "Локализация интегрируется как в Frontend (для отображения переведенного UI), так и в Backend (для возврата локализованных ошибок или уведомлений).",
        "frontend_title": "5.1. Frontend (React Native): Использование i18next",
        "frontend_init_title": "Инициализация i18next:",
        "frontend_init_code": "В главном файле приложения или файла конфигурации (frontend/src/index.ts или подобном):\n\n```jsx\nimport i18n from 'i18next'\nimport { initReactI18next } from 'react-i18next'\n\n// Импорт всех файлов локалей\nimport en from './locales/en.json'\nimport es from './locales/es.json'\nimport fr from './locales/fr.json'\nimport ru from './locales/ru.json'\nimport ar from './locales/ar.json'\n\n// Определение ресурсов\nconst resources = {\n  en: { translation: en },\n  es: { translation: es },\n  fr: { translation: fr },\n  ru: { translation: ru },\n  ar: { translation: ar },\n};\n\ni18n\n  .use(initReactI18next) // Подключение react-i18next\n  .init({\n    resources,\n    lng: 'en', // Язык по умолчанию при первом запуске (может определяться по системным настройкам или выбору пользователя)\n    fallbackLng: 'en', // Резервный язык, если текущий перевод отсутствует\n    interpolation: {\n      escapeValue: false // Позволяет использовать HTML теги в переводах (осторожно!)\n    }\n  });\n\nexport default i18n;\n```",
        "frontend_usage_title": "Использование перевода в компонентах:",
        "frontend_usage_code": "Используйте хук useTranslation для доступа к функции t и объекту i18n.\n\n```jsx\nimport { useTranslation } from 'react-i18next';\nimport { Text, Button, View } from 'react-native';\n\nconst WelcomeScreen = () => {\n  const { t, i18n } = useTranslation(); // Получаем функцию t и объект i18n\n\n  return (\n    <View>\n      {/* Использование простого перевода */}\n      <Text>{t('welcomeTitle')}</Text>\n      \n      {/* Использование перевода с интерполяцией */}\n      {/* Предполагается, что где-то есть состояние unreadCount */}\n      <Text>{t('chat.unreadCount', { count: 5 })}</Text> \n\n      {/* Использование перевода для текста кнопки */}\n      <Button title={t('sendButton')} onPress={sendMessage} />\n      \n      {/* Пример смены языка */}\n      <Button title={t('settings.language')} onPress={() => i18n.changeLanguage('ar')} />\n    </View>\n  );\n};\n```",
        "frontend_change_title": "Смена языка:",
        "frontend_change_content": "Язык меняется вызовом i18n.changeLanguage('код_языка'). Обычно это делается в настройках пользователя.",
        "backend_title": "5.2. Backend (NestJS): Локализация Ошибок и Уведомлений",
        "backend_intro": "Backend может возвращать локализованные сообщения об ошибках или уведомления, опираясь на язык, переданный Frontend (например, в заголовке Accept-Language или настройках пользователя).",
        "backend_code": "Использование локализованных сообщений при выбрасывании ошибок:\n\n```typescript\nimport { HttpException, HttpStatus } from '@nestjs/common';\nimport { t } from 'i18next'; // Предполагается, что i18next инициализирован и в Backend\n\n// В сервисе или контроллере\nif (!user) {\n  // Определяем язык пользователя (например, из request.headers['accept-language'])\n  const userLang = determineUserLanguage(request); \n  throw new HttpException(t('errors.unauthorized', { lng: userLang }), HttpStatus.UNAUTHORIZED);\n}\n```",
        "backend_note": "Локаль пользователя определяется из заголовка Accept-Language (стандартный подход) или сохраняется в профиле пользователя в базе данных после его выбора в настройках приложения.",
        "rtl_adaptation_title": "5.3. RTL-адаптация (Справа Налево): Зеркальное Отображение Системы",
        "rtl_adaptation_intro": "Для языков с RTL (арабский, иврит и др.) необходимо зеркально отобразить макет и некоторые элементы интерфейса.",
        "rtl_css_title": "Стили (CSS/CSS-in-JS):",
        "rtl_css_code": "Используйте rtlcss в процессе сборки или условные стили в коде. rtlcss автоматически преобразует свойства вроде margin-left, padding-right, text-align: left и т.п. в их RTL-эквиваленты (margin-right, padding-left, text-align: right).\n\n```css\n/* Исходный CSS для LTR */\n.message-bubble {\n  margin-left: 10px;\n  text-align: left;\n}\n/* После обработки rtlcss для RTL */\n.message-bubble {\n  margin-right: 10px;\n  text-align: right;\n}\n```",
        "rtl_rn_title": "React Native:",
        "rtl_rn_code": "React-Native имеет встроенную поддержку RTL через I18nManager.\n\n```jsx\nimport { I18nManager } from 'react-native';\nimport i18n from './index'; // Ваш файл инициализации i18next\n\n// В главном файле приложения, перед рендером\nconst isRTL = i18n.language === 'ar' || i18n.language === 'he'; // Проверяем, является ли текущий язык RTL\n\n// ForceRTL может потребовать перезагрузки приложения для полной силы\nif (isRTL !== I18nManager.isRTL) {\n  I18nManager.forceRTL(isRTL);\n  // Optional: Restart the app to apply RTL layout fully\n  // RNRestart.Restart(); \n}\n\n// Некоторые стили могут требовать ручной адаптации, если auto-conversion недостаточно\nconst containerStyle = {\n  flexDirection: isRTL ? 'row-reverse' : 'row',\n  textAlign: isRTL ? 'right' : 'left',\n};\n```",
        "rtl_icons_title": "Иконки:",
        "rtl_icons_content": "Некоторые иконки (например, стрелки \"назад\", \"далее\") должны быть зеркально отображены для RTL. Это можно делать условно в коде или использовать RTL-ready наборы иконок."
      },
      "section6": {
        "title": "6. Процесс Добавления Нового Языка: Масштабируемая Система (Принцип 9)",
        "intro": "Процесс добавления нового языка построен как четкая, повторяемая последовательность действий для обеспечения эффективности (Принцип 9).",
        "file_title": "Создание базового файла перевода:",
        "file_content": "Скопируйте актуальный en.json (или другой наиболее полный файл) в frontend/src/locales/<code>.json, где <code> — двухбуквенный код нового языка (например, de.json для немецкого).\nДобавьте rtl: true в начало файла, если новый язык RTL.",
        "transifex_title": "Загрузка на платформу переводов (Transifex):",
        "transifex_content": "Загрузите новый файл <code>.json в проект BrainMessenger на Transifex. Система автоматически определит, какие строки нуждаются в переводе.",
        "process_title": "Организация процесса перевода:",
        "process_content": "Назначьте переводчиков (профессионалов или проверенных участников сообщества, Принцип 14) для нового языка в Transifex.\nОтвечайте на их вопросы по контексту строк.\nКонтролируйте прогресс перевода в Transifex.",
        "export_title": "Экспорт и Интеграция перевода:",
        "export_content": "После завершения перевода экспортируйте готовый файл <code>.json из Transifex.\nПоместите его обратно в директорию frontend/src/locales/.\nИмпортируйте новый ресурс в файле инициализации i18next (frontend/src/index.ts) и добавьте его в объект resources.",
        "ui_title": "Добавление опции выбора языка в UI:",
        "ui_content": "Добавьте новый язык в список доступных языков в разделе \"Настройки\" > \"Язык\".",
        "testing_title": "Тестирование:",
        "testing_intro": "Критически важный шаг (Принцип 3: Качество). Переключите язык в настройках приложения.",
        "testing_scenarios": [
          "Корректность перевода всех строк в UI.",
          "Отсутствие обрезки текста (некоторые языки длиннее английского).",
          "Корректное отображение UI для RTL-языков (зеркальность, выравнивание).",
          "Интерполяция и Форматирование: Проверьте экраны, где используются динамические данные (имена, счетчики, даты, числа), убедитесь, что они форматируются правильно для текущей локали.",
          "Локализованные ошибки: Инициируйте различные ошибки (неправильный логин, отсутствие элемента), проверьте, что сообщения об ошибках приходят на выбранном языке."
        ]
      },
      "section7": {
        "title": "7. Поддерживаемые Языки (Начальный Список и План)",
        "intro": "Начальный список языков, выбранный по прагматическим соображениям (Принцип 12) и потенциальному охвату.",
        "languages_table": [
          ["Код", "Язык", "Направление", "Статус", "План (Q 2025)"],
          ["en", "Английский", "LTR", "Реализован (Базовый)", "-"],
          ["es", "Испанский", "LTR", "В плане (Q3)", "Q3"],
          ["fr", "Французский", "LTR", "В плане (Q3)", "Q3"],
          ["ru", "Русский", "LTR", "В плане (Q3)", "Q3"],
          ["ar", "Арабский", "RTL", "В плане (Q3, требуется RTL)", "Q3"]
        ],
        "expansion_note": "Расширение списка: Новые языки будут добавляться на основе обратной связи (Принцип 14) и анализа потенциальной ценности (Принцип 2) для роста аудитории (например, если >10% запросов о поддержке нового языка)."
      },
      "section8": {
        "title": "8. Рекомендации: Лучшие Практики Локализации",
        "dev_title": "8.1. Для Разработчиков (Пишем Код, Готовый к Миру)",
        "dev_points": [
          "Не хардкодьте строки! Все строки, которые видит пользователь, должны быть вынесены в файлы локализации и использоваться через функцию t('ключ') (Принцип 9: Система).",
          "Используйте интерполяцию для строк с переменными данными (t('chat.newMessageNotification', { name: user.name })), а не конкатенацию строк в коде.",
          "Учитывайте плюрализацию (формы единственного/множественного числа) при работе со счетчиками ({{count}} unread messages). i18next и react-intl поддерживают это.",
          "Используйте react-intl для всех операций с датами, числами, валютами, чтобы их формат был корректным для каждой локали (Принцип 3: Качество, Принцип 2: Ценность).",
          "Тестируйте UI с длинными переводами (например, немецкий, который часто длиннее английского) и RTL-языками, чтобы убедиться, что макет не ломается и текст не обрезается (Принцип 3: Качество)."
        ],
        "design_title": "8.2. Для Дизайнеров (Рисуем Макеты, Гибкие к Языкам)",
        "design_points": [
          "Учитывайте, что текст на других языках может быть на 30% (и более) длиннее английского. Оставляйте достаточно пространства в компонентах.",
          "Проектируйте макеты с учетом зеркального отображения для RTL. Иконки направлений, расположение текста и элементов должны меняться (Принцип 2: Доступность)."
        ],
        "translator_title": "8.3. Для Переводчиков (Создаем Понятный Контент)",
        "translator_points": [
          "Сохраняйте контекст. Одно и то же английское слово может переводиться по-разному в зависимости от того, где оно используется (например, \"Send\" для сообщения или для заявки). Платформы вроде Transifex помогают добавлять контекстные комментарии.",
          "Придерживайтесь последовательной терминологии, используйте глоссарий, если он есть.",
          "Сохраняйте тон приложения (дружелюбный, но профессиональный, особенно в системных сообщениях и ошибках).",
          "Используйте возможности интерполяции и плюрализации в файлах перевода."
        ]
      },
      "section9": {
        "title": "9. Форматирование (Даты, Числа, Валюты): Детали, Создающие Качество (Принцип 3)",
        "intro": "Корректное отображение локализованных данных критически важно для качества (Принцип 3) и удобства (Принцип 2).",
        "dates_title": "Даты и Время:",
        "dates_code": "```jsx\nimport { FormattedDate, FormattedTime } from 'react-intl';\n\n// Отобразит дату в формате, соответствующем текущей локали\n<FormattedDate value={new Date()} /> // Например, \"3/14/2025\" (en-US) или \"14.3.2025\" (de-DE)\n<FormattedDate value={new Date()} weekday=\"long\" year=\"numeric\" month=\"long\" day=\"numeric\" /> // \"Friday, March 14, 2025\"\n\n// Отобразит время\n<FormattedTime value={new Date()} /> // Например, \"3:00:00 PM\" (en-US) или \"15:00:00\" (de-DE)\n```",
        "numbers_title": "Числа и Валюты:",
        "numbers_code": "```jsx\nimport { FormattedNumber, FormattedCurrency } from 'react-intl';\n\n// Отобразит число с локальным разделителем тысяч и десятичным знаком\n<FormattedNumber value={1234.56} /> // \"1,234.56\" (en-US) или \"1.234,56\" (de-DE)\n\n// Отобразит число как процент\n<FormattedNumber value={0.75} style=\"percent\" /> // \"75%\"\n\n// Отобразит число как валюту (требует кода валюты)\n<FormattedCurrency value={123.45} currency=\"USD\" /> // \"$123.45\" (en-US)\n```\n\nДля работы с react-intl необходимо обернуть ваше приложение в IntlProvider и загрузить соответствующие данные локали (react-intl/locale-data)."
      },
      "section10": {
        "title": "10. Тестирование Локализации: Гарантия Качества (Принцип 3, 9)",
        "intro": "Тестирование — неотъемлемая часть системы обеспечения качества (Принцип 3, 9).",
        "scenarios_title": "Сценарии Тестирования:",
        "scenarios_points": [
          "Переключение языка: Убедитесь, что смена языка в настройках мгновенно (или после перезапуска, если требуется I18nManager) применяет новый перевод и RTL-макет.",
          "Отображение всех строк: Проверьте основные экраны и диалоги, чтобы убедиться, что все видимые пользователю строки переведены.",
          "Длинный текст: Проверьте UI с языками, известными своей длиной (например, немецкий, русский), чтобы убедиться, что текст не обрезается, элементы не накладываются друг на друга.",
          "RTL-интерфейс: Тщательно проверьте UI на арабском (или другом RTL-языке): направление текста, выравнивание элементов, отображение иконок направлений, положение скроллбаров.",
          "Интерполяция и Форматирование: Проверьте экраны, где используются динамические данные (имена, счетчики, даты, числа), убедитесь, что они форматируются правильно для текущей локали.",
          "Локализованные ошибки: Инициируйте различные ошибки (неправильный логин, отсутствие элемента), проверьте, что сообщения об ошибках приходят на выбранном языке."
        ],
        "tools_title": "Инструменты:",
        "tools_points": [
          "Ручное тестирование: Основной метод. Тестирование на реальных устройствах с разными локалями.",
          "Автоматизированные тесты (Cypress/detox): Можно написать тесты, которые проверяют наличие определенных ключей перевода на странице или даже делают скриншоты UI для сравнения LTR/RTL макетов (Принцип 9: Система)."
        ],
        "criteria_title": "Критерии Успеха Тестирования:",
        "criteria_points": [
          "100% пользовательских строк переведены.",
          "Отсутствие обрезки или наложения текста в UI.",
          "Корректное и полное RTL-отображение для соответствующих языков.",
          "Правильное локализованное форматирование дат, чисел, валют."
        ]
      },
      "section11": {
        "title": "11. Примечания",
        "notes": [
          "План: Полная реализация поддержки 5 ключевых языков запланирована на Q3 2025 (см. Дорожную карту), после завершения этапа построения технологического фундамента и начала разработки MVP.",
          "Масштабирование: Система разработана так, чтобы добавление новых языков в будущем было эффективным (Принцип 9). Основные затраты — это сам перевод.",
          "Ограничения: Технические логи, сообщения сервера для отладки не переводятся. Локализация касается только пользовательского интерфейса и сообщений, предназначенных для конечного пользователя."
        ]
      }
    },
    "userGuide": {
      "title": "Посібник користувача BrainMessenger",
      "subtitle": "Ваш центр для ефективного спілкування та зростання",
      "introduction": {
        "title": "1. Вступ: Ласкаво просимо до Вашої системи взаємодії",
        "p1": "<strong>Ласкаво просимо до BrainMessenger!</strong>",
        "p2": "BrainMessenger — це не просто месенджер, а <strong>ваша особиста система</strong> для безпечного, зручного та <strong>ефективного спілкування і взаємодії</strong> (Принцип 2: Створення цінності, Принцип 9: Система). Ми створили цей <strong>цифровий АКТИВ</strong> (Принцип 10), щоб <strong>спростити складність</strong> (Маргулан), надаючи вам надійний інструмент для зв'язку з іншими та організації вашого спілкування.",
        "p3": "Цей посібник — ваш компас у світі BrainMessenger. Він структурований так, щоб ви могли швидко освоїти ключові функції та використовувати додаток максимально <strong>ефективно</strong> (Принцип 9).",
        "p4": "<strong>Для кого:</strong> BrainMessenger розроблений для широкої аудиторії та доступний на всіх основних платформах: iOS (версія 13+), Android (версія 9+), а також повноцінна веб-версія для сучасних браузерів (Chrome, Firefox, Safari, Edge). Ми прагнемо до максимальної <strong>доступності</strong> (Принцип 5) для кожного.",
        "p5": "<strong>Як почати:</strong> Найбільш <strong>прагматичний</strong> (Принцип 12) спосіб — встановити додаток з відповідного магазину додатків або відкрити веб-сайт `https://brainmessenger.com`."
      },
      "gettingStarted": {
        "title": "2. Початок роботи: Перші кроки в системі BrainMessenger",
        "p1": "Ваш процес реєстрації та входу в систему розроблений як <strong>проста та безпечна система</strong> (Принцип 9, 5).",
        "registration": {
          "title": "2.1. Реєстрація: Створення Вашого профілю в системі",
          "steps": [
            "1. Відкрийте додаток або перейдіть на веб-сайт.",
            "2. Натисніть кнопку <strong>\"Почати\"</strong> (Зареєструватися) на екрані привітання.",
            "3. Дотримуйтесь покрокових інструкцій:",
            "<strong>Введіть Email:</strong> Ваша активна електронна адреса (наприклад, `user@example.com`). Вона буде використовуватися для сповіщень, входу та відновлення доступу. Переконайтеся, що формат електронної пошти правильний.",
            "<strong>Створіть Пароль:</strong> Придумайте <strong>надійний пароль</strong> (мінімум 8 символів, включаючи хоча б одну цифру та один спеціальний символ, наприклад, `MyStrongP@ss!1`). Безпека вашого облікового запису є частиною нашої <strong>основи</strong> (Принцип 5, 8).",
            "<strong>Введіть Ім'я:</strong> Ваше відображуване ім'я в BrainMessenger.",
            "<strong>Підтвердіть Email:</strong> Ми надішлемо 8-значний код підтвердження на вказаний Email (див. API Specification, DocInt). Перевірте пошту (в тому числі папку \"Спам\"). Введіть код у додатку.",
            "4. Натисніть кнопку підтвердження на кожному кроці."
          ],
          "result": "*Результат:* Ваш обліковий запис успішно створено. Ви стаєте частиною <strong>системи BrainMessenger</strong>."
        },
        "login": {
          "title": "2.2. Вхід: Доступ до Вашої мережі взаємодії",
          "steps": [
            "1. На екрані привітання виберіть <strong>\"Увійти\"</strong> (Sign In).",
            "2. Введіть зареєстрований email та пароль.",
            "3. Натисніть <strong>\"Увійти\"</strong> (Sign In)."
          ],
          "note": "*Примітка:* Якщо у вас увімкнено двофакторну автентифікацію (2FA) для додаткової безпеки (див. розділ 3.5), вам потрібно буде ввести додатковий код, отриманий електронною поштою, після введення пароля."
        },
        "logout": {
          "title": "2.3. Вихід: Завершення Вашої поточної сесії",
          "steps": [
            "1. Відкрийте головне меню (зазвичай значок \"гамбургер\" або ваш аватар у верхньому куті).",
            "2. Перейдіть до розділу <strong>\"Налаштування\"</strong>.",
            "3. Прокрутіть униз і виберіть <strong>\"Вийти\"</strong>.",
            "4. Підтвердіть свою дію, якщо потрібно."
          ]
        }
      },
      "mainFunctions": {
        "title": "3. Ключові функції: Інструменти для ефективного спілкування (Принцип 2)",
        "p1": "BrainMessenger надає набір <strong>інструментів</strong> (Принцип 10) для різних типів спілкування, орієнтованих на надання вам <strong>цінності</strong> (Принцип 2).",
        "chatsAndMessages": {
          "title": "3.1. Чати та повідомлення: Ваш особистий простір системи комунікації",
          "sections": [
            "<strong>Перегляд чатів:</strong> На головному екрані відображається <strong>систематично організований</strong> (Принцип 9) список усіх ваших чатів (особисті, групові, канали). Чати з новими повідомленнями завжди знаходяться зверху.",
            "<strong>Створення нового чату:</strong>",
            "1. Натисніть на піктограму <strong>\"+\"</strong> (зазвичай у верхньому правому куті).",
            "2. Виберіть <strong>\"Новий чат\"</strong> або \"Нова група\", \"Новий канал\".",
            "3. Виберіть контакти або додайте учасників, вкажіть ім'я (для груп/каналів).",
            "4. Натисніть <strong>\"Створити\"</strong>.",
            "<strong>Надсилання повідомлення:</strong>",
            "1. Відкрийте потрібний чат.",
            "2. Введіть текст у поле введення повідомлення внизу.",
            "3. Натисніть піктограму <strong>\"Надіслати\"</strong>.",
            "<strong>Надсилання файлів:</strong>",
            "1. У полі введення повідомлення натисніть піктограму скріпки.",
            "2. Виберіть файл (фото, відео, документ). Максимальний розмір файлу для завантаження — 100 МБ.",
            "3. Натисніть <strong>\"Надіслати\"</strong>. Файли безпечно зберігаються в Cloudflare R2 (див. DocInt).",
            "<strong>Пошук чатів та повідомлень:</strong> Використовуйте рядок пошуку у верхній частині головного екрана. Пошук швидкий та <strong>ефективний</strong> (Принцип 9).",
            "<strong>Архівування чатів:</strong> Щоб видалити чат з основного списку, не видаляючи його, проведіть по ньому ліворуч (на мобільному пристрої) або скористайтеся контекстним меню та виберіть <strong>\"Архівувати\"</strong>. Доступ до архіву здійснюється через головне меню. Частина вашої <strong>системи організації</strong> робочого простору (Принцип 9)."
          ]
        },
        "calls": {
          "title": "3.2. Дзвінки та відеодзвінки: Пряма взаємодія",
          "sections": [
            "<strong>Почати дзвінок:</strong> У відкритому чаті натисніть на піктограму телефону (аудіо) або камери (відео).",
            "<strong>Конференції:</strong> Створіть груповий чат і використовуйте функцію \"Почати дзвінок\".",
            "<strong>Історія дзвінків:</strong> Перегляньте список усіх минулих дзвінків у розділі <strong>\"Дзвінки\"</strong> головного меню.",
            "<strong>Налаштування якості:</strong> Під час дзвінка ви можете вибрати якість відео/аудіо (низька, середня, висока) для <strong>прагматичного</strong> (Принцип 12) використання інтернет-трафіку."
          ]
        },
        "filesAndMedia": {
          "title": "3.3. Файли та медіа: Централізований доступ до обміну",
          "sections": [
            "<strong>Перегляд файлів з чату:</strong> У відкритому чаті перейдіть до інформації про чат (натисніть на ім'я/аватар у заголовку) та виберіть розділ <strong>\"Медіа\"</strong>. Тут зібрані всі файли, якими ви обмінювалися в цьому чаті. Ви можете фільтрувати їх за типом."
          ]
        },
        "contacts": {
          "title": "3.4. Контакти: Керування Вашою мережею зв'язків",
          "sections": [
            "<strong>Список контактів:</strong> Доступний у розділі <strong>\"Контакти\"</strong> головного меню.",
            "<strong>Пошук та додавання:</strong> Шукайте існуючих користувачів або додавайте нових за email/номером телефону."
          ]
        },
        "settings": {
          "title": "3.5. Налаштування: Адаптація системи під себе (Принцип 2)",
          "p1": "Розділ \"Налаштування\" дозволяє вам персоналізувати BrainMessenger, роблячи його більш <strong>цінним та зручним</strong> саме для вас.",
          "sections": [
            "<strong>Профіль:</strong> Змініть ім'я, фото, email, пароль. Налаштуйте параметри безпеки (наприклад, увімкніть <strong>двофакторну автентифікацію (2FA)</strong> для додаткового захисту облікового запису). Пов'язано з <strong>відповідальністю</strong> (Принцип 6) за безпеку ваших даних.",
            "<strong>Сповіщення:</strong> Налаштуйте типи сповіщень, звуки, вібрацію.",
            "<strong>Зовнішній вигляд (Тема):</strong> Виберіть <strong>\"Світлу\"</strong> або <strong>\"Темну\"</strong> тему. Темна тема може зменшити навантаження на очі (пов'язано з Принципом 5: Здоров'я).",
            "<strong>Мова:</strong> Виберіть мову інтерфейсу зі списку доступних мов. Зміни застосовуються швидко. Підтримуються мови з письмом справа наліво (RTL), що робить додаток <strong>доступним</strong> (Принцип 2, 5) для різних регіонів (див. DocLocIn).",
            "<strong>Налаштування батареї та анімації:</strong> Увімкніть або вимкніть анімацію інтерфейсу. Це <strong>прагматичне</strong> (Принцип 12) рішення для економії заряду батареї та ресурсів пристрою (Принцип 5).",
            "<strong>Налаштування чату (Налаштування):</strong> У кожному чаті ви можете змінити його візуальне оформлення (кольори фону, шрифти), що додає <strong>цінності</strong> (Принцип 2) за рахунок персоналізації."
          ]
        },
        "premiumSubscription": {
          "title": "3.6. Преміум-підписка: Додаткові функції та підтримка розвитку Активу (Принцип 2, 10)",
          "p1": "Преміум-підписка надає доступ до розширених функцій, які підвищують <strong>цінність</strong> (Принцип 2) вашого досвіду, і є способом підтримки <strong>довгострокового розвитку</strong> (Принцип 8) BrainMessenger як <strong>цифрового Активу</strong> (Принцип 10).",
          "sections": [
            "<strong>Переваги:</strong> Ознайомтеся з ексклюзивними Преміум-функціями в розділі <strong>\"Налаштування\" → \"Преміум\"</strong>.",
            "<strong>Придбання:</strong> Виберіть тарифний план і оформіть підписку через захищену платіжну систему (Stripe, див. DocInt).",
            "<strong>Історія платежів:</strong> Переглядайте інформацію про ваші транзакції."
          ]
        }
      },
      "faq": {
        "title": "4. Часті питання (FAQ): Швидкі відповіді із системи знань",
        "p1": "Цей розділ містить відповіді на типові питання, засновані на нашому <strong>накопиченому досвіді</strong> (Принцип 1, 14).",
        "q1": {
          "question": "З: Що робити, якщо я не отримав код підтвердження під час реєстрації?",
          "answer": "В: Перевірте папку \"Спам\" у вашій електронній пошті. Якщо коду немає, поверніться на екран введення коду та натисніть <strong>\"Надіслати код повторно\"</strong>."
        },
        "q2": {
          "question": "З: Як відновити пароль?",
          "answer": "В: На екрані входу натисніть <strong>\"Забули пароль?\"</strong> та дотримуйтесь інструкцій, надісланих на ваш email."
        },
        "q3": {
          "question": "З: Як видалити мій обліковий запис та дані?",
          "answer": "В: Ви можете ініціювати видалення облікового запису в <strong>\"Налаштування\" → \"Профіль\"</strong>, вибравши <strong>\"Видалити обліковий запис\"</strong>. Ваші дані будуть надійно видалені відповідно до політики конфіденційності (див. DocSecurity)."
        },
        "q4": {
          "question": "З: Чи підтримує BrainMessenger наскрізне шифрування?",
          "answer": "В: Так, безпека та <strong>цілісність</strong> (Принцип 7) ваших даних — наш пріоритет. Усі особисті чати використовують наскрізне шифрування."
        }
      },
      "tips": {
        "title": "5. Корисні поради: Оптимізація Вашого досвіду (Принцип 9)",
        "p1": "Кілька порад для більш <strong>ефективного</strong> (Принцип 9) використання BrainMessenger:",
        "sections": [
          "<strong>Використовуйте онбординг:</strong> Перший екран зі слайдером містить корисну інформацію про додаток.",
          "<strong>Оптимізуйте продуктивність на вашому пристрої:</strong> Якщо додаток працює повільно або сильно споживає батарею, спробуйте вимкнути анімації в <strong>\"Налаштування\" → \"Батарея та Анімації\"</strong>. Це <strong>прагматичний</strong> крок для збереження <strong>здоров'я</strong> вашого пристрою (Принцип 5).",
          "<strong>Підтримуйте порядок у чатах:</strong> Використовуйте функцію архівування, щоб приховати менш актуальні діалоги.",
          "<strong>Дослідіть налаштування:</strong> Дослідіть усі опції в \"Налаштуваннях\", щоб повністю адаптувати додаток під себе."
        ]
      },
      "support": {
        "title": "6. Підтримка: Ми готові допомогти (Принцип 2, 14)",
        "p1": "Якщо у вас виникнуть питання або проблеми, будь ласка, зв'яжіться з нами. Ваш <strong>відгук</strong> допомагає нам <strong>покращувати систему</strong> (Принцип 9).",
        "sections": [
          "<strong>Через додаток:</strong> Відкрийте головне меню, виберіть <strong>\"Підтримка\"</strong> → <strong>\"Зв'язатися з нами\"</strong>.",
          "<strong>За електронною поштою:</strong> Ви також можете написати нам безпосередньо на `support@brainmessenger.com`."
        ],
        "p2": "Ми прагнемо швидко відповідати на запити та надавати вам найкориснішу <strong>допомогу</strong> (Маргулан)."
      }
    },
    "devGuide": {
      "title": "Посібник з розробки BrainMessenger",
      "subtitle": "Застосування принципів у коді",
      "introduction": {
        "title": "1. Вступ: Процес розробки як система вдосконалення",
        "description": "Цей документ — ваш посібник з процесу розробки BrainMessenger. Ми будуємо цей проєкт не хаотично, а як <strong>цілісну систему</strong> (Принцип 9), де кожен член команди (або ви самі) діє відповідно до <strong>чітких стандартів та принципів</strong>, прагнучи до <strong>безперервного вдосконалення</strong> (Принцип 1, 9). Цей процес безпосередньо впливає на <strong>якість</strong> (Принцип 3) кінцевого продукту та його перетворення на <strong>цінний АКТИВ</strong> (Принцип 10).",
        "goal": "Забезпечити <strong>єдиний, ефективний та масштабований</strong> процес розробки, спростити онбординг для нових учасників та підтримувати високий рівень <strong>якості коду та архітектури</strong> на кожному етапі, включно з глибоким навчанням та застосуванням технологій (як видно у відео трекері).",
        "audience": "Усі, хто пише код або керує процесом розробки BrainMessenger (Frontend, Backend, Mobile, Desktop, DevOps розробники).",
        "principles_title": "Принципи, що керують процесом розробки:",
        "principles": [
          "<strong>Система та Оптимізація (Принцип 9):</strong> Структура репозиторію, стандарти кодування, CI/CD, використання інструментів — все спрямовано на створення ефективної та передбачуваної системи. <strong>Кайдзен</strong> застосовується до самого процесу розробки.",
          "<strong>Якість > Кількість (Принцип 3):</strong> Пріоритет надається написанню чистого, тестованого та підтримуваного коду, навіть якщо це займає більше часу на початковому етапі.",
          "<strong>Безперервне Навчання (Принцип 1):</strong> Процес розробки включає вивчення нових технологій, їх прагматичне застосування та рефлексію над набутим досвідом (як задокументовано у відео трекері та годинах Кайдзен).",
          "<strong>Прагматизм та Реалізм (Принцип 12):</strong> Вибір інструментів та підходів, що підходять для поточного етапу проєкту, без зайвого ускладнення.",
          "<strong>Довгострокове Мислення (Принцип 8):</strong> Архітектурні рішення приймаються з урахуванням майбутньої масштабованості та підтримуваності. Код пишеться так, щоб його можна було легко розвивати.",
          "<strong>Відповідальність та Проактивність (Принцип 6):</strong> Кожен розробник несе відповідальність за якість свого коду, тестів та активно бере участь у вдосконаленні процесу."
        ]
      },
      "repoStructure": {
        "title": "2. Структура репозиторію: Монорепозиторій як система організації коду",
        "description": "Проєкт організований як <strong>монорепозиторій</strong>, використовуючи <strong>Turborepo</strong> для управління пакетами. Це свідомий вибір, покликаний підвищити <strong>ефективність</strong> (Принцип 9) за рахунок повторного використання коду та <strong>оптимізації</strong> (Принцип 9) процесів збирання та тестування.",
        "core_title": "<code>core</code>:",
        "core_content": "Містить код, який є <strong>ядром системи</strong> (Принцип 9) і придатний для використання на будь-якій платформі (API-клієнт, спільні утиліти, бізнес-логіка, не прив'язана до UI/сервера). Повторне використання підвищує <strong>ефективність</strong> (Принцип 9) та <strong>послідовність</strong> (Принцип 7).",
        "mobile_desktop_title": "<code>mobile-desktop</code>:",
        "mobile_desktop_content": "Містить код для <strong>клієнтського Активу</strong> (Принцип 10) на мобільних та настільних платформах.",
        "web_title": "<code>web</code>:",
        "web_content": "Містить код для <strong>клієнтського Активу</strong> на веб-платформі.",
        "backend_title": "<code>backend</code>:",
        "backend_content": "Містить код для <strong>серверної частини системи</strong>, що обробляє запити, взаємодіє з базою даних та зовнішніми сервісами. Це критично важливий <strong>важіль</strong> (Маргулан) для всього застосунку.",
        "infrastructure_title": "<code>infrastructure</code>:",
        "infrastructure_content": "Містить конфігурації для <strong>розгортання системи</strong> (Принцип 9) на хмарних ресурсах.",
        "docs_title": "<code>docs</code>:",
        "docs_content": "Містить <strong>документацію — частину системи знань</strong> (Принцип 1), необхідну для ефективної роботи та онбордингу.",
        "turbo_title": "<code>turbo.json</code>:",
        "turbo_content": "Визначає, як Turborepo керує завданнями (збирання, тестування, лінтинг) по всьому монорепозиторію, використовуючи <strong>кешування та паралельне виконання</strong> для <strong>оптимізації</strong> (Принцип 9) часу розробки."
      },
      "techStack": {
        "title": "3. Стек технологій: Інструменти для побудови фундаменту (Принцип 8)",
        "intro": "Вибір стеку базується на <strong>прагматизмі, надійності та потенціалі для довгострокового розвитку</strong> (Принцип 8, 12). Ми використовуємо <strong>перевірені технології</strong>, які дозволяють швидко будувати, закладаючи при цьому <strong>міцний фундамент</strong> (Принцип 8).",
        "table": [
          ["Компонент", "Технологія", "Версія", "Призначення", "Зв'язок з принципами"],
          ["Frontend: Mobile", "React Native", "0.72+", "Створення UI для Android з єдиної кодової бази.", "П9 (Система), П12 (Прагматизм), П2 (Цінність - кросплатформа)."],
          ["Frontend: Desktop", "React Native for Windows (RNW)", "0.72+", "Створення UI для Windows з єдиної кодової бази.", "П9 (Система), П12 (Прагматизм), П2 (Цінність - кросплатформа)."],
          ["Frontend: Web", "Next.js, Tailwind CSS", "14.x", "Веб-застосунок з SSR/SSG для SEO та продуктивності, стилізація на основі утиліт.", "П2 (Цінність), П9 (Система - фреймворк), П12 (Прагматизм)."],
          ["Frontend: General", "TypeScript", "5.x", "Сильна статична типізація для підвищення <strong>якості та надійності</strong> коду.", "П3 (Якість), П9 (Система - передбачуваність)."],
          ["Backend", "Node.js, NestJS", "22.x, 10.x", "Серверна логіка, GraphQL API, висока продуктивність Node.js, модульність NestJS.", "П9 (Система - модульність), П8 (Довгостроковість - масштабованість Node.js)."],
          ["ORM", "Prisma", "5.x", "Зручна та безпечна робота з базою даних (PostgreSQL).", "П3 (Якість - безпека запитів), П9 (Система - абстракція БД)."],
          ["База даних", "PostgreSQL (Neon)", "15.x", "Основне сховище структурованих даних. Надійна реляційна СУБД.", "П8 (Довгостроковість), П9 (Система), П12 (Прагматизм)."],
          ["Файлове сховище", "Cloudflare R2 (S3-сумісне)", "-", "Зберігання медіафайлів та бінарних даних. Економічне та масштабоване.", "П10 (Активи), П12 (Прагматизм), П8 (Довгостроковість)."],
          ["Кешування", "Redis", "7.x", "Кешування даних, обмеження частоти запитів (Rate Limiting), управління присутністю WebSocket.", "П9 (Система - ефективність), П3 (Якість - зниження навантаження), П5 (Здоров'я - чуйність)."],
          ["Асинхронність", "Kafka", "3.x", "Надійна асинхронна обробка фонових завдань (обробка зображень).", "П9 (Система - розділення відповідальності), П3 (Якість - надійність)."],
          ["Оркестрація", "Kubernetes", "1.24+", "Управління контейнерами, автоматичне масштабування, самовідновлення.", "П8 (Довгостроковість), П9 (Система - управління складністю), П3 (Якість - відмовостійкість)."],
          ["Інфраструктура", "Terraform", "1.5+", "Автоматизація створення та управління інфраструктурою (IaC).", "П9 (Система - автоматизація), П3 (Якість - передбачуваність інфраструктури)."],
          ["Тестування", "Jest, Cypress, Detox", "-", "Модульні, інтеграційні, E2E тести для забезпечення <strong>якості</strong>.", "П3 (Якість), П9 (Система - автоматична верифікація)."],
          ["Профілювання", "V8 Profiler, Chrome DevTools", "-", "Інструменти для <strong>вимірювання та оптимізації продуктивності</strong>.", "П1 (Навчання), П9 (Система - Кайдзен), П13 (Наполегливість)."],
          ["Моніторинг Kafka", "Kafdrop", "-", "Візуальний моніторинг черг Kafka.", "П9 (Система), П5 (Здоров'я - систем, видимість проблем)."]
        ]
      },
      "codingStandards": {
        "title": "4. Стандарти кодування: Дисципліна як основа якості (Принцип 3, 9)",
        "intro": "Дотримання стандартів кодування — це вияв <strong>дисципліни</strong> та частина <strong>системи забезпечення якості</strong>. Це робить код передбачуваним, легко читабельним та підтримуваним іншими розробниками (або вами самими в майбутньому).",
        "generalPrinciples": {
          "title": "4.1. Загальні принципи",
          "principles": [
            "<strong>DRY (Don’t Repeat Yourself):</strong> Уникайте дублювання коду. Використовуйте спільні функції, компоненти, хуки в пакеті <code>core</code>.",
            "<strong>KISS (Keep It Simple, Stupid):</strong> Прагніть до простих рішень. Не ускладнюйте без необхідності. <strong>Спрощення складного</strong> (Маргулан) застосовне й до коду.",
            "<strong>Іменування:</strong> Використовуйте англійську для всіх ідентифікаторів (змінних, функцій, класів), коментарів. Будьте послідовними.",
            "<strong>Коментарі:</strong> Обов'язкові для:",
            "Складної бізнес-логіки (наприклад, обробка платежів, управління WebSocket-з'єднаннями).",
            "Інтеграцій із зовнішніми сервісами (де можуть бути неочевидні деталі API).",
            "Критичних ділянок коду (аутентифікація, шифрування, операції з множинами).",
            "Неочевидних рішень або обхідних шляхів (з поясненням)."
          ]
        },
        "namingConventions": {
          "title": "4.2. Угоди про іменування",
          "conventions": [
            "<strong>Змінні та функції:</strong> <code>camelCase</code> (наприклад, <code>getUserProfile</code>, <code>chatMessage</code>).",
            "<strong>Класи та модулі:</strong> <code>PascalCase</code> (наприклад, <code>UserService</code>, <code>ChatModule</code>).",
            "<strong>Константи:</strong> <code>UPPER_SNAKE_CASE</code> (наприклад, <code>MAX_FILE_SIZE</code>, <code>DEFAULT_TIMEOUT</code>).",
            "<strong>Файли та папки:</strong> <code>kebab-case</code> (наприклад, <code>user-service.ts</code>, <code>chat-screen.tsx</code>, <code>image-processing</code>).",
            "<strong>API Endpoints (у контексті GraphQL):</strong> Резолвери та їх поля іменуються відповідно до доменної моделі, часто дотримуючись REST-подібної логіки (наприклад, query <code>getUser</code>, mutation <code>sendMessage</code>)."
          ]
        },
        "formattingLinting": {
          "title": "4.3. Форматування та лінтинг: Автоматизація підтримки порядку",
          "intro": "Використовуйте автоматичні інструменти для забезпечення уніфікованого форматування та дотримання базових правил кодування. Це частина <strong>автоматизованої системи якості</strong> (Принцип 9).",
          "prettier_title": "<strong>Форматування:</strong> <strong>Prettier</strong> — автоматичний форматер коду.",
          "prettier_content": "Налаштуйте <code>.prettierrc</code> у корені проєкту. Рекомендовані налаштування: 2 пробіли для відступів, без крапок з комою в кінці рядків, одинарні лапки для рядків.",
          "prettier_code": "```json\n{\n  \"tabWidth\": 2,\n  \"semi\": false,\n  \"singleQuote\": true,\n  \"trailingComma\": \"es5\"\n}\n```",
          "eslint_title": "<strong>Лінтинг:</strong> <strong>ESLint</strong> — статичний аналізатор коду для виявлення проблем.",
          "eslint_content": "Використовуйте конфігурацію, таку як Airbnb або Standard, адаптовану для TypeScript, React/React Native, NestJS. Налаштуйте правила в <code>.eslintrc.js</code>.\nІнтегруйте ESLint у ваш редактор коду для зворотного зв'язку в реальному часі."
        },
        "codeStructure": {
          "title": "4.4. Структура коду: Модульність та чіткі межі",
          "intro": "Код організовано модульно всередині кожного пакета, дотримуючись принципів <strong>систематизації</strong> (Принцип 9) та розділення відповідальності.",
          "corePackage": {
            "title": "Core (<code>packages/core</code>):",
            "points": [
              "<code>api/</code>: Код для взаємодії з GraphQL API BrainMessenger (Apollo Client).",
              "<code>hooks/</code>: Перевикористовувані хуки для React/React Native.",
              "<code>utils/</code>: Чисті утилітарні функції, незалежні від конкретної платформи."
            ]
          },
          "mobileDesktopPackage": {
            "title": "Mobile-Desktop (<code>packages/mobile-desktop</code>):",
            "points": [
              "<code>components/</code>: Невеликі, перевикористовувані UI-компоненти (<code>Button</code>, <code>MessageBubble</code>).",
              "<code>screens/</code>: Компоненти, що представляють цілі екрани (<code>ChatScreen</code>, <code>SettingsScreen</code>).",
              "<code>theme/</code>: Файли з колірними схемами та типографією, визначені в DocDesign.",
              "<code>platform/</code>: Код, специфічний для Android або Windows (наприклад, робота з нативними модулями)."
            ]
          },
          "webPackage": {
            "title": "Web (<code>packages/web</code>):",
            "points": [
              "<code>pages/</code>: Компоненти сторінок Next.js.",
              "<code>components/</code>: UI-компоненти для вебу (можуть перевикористовувати логіку з <code>core/hooks</code> або <code>core/utils</code>).",
              "<code>styles/</code>: Файли стилів (Tailwind CSS)."
            ]
          },
          "backendPackage": {
            "title": "Backend (<code>backend</code>):",
            "points": [
              "Структура NestJS: Модулі (<code>auth</code>, <code>user</code>, <code>chat</code>, <code>message</code>), сервіси (<code>AuthService</code>, <code>UserService</code>), контролери (для REST, якщо є) або резолвери (для GraphQL), DTO (об'єкти передачі даних), Entities (визначаються Prisma).",
              "<code>src/</code>: Вихідний код.",
              "<code>test/</code>: Тести."
            ]
          }
        }
      },
      "libraries": {
        "title": "5. Використовувані бібліотеки: Вибір правильних інструментів (Принцип 12)",
        "intro": "Ми обираємо бібліотеки, які вирішують проблеми <strong>прагматично</strong> (Принцип 12), забезпечують <strong>якість</strong> (Принцип 3) та добре інтегруються в нашу <strong>систему</strong> (Принцип 9).",
        "common": {
          "title": "5.1. Загальні (Core)",
          "libs": [
            "<code>@apollo/client</code> (та пов'язані): GraphQL-клієнт для виконання запитів до Backend API. Використовується в <code>core</code> та імпортується в <code>mobile-desktop</code> та <code>web</code>. Забезпечує <strong>ефективність</strong> (Принцип 9) за рахунок управління кешем."
          ]
        },
        "mobileDesktop": {
          "title": "5.2. Мобільні-Десктопні (React Native)",
          "libs": [
            "<code>react-native-reanimated</code>, <code>moti</code>, <code>lottie-react-native</code>: Бібліотеки для створення <strong>плавних та продуктивних анімацій</strong> (див. DocDesign). Стосуються Принципу 3 (Якість UI) та Принципу 5 (Здоров'я - зниження навантаження).",
            "<code>@react-navigation/native</code> (та пов'язані): Навігація між екранами застосунку. <strong>Систематичне</strong> (Принцип 9) управління переходами.",
            "<code>react-native-sound</code>: Базова бібліотека для відтворення звуків (повідомлення, дзвінки). Див. Sound Documentation."
          ]
        },
        "web": {
          "title": "5.3. Веб (Next.js)",
          "libs": [
            "<code>next</code>, <code>react</code>, <code>react-dom</code>: Фундамент веб-застосунку. Next.js надає <strong>систему</strong> (Принцип 9) для SSR, SSG, маршрутизації та <strong>оптимізації</strong> (див. DocOptimizationIn).",
            "<code>tailwindcss</code>: CSS-фреймворк з акцентом на утиліти для швидкої та <strong>прагматичної</strong> (Принцип 12) стилізації.",
            "<code>framer-motion</code>: Бібліотека для <strong>якісних</strong> (Принцип 3) анімацій на вебі."
          ]
        },
        "backend": {
          "title": "5.4. Backend (NestJS)",
          "libs": [
            "<code>@nestjs/*</code>: Основні пакети NestJS (core, common, platform-express/fastify, graphql, typeorm/prisma, jwt, passport, websockets тощо). Надають <strong>модульну, масштабовану систему</strong> (Принцип 9).",
            "<code>@nestjs/prisma</code>: Інтеграція NestJS та Prisma.",
            "<code>graphql</code>, <code>@nestjs/graphql</code>, <code>apollo-server-express</code>: Реалізація GraphQL API.",
            "<code>@prisma/client</code>: Prisma ORM клієнт для взаємодії з Neon (PostgreSQL).",
            "<code>@aws-sdk/client-s3</code>, <code>@aws-sdk/s3-request-presigner</code>: Робота з Cloudflare R2 (S3-сумісним).",
            "<code>ioredis</code>: Redis-клієнт для кешування та інших завдань.",
            "<code>kafkajs</code>: Kafka-клієнт для асинхронних завдань.",
            "<code>firebase-admin</code>: Firebase SDK (Push-сповіщення).",
            "<code>stripe</code>: Stripe SDK (Платежі).",
            "<code>googleapis</code>: Google APIs SDK (Gmail API).",
            "<code>bcrypt</code> або <code>argon2</code>: Бібліотека для <strong>безпечного</strong> (Принцип 3, 5) хешування паролів."
          ]
        },
        "crossPackage": {
          "title": "5.5. Загальні (Cross-Package)",
          "libs": [
            "<code>typescript</code>: Мова розробки.",
            "<code>winston</code> або <code>pino</code>: Бібліотека для <strong>структурованого логування</strong> (Принцип 9).",
            "<code>@sentry/node</code>, <code>@sentry/react</code>, <code>@sentry/react-native</code>: Клієнти Sentry для <strong>відстеження помилок у продакшені</strong> (частина системи <strong>якості</strong> та <strong>Кайдзен</strong>).",
            "<code>core-js</code>, <code>regenerator-runtime</code>: Поліфіли для підтримки сучасних функцій JavaScript у старих середовищах (наприклад, нові методи Set в ES2024).",
            "<code>zod</code> або <code>class-validator</code>/<code>class-transformer</code>: Бібліотеки для <strong>валідації даних</strong>, що забезпечують <strong>якість</strong> (Принцип 3) на вході до системи."
          ]
        },
        "setMethods": {
          "title": "5.6. Робота з Sets в ES2024+: Приклад застосування нових знань (Принцип 1)",
          "intro": "<strong>Безперервне навчання</strong> (Принцип 1) та застосування <strong>прагматичних</strong> (Принцип 12) мовних інструментів — частина нашої філософії. Нові методи об'єкта <code>Set</code> в ECMAScript 2024 (підтримуються в Node.js 22+, сучасних браузерах) надають <strong>чистіший, читабельніший і часто ефективніший</strong> (Принцип 9) спосіб роботи з унікальними наборами даних порівняно з ручними циклами або перетвореннями в масиви.",
          "areas": {
            "title": "Області застосування в BrainMessenger:",
            "points": [
              "Управління списками користувачів у групових чатах (додавання/видалення учасників).",
              "Відстеження унікальних активних сесій або WebSocket-з'єднань.",
              "Управління правами доступу (перевірка, чи входить набір дозволів до доступних).",
              "Синхронізація списків (наприклад, контактів, чатів) між клієнтом та сервером, виявлення доданих/видалених елементів."
            ]
          },
          "keys": {
            "title": "Ключові методи (з ES2024):",
            "points": [
              "<code>union(iterable)</code>: Повертає новий <code>Set</code> з усіма унікальними елементами з поточного <code>Set</code> та переданого ітерованого об'єкта.",
              "<code>intersection(iterable)</code>: Повертає новий <code>Set</code> з елементами, присутніми в <strong>обох</strong> множинах.",
              "<code>difference(iterable)</code>: Повертає новий <code>Set</code> з елементами, присутніми в поточному <code>Set</code>, але <strong>не</strong> в переданому ітерованому об'єкті.",
              "<code>symmetricDifference(iterable)</code>: Повертає новий <code>Set</code> з елементами, які знаходяться в <strong>одній</strong>, але не в <strong>обох</strong> множинах.",
              "<code>isSubsetOf(iterable)</code>: Перевіряє, чи є всі елементи поточного <code>Set</code> підмножиною переданого ітерованого об'єкта (<code>true</code> або <code>false</code>).",
              "<code>isSupersetOf(iterable)</code>: Перевіряє, чи містить поточний <code>Set</code> усі елементи переданого ітерованого об'єкта (<code>true</code> або <code>false</code>).",
              "<code>isDisjointFrom(iterable)</code>: Перевіряє, чи не мають поточний <code>Set</code> та переданий ітерований об'єкт спільних елементів (<code>true</code> або <code>false</code>)."
            ]
          },
          "examples": {
            "title": "Приклади використання в коді (TypeScript):",
            "code": "```typescript\n// backend/src/chat/chat.service.ts (example of group member management)\nasync updateGroupMembers(groupId: string, currentMemberIds: Set<string>, newMemberIds: Set<string>) {\n  // Principle 9: Optimization and clarity\n  const addedMembers = newMemberIds.difference(currentMemberIds);\n  const removedMembers = currentMemberIds.difference(newMemberIds);\n  const unchangedMembers = currentMemberIds.intersection(newMemberIds); // For verification\n\n  console.log('Added:', addedMembers);\n  console.log('Removed:', removedMembers);\n\n  // Perform add/remove operations in the database via Prisma\n  if (addedMembers.size > 0) {\n    await this.prisma.userChat.createMany({\n      data: Array.from(addedMembers).map(userId => ({ groupId, userId })),\n    });\n  }\n  if (removedMembers.size > 0) {\n    await this.prisma.userChat.deleteMany({\n      where: {\n        groupId: groupId,\n        userId: { in: Array.from(removedMembers) },\n      },\n    });\n  }\n\n  // Permissions check: Ensure the current user has permission to modify group membership\n  const requiredPermission = new Set(['manage_members']);\n  const userPermissions = new Set(await this.getUserPermissions(userId, groupId)); // Get user permissions\n  const hasPermission = requiredPermission.isSubsetOf(userPermissions); // Check using new method\n  if (!hasPermission) {\n      throw new ForbiddenException(\"Insufficient permissions to modify group membership.\");\n  }\n}\n\n// frontend/src/hooks/useChats.ts (example of chat list synchronization)\nfunction useSyncChats(localChats: Set<string>, serverChats: string[]) {\n    // Principle 9: Synchronization efficiency\n    const serverChatsSet = new Set(serverChats);\n    const newChats = serverChatsSet.difference(localChats);\n    const removedChats = localChats.difference(serverChatsSet);\n\n    console.log('New chats:', newChats);\n    console.log('Removed chats:', removedChats);\n\n    // Update local state/UI based on newChats and removedChats\n    // ...\n}\n",
            "recommendations": [
              "Застосовуйте їх для операцій з унікальними наборами даних. Вони спеціально для цього призначені і часто більш продуктивні, ніж аналогічні операції з масивами, особливо для великих обсягів даних.",
              "Враховуйте сумісність: Нові методи доступні в Node.js 22+ та сучасних браузерах. Якщо вам потрібно підтримувати старіші середовища, використовуйте поліфіли (core-js/proposals/set-methods-v2).",
              "Типізація TypeScript: Завжди вказуйте тип елементів у Set (наприклад, Set<string>, Set<number>) для кращої перевірки типів та автодоповнення."
            ]
          }
        }
      },
      "devProcess": {
        "title": "6. Процес розробки: Наша система робочого процесу (Принцип 9)",
        "intro": "Чіткий процес розробки забезпечує систематизацію, якість та передбачуваність (Принцип 9).",
        "envSetup": {
          "title": "6.1. Налаштування середовища: Підготовка до роботи",
          "intro": "Клонувати репозиторій:",
          "cloneRepo": {
            "title": "Клонувати репозиторій:",
            "code": "```bash\ngit clone <https://github.com/xAI/BrainMessenger.git> # Приклад\ncd BrainMessenger\n```"
          },
          "installDeps": {
            "title": "Встановити залежності:",
            "code": "```bash\nnpm install\n```"
          },
          "envVars": {
            "title": "Налаштувати змінні середовища:",
            "code": "```bash\ncp .env.example .env\n# Заповнити .env даними для Neon, R2, Redis, Kafka, API Gateways, Stripe, Firebase, Gmail API\n```",
            "note": "Важливо мати робочі локальні або тестові інстанси БД, Redis, Kafka або використовувати їх хмарні версії для розробки."
          },
          "prismaClient": {
            "title": "Згенерувати Prisma Client:",
            "code": "```bash\ncd backend\nnpx prisma generate\ncd ..\n```"
          },
          "localDb": {
            "title": "Налаштувати локальну БД (якщо не використовується хмарна):",
            "code": "```bash\ncd backend\nnpx prisma migrate dev --name initial_setup\ncd ..\n```"
          }
        },
        "localRun": {
          "title": "6.2. Локальний запуск: Активізація системи для розробки",
          "intro": "Використовуйте команди <code>turbo run</code> або команди конкретних пакетів.",
          "runAll": {
            "title": "Запустити всі сервіси (Backend, Web) для розробки:",
            "code": "```bash\nturbo run dev # Запустить dev-сервери для всіх пакетів із завданням 'dev' у turbo.json\n```"
          },
          "runBackend": {
            "title": "Окремий запуск Backend:",
            "code": "```bash\ncd backend\nnpm run start:dev # або npm run start:debug для налагодження\n```"
          },
          "runMobileDesktop": {
            "title": "Окремий запуск Mobile-Desktop (React Native):",
            "code": "```bash\ncd packages/mobile-desktop\nnpm run android # для запуску на Android емуляторі/пристрої\nnpm run windows # для запуску на Windows\n```"
          },
          "runWeb": {
            "title": "Окремий запуск Web (Next.js):",
            "code": "```bash\ncd packages/web\nnpm run dev\n```"
          }
        },
        "commitsBranches": {
          "title": "6.3. Коміти та гілки: Структура еволюції коду (Принцип 9)",
          "intro": "Ми використовуємо чітку стратегію гілкування та стандарти комітів для підтримки порядку (Принцип 9) та чіткої історії змін (Принцип 7).",
          "mainBranches": {
            "title": "Основна гілка розробки:",
            "points": [
              "<code>develop</code>. Тут інтегруються всі нові функції та виправлення.",
              "Стабільна гілка: <code>main</code>. Лише перевірений код з <code>develop</code> (через PR релізів)."
            ]
          },
          "workBranches": {
            "title": "Робочі гілки:",
            "points": [
              "<code>feature/<feature_name></code>: Для розробки нової функціональності (наприклад, <code>feature/graphql-auth</code>).",
              "<code>fix/<fix_name></code>: Для виправлення помилок (наприклад, <code>fix/chat-message-scroll</code>).",
              "<code>refactor/<name></code>: Для рефакторингу коду."
            ]
          },
          "commitFormat": {
            "title": "Формат комітів:",
            "example": "Використовуйте Conventional Commits. Це спрощує генерацію changelog та розуміння призначення кожного коміту.\n\nПриклад:\n\n<code>feat(backend/auth): add JWT authentication</code> (нова функція в модулі аутентифікації бекенда)\n\n<code>fix(mobile/chat): resolve message display bug on scroll</code> (виправлення помилки відображення повідомлень у мобільному чаті при прокрутці)\n\n<code>docs(roadmap): update Q3 2025 plan</code> (оновлення документації)\n\n<code>chore(deps): update prisma to 5.x</code> (рутинне завдання, оновлення залежностей)",
            "structure": "Структура: <code>type(scope): description</code>\n\n<code>type</code>: <code>feat</code>, <code>fix</code>, <code>docs</code>, <code>chore</code>, <code>style</code>, <code>refactor</code>, <code>test</code>, <code>ci</code>, <code>perf</code>, <code>build</code>\n\n<code>scope</code>: Необов'язково, вказує пакет або область (<code>backend</code>, <code>web</code>, <code>mobile-desktop</code>, <code>core</code>, <code>auth</code>, <code>chat</code>, <code>ui</code>, <code>infra</code> тощо)."
          }
        },
        "prCodeReview": {
          "title": "6.4. Pull Request (PR) та Code Review: Колективне забезпечення якості (Принцип 3, 14)",
          "intro": "Кожен Pull Request — це можливість отримати зворотний зв'язок (Принцип 14), покращити код та забезпечити якість (Принцип 3) перед інтеграцією в основну гілку.",
          "prDescription": {
            "title": "Опис PR:",
            "points": [
              "Чітко опишіть, яку проблему вирішує PR або яку функцію він додає.",
              "Посилайтеся на відповідне завдання Jira (наприклад, [BM-123]) або інше місце відстеження завдань.",
              "Опишіть основні зміни та будь-які потенційні ризики чи питання."
            ]
          },
          "prRequirements": {
            "title": "Вимоги до PR:",
            "points": [
              "Код має відповідати стандартам кодування (лінтер, форматер).",
              "Усі тести повинні проходити (<code>npm test</code>). Налаштуйте перевірки в GitHub Actions.",
              "Має бути щонайменше 1 схвалення від іншого розробника (або від вас самих, якщо працюєте самостійно, але прагніть до ідеального code review).",
              "Нетривіальні зміни можуть вимагати рев'ю від більш досвідченого розробника або архітектора."
            ]
          }
        },
        "testing": {
          "title": "6.5. Тестування: Перевірка надійності системи (Принцип 3)",
          "intro": "Тестування є невід'ємною частиною процесу забезпечення якості (Принцип 3). Ми використовуємо багаторівневий підхід.",
          "runAllTests": {
            "title": "Запустити всі тести:",
            "code": "```bash\nnpm run test # Запустить тести для всіх пакетів (модульні, інтеграційні)\n```"
          },
          "testTypes": {
            "title": "Типи тестів:",
            "points": [
              "Модульні тести: Тестування окремих функцій або класів ізольовано (Jest). Фокус: Коректність роботи невеликих частин коду.",
              "Інтеграційні тести: Тестування взаємодії між кількома компонентами (наприклад, сервіс -> БД, API -> сервіс) (Jest). Фокус: Коректність зв'язків між частинами системи.",
              "E2E тести (Наскрізні тести): Тестування користувацьких сценаріїв у застосунку (Cypress для Web, Detox для React Native). Фокус: Загальна працездатність системи з точки зору користувача."
            ]
          },
          "ciCdTests": {
            "title": "Налаштувати автоматичний запуск тестів у CI/CD (GitHub Actions) при кожному PR та пуші в гілку develop.",
            "content": "Налаштувати автоматичний запуск тестів у CI/CD (GitHub Actions) при кожному PR та пуші в гілку develop."
          }
        }
      },
      "devRecommendations": {
        "title": "7. Рекомендації з розробки: Кращі практики для створення Активу",
        "intro": "Застосовуйте ці рекомендації для створення якісного, підтримуваного коду, який стане фундаментом вашого цифрового Активу (Принцип 3, 10).",
        "corePackage": {
          "title": "7.1. Пакет Core: Повторне використання для ефективності",
          "points": [
            "API-клієнт (<code>@apollo/client</code>): Використовуйте його для всіх GraphQL-запитів з Frontend. Налаштуйте кешування (InMemoryCache) та обробку помилок. Це зменшує дублювання коду та забезпечує уніфікований спосіб взаємодії з API.",
            "Спільні хуки/утиліти: Виділяйте сюди логіку, яка повторюється на різних платформах (форматування даних, валідація, обробка токенів)."
          ]
        },
        "mobileDesktop": {
          "title": "7.2. Мобільні-Десктопні (React Native)",
          "points": [
            "Функціональні компоненти: Використовуйте React Hooks та функціональні компоненти. Розділяйте компоненти на «розумні» (з логікою) та «прості» (лише UI).",
            "Стилізація: Використовуйте StyleSheet.create для продуктивності або бібліотеки типу styled-components / NativeBase для узгодженості.",
            "Нативна оптимізація: Вивчіть специфіку RNW та RN (наприклад, робота з нативними модулями для підвищення продуктивності критичних ділянок, анімації на нативному потоці з Reanimated)."
          ]
        },
        "web": {
          "title": "7.3. Веб (Next.js)",
          "points": [
            "Маршрутизація та отримання даних: Використовуйте можливості Next.js (File-system routing, getStaticProps, getServerSideProps, getStaticPaths) для оптимізації завантаження сторінок (SSR/SSG) та SEO (Принцип 2).",
            "Стилізація: Tailwind CSS прискорює розробку UI. Дотримуйтесь принципів з DocDesign.",
            "Оптимізація зображень: Використовуйте next/image для автоматичної оптимізації зображень."
          ]
        },
        "backend": {
          "title": "7.4. Backend (NestJS)",
          "points": [
            "GraphQL API: Дотримуйтесь принципів GraphQL (запитуйте лише те, що потрібно). Використовуйте DataLoader для вирішення проблеми N+1 (див. DocOptimizationIn).",
            "Prisma: Використовуйте ORM для всіх взаємодій з БД. Це забезпечує безпеку (захист від SQL-ін'єкцій - Принцип 3, 5) та типізацію.",
            "Сервіси: Виділяйте основну бізнес-логіку в сервіси. Контролери/резолвери мають бути тонкими (лише обробка запитів та виклик сервісів).",
            "Інтеграції: Взаємодія із зовнішніми сервісами (R2, Firebase, Stripe, Gmail API) має бути інкапсульована в окремі сервіси (наприклад, StorageService, NotificationService). Це робить код більш модульним та тестованим (Принцип 9).",
            "Обробка помилок: Використовуйте фільтри винятків NestJS для централізованої обробки помилок та повернення стандартизованих API-відповідей (див. DocSpec). Детально логуйте помилки (Winston, Sentry)."
          ]
        },
        "security": {
          "title": "7.5. Безпека: Захист вашого Активу (Принцип 3, 5, 10)",
          "intro": "Безпека — це не функція, а фундаментальний аспект якості (Принцип 3), безпосередньо пов'язаний зі здоров'ям системи (Принцип 5) та захистом цифрового активу (Принцип 10: ваш продукт та дані користувачів).",
          "points": [
            "Аутентифікація: Використовуйте JWT для stateless-аутентифікації з коротким терміном дії access-токенів та refresh-токенів. Надійно зберігайте JWT-секрет.",
            "Хешування паролів: Ніколи не зберігайте паролі у відкритому вигляді. Використовуйте сильні алгоритми хешування (bcrypt, argon2).",
            "Валідація вхідних даних: Суворо валідуйте всі вхідні дані на Backend (наприклад, використовуючи class-validator та DTO).",
            "Захист від атак: Реалізуйте Rate Limiting (<code>@nestjs/throttler</code>) для захисту від brute-force атак або DDoS на рівні API. Використовуйте helmet для встановлення безпечних HTTP-заголовків.",
            "Шифрування конфіденційних даних: Шифруйте дані перед збереженням у R2 (див. DocInt). Ключ шифрування зберігайте окремо від даних.",
            "2FA: Реалізуйте двофакторну аутентифікацію як опцію для користувачів."
          ]
        }
      },
      "optimization": {
        "title": "8. Оптимізація проєкту: Безперервне вдосконалення (Принцип 9, 1)",
        "content": "Оптимізація — це ітеративний процес (Принцип 9: Кайдзен), заснований на вимірюваннях та навчанні (Принцип 1). Див. докладний посібник з оптимізації BrainMessenger."
      },
      "deployProcess": {
        "title": "9. Процес розгортання: Доставка системи користувачам (Принцип 9)",
        "intro": "Процес розгортання має бути автоматизованим, надійним та передбачуваним (Принцип 9, 3).",
        "points": [
          "Контейнеризація (Docker): Створюйте Docker-образи для Backend та інших сервісів. Використовуйте багатоступеневі збірки для оптимізації розміру образів (див. CI/CD Optimization Guide).",
          "Оркестрація (Kubernetes): Розгортайте контейнери в Kubernetes. Використовуйте маніфести в папці <code>infrastructure/k8s</code>. K8s забезпечує автоматичне масштабування, самовідновлення та управління навантаженням.",
          "Інфраструктура як код (Terraform): Керуйте хмарними ресурсами (кластер K8s, мережі) за допомогою Terraform (<code>infrastructure/main.tf</code>). Це робить інфраструктуру версіонованою та відтворюваною.",
          "CI/CD (GitHub Actions): Налаштуйте автоматичні пайплайни для збирання, тестування та розгортання (див. CI/CD Optimization Guide)."
        ],
        "process": "Процес: Код пушиться в <code>develop</code> → CI/CD запускає тести та збірки → Після успішних тестів та рев'ю, PR зливається в <code>develop</code> → (опціонально) автоматичне розгортання dev/staging середовища → Release PR з <code>develop</code> у <code>main</code> → Продакшн розгортання."
      },
      "devCommands": {
        "title": "10. Корисні команди розробника: Інструментарій системи",
        "table": [
          ["Команда", "Опис", "Розташування"],
          ["<code>npm install</code>", "Встановлює залежності для всіх пакетів (Turborepo).", "Корінь"],
          ["<code>turbo run <task></code>", "Запускає завдання (build, test, lint, dev) для всіх пакетів або за фільтром.", "Корінь"],
          ["<code>npm run lint</code>", "Запускає лінтери для всіх пакетів.", "Корінь"],
          ["<code>npm run format</code>", "Форматує код для всіх пакетів (Prettier).", "Корінь"],
          ["<code>npm run build</code>", "Збирає production версії всіх пакетів.", "Корінь"],
          ["<code>npm run test</code>", "Запускає тести для всіх пакетів.", "Корінь"],
          ["<code>cd backend && npx prisma migrate dev --name <name></code>", "Створює та застосовує нову міграцію БД.", "Корінь/backend"],
          ["<code>cd backend && npx prisma studio</code>", "Запускає графічний інтерфейс для перегляду БД.", "Корінь/backend"],
          ["<code>cd backend && npm run start:dev</code>", "Запускає бекенд у режимі розробки.", "Корінь/backend"],
          ["<code>cd packages/web && npm run dev</code>", "Запускає веб-застосунок у режимі розробки.", "Корінь/packages/web"],
          ["<code>cd packages/mobile-desktop && npm run android</code>", "Запускає мобільний застосунок на Android.", "Корінь/packages/mobile-desktop"],
          ["<code>cd packages/mobile-desktop && npm run windows</code>", "Запускає десктопний застосунок на Windows.", "Корінь/packages/mobile-desktop"],
          ["<code>cd infrastructure && terraform plan</code>", "Показує план змін інфраструктури.", "Корінь/infrastructure"],
          ["<code>cd infrastructure && terraform apply</code>", "Застосовує зміни інфраструктури.", "Корінь/infrastructure"]
        ]
      },
      "notes": {
        "title": "11. Примітки: Безперервне навчання та Кайдзен",
        "points": [
          "Онбординг: Нові розробники повинні почати з вивчення цієї документації, а також Технічної документації (загальний огляд), Документації з дизайну (візуальні стандарти) та Посібника з оптимізації (як писати продуктивний код).",
          "Живий документ: Ця документація — живий документ. Вона буде оновлюватися в міру розвитку проєкту, вивчення нових технологій та вдосконалення процесів. Ваші пропозиції щодо вдосконалення вітаються! (Принцип 1, 14).",
          "Сумісність з ECMAScript 2024: Переконайтеся, що ви використовуєте Node.js 22+ (для бекенда) та актуальні версії браузерів/React Native (для фронтенда) для повної підтримки нових методів Set. За потреби використовуйте поліфіли.",
          "Питання та зворотний зв'язок: Якщо щось незрозуміло, або ви бачите можливість покращити процес — задавайте питання в командному чаті (#dev-team у Slack або іншому інструменті) та пропонуйте зміни. Це частина Сили Взаємодії та Співпраці (Маргулан), яка робить систему сильнішою."
        ]
      }
    },
    "integrationsGuide": {
      "title": "Документація Інтеграцій BrainMessenger",
      "subtitle": "Побудова Надійної Системи із Зовнішніми Важелями",
      "introduction": {
        "title": "1. Вступ: Інтеграції як Частина Фундаменту Системи",
        "description": "Цей документ описує, як BrainMessenger інтегрується з ключовими зовнішніми сервісами. Ми обираємо ці інтеграції <strong>прагматично</strong> (Принцип 12), розглядаючи їх як <strong>важелі</strong> (принцип Маргулана), які дозволяють нам не винаходити колесо, а використовувати <strong>надійні та масштабовані</strong> (Принцип 8, 9) сторонні рішення для прискорення розробки та забезпечення <strong>якості</strong> (Принцип 3) нашого продукту. Ці інтеграції є невід'ємною частиною нашого <strong>технологічного фундаменту</strong> (Принцип 8).",
        "principlesTitle": "Принципи, якими керується вибір та налаштування інтеграцій:",
        "principles": [
          "<strong>Система та Оптимізація (Принцип 9):</strong> Інтеграції повинні бути частиною єдиної, добре продуманої системи, де кожен компонент виконує свою роль ефективно.",
          "<strong>Прагматизм та Реалізм (Принцип 12):</strong> Вибір сервісів з урахуванням поточних потреб, бюджету (безкоштовні/доступні тарифи на старті) та простоти інтеграції.",
          "<strong>Довгострокове Мислення (Принцип 8):</strong> Вибір сервісів, здатних масштабуватися разом із зростанням проєкту.",
          "<strong>Якість > Кількість (Принцип 3):</strong> Фокус на надійності та продуктивності інтеграцій, навіть якщо їх список на старті невеликий.",
          "<strong>Створення Цінності (Принцип 2):</strong> Кожна інтеграція повинна додавати реальну цінність для кінцевого користувача (наприклад, надійне зберігання файлів, миттєві сповіщення)."
        ]
      },
      "overview": {
        "title": "2. Огляд Ключових Інтеграцій: Наші Зовнішні Компоненти Системи",
        "table": [
          ["Сервіс", "Призначення", "Роль у BrainMessenger", "Основні функції", "Зв'язок з Принципами"],
          ["<strong>Neon</strong>", "Керована PostgreSQL БД", "Зберігання всіх <strong>структурованих даних</strong> (користувачі, чати, повідомлення, метадані файлів). Фундамент даних.", "Хостинг PostgreSQL, масштабування, доступ через рядок підключення.", "P8 (Довгострокове), P9 (Система), P12 (Прагматизм - безкоштовний тариф)."],
          ["<strong>Cloudflare R2</strong>", "Хмарне Сховище (S3-сумісне)", "Зберігання всіх <strong>неструктурованих даних</strong> (файли користувачів, аватарки, записи дзвінків, зашифровані метадані). Сховище Активів.", "Надійне зберігання об'єктів, CDN-доставка, відсутність плати за вихідний трафік.", "P8 (Довгострокове), P10 (Активи), P12 (Прагматизм - безкоштовний тариф, немає плати за трафік), P3 (Якість - CDN)."],
          ["<strong>Firebase</strong>", "Push-сповіщення", "Миттєва доставка сповіщень користувачам на мобільні пристрої.", "Відправлення push-сповіщень (FCM).", "P2 (Цінність - інформування), P9 (Система - надійна доставка), P12 (Прагматизм - готове рішення)."],
          ["<strong>Stripe</strong>", "Платіжна Система", "Обробка платежів за Premium-підписку. Доступ до платежів як до важеля створення Цінності/Багатства.", "Прийом платежів, управління підписками.", "P2 (Цінність - преміум), P10 (Багатство/Активи), P9 (Система - автоматизація платежів)."],
          ["<strong>Gmail API</strong>", "Сервіс відправки email", "Відправлення критично важливих email (коди підтвердження для реєстрації та 2FA).", "Відправлення транзакційних email.", "P3 (Якість - надійна доставка email), P9 (Система - частина автентифікації), P5 (Здоров'я - безпека користувача)."]
        ]
      },
      "neonIntegration": {
        "title": "3. Інтеграція з Neon: Фундамент Структурованих Даних",
        "generalInfo": {
          "title": "3.1. Загальна Інформація",
          "description": "Neon надає керований сервіс PostgreSQL. Ми використовуємо його як <strong>основне сховище структурованих даних</strong>, таких як інформація про користувачів, чати, повідомлення та метадані файлів.",
          "advantages": [
            "<strong>Прагматизм (P12):</strong> Безкоштовний тариф на старті (30 ГБ) повністю покриває початкові потреби.",
            "<strong>Система та Довгострокове Мислення (P9, P8):</strong> Керований сервіс знижує операційне навантаження, автоматичне масштабування та реплікація доступні на платних планах, забезпечуючи готовність до зростання.",
            "<strong>Якість (P3):</strong> Надійність та продуктивність PostgreSQL як перевіреної СУБД."
          ],
          "role": "Роль: Ядро, до якого звертається Backend для всіх CRUD-операцій над метаданими."
        },
        "configuration": {
          "title": "3.2. Конфігурація: Підключення до Системи Даних",
          "steps": [
            "1. <strong>Реєстрація та Створення Проєкту:</strong>",
            "Створіть обліковий запис на `https://neon.tech`.",
            "Створіть новий проєкт (наприклад, `brainmessenger-prod`) у консолі Neon.",
            "2. <strong>Налаштування Бази Даних:</strong>",
            "Neon автоматично надає інстанс PostgreSQL.",
            "<strong>Застосуйте схему бази даних:</strong> Використовуйте Prisma Migrate для ініціалізації структури таблиць (див. `database/schema.prisma` та Посібник з розробки).",
            "3. <strong>Змінні Середовища:</strong>",
            "Отримайте <strong>рядок підключення</strong> (Connection Details) з консолі Neon (Settings → Connection Details).",
            "Додайте у ваш `.env` файл:"
          ],
          "envExample": "```env\n# Рядок підключення до бази даних Neon\nDATABASE_URL=postgresql://<user>:<password>@<neon-host>/<dbname>?sslmode=require\n```",
          "note1": "*Примітка:* Використовуйте `sslmode=require` для безпечного з'єднання.",
          "backendCode": "4. <strong>Підключення Backend (NestJS + Prisma):</strong>\nPrisma використовує `DATABASE_URL` для підключення. Переконайтеся, що Prisma Client згенеровано (`npx prisma generate`).\nВикористовуйте `PrismaService` (з `nestjs-prisma`) для всіх операцій з БД.\n```typescript\n// backend/src/app.module.ts (або db.module.ts)\nimport { Module } from '@nestjs/common';\nimport { PrismaService } from 'nestjs-prisma'; // Переконайтеся, що PrismaModule імпортовано в app.module\n\n@Module({\n  providers: [PrismaService], // PrismaService доступний для ін'єкції\n  exports: [PrismaService],\n})\nexport class DbModule {}\n```"
        },
        "interactionScenarios": {
          "title": "3.3. Методи та Сценарії Взаємодії: API Даних",
          "description": "Усі взаємодії з Neon відбуваються через Prisma ORM у Backend, що забезпечує <strong>типізацію, безпеку та системність</strong> (Принцип 3, 9).",
          "signup": {
            "title": "Сценарій: Реєстрація користувача:",
            "interaction": "<strong>Взаємодія:</strong> Backend отримує дані користувача → Використовує `PrismaService` для створення нового запису в таблиці `users`.",
            "code": "<strong>Приклад коду (Backend Service):</strong>\n```typescript\n// backend/src/auth/auth.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { PrismaService } from 'nestjs-prisma';\nimport { Prisma } from '@prisma/client'; // Імпорт типів Prisma\n\n@Injectable()\nexport class AuthService {\n  constructor(private prisma: PrismaService) {}\n\n  async signUp(data: Prisma.UserCreateInput) {\n    // Приклад: пароль має бути захейшований ДО збереження\n    const hashedPassword = await hashPassword(data.password); // Використання утиліти для хешування\n    return this.prisma.user.create({\n      data: {\n        email: data.email,\n        name: data.name,\n        password: hashedPassword, // Зберігаємо захейшований пароль\n        // ... інші поля за схемою\n      },\n    });\n  }\n}\n```",
            "result": "<strong>Результат:</strong> Дані користувача надійно збережено в Neon."
          },
          "getChats": {
            "title": "Сценарій: Отримання списку чатів користувача:",
            "interaction": "<strong>Взаємодія:</strong> Frontend запитує чати через GraphQL API → Backend використовує `PrismaService` для виконання запиту до таблиці `chats` (можливо, з фільтрацією за `userId` та `include` для метаданих).",
            "code": "<strong>Приклад коду (Backend Service):</strong>\n```typescript\n// backend/src/chat/chat.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { PrismaService } from 'nestjs-prisma';\n\n@Injectable()\nexport class ChatService {\n  constructor(private prisma: PrismaService) {}\n\n  async getUserChats(userId: string) {\n    // Використовуємо індекси @@index([userId]) для оптимізації (Принцип 9, Оптимізація)\n    return this.prisma.chat.findMany({\n      where: {\n        users: { // Передбачається зв'язок Many-to-Many з таблицею UserChat\n          some: {\n            userId: userId,\n          },\n        },\n      },\n      select: { // Обираємо лише необхідні поля (Принцип 9, Оптимізація)\n        id: true,\n        name: true,\n        type: true,\n        // ... інші потрібні поля\n      },\n      orderBy: { // Сортування за датою останнього повідомлення для актуальності (Принцип 2, Цінність)\n        lastMessageAt: 'desc',\n      },\n    });\n  }\n}\n```"
          },
          "saveMessage": {
            "title": "Сценарій: Збереження повідомлення:",
            "interaction": "<strong>Взаємодія:</strong> Користувач відправляє повідомлення → Frontend відправляє його через GraphQL API → Backend використовує `PrismaService` для створення нового запису в таблиці `messages`, пов'язуючи його з `chatId` та `userId`.",
            "code": "<strong>Приклад коду (Backend Service):</strong>\n```typescript\n// backend/src/message/message.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { PrismaService } from 'nestjs-prisma';\nimport { Prisma } from '@prisma/client';\n\n@Injectable()\nexport class MessageService {\n  constructor(private prisma: PrismaService) {}\n\n  async createMessage(data: Prisma.MessageCreateInput) {\n    // Використовуємо транзакцію, якщо потрібно оновити дату останнього повідомлення в чаті\n    return this.prisma.$transaction(async (tx) => {\n      const message = await tx.message.create({ data });\n      await tx.chat.update({\n        where: { id: data.chatId },\n        data: { lastMessageAt: message.createdAt }, // Оновлюємо час останнього повідомлення\n      });\n      return message;\n    });\n  }\n}\n```"
          }
        },
        "errorHandling": {
          "title": "3.4. Обробка Помилок Інтеграції: Підтримка Якості Системи",
          "description": "Надійна система повинна вміти обробляти помилки зовнішніх залежностей (Принцип 3: Якість).",
          "connectionError": {
            "title": "Connection Error:",
            "cause": "Причина: Неможливо встановити з'єднання з Neon. Невірний рядок підключення (`DATABASE_URL`), проблеми з мережею, недоступність сервісу Neon.",
            "solution": "Рішення: Перевірити змінну середовища `DATABASE_URL`, статус сервісу Neon. Логувати помилку на Backend (Sentry/Winston)."
          },
          "queryError": {
            "title": "Database Query Error:",
            "cause": "Причина: Помилка виконання запиту до БД (наприклад, порушення унікальності, невірний тип даних). Помилка в логіці Backend, невідповідність схеми БД.",
            "solution": "Рішення: Відлагодити запит у Backend, перевірити логи Prisma. Логувати помилку."
          },
          "rateLimitError": {
            "title": "Rate Limit Exceeded (на платних тарифах):",
            "cause": "Причина: Перевищено ліміти на кількість запитів або обчислювальні ресурси в Neon. Високе навантаження, неоптимізовані запити, недостатній тарифний план.",
            "solution": "Рішення: Оптимізувати запити (див. Посібник з оптимізації), розглянути перехід на вищий тарифний план Neon."
          }
        }
      },
      "r2Integration": {
        "title": "4. Інтеграція з Cloudflare R2: Сховище Цифрових Активів",
        "generalInfo": {
          "title": "4.1. Загальна Інформація",
          "description": "Cloudflare R2 — це сервіс об'єктного сховища, сумісний з S3 API. Ми використовуємо його для зберігання <strong>всіх файлів користувачів</strong>, таких як зображення, відео, документи, а також зашифровані дані.",
          "advantages": [
            "<strong>Прагматизм (P12), Створення Багатства/Активів (P10):</strong> <strong>Відсутність плати за вихідний трафік</strong> — критично важлива перевага для месенджера, де користувачі активно обмінюються файлами. Безкоштовний тариф 10 ГБ на старті.",
            "<strong>Якість (P3):</strong> Висока продуктивність та надійність завдяки глобальній мережі Cloudflare.",
            "<strong>Довгострокове Мислення (P8), Система (P9):</strong> S3-сумісний API дозволяє легко використовувати стандартні бібліотеки та інструменти, забезпечуючи гнучкість у майбутньому."
          ],
          "role": "Роль: Децентралізоване сховище для великих бінарних об'єктів, що знижує навантаження на основну базу даних."
        },
        "configuration": {
          "title": "4.2. Конфігурація: Підключення до Сховища Активів",
          "steps": [
            "1. <strong>Створення Бакета:</strong>",
            "Увійдіть у Cloudflare Dashboard → R2.",
            "Натисніть <strong>\"Create Bucket\"</strong>.",
            "Назвіть бакет (наприклад, `brainmessenger-files`). Назва має бути унікальною в рамках усіх облікових записів Cloudflare.",
            "<strong>Налаштування:</strong> Увімкніть шифрування у стані спокою (Encryption at rest) — це частина нашої <strong>системи безпеки</strong> (Принцип 3, 5). Обмежте публічний доступ до бакету, доступ буде здійснюватися через підписані URL (якщо потрібно) або через Backend.",
            "2. <strong>Ключі Доступу:</strong>",
            "У Cloudflare Dashboard перейдіть до R2 → Manage R2 API Tokens.",
            "Створіть новий API-токен. Надайте йому мінімально необхідні дозволи (наприклад, Read and Write to specific buckets).",
            "Скопіюйте `Access Key ID` та `Secret Access Key`.",
            "3. <strong>Змінні Середовища:</strong>",
            "Додайте у ваш `.env` файл:"
          ],
          "envExample": "```env\n# Cloudflare R2 Credentials\nR2_ENDPOINT=<Your R2 Endpoint> # Формат: https://<account-id>.r2.cloudflarestorage.com\nR2_ACCESS_KEY=<Your Access Key ID>\nR2_SECRET_KEY=<Your Secret Access Key>\nR2_BUCKET=brainmessenger-files # Назва вашого бакета\n\n# Ключ шифрування для конфіденційних даних (важливо для P3, P5, P10)\nENCRYPTION_KEY=<Your 32-byte (256-bit) hex or base64 encryption key> # Згенеруйте надійний ключ!\n```",
          "note": "*Примітка:* <strong>Не комітьте ці ключі в Git!</strong> (Принцип 3, 5, 6). Використовуйте `.env.example` без чутливих даних. <strong>ENCRYPTION_KEY</strong> має бути згенерований надійно та зберігатися в безпеці.",
          "backendCode": "4. <strong>Підключення Backend (`@aws-sdk/client-s3`):</strong>\nR2 сумісний з S3 API, тому можна використовувати стандартний AWS SDK для S3.\nВстановіть SDK: `npm install @aws-sdk/client-s3`.\nІніціалізуйте S3 Client у вашому Backend-сервісі (наприклад, `StorageService`).\n```typescript\n// backend/src/storage/storage.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3';\nimport { getSignedUrl } from '@aws-sdk/s3-request-presigner'; // Для підписаних URL\nimport { createCipheriv, randomBytes, createDecipheriv } from 'crypto'; // Для шифрування\n\n@Injectable()\nexport class StorageService {\n  private r2: S3Client;\n  private encryptionKey: Buffer; // Ключ для шифрування\n\n  constructor() {\n    this.r2 = new S3Client({\n      region: 'auto', // R2 не використовує регіони в класичному розумінні\n      endpoint: process.env.R2_ENDPOINT,\n      credentials: {\n        accessKeyId: process.env.R2_ACCESS_KEY,\n        secretAccessKey: process.env.R2_SECRET_KEY,\n      },\n    });\n    // Важливо: ENCRYPTION_KEY має бути Buffer 32 байти для aes-256-cbc\n    this.encryptionKey = Buffer.from(process.env.ENCRYPTION_KEY, 'hex'); // Або 'base64'\n    if (this.encryptionKey.length !== 32) {\n         // Логувати помилку або викинути виняток - ключ невірної довжини\n         console.error(\"Invalid ENCRYPTION_KEY length. Must be 32 bytes for aes-256-cbc.\");\n         // process.exit(1); // Можливо, варто зупинити додаток\n    }\n  }\n\n  // Утиліта для шифрування (частина системи безпеки - P3, P5)\n  private encrypt(data: string): { encrypted: string, iv: string } {\n    const iv = randomBytes(16); // Initialization Vector, 16 байт для aes-256-cbc\n    const cipher = createCipheriv('aes-256-cbc', this.encryptionKey, iv);\n    let encrypted = cipher.update(data, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    return { encrypted, iv: iv.toString('hex') };\n  }\n\n  // Утиліта для дешифрування\n  private decrypt(encrypted: string, iv: string): string {\n      const decipher = createDecipheriv('aes-256-cbc', this.encryptionKey, Buffer.from(iv, 'hex'));\n      let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n      decrypted += decipher.final('utf8');\n      return decrypted;\n  }\n\n  // ... методи для роботи з R2 (завантаження, скачування, видалення)\n}\n```"
        },
        "interactionScenarios": {
          "title": "4.3. Методи та Сценарії Взаємодії: API Сховища",
          "description": "Взаємодія з R2 здійснюється через Backend, що дозволяє контролювати доступ, обробляти файли (наприклад, оптимізація зображень перед завантаженням) та керувати метаданими в БД (Принцип 9: Система).",
          "uploadFile": {
            "title": "Сценарій: Завантаження файлу користувачем:",
            "interaction": "<strong>Взаємодія:</strong> Користувач прикріплює файл у чаті → Frontend відправляє файл на Backend → Backend (`StorageService`) завантажує файл у R2 → Backend зберігає метадані файлу (URL, тип, розмір) у Neon → Backend відправляє повідомлення в чат з посиланням на файл.",
            "code": "<strong>Приклад коду (Backend Service):</strong>\n```typescript\n// backend/src/storage/storage.service.ts (продовження)\n// ... S3Client та encryptionKey ініціалізація ...\n\nasync uploadFile(fileBuffer: Buffer, fileName: string, mimeType: string): Promise<string> {\n  const key = `uploads/${Date.now()}-${fileName}`; // Унікальний ключ файлу\n  const params = {\n    Bucket: process.env.R2_BUCKET,\n    Key: key,\n    Body: fileBuffer,\n    ContentType: mimeType, // Важливо для віддачі файлу\n  };\n  const command = new PutObjectCommand(params);\n  await this.r2.send(command); // Асинхронне завантаження\n\n  // Повертаємо URL для збереження в БД. R2 дозволяє прямі посилання, якщо налаштовано публічний домен.\n  // АБО генеруємо підписаний URL для обмеженого доступу (більш безпечно).\n  // Приклад прямого посилання (вимагає налаштування Public Access URL у CF Dashboard):\n  // const publicUrl = `${process.env.R2_ENDPOINT.replace('.r2.cloudflarestorage.com', '.r2.dev')}/${process.env.R2_BUCKET}/${key}`;\n  // Для власного домену (бажано):\n  const fileUrl = `https://r2.brainmessenger.com/${key}`; // Ваш налаштований домен Cloudflare Workers/Pages\n\n  return fileUrl;\n}\n\n//backend/src/chat/chat.service.ts (інтеграція uploadFile)\n// ... constructor з StorageService ...\nasync sendFileMessage(chatId: string, userId: string, file: Express.Multer.File): Promise<Message> {\n   // Опціонально: обробка зображення перед завантаженням (див. DocOptimizationIn)\n   // const processedFileBuffer = await this.imageProcessingService.processImage(file.buffer, 800, 600); // Приклад\n   const fileUrl = await this.storageService.uploadFile(file.buffer, file.originalname, file.mimetype);\n\n   // Створюємо повідомлення в БД з посиланням на файл\n   return this.prisma.message.create({\n     data: {\n       chatId,\n       userId,\n       content: '[File]', // Або інше позначення файлу\n       fileUrl: fileUrl, // Зберігаємо посилання на файл у БД\n       // fileMetadata: { type: file.mimetype, size: file.size }, // Опціонально: збереження метаданих у JSON полі або окремій таблиці\n     },\n   });\n}\n```",
            "result": "<strong>Результат:</strong> Файл надійно зберігається в R2, посилання на нього доступне в БД для відображення в чаті."
          },
          "sensitiveData": {
            "title": "Сценарій: Зберігання конфіденційних даних (наприклад, зашифровані метадані):",
            "interaction": "<strong>Взаємодія:</strong> При реєстрації або оновленні профілю Backend шифрує чутливі дані (наприклад, резервні email, секретні питання) та зберігає їх у R2 в окремому бакеті або папці.",
            "code": "<strong>Приклад коду (Backend Service):</strong>\n```typescript\n// backend/src/storage/storage.service.ts (продовження)\n// ... методи encrypt/decrypt ...\n\nasync storeSensitiveData(userId: string, sensitiveInfo: any): Promise<string> {\n   const encryptedData = {};\n   for (const key in sensitiveInfo) {\n       if (sensitiveInfo.hasOwnProperty(key)) {\n           const { encrypted, iv } = this.encrypt(JSON.stringify(sensitiveInfo[key])); // Шифруємо кожне поле або весь об'єкт\n           encryptedData[key] = { encrypted, iv };\n       }\n   }\n\n   const key = `sensitive/${userId}/metadata.json`;\n   const params = {\n       Bucket: process.env.R2_BUCKET, // Або окремий бакет для чутливих даних\n       Key: key,\n       Body: JSON.stringify(encryptedData),\n       ContentType: 'application/json',\n   };\n   const command = new PutObjectCommand(params);\n   await this.r2.send(command);\n   return `https://r2.brainmessenger.com/${key}`; // Посилання для внутрішнього використання\n}\n\n// backend/src/user/user.service.ts (інтеграція storeSensitiveData)\n// ... constructor з StorageService ...\nasync createUserWithSensitiveData(userData: any, sensitiveData: any) {\n    // Створюємо користувача в БД\n    const user = await this.prisma.user.create({ data: userData });\n    // Зберігаємо зашифровані дані в R2\n    const sensitiveDataUrl = await this.storageService.storeSensitiveData(user.id, sensitiveData);\n    // Зберігаємо посилання на зашифровані дані в БД (опціонально)\n    await this.prisma.user.update({\n        where: { id: user.id },\n        data: { sensitiveDataUrl: sensitiveDataUrl } // Додати поле sensitiveDataUrl у схему Prisma\n    });\n    return user;\n}\n```",
            "result": "<strong>Результат:</strong> Конфіденційні дані надійно зашифровані та зберігаються окремо від основної БД в R2. Доступ до них можливий лише через Backend з використанням ключа шифрування."
          },
          "getFile": {
            "title": "Сценарій: Отримання файлу (для відображення або скачування):",
            "interaction": "<strong>Взаємодія:</strong> Frontend отримує URL файлу з метаданих повідомлення (з Neon) → Frontend (або Backend, якщо потрібна автентифікація/підписані URL) використовує цей URL для скачування файлу безпосередньо з R2.",
            "code": "<strong>Реалізація:</strong> Якщо бакет R2 налаштований з Public Access URL (через Cloudflare Workers/Pages), Frontend може звертатися безпосередньо. Якщо доступ обмежений, Backend може генерувати тимчасові підписані URL через `@aws-sdk/s3-request-presigner`.\n```typescript\n// backend/src/storage/storage.service.ts (продовження)\n// ... S3Client ініціалізація ...\n\n// Метод для генерації підписаного URL (більш безпечний підхід для приватних файлів)\nasync getSignedFileUrl(fileKey: string): Promise<string> {\n    const command = new GetObjectCommand({\n        Bucket: process.env.R2_BUCKET,\n        Key: fileKey,\n    });\n    // Згенерувати підписаний URL, дійсний, наприклад, 60 секунд\n    const signedUrl = await getSignedUrl(this.r2, command, { expiresIn: 60 });\n    return signedUrl;\n}\n```"
          }
        },
        "errorHandling": {
          "title": "4.4. Обробка Помилок Інтеграції: Сховище Активів",
          "forbidden": {
            "title": "403 Forbidden:",
            "cause": "Причина: Помилка доступу до бакету R2. Невірні ключі доступу (`R2_ACCESS_KEY`, `R2_SECRET_KEY`), невірні дозволи токена, спроба доступу до приватного файлу без автентифікації/підписаного URL.",
            "solution": "Рішення: Перевірити змінні середовища, дозволи токена R2. Переконатися, що логіка доступу (публічний URL vs підписаний URL) реалізована коректно. Логувати помилку."
          },
          "notFound": {
            "title": "404 Not Found:",
            "cause": "Причина: Файл відсутній у R2. Невірний ключ файлу (`Key`), файл було видалено.",
            "solution": "Рішення: Перевірити ключ файлу, який було збережено в Neon. Переконатися, що файл дійсно було завантажено. Логувати помилку."
          },
          "tooManyRequests": {
            "title": "429 Too Many Requests:",
            "cause": "Причина: Перевищено ліміт запитів до R2 API. Висока частота запитів завантаження/скачування.",
            "solution": "Рішення: Впровадити Rate Limiting на Backend (див. Посібник з оптимізації). Оптимізувати логіку роботи з файлами."
          },
          "encryptionError": {
            "title": "Encryption/Decryption Error:",
            "cause": "Причина: Помилка шифрування/дешифрування. Невірний ключ шифрування (`ENCRYPTION_KEY`), пошкоджений IV, пошкоджені зашифровані дані.",
            "solution": "Рішення: Переконатися, що використовується правильний ключ (`ENCRYPTION_KEY`), який збігається з ключем, використаним при шифруванні. Перевірити цілісність даних та IV. Логувати критичну помилку."
          }
        }
      },
      "neonR2Interaction": {
        "title": "5. Взаємодія Neon та Cloudflare R2: Оптимізація Зберігання Даних (Принцип 9, 12)",
        "description": "Ми використовуємо Neon та R2 спільно, щоб створити оптимізовану систему зберігання даних, де кожен сервіс виконує свою найкращу функцію (Принцип 9).",
        "scenario": [
          "<strong>Neon (PostgreSQL):</strong> Зберігає <strong>структуровані метадані</strong>, які часто запитуються і за якими виконуються складні запити (користувачі, чати, текстові повідомлення, посилання на файли).",
          "<strong>Cloudflare R2:</strong> Зберігає <strong>неструктуровані бінарні дані</strong> великого розміру (файли), які рідше запитуються і не вимагають складної логіки вибірки за вмістом).",
          "<strong>Сценарій комплексного взаємодії:</strong>",
          "1. Користувач відправляє файл через чат (Frontend -> Backend).",
          "2. Backend (`StorageService`) <strong>завантажує файл у Cloudflare R2</strong> (використовуючи S3 API). Отримує URL файлу (або ключ).",
          "3. Backend (`ChatService`) <strong>зберігає метадані повідомлення в Neon через Prisma</strong>, включаючи отриманий URL/ключ файлу.",
          "4. Коли інший користувач відкриває чат, Backend (`ChatService`) <strong>отримує список повідомлень з Neon через Prisma</strong>, включаючи URL/ключі файлів.",
          "5. Frontend відображає список повідомлень та використовує URL/ключі для <strong>скачування файлів безпосередньо з R2</strong> (або через Backend, якщо потрібна автентифікація)."
        ],
        "advantagesTitle": "Переваги такого розділення:",
        "advantages": [
          "<strong>Оптимізація продуктивності БД:</strong> PostgreSQL не \"засмічується\" великими бінарними даними, що покращує швидкість текстових запитів (Принцип 9).",
          "<strong>Зниження вартості:</strong> R2 пропонує дуже вигідні тарифи для зберігання великих обсягів даних без плати за вихідний трафік, що <strong>прагматично</strong> (Принцип 12) та сприяє створенню <strong>активу</strong> (Принцип 10).",
          "<strong>Масштабованість:</strong> Кожен сервіс масштабується незалежно відповідно до свого типу навантаження (Neon для транзакцій, R2 для обсягу/трафіку файлів).",
          "<strong>Надійність:</strong> Розділення відповідальності між сервісами підвищує загальну відмовостійкість системи."
        ]
      },
      "otherIntegrations": {
        "title": "6. Інші Інтеграції: Розширення Функціоналу Системи (Принцип 2, 12)",
        "description": "Ці інтеграції додають <strong>цінність</strong> (Принцип 2) та використовують <strong>прагматичні, готові рішення</strong> (Принцип 12).",
        "firebase": {
          "title": "6.1. Firebase (Push-сповіщення)",
          "purpose": "Призначення: Миттєва доставка сповіщень про нові повідомлення, дзвінки та системні події користувачам мобільних додатків.",
          "role": "Роль: <strong>Критично важливий компонент системи сповіщень</strong> (Принцип 9) для підтримки залученості користувачів та оперативного інформування (Принцип 2).",
          "configuration": "Конфігурація: Змінна середовища: `FIREBASE_CREDENTIALS_PATH` (шлях до JSON-файлу облікових даних сервісного облікового запису Firebase). <strong>Зберігайте цей файл безпечно!</strong>",
          "example": "Використовується бібліотека `firebase-admin` у Backend NestJS. Приклад використання: Відправлення сповіщення при отриманні нового повідомлення (див. Посібник з оптимізації для батчингу та тем)."
        },
        "stripe": {
          "title": "6.2. Stripe (Платежі)",
          "purpose": "Призначення: Обробка підписок на Premium-функціонал BrainMessenger.",
          "role": "Роль: <strong>Фінансовий важіль</strong> для підтримки розвитку проєкту (Принцип 10: Створення Багатства) та надання додаткової <strong>цінності</strong> (Принцип 2) преміум-користувачам.",
          "configuration": "Конфігурація: Змінна середовища: `STRIPE_SECRET_KEY`.",
          "example": "Використовується бібліотека `stripe` у Backend NestJS. Приклад використання: Створення сесії оплати при спробі оформити підписку. Обробка вебхуків для підтвердження успішної оплати."
        },
        "gmailApi": {
          "title": "6.3. Gmail API (Відправлення Email)",
          "purpose": "Призначення: Відправлення транзакційних email, таких як коди підтвердження для реєстрації та двофакторної автентифікації (2FA), сповіщення про скидання пароля.",
          "role": "Роль: <strong>Критично важливий компонент системи автентифікації та безпеки</strong> (Принцип 9, 5).",
          "configuration": "Конфігурація: Вимагає налаштування сервісного облікового запису Google Cloud та отримання облікових даних (див. Технічну документацію, розділ 10.1). Змінні середовища для облікових даних сервісного облікового запису або API-ключів.",
          "example": "Приклад використання: Виклик API для відправлення листа з кодом підтвердження після введення email при реєстрації або ввімкненні 2FA (див. Специфікацію API, розділ 2.4)."
        }
      },
      "recommendations": {
        "title": "7. Рекомендації щодо Інтеграцій: Підтримка Здоров'я Системи (Принцип 3, 5, 9)",
        "intro": "Щоб інтеграції залишалися <strong>надійними, безпечними та ефективними</strong> (Принцип 3, 9), дотримуйтесь цих рекомендацій, пов'язаних з підтримкою \"здоров'я\" системи (Принцип 5, стосовно техніки):",
        "security": {
          "title": "Безпека:",
          "points": [
            "<strong>Ніколи не комітьте ключі та секрети в Git.</strong> Використовуйте змінні середовища та системи управління секретами в продакшен-середовищі (наприклад, Kubernetes Secrets, HashiCorp Vault).",
            "Регулярно проводьте <strong>ротацію API-токенів</strong> (R2, Firebase, Gmail, Stripe) для підвищення безпеки.",
            "Використовуйте <strong>принцип мінімальних привілеїв</strong> при створенні API-токенів: надавайте їм лише ті дозволи, які дійсно необхідні."
          ]
        },
        "scaling": {
          "title": "Масштабування:",
          "points": [
            "<strong>Моніторте використання ресурсів</strong> (місце в Neon/R2, запити до API Firebase/Stripe) через консолі відповідних сервісів. Будьте готові перейти на платний тариф при зростанні навантаження (Принцип 8, 12).",
            "Використовуйте <strong>оптимізаційні підходи</strong> (наприклад, батчинг запитів до Firebase, індексування в Neon, див. Посібник з оптимізації), щоб відкласти необхідність переходу на дорожчі тарифи."
          ]
        },
        "monitoring": {
          "title": "Моніторинг та Логування:",
          "points": [
            "Налаштуйте <strong>логування помилок інтеграцій</strong> у NestJS (Winston, Sentry).",
            "Використовуйте <strong>системи моніторингу</strong> (Prometheus/Grafana) для відстеження метрик запитів до зовнішніх сервісів (затримки, кількість помилок) — це частина <strong>Кайдзен</strong> (Принцип 9), що дозволяє виявляти проблеми на ранній стадії."
          ]
        },
        "errorHandling": {
          "title": "Обробка Помилок:",
          "points": [
            "Реалізуйте <strong>грамотну обробку помилок</strong> від зовнішніх сервісів на Backend. Логуйте їх детально.",
            "Для критично важливих операцій (наприклад, реєстрація, платежі) передбачте механізми <strong>повторних спроб (retries)</strong> або <strong>компенсуючих дій</strong> (наприклад, позначка платежу як незавершеного) при тимчасових збоях зовнішніх сервісів."
          ]
        },
        "documentation": {
          "title": "Документація:",
          "content": "Підтримуйте цю документацію в актуальному стані, відображаючи зміни у використовуваних сервісах або додаванні нових інтеграцій (Принцип 1: Навчання, Принцип 9: Система)."
        }
      }
    },
    "optimizationGuide": {
      "title": "Посібник з Оптимізації BrainMessenger (Принцип Кайдзен у Дії)",
      "subtitle": "Вступ: Оптимізація як Безперервний Процес Покращення",
      "introduction": {
        "title": "1. Вступ: Оптимізація як Безперервний Процес Покращення",
        "description": "Цей документ детально описує підходи, інструменти та техніки, які ми використовуємо для оптимізації продуктивності BrainMessenger. Оптимізація — це не одноразове завдання, а <strong>безперервний процес покращення</strong> (Принцип 1, 9: Кайдзен), який дозволяє нам забезпечити <strong>високу якість, надійність та масштабованість</strong> (Принцип 3, 8) застосунку.",
        "goalTitle": "Мета:",
        "goalContent": "Ідентифікувати та усувати вузькі місця у продуктивності на всіх рівнях системи (Frontend, Backend, База даних, Інфраструктура), щоб BrainMessenger залишався <strong>швидким, чуйним та ефективним</strong> (Принцип 2) навіть при значному навантаженні (ціль — 1 мільйон активних користувачів), підтримуючи <strong>здоров'я системи</strong> (Принцип 5, стосовно техніки).",
        "audienceTitle": "Аудиторія:",
        "audienceContent": "Backend, Frontend, Mobile, Desktop та DevOps розробники, сфокусовані на продуктивності та масштабуванні.",
        "principlesTitle": "Принципи, якими керується оптимізація:",
        "principles": [
          "<strong>Система та Оптимізація (Принцип 9: Кайдзен):</strong> Оптимізація є ключовим аспектом нашої системи розробки. Використовується циклічний підхід: Вимірювання → Аналіз → Покращення → Перевірка.",
          "<strong>Якість > Кількість (Принцип 3):</strong> Краще мати кілька критично важливих оптимізацій, ніж багато дрібних, що не дають значного ефекту.",
          "<strong>Прагматизм та Реалізм (Принцип 12):</strong> Оптимізуємо те, що дійсно впливає на продуктивність та користувацький досвід, ґрунтуючись на реальних даних, а не на здогадках.",
          "<strong>Постійне Навчання (Принцип 1):</strong> Вивчення нових технік та інструментів оптимізації, аналіз результатів та уроків.",
          "<strong>Наполегливість (Принцип 13):</strong> Оптимізація може бути складною. Потрібна наполегливість для виявлення та вирішення глибоких проблем продуктивності.",
          "<strong>Здоров'я як Фундамент (Принцип 5):</strong> Оптимізація системи (наприклад, зниження споживання пам'яті/CPU) безпосередньо впливає на \"здоров'я\" серверів та пристроїв користувачів.",
          "<strong>Зовнішня Експертиза (Принцип 14):</strong> Використання стандартних інструментів (Prometheus, Grafana, V8 Profiler), вивчення досвіду інших команд (Google, Next.js тощо)."
        ]
      },
      "generalPrinciple": {
        "title": "2. Загальний Принцип Оптимізації (Цикл Кайдзен)",
        "intro": "Наш підхід до оптимізації слідує <strong>циклу Кайдзен (Принцип 9)</strong>:",
        "step1": {
          "title": "1. Вимірювання (Measure):",
          "content": "Зберіть дані про продуктивність. Використовуйте інструменти моніторингу (Prometheus, Sentry), профілювання (V8 Profiler), аналізу бандлів (Webpack Bundle Analyzer, `@next/bundle-analyzer`)."
        },
        "step2": {
          "title": "2. Аналіз (Analyze):",
          "content": "Визначте <strong>вузькі місця (bottlenecks)</strong> на основі зібраних даних. Де система витрачає найбільше часу або ресурсів?"
        },
        "step3": {
          "title": "3. Покращення (Improve):",
          "content": "Застосуйте конкретні техніки оптимізації, описані в цьому посібнику, для усунення виявлених вузьких місць."
        },
        "step4": {
          "title": "4. Перевірка (Verify):",
          "content": "Знову виміряйте продуктивність після внесених змін. Переконайтеся, що оптимізація дала очікуваний ефект і не викликала регресій (не погіршила інші аспекти)."
        },
        "step5": {
          "title": "5. Повторення:",
          "content": "Продуктивність може змінюватися зі зростанням навантаження та функціоналу. Повторюйте цикл Кайдзен безперервно."
        }
      },
      "imageProcessing": {
        "title": "3. Оптимізація Обробки Зображень: Ефективність та Швидкість (Принцип 9, 2)",
        "intro": "Обробка зображень може бути ресурсоємною. <strong>Оптимізація цього процесу безпосередньо впливає на швидкість завантаження контенту та чуйність застосунку</strong> (Принцип 2: Цінність).",
        "libraryTitle": "Бібліотека:",
        "libraryContent": "`sharp` (на базі `libvips`). Обрано як <strong>прагматичне</strong> (Принцип 12) та <strong>високопродуктивне</strong> (Принцип 9) рішення для Node.js.",
        "applicationAreasTitle": "Області застосування:",
        "applicationAreasContent": "Зміна розміру, стиснення, конвертація формату для аватарів, зображень у чатах.",
        "keyTechniqueTitle": "Ключова техніка:",
        "keyTechniqueContent": "<strong>Асинхронна обробка</strong> у фоновому режимі через Kafka.",
        "implementationStepsTitle": "Кроки з впровадження (Backend):",
        "step1": {
          "title": "1. Встановіть `sharp`:",
          "content": "Переконайтеся, що `libvips` встановлено у вашій операційній системі або Docker-образі.",
          "code": "```bash\\nnpm install sharp\\n```"
        },
        "step2": {
          "title": "2. Створіть сервіс обробки зображень:",
          "content": "Інкапсулюйте логіку в окремому сервісі (частина <strong>системи</strong> - Принцип 9).",
          "code": "```typescript\\n// backend/src/image-processing/image-processing.service.ts\\nimport { Injectable } from '@nestjs/common';\\nimport sharp from 'sharp';\\n\\n@Injectable()\\nexport class ImageProcessingService {\\n  // Метод для зміни розміру, стиснення та конвертації в WebP\\n  async processImage(buffer: Buffer, width: number, height?: number): Promise<Buffer> {\\n    // resize({ width, height, withoutEnlargement: true }) - уникаємо збільшення, якщо оригінал менший\\n    // webp({ quality: 80 }) - стиснення у формат WebP (гарне стиснення при збереженні якості)\\n    // withMetadata({ orientation: true }) - зберігаємо орієнтацію з EXIF, решту видаляємо (економія розміру - Принцип 9)\\n    return sharp(buffer)\\n      .resize(width, height, { withoutEnlargement: true })\\n      .webp({ quality: 80 })\\n      .withMetadata({ orientation: true })\\n      .toBuffer();\\n  }\\n\\n  // Метод для простої зміни розміру\\n  async resizeImage(buffer: Buffer, width: number, height?: number): Promise<Buffer> {\\n       return sharp(buffer)\\n           .resize(width, height, { withoutEnlargement: true })\\n           .toBuffer();\\n  }\\n\\n   // Метод для конвертації в певний формат\\n   async convertToFormat(buffer: Buffer, format: keyof sharp.Format): Promise<Buffer> {\\n       return sharp(buffer).toFormat(format).toBuffer();\\n   }\\n}\\n```"
        },
        "step3": {
          "title": "3. Інтеграція із завантаженням файлів (Backend Controller/Service):",
          "content": "",
          "code": "```typescript\\n// backend/src/upload/upload.controller.ts (приклад обробки завантаження аватара)\\nimport { Controller, Post, UploadedFile, UseInterceptors, Body, Inject } from '@nestjs/common';\\nimport { FileInterceptor } from '@nestjs/platform-express';\\nimport { ImageProcessingService } from '../image-processing/image-processing.service';\\nimport { StorageService } from '../storage/storage.service';\\nimport { UserService } from '../user/user.service';\\n\\n@Controller('upload')\\nexport class UploadController {\\n  constructor(\\n    private imageProcessingService: ImageProcessingService,\\n    private storageService: StorageService,\\n    private userService: UserService,\\n    // ... ін'єкція Kafka продюсера для асинхронної обробки\\n  ) {}\\n\\n  @Post('avatar')\\n  @UseInterceptors(FileInterceptor('file')) // 'file' - ім'я поля форми\\n  async uploadAvatar(@UploadedFile() file: Express.Multer.File, @Body('userId') userId: string) {\\n    // Оптимізація: Обробка зображення перед завантаженням в R2\\n    const processedImageBuffer = await this.imageProcessingService.processImage(file.buffer, 300, 300); // Змінити розмір та стиснути\\n    const fileName = `avatars/${userId}-${Date.now()}.webp`; // Унікальне ім'я файлу в папці avatars\\n    const mimeType = 'image/webp'; // Відповідає формату WebP\\n\\n    // Завантаження обробленого файлу в Cloudflare R2\\n    const avatarUrl = await this.storageService.uploadFile(processedImageBuffer, fileName, mimeType);\\n\\n    // Оновлення посилання на аватар у профілі користувача в Neon\\n    await this.userService.updateUserAvatar(userId, avatarUrl);\\n\\n    // Повертаємо URL аватара клієнту\\n    return { avatarUrl };\\n  }\\n\\n  @Post('chat-image')\\n  @UseInterceptors(FileInterceptor('file'))\\n  async uploadChatImage(@UploadedFile() file: Express.Multer.File, @Body('chatId') chatId: string, @Body('userId') userId: string) {\\n      // Надсилання завдання на обробку зображення в Kafka для асинхронної обробки (Принцип 9)\\n      const taskPayload = { fileBuffer: file.buffer.toString('base64'), fileName: file.originalname, mimeType: file.mimetype, chatId, userId };\\n      // Передбачається, що у вас є Kafka продюсер сервіс\\n      // await this.kafkaProducerService.sendMessage('image-processing-topic', JSON.stringify(taskPayload));\\n\\n      // Негайна відповідь клієнту, що файл прийнято до обробки\\n      return { status: 'processing', originalFileName: file.originalname };\\n\\n      // АБО, якщо синхронна обробка прийнятна для невеликих файлів:\\n      /*\\n      const processedImageBuffer = await this.imageProcessingService.processImage(file.buffer, 800); // Змінити розмір\\n      const fileName = `chat-images/${chatId}-${Date.now()}.webp`;\\n      const mimeType = 'image/webp';\\n      const imageUrl = await this.storageService.uploadFile(processedImageBuffer, fileName, mimeType);\\n\\n      // Створення повідомлення типу 'image' у чаті\\n      // await this.chatService.sendImageMessage(chatId, userId, imageUrl);\\n\\n      return { imageUrl };\\n      */\\n  }\\n}\\n```"
        },
        "step4": {
          "title": "4. Асинхронність через Kafka (для важких завдань):",
          "content": "Для обробки зображень у чатах (які можуть бути великими) використовуйте <strong>Kafka</strong> (див. розділ 8) для <strong>асинхронної обробки</strong>. Backend швидко приймає файл від клієнта і ставить завдання в чергу Kafka. Окремий воркер (consumer Kafka) забирає завдання, обробляє зображення за допомогою `sharp`, завантажує в R2 і тільки після цього створює повідомлення в чаті через API. Це <strong>знижує час відповіді API</strong> (Принцип 9) та покращує користувацький досвід."
        }
      },
      "dbOptimization": {
        "title": "4. Оптимізація Бази Даних (Neon/PostgreSQL): Прискорення Доступу до Даних (Принцип 9, 8)",
        "intro": "База даних часто стає вузьким місцем. Оптимізація запитів та структури БД критично важлива для <strong>довгострокової продуктивності</strong> (Принцип 8) та <strong>ефективності системи</strong> (Принцип 9).",
        "platformTitle": "Платформа:",
        "platformContent": "Neon (керований PostgreSQL).",
        "toolTitle": "Інструмент:",
        "toolContent": "Prisma ORM.",
        "analysisToolTitle": "Інструмент аналізу:",
        "analysisToolContent": "`EXPLAIN ANALYZE` у SQL-клієнті Neon або `prisma.queryRaw` з `EXPLAIN ANALYZE`.",
        "monitoringToolTitle": "Інструмент моніторингу:",
        "monitoringToolContent": "Prometheus + `postgres_exporter` (див. розділ 14).",
        "indexing": {
          "title": "4.1. Індексація: Прискорення Пошуку та Фільтрації",
          "intro": "Індекси дозволяють базі даних швидше знаходити потрібні рядки.",
          "whenTitle": "Коли використовувати:",
          "whenContent": "На полях, які часто використовуються в `WHERE`, `JOIN`, `ORDER BY`.",
          "applicationAreasTitle": "Області застосування в BrainMessenger:",
          "applicationAreasContent": "`userId`, `chatId`, `createdAt` (у таблиці `Message`), `email` (у таблиці `User`), поля для пошуку.",
          "prismaTitle": "Реалізація (Prisma):",
          "prismaContent": "Додавайте `@index` до `schema.prisma`.",
          "prismaCode": "```prisma\\n// schema.prisma\\nmodel Message {\\n  id        String   @id @default(cuid())\\n  content   String\\n  createdAt DateTime @default(now()) @map(\\\"created_at\\\") // Приклад @map для snake_case в БД\\n  chatId    String @map(\\\"chat_id\\\")\\n  userId    String @map(\\\"user_id\\\")\\n  chat      Chat     @relation(fields: [chatId], references: [id])\\n  user      User     @relation(fields: [userId], references: [id])\\n\\n  // Комбінований індекс для швидких запитів повідомлень у чаті за часом\\n  @@index([chatId, createdAt])\\n  // Індекс для швидкого отримання повідомлень за користувачем (наприклад, для статистики)\\n  @@index([userId])\\n  // Індекс для пошуку за вмістом (якщо потрібен повнотекстовий пошук - розглянути tsearch)\\n  // @@index([content]) // Тільки для простих фільтрів LIKE\\n}\\n\\nmodel User {\\n    id    String @id @default(cuid())\\n    email String @unique // Унікальний індекс для швидкого пошуку за email (логін, реєстрація)\\n    name  String\\n    // ... інші поля\\n}\\n\\nmodel Chat {\\n   id          String @id @default(cuid())\\n   lastMessageAt DateTime? @map(\\\"last_message_at\\\") // Для сортування чатів (потрібен індекс)\\n   // ... інші поля\\n   @@index([lastMessageAt]) // Індекс для сортування списку чатів\\n}\\n```",
          "applicationTitle": "Застосування:",
          "applicationContent": "Після зміни `schema.prisma` виконайте міграцію (`npx prisma migrate dev`)."
        },
        "queryOptimization": {
          "title": "4.2. Оптимізація Запитів (Prisma): Пишемо Ефективний Код Взаємодії з БД",
          "intro": "",
          "selectFieldsTitle": "Обирайте лише потрібні поля (`select`):",
          "selectFieldsContent": "Не запитуйте `SELECT *`. Вказуйте поля, які вам дійсно потрібні. Це зменшує обсяг даних, що передаються мережею та обробляються БД.",
          "selectFieldsCode": "```typescript\\n// Погано\\nconst user = await prisma.user.findUnique({ where: { id: userId } }); // Вибере всі поля\\n\\n// Добре (якщо потрібні лише email та name)\\nconst user = await prisma.user.findUnique({\\n  where: { id: userId },\\n  select: {\\n    email: true,\\n    name: true,\\n  },\\n});\\n```",
          "nPlus1Title": "Уникайте N+1 проблем (`include`):",
          "nPlus1Content": "Якщо вам потрібні пов'язані дані (наприклад, автор повідомлення при отриманні списку повідомлень), використовуйте `include` або `select` із вкладеними полями замість виконання окремого запиту для кожного елемента.",
          "nPlus1Code": "```typescript\\n// Погано (N+1 проблема - окремий запит за кожним користувачем)\\nconst messages = await prisma.message.findMany({ where: { chatId: chatId } });\\nfor (const message of messages) {\\n  const sender = await prisma.user.findUnique({ where: { id: message.userId } });\\n  // ... використовувати sender\\n}\\n\\n// Добре (використовуємо include для отримання автора повідомлення одним запитом)\\nconst messagesWithSender = await prisma.message.findMany({\\n  where: { chatId: chatId },\\n  include: {\\n    user: { // Включаємо дані користувача, пов'язаного з повідомленням через поле 'user' в моделі Message\\n      select: { id: true, name: true, avatarUrl: true } // Вибираємо лише потрібні поля користувача\\n    },\\n  },\\n  orderBy: { createdAt: 'asc' }, // Приклад: повідомлення в хронологічному порядку\\n  take: 50, // Приклад: пагінація\\n});\\n```",
          "paginationTitle": "Пагінація (`skip`, `take`, `cursor`):",
          "paginationContent": "Для отримання великих списків (повідомлення в чаті, список чатів) використовуйте пагінацію, щоб не завантажувати всі дані одразу. `cursor`-пагінація краща для нескінченної прокрутки.",
          "paginationCode": "```typescript\\n// Приклад пагінації з take та skip\\nconst messages = await prisma.message.findMany({\\n    where: { chatId: chatId },\\n    orderBy: { createdAt: 'asc' },\\n    skip: (page - 1) * pageSize, // Пропустити N повідомлень\\n    take: pageSize, // Взяти M повідомлень\\n});\\n\\n// Приклад Cursor-based пагінації (для \\\"показати ще\\\")\\nconst messages = await prisma.message.findMany({\\n    where: { chatId: chatId },\\n    orderBy: { createdAt: 'asc' },\\n    cursor: { id: lastMessageId }, // Почати після останнього повідомлення\\n    skip: 1, // Пропустити саме останнє повідомлення\\n    take: pageSize,\\n});\\n```"
        },
        "prismaAccelerate": {
          "title": "4.3. Prisma Accelerate: Глобальний Кеш та Пул З'єднань",
          "intro": "Prisma Accelerate надає глобальну мережу серверів (Edge locations), які кешують результати запитів та керують пулом з'єднань до вашої БД Neon.",
          "whenTitle": "Коли використовувати:",
          "whenContent": "Для зниження затримки запитів (latency) для користувачів по всьому світу та оптимізації використання пулу з'єднань БД.",
          "implementationTitle": "Реалізація:",
          "implementationContent": "Налаштовується в консолі Prisma. Ваша `DATABASE_URL` замінюється на URL Prisma Accelerate."
        },
        "materializedViews": {
          "title": "4.4. Матеріалізовані Представлення: Кешування Складних Агрегацій",
          "intro": "Матеріалізовані представлення — це по суті кешовані результати складних запитів або агрегацій (наприклад, кількість повідомлень у чаті, останні активні користувачі в групі). Вони зберігаються на диску та можуть бути швидко прочитані.",
          "whenTitle": "Коли використовувати:",
          "whenContent": "Для запитів, які виконуються часто, але вимагають складних обчислень (JOINs, GROUP BY, агрегатні функції) над великими таблицями, і дані в яких не повинні бути абсолютно актуальними кожну мілісекунду.",
          "applicationAreasTitle": "Області застосування:",
          "applicationAreasContent": "Статистика чатів (загальна кількість повідомлень, учасників), списки \"топ\" користувачів (наприклад, за кількістю відправлених повідомлень).",
          "implementationTitle": "Реалізація (SQL, через Prisma `queryRaw` або SQL-клієнт Neon):",
          "implementationContent": "```sql\\n-- Створити матеріалізоване представлення для підрахунку повідомлень у кожному чаті\\nCREATE MATERIALIZED VIEW chat_message_counts AS\\nSELECT\\n    \\\"chatId\\\",\\n    COUNT(*) as \\\"messageCount\\\"\\nFROM \\\"Message\\\"\\nGROUP BY \\\"chatId\\\";\\n\\n-- Створити індекс на представленні для швидкого пошуку за chatId (необов'язково, але часто корисно)\\nCREATE INDEX idx_chat_message_counts_chat_id ON chat_message_counts (\\\"chatId\\\");\\n```",
          "updateTitle": "Оновлення:",
          "updateContent": "Матеріалізовані представлення потрібно <strong>періодично оновлювати</strong>, щоб відобразити зміни в базових таблицях. Це робиться командою `REFRESH MATERIALIZED VIEW <view_name>;`. Частота оновлення залежить від того, наскільки актуальними повинні бути дані (наприклад, раз на годину, раз на день).",
          "updateCode": "```sql\\n-- Оновити представлення (може блокувати читання під час виконання)\\nREFRESH MATERIALIZED VIEW chat_message_counts;\\n\\n-- Оновити представлення без блокування читання (для великих представлень)\\nREFRESH MATERIALIZED VIEW CONCURRENTLY chat_message_counts; -- Вимагає унікального індексу\\n```",
          "usageTitle": "Використання в Prisma:",
          "usageContent": "Запитуйте як звичайну таблицю.",
          "usageCode": "```typescript\\nconst chatStats = await prisma.chatMessageCounts.findMany({\\n  select: { chatId: true, messageCount: true },\\n  where: { chatId: 'some-chat-id' },\\n});\\n```"
        },
        "partitioning": {
          "title": "4.5. Партиціонування Таблиць: Розділення Великих Обсягів Даних",
          "intro": "Партиціонування фізично розділяє дуже великі таблиці (наприклад, `Message`) на менші частини (партиції) на основі значення в певному стовпці (наприклад, `createdAt` або `chatId`).",
          "whenTitle": "Коли використовувати:",
          "whenContent": "Коли таблиця стає настільки великою (мільярди рядків), що індекси вже не справляються, і запити починають сповільнюватися через необхідність сканувати занадто багато даних.",
          "applicationAreasTitle": "Області застосування:",
          "applicationAreasContent": "Таблиця `Message` — ідеальний кандидат для партиціонування за часом створення (`createdAt`) або за ID чату (`chatId`).",
          "implementationTitle": "Реалізація (SQL, через Prisma `queryRaw` або SQL-клієнт Neon):",
          "implementationContent": "PostgreSQL підтримує нативне партиціонування.",
          "implementationCode": "```sql\\n-- Створити головну партиціоновану таблицю за діапазоном дат\\nCREATE TABLE messages (\\n    id TEXT NOT NULL,\\n    content TEXT NOT NULL,\\n    created_at TIMESTAMP WITH TIME ZONE NOT NULL,\\n    chat_id TEXT NOT NULL,\\n    user_id TEXT NOT NULL,\\n    PRIMARY KEY (id, created_at) -- Ключ партиціонування має бути частиною первинного ключа\\n) PARTITION BY RANGE (created_at); -- Партиціонуємо за діапазоном поля created_at\\n\\n-- Створити партиції (наприклад, за місяцями)\\nCREATE TABLE messages_2025_03 PARTITION OF messages\\n    FOR VALUES FROM ('2025-03-01 00:00:00+00') TO ('2025-04-01 00:00:00+00');\\n\\nCREATE TABLE messages_2025_04 PARTITION OF messages\\n    FOR VALUES FROM ('2025-04-01 00:00:00+00') TO ('2025-05-01 00:00:00+00');\\n\\n-- ... створювати нові партиції в міру необхідності (автоматично або вручну)\\n\\n-- Створити індекси для партиціонованої таблиці (застосовуються до всіх партицій)\\nCREATE INDEX ON messages (\\\"chat_id\\\", \\\"created_at\\\");\\nCREATE INDEX ON messages (\\\"user_id\\\");\\n```",
          "advantagesTitle": "Переваги:",
          "advantagesContent": "Запити, що включають фільтр за ключем партиціонування (наприклад, `WHERE created_at BETWEEN ...`), скануватимуть лише потрібні партиції, що значно прискорює їх виконання. Управління старими даними (видалення) стає простішим (можна просто видалити старі партиції).",
          "prismaRelationTitle": "Зв'язок з Prisma:",
          "prismaRelationContent": "Prisma працює з партиціонованою таблицею як зі звичайною."
        }
      },
      "graphqlOptimization": {
        "title": "5. Оптимізація GraphQL API (NestJS + Prisma): Ефективна Передача Даних",
        "intro": "GraphQL сам по собі є інструментом <strong>оптимізації</strong> (Принцип 9) порівняно з REST (клієнт запитує лише потрібні дані). Однак і його можна оптимізувати.",
        "analysisToolTitle": "Інструмент аналізу:",
        "analysisToolContent": "`graphql-query-complexity` для захисту від складних запитів.",
        "dataloader": {
          "title": "5.1. DataLoader: Вирішення Проблеми N+1 у GraphQL",
          "intro": "DataLoader — це утиліта, яка допомагає вирішити проблему N+1 запитів при роботі з графами даних. Якщо у вас є список об'єктів, і для кожного об'єкта потрібно підтягнути пов'язаний з ним об'єкт (наприклад, список повідомлень і для кожного повідомлення його автора), DataLoader збере всі ID пов'язаних об'єктів і зробить один пакетний запит до БД.",
          "whenTitle": "Коли використовувати:",
          "whenContent": "У резолверах GraphQL, коли вам потрібно отримати пов'язані об'єкти для списку батьківських об'єктів.",
          "applicationAreasTitle": "Області застосування:",
          "applicationAreasContent": "Отримання даних автора для кожного повідомлення в чаті, отримання списку учасників для кожного чату у списку чатів користувача.",
          "implementationTitle": "Реалізація:",
          "implementationContent": "Створіть окремі DataLoader для кожного типу об'єкта, який потрібно підтягувати. Інтегруйте їх у контекст GraphQL запиту.",
          "implementationCode": "```typescript\\n// backend/src/graphql/loaders/user.loader.ts\\nimport { Injectable, Scope } from '@nestjs/common';\\nimport DataLoader from 'dataloader';\\nimport { PrismaService } from 'nestjs-prisma';\\nimport { User } from '@prisma/client'; // Імпорт моделі Prisma\\n\\n// Scope.REQUEST - важливо, щоб DataLoader був унікальним для кожного запиту GraphQL\\n@Injectable({ scope: Scope.REQUEST })\\nexport class UserLoader {\\n  private loader: DataLoader<string, User>;\\n\\n  constructor(private prisma: PrismaService) {\\n    // Створюємо новий DataLoader. Функція batchLoadFn приймає масив ключів (user IDs)\\n    this.loader = new DataLoader<string, User>(\\n      async (ids: readonly string[]) => {\\n        // Виконуємо ОДИН запит до БД, щоб отримати ВСІх користувачів за їх ID\\n        const users = await this.prisma.user.findMany({\\n          where: {\\n            id: { in: Array.from(ids) }, // Array.from(ids) для сумісності з Prisma\\n          },\\n        });\\n\\n        // Важливо: Повернути масив результатів, упорядкований за вихідним масивом ids\\n        const userMap = new Map(users.map(user => [user.id, user]));\\n        return ids.map(id => userMap.get(id)); // Повертаємо користувачів у тому ж порядку, що й запитали\\n      },\\n      { cache: true } // Включаємо кешування всередині запиту GraphQL\\n    );\\n  }\\n\\n  // Метод для завантаження одного користувача за ID\\n  load(id: string): Promise<User> {\\n    return this.loader.load(id);\\n  }\\n\\n  // Метод для завантаження списку користувачів за ID\\n  loadMany(ids: string[]): Promise<(Error | User)[]> {\\n      return this.loader.loadMany(ids);\\n  }\\n}\\n```\\nІнтегруйте лоадери в контекст GraphQL (`backend/src/graphql/graphql.module.ts` або `app.module.ts`):\\n```typescript\\n// backend/src/graphql/graphql.module.ts\\nimport { Module } from '@nestjs/common';\\nimport { GraphQLModule } from '@nestjs/graphql';\\nimport { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';\\nimport { UserLoader } from './loaders/user.loader'; // Імпорт лоадера\\n// ... інші імпорти резолверів та модулів\\n\\n@Module({\\n  imports: [\\n    GraphQLModule.forRoot<ApolloDriverConfig>({\\n      driver: ApolloDriver,\\n      // ... інші налаштування GraphQL (schema path, context, etc.)\\n      context: ({ req, connection }) => {\\n        // Створюємо контекст для кожного запиту\\n        const context = { req }; // Додаємо об'єкт запиту\\n         if (connection) {\\n           // Для WebSocket (підписки)\\n           // context.loaders = new Loaders(); // Якщо лоадери створюються тут\\n         } else {\\n           // Для HTTP запитів (queries/mutations)\\n           // Створюємо лоадери та додаємо їх у контекст\\n           context.loaders = {\\n              userLoader: new UserLoader(/* залежності */), // Потрібно інжектувати PrismaService\\n              // ... інші лоадери\\n           };\\n           // Приклад ін'єкції залежностей в лоадер (може вимагати FactoryProvider)\\n           // context.loaders = {\\n           //     userLoader: req.loaders.userLoader, // Якщо використовуєте Request-scoped провайдери NestJS\\n           // };\\n         }\\n        return context;\\n      },\\n      // plugins: [complexityPlugin], // Плагін для аналізу складності запитів\\n    }),\\n    // ... імпорт інших модулів\\n  ],\\n   providers: [UserLoader], // Додаємо лоадер як провайдер (для Request scope)\\n})\\nexport class GraphqlModule {}\\n```",
          "usageTitle": "Використовуйте лоадери в резолверах:",
          "usageContent": "",
          "usageCode": "```typescript\\n// backend/src/message/message.resolver.ts\\nimport { Resolver, ResolveField, Parent, Context } from '@nestjs/graphql';\\nimport { Message } from '@prisma/client'; // Імпорт моделі Prisma\\nimport { UserLoader } from '../graphql/loaders/user.loader'; // Імпорт лоадера\\n\\n@Resolver('Message') // Вказуємо GraphQL тип, до якого відноситься резолвер\\nexport class MessageResolver {\\n  @ResolveField('user') // Визначаємо резолвер для поля 'user' у типі Message\\n  async resolveUser(@Parent() message: Message, @Context() context: any) {\\n    // Використовуємо userLoader з контексту для завантаження користувача за message.userId\\n    // DataLoader автоматично збере всі message.userId в поточному запиті та завантажить їх пакетом\\n    return context.loaders.userLoader.load(message.userId);\\n  }\\n}\\n```"
        },
        "queryComplexityAnalysis": {
          "title": "5.2. Аналіз Складності Запитів: Захист від \"Важких\" Запитів",
          "intro": "GraphQL дозволяє клієнту запитувати дані довільної вкладеності, що може призвести до дуже \"важких\" запитів, що сильно навантажують сервер та БД.",
          "toolTitle": "Інструмент:",
          "toolContent": "`graphql-query-complexity`.",
          "whenTitle": "Коли використовувати:",
          "whenContent": "Завжди включайте захист від складності в продакшені.",
          "principleTitle": "Принцип роботи:",
          "principleContent": "Плагін аналізує запит до його виконання та обчислює його \"складність\" (наприклад, як суму \"вартості\" кожного поля). Якщо складність перевищує заданий поріг, запит відхиляється.",
          "implementationTitle": "Реалізація:",
          "implementationContent": "Налаштуйте плагін у NestJS GraphQLModule (див. Посібник з розробки)."
        },
        "persistedQueries": {
          "title": "5.3. Persisted Queries: Кешування Запитів на Рівні Мережі",
          "intro": "Persisted Queries дозволяють клієнту надсилати на сервер не повний текст GraphQL запиту, а лише його хеш. Сервер за цим хешем знаходить повний запит (якщо він йому знайомий) і виконує його.",
          "whyTitle": "Чому:",
          "whyContent": "Зменшує обсяг даних, що передаються мережею, що прискорює запити, особливо на мобільних пристроях. Покращує ефективність кешування на CDN.",
          "whenTitle": "Коли використовувати:",
          "whenContent": "Для часто повторюваних запитів від клієнта.",
          "implementationTitle": "Реалізація:",
          "implementationContent": "Вимагає підтримки як на стороні клієнта (Apollo Client підтримує), так і на стороні сервера (Apollo Server підтримує). На сервері потрібно зберігати відповідність хешів та запитів (наприклад, у Redis)."
        }
      },
      "backendLogicOptimization": {
        "title": "6. Оптимізація Backend Логіки (NestJS): Ефективність Коду",
        "intro": "",
        "toolsTitle": "Інструменти:",
        "toolsContent": "Профілювання Node.js (V8 Profiler), виявлення витоків пам'яті (`heapdump`).",
        "whenTitle": "Коли використовувати:",
        "whenContent": "Для виявлення \"гарячих\" ділянок коду, що споживають багато CPU або пам'яті, та діагностики проблем з пам'яттю.",
        "processTitle": "Процес:",
        "processContent": "Використовуйте інструменти профілювання для <strong>вимірювання</strong> (Крок 1 Кайдзен). Аналізуйте результати (Крок 2). Вносьте зміни в код (Крок 3). Повторіть (Крок 4).",
        "recommendationsTitle": "Рекомендації:",
        "recommendationsContent": "Уникайте синхронних операцій, що блокують основний потік Node.js. Використовуйте асинхронні API. Оптимізуйте цикли, роботу з великими масивами/об'єктами."
      },
      "caching": {
        "title": "7. Кешування (Redis): Зниження Навантаження на БД та Прискорення (Принцип 9)",
        "intro": "Кешування дозволяє зберігати часто запитувані дані у швидкій пам'яті (Redis), щоб не звертатися до повільнішої БД (Neon) при кожному запиті. Це ключовий <strong>важіль</strong> для підвищення <strong>ефективності системи</strong> (Принцип 9).",
        "libraryTitle": "Бібліотека:",
        "libraryContent": "`ioredis`, `@nestjs/cache-manager`, `cache-manager-redis-store`.",
        "patternTitle": "Патерн:",
        "patternContent": "Cache-Aside (читання з кешу, якщо немає — читання з БД та запис у кеш).",
        "applicationAreasTitle": "Області застосування:",
        "applicationAreasContent": "Часто запитувані, відносно рідко змінювані дані (профілі користувачів, налаштування застосунку, результати складних запитів/агрегацій, матеріалізованих представлень).",
        "implementationTitle": "Реалізація:",
        "implementationContent": "Налаштуйте Redis у NestJS та використовуйте його в сервісах.",
        "invalidationTitle": "Ключовий аспект:",
        "invalidationContent": "<strong>Інвалідація кешу</strong>. При зміні даних у БД видаляйте відповідні ключі з Redis, щоб клієнти не отримували застарілі дані."
      },
      "asyncProcessing": {
        "title": "8. Асинхронна Обробка (Kafka): Надійність та Чуйність (Принцип 9, 2)",
        "intro": "Використовуйте <strong>Kafka</strong> для виконання завдань, які не вимагають негайної відповіді користувачеві (відправлення email, обробка зображень, нотифікації, аналітика).",
        "libraryTitle": "Бібліотека:",
        "libraryContent": "`kafkajs`.",
        "whyTitle": "Чому:",
        "whyContent": "Kafka — <strong>надійна розподілена система черг</strong>, що гарантує доставку повідомлень і дозволяє масштабувати обробку завдань незалежно від основного API (воркери-консюмери).",
        "applicationAreasTitle": "Області застосування:",
        "applicationAreasContent": [
          "Обробка зображень/відео після завантаження.",
          "Відправлення великих обсягів push-сповіщень.",
          "Генерація звітів або статистики.",
          "Архівування старих повідомлень/файлів."
        ],
        "patternTitle": "Патерн:",
        "patternContent": "<strong>Producer-Consumer</strong>. Backend-API ставить завдання в топік Kafka (Producer). Окремі сервіси/воркери (Consumer) читають завдання з топіка та виконують їх у фоновому режимі.",
        "partitioningTitle": "Партиціонування в Kafka:",
        "partitioningContent": "Використовуйте ключі повідомлень (наприклад, `userId`, `chatId`), щоб повідомлення, що стосуються одного користувача/чату, потрапляли в одну партицію. Це гарантує порядок обробки всередині партиції, що може бути важливим для деяких завдань.",
        "monitoringTitle": "Моніторинг:",
        "monitoringContent": "Використовуйте <strong>Kafdrop</strong> для візуального моніторингу топіків, повідомлень та стану консюмер-груп."
      },
      "pushNotificationsOptimization": {
        "title": "9. Оптимізація Push-сповіщень (Firebase FCM): Ефективна Доставка Інформації (Принцип 2)",
        "intro": "Push-сповіщення — важливий канал зв'язку з користувачем (Принцип 2: Цінність). Оптимізація їх доставки важлива для користувацького досвіду.",
        "platformTitle": "Платформа:",
        "platformContent": "Firebase Cloud Messaging (FCM).",
        "techniquesTitle": "Техніки:",
        "techniquesContent": [
          "<strong>Батчінг:</strong> Надсилайте кілька сповіщень одним викликом API FCM (`sendMulticast`) для зниження мережевих накладних витрат.",
          "<strong>Теми (Topics):</strong> Використовуйте теми для масових розсилок (наприклад, сповіщення про нове повідомлення в каналі), щоб FCM керував списком підписників.",
          "<strong>Data Messages:</strong> Використовуйте Data Messages для повного контролю над відображенням сповіщення на клієнті та можливості прикріплювати кастомні дані."
        ]
      },
      "clientApiDbInteraction": {
        "title": "10. Оптимізація Взаємодії Клієнт-API-БД: Скорочення Шляху Даних (Принцип 9)",
        "intro": "",
        "clientLevelTitle": "На Рівні Клієнта:",
        "clientLevelContent": "Використовуйте бібліотеки для управління станом та кешування даних, отриманих мережею (`@apollo/client`, `react-query`/`@tanstack/react-query`). Це дозволяє уникнути повторних запитів за одними й тими ж даними та швидко показувати кешовані дані.",
        "networkLevelTitle": "На Рівні Мережі:",
        "networkLevelContent": "Увімкніть сучасні протоколи (HTTP/2, HTTP/3) та стиснення (Gzip/Brotli) на вашому API Gateway або Backend сервері для зменшення обсягу переданих даних та зниження затримки.",
        "backendLevelTitle": "На Рівні Backend:",
        "backendLevelContent": "Оптимізуйте взаємодію з БД (розділ 4) та зовнішніми сервісами (розділ 7)."
      },
      "authenticationOptimization": {
        "title": "11. Оптимізація Автентифікації: Швидкість та Безпека",
        "intro": "",
        "statelessJwtTitle": "Stateless (JWT):",
        "statelessJwtContent": "Використання JWT знижує навантаження на сервер, оскільки йому не потрібно зберігати стан сесій користувачів.",
        "rateLimitingTitle": "Rate Limiting (`@nestjs/throttler`):",
        "rateLimitingContent": "Захист ендпоінтів автентифікації від Brute Force атак, що також знижує навантаження.",
        "secureHeadersTitle": "Безпечні Заголовки (`helmet`):",
        "secureHeadersContent": "Додавання HTTP-заголовків для захисту від XSS, CSRF та інших атак."
      },
      "chatWebSocketOptimization": {
        "title": "12. Оптимізація Чатів (WebSocket): Низька Затримка та Масштабування",
        "intro": "WebSocket використовується для обміну повідомленнями в реальному часі. <strong>Оптимізація WebSocket-з'єднань критична для чуйності чатів</strong> (Принцип 2).",
        "libraryTitle": "Бібліотека:",
        "libraryContent": "NestJS Gateways (`@nestjs/websockets`), Socket.IO (якщо потрібна крос-браузерна сумісність та fallback).",
        "techniquesTitle": "Техніки:",
        "techniquesContent": [
          "<strong>Бінарні Формати:</strong> Передача повідомлень у бінарному форматі (наприклад, MessagePack) замість текстового JSON може зменшити обсяг даних.",
          "<strong>Батчінг Повідомлень:</strong> Буферизуйте повідомлення на клієнті та сервері та надсилайте їх пачками (наприклад, кожні 50 мс), а не по одному. Знижує кількість пакетів.",
          "<strong>Управління Присутністю:</strong> Використовуйте Redis для швидкого відстеження статусу онлайн/офлайн користувачів. Heartbeats (пінг-понг) для підтримки з'єднання та виявлення відключень.",
          "<strong>Вертикальне/Горизонтальне Масштабування:</strong> NestJS Gateways можуть працювати в кластерному режимі. Використовуйте Redis або інший Pub/Sub механізм (наприклад, Kafka) для обміну повідомленнями між інстансами Backend, щоб повідомлення доставлялися всім підписникам, незалежно від того, до якого інстансу Backend вони підключені."
        ]
      },
      "animationsOptimization": {
        "title": "13. Оптимізація Анімацій: Плавність та Продуктивність (Принцип 3, 5)",
        "intro": "Продуктивні анімації роблять інтерфейс <strong>якісним</strong> (Принцип 3) та знижують навантаження на пристрій (Принцип 5: Здоров'я).",
        "mobileDesktopTitle": "Mobile-Desktop (React Native):",
        "mobileDesktopContent": "Використовуйте `react-native-reanimated` для анімацій, які виконуються на нативному потоці, не блокуючи потік JavaScript.",
        "webTitle": "Web (Next.js):",
        "webContent": "Використовуйте `framer-motion` для декларативного створення плавних анімацій.",
        "docDesignTitle": "DocDesign:",
        "docDesignContent": "У DocDesign описані принципи та параметри анімацій, включаючи можливість їх відключення користувачем (Принцип 12: Прагматизм)."
      },
      "monitoring": {
        "title": "14. Моніторинг з Prometheus та Grafana: Вимірювання як Основа Кайдзен (Принцип 9)",
        "intro": "Система моніторингу — це ваші <strong>очі</strong> та <strong>вимірювальні інструменти</strong> (Крок 1 Кайдзен).",
        "toolsTitle": "Інструменти:",
        "toolsContent": "Prometheus (збір метрик), Grafana (візуалізація), Alertmanager (сповіщення про аномалії).",
        "whenTitle": "Коли використовувати:",
        "whenContent": "Завжди. Налаштуйте моніторинг на всіх рівнях: Backend (затримки API, помилки), БД (час запитів, навантаження), Redis (попадання в кеш, використання пам'яті), Kafka (кількість повідомлень у топіках, лаг консюмерів), Інфраструктура (CPU, RAM, мережа).",
        "implementationTitle": "Реалізація:",
        "implementationContent": "Див. докладні кроки з налаштування в Посібнику з розробки (розділ 14).",
        "principleTitle": "Принцип:",
        "principleContent": "Використовуйте метрики для <strong>виявлення вузьких місць</strong> (Крок 2 Кайдзен) та оцінки <strong>ефективності</strong> (Принцип 9) ваших оптимізацій. Налаштуйте <strong>алерти</strong> для проактивного виявлення проблем."
      },
      "ciCdOptimization": {
        "title": "15. Оптимізація CI/CD: Прискорення Циклу Розробки (Принцип 9)",
        "intro": "Ефективний CI/CD пайплайн прискорює доставку коду, що є частиною <strong>оптимізації всього процесу розробки</strong> (Принцип 9).",
        "toolsTitle": "Інструменти:",
        "toolsContent": "Turborepo (кешування, паралелізація), GitHub Actions (автоматизація).",
        "techniquesTitle": "Техніки:",
        "techniquesContent": [
          "<strong>Кешування з Turborepo:</strong> Кешуйте результати збірки та тестів між запусками в CI та локально.",
          "<strong>Паралельне виконання:</strong> Запускайте завдання (lint, build, test) для різних пакетів або частин тестів паралельно.",
          "<strong>Оптимізація Docker-образів:</strong> Використовуйте багатоступеневу збірку та `.dockerignore` для зменшення розміру образів та прискорення збірки/деплою."
        ]
      },
      "frontendOptimization": {
        "title": "16. Оптимізація Фронтенду: Швидкість та Чуйність для Користувача (Принцип 2, 3)",
        "intro": "Фронтенд має бути <strong>швидким та чуйним</strong>, щоб користувач відчув <strong>цінність</strong> (Принцип 2) продукту.",
        "webTechniquesTitle": "Техніки (Web - Next.js):",
        "webTechniquesContent": [
          "<strong>Code Splitting / Dynamic Imports:</strong> Завантажуйте код лише тоді, коли він потрібен (`next/dynamic`).",
          "<strong>SSR/SSG:</strong> Використовуйте серверний рендеринг або генерацію статики для прискорення першого відтворення та SEO (`getStaticProps`, `getServerSideProps`).",
          "<strong>Оптимізація Зображень:</strong> Використовуйте `next/image` або `<picture>` та сучасні формати (WebP).",
          "<strong>Аналіз Бандла:</strong> Використовуйте `@next/bundle-analyzer` для виявлення найважчих модулів."
        ],
        "reactNativeTechniquesTitle": "Техніки (React Native):",
        "reactNativeTechniquesContent": [
          "<strong>Лениве Завантаження:</strong> Використовуйте `React.lazy` та `Suspense` для екранів та компонентів, які не потрібні під час старту.",
          "<strong>Продуктивні Списки:</strong> Використовуйте `FlatList` або `SectionList` з правильним налаштуванням (`getItemLayout`, `windowSize`) для великих списків повідомлень або чатів.",
          "<strong>Оптимізація Зображень:</strong> Використовуйте `react-native-fast-image`.",
          "<strong>Профілювання:</strong> Використовуйте Performance Monitor у Debugger Menu React Native для виявлення вузьких місць UI."
        ],
        "generalTechniquesTitle": "Загальні техніки:",
        "generalTechniquesContent": [
          "Видалення невикористовуваного коду (Tree Shaking), заміна важких бібліотек на легкі аналоги (наприклад, `dayjs` замість `moment`), стиснення бандлів (Gzip/Brotli)."
        ]
      },
      "dbScaling": {
        "title": "17. Масштабування Бази Даних (Реплікація та Шардинг): Підготовка до Зростання (Принцип 8)",
        "intro": "Ці техніки стають актуальними при значному зростанні обсягу даних та навантаження. Вони є частиною <strong>довгострокової стратегії масштабування</strong> (Принцип 8).",
        "replicationTitle": "Реплікація (Master-Slave):",
        "replicationContent": "Створення копій БД тільки для читання (read replicas). Дозволяє розподілити навантаження на читання.",
        "shardingTitle": "Шардинг:",
        "shardingContent": "Розділення даних великої таблиці на частини (шарди) за певним ключем (`chatId`, `userId`), розподіляючи їх по різних серверах. Дозволяє масштабувати як читання, так і запис. Реалізується логічно (у застосунку) або за допомогою розширень (Citus для PostgreSQL).",
        "whenToApplyTitle": "Коли застосовувати:",
        "whenToApplyContent": "Ґрунтуючись на <strong>вимірюваннях</strong> навантаження та продуктивності БД (Принцип 9), а не заздалегідь."
      },
      "notes": {
        "title": "18. Примітки: Безперервний Кайдзен в Оптимізації",
        "prioritizationTitle": "Пріоритезація:",
        "prioritizationContent": "Починайте оптимізацію з тих місць, які приносять найбільший ефект на поточному етапі проєкту (Принцип 12). Для MVP це може бути швидкість завантаження Frontend, продуктивність основних API-запитів.",
        "automationTitle": "Автоматизація:",
        "automationContent": "Максимально автоматизуйте процеси вимірювання та перевірки оптимізацій (CI/CD, алерти в моніторингу) — це частина <strong>Системи</strong> (Принцип 9).",
        "documentationNotesTitle": "Документування:",
        "documentationNotesContent": "Фіксуйте проведені оптимізації, їх ефект та уроки в цій документації або в завданнях/коммітах (Принцип 1: Навчання, Принцип 9: Кайдзен).",
        "cultureTitle": "Культура:",
        "cultureContent": "Створіть культуру, де кожен розробник несе відповідальність за продуктивність свого коду та активно бере участь у пошуку та усуненні вузьких місць (Принцип 6)."
      }
    },
    "apiSpec": {
      "title": "Специфікація API BrainMessenger (Інтерфейс Системи)",
      "subtitle": "Інтерфейс Системи",
      "generalInfo": {
        "title": "1. Загальна Інформація: API як Точка Взаємодії з Системою",
        "description": "Цей документ описує GraphQL API BrainMessenger — <strong>основний інтерфейс</strong> (Принцип 9), через який клієнтські застосунки (Web, Mobile, Desktop) взаємодіють із сервером системи та отримують доступ до даних і функціональності. GraphQL обрано за його <strong>ефективність та гнучкість</strong> (Принцип 9, 2), що дозволяє клієнтам запитувати лише ті дані, які їм необхідні.",
        "projectNameTitle": "Назва проєкту:",
        "projectNameContent": "BrainMessenger",
        "apiPurposeTitle": "Мета:",
        "apiPurposeContent": "Надати чіткий і повний опис доступних запитів (Queries) та мутацій (Mutations), їх вхідних і вихідних даних, а також правил автентифікації та форматів помилок. Це забезпечує <strong>системність</strong> (Принцип 9) взаємодії між Frontend та Backend та підвищує <strong>якість</strong> (Принцип 3) розробки.",
        "baseUrlTitle": "Базовий URL:",
        "baseUrlContent": "`https://api.brainmessenger.com/graphql` (адреса API Gateway, який перенаправляє запити на Backend Service).",
        "requestFormatTitle": "Формат запитів:",
        "requestFormatContent": "GraphQL-запити (POST-запити з `Content-Type: application/json` та тілом у форматі GraphQL).",
        "authenticationTitle": "Автентифікація:",
        "authenticationContent": "Для більшості методів потрібно передати JWT-токен у заголовку `Authorization: Bearer <token>`. Токен отримується після успішного входу. Це частина нашої <strong>системи безпеки</strong> (Принцип 3, 5).",
        "relatedDocsTitle": "Зв'язок з іншими документами:",
        "relatedDocsContent": [
          "DocTech.md: Загальна архітектура системи, включаючи Backend та API Gateway.",
          "DocDevIn.md: Деталі реалізації Backend на NestJS та GraphQL.",
          "DocInt.md: Опис інтеграцій, які Backend використовує (Neon, R2, Firebase та ін.).",
          "DocOptimizationIn.md: Підходи до оптимізації продуктивності API."
        ]
      },
      "graphqlSchema": {
        "title": "2. Схема GraphQL: Структура Доступних Даних та Операцій",
        "description": "Повна схема GraphQL доступна за адресою API через інструменти інтроспекції (наприклад, GraphQL Playground, Apollo Studio). Нижче наведено основні типи та операції.",
        "dataTypes": {
          "title": "2.1. Типи Даних (Schemas): Опис Структури Інформації",
          "user": {
            "title": "User:",
            "code": "type User {\n  id: ID!\n  email: String!\n  name: String!\n  avatarUrl: String # URL аватара користувача (зберігається в R2)\n  createdAt: DateTime!\n  updatedAt: DateTime!\n  # ... інші поля (наприклад, статус онлайн/офлайн)\n}"
          },
          "chat": {
            "title": "Chat:",
            "code": "type Chat {\n  id: ID!\n  name: String! # Назва чату (для груп/каналів)\n  type: String! # Тип чату (\"personal\", \"group\", \"channel\")\n  users: [User!] # Список учасників чату\n  messages(pagination: PaginationInput): [Message!] # Повідомлення в чаті (з пагінацією)\n  lastMessageAt: DateTime # Час останнього повідомлення (для сортування списку чатів)\n  createdAt: DateTime!\n  updatedAt: DateTime!\n  # ... інші поля (наприклад, фото групи/каналу, опис)\n}"
          },
          "message": {
            "title": "Message:",
            "code": "type Message {\n  id: ID!\n  content: String! # Текст повідомлення (для текстових повідомлень)\n  fileUrl: String # URL файлу, якщо повідомлення є файлом (зберігається в R2)\n  fileMetadata: JSON # Метадані файлу (тип, розмір, ім'я) (зберігається в Neon/R2)\n  sender: User! # Відправник повідомлення\n  chat: Chat! # Чат, якому належить повідомлення\n  createdAt: DateTime! # Час відправлення повідомлення\n  updatedAt: DateTime!\n  # ... інші поля (наприклад, статус прочитання, реакції)\n}"
          },
          "paginationInput": {
            "title": "PaginationInput:",
            "code": "input PaginationInput {\n  take: Int # Максимальна кількість елементів\n  skip: Int # Пропустити елементів (для offset-based пагінації)\n  cursor: String # Курсор (ID) для cursor-based пагінації\n}"
          },
          "authPayload": {
            "title": "AuthPayload:",
            "code": "type AuthPayload {\n  token: String! # JWT токен доступу\n  user: User! # Дані автентифікованого користувача\n}"
          },
          "dateTimeJson": {
            "title": "DateTime, JSON:",
            "content": "Стандартні скалярні типи або кастомні скаляри, визначені на Backend."
          }
        },
        "operations": {
          "title": "2.2. Операції (Queries та Mutations): Доступ до Функціоналу Системи",
          "authentication": {
            "title": "2.2.1. Автентифікація (Authentication)",
            "registerUser": {
              "title": "`mutation registerUser(input: RegisterInput!): AuthPayload!`",
              "description": "Реєструє нового користувача в системі.",
              "input": "`RegisterInput`: `{ email: String!, password: String!, name: String! }` (password min 8 chars, digit, special char - див. валідацію).",
              "authRequired": "Потрібна автентифікація: Ні.",
              "scenario": "Сценарій: Користувач заповнює форму реєстрації.",
              "errors": "Помилки: `400 Bad Request` (невірний формат даних/валідація), `409 Conflict` (email вже використовується)."
            },
            "loginUser": {
              "title": "`mutation loginUser(input: LoginInput!): AuthPayload!`",
              "description": "Автентифікує користувача за email та паролем.",
              "input": "`LoginInput`: `{ email: String!, password: String! }`.",
              "authRequired": "Потрібна автентифікація: Ні.",
              "scenario": "Сценарій: Користувач вводить облікові дані для входу.",
              "errors": "Помилки: `401 Unauthorized` (невірний email або пароль)."
            },
            "logoutUser": {
              "title": "`mutation logoutUser: Boolean!`",
              "description": "Інактивація поточного JWT токена на сервері (якщо реалізовано зберігання токенів або їх чорних списків).",
              "authRequired": "Потрібна автентифікація: Так (використовується поточний токен).",
              "scenario": "Сценарій: Користувач натискає \"Вийти\".",
              "returns": "Повертає: `true` при успішному виході.",
              "errors": "Помилки: `401 Unauthorized` (токен недійсний)."
            }
          },
          "user": {
            "title": "2.2.2. Користувач (User)",
            "getUser": {
              "title": "`query getUser(id: ID!): User`",
              "description": "Отримує дані користувача за його унікальним ID.",
              "authRequired": "Потрібна автентифікація: Так (для доступу до будь-яких даних користувача, окрім, можливо, публічного профілю).",
              "scenario": "Сценарій: Перегляд профілю користувача.",
              "errors": "Помилки: `404 Not Found` (користувач з таким ID не знайдений)."
            },
            "getCurrentUser": {
              "title": "`query getCurrentUser: User!`",
              "description": "Отримує дані поточного автентифікованого користувача.",
              "authRequired": "Потрібна автентифікація: Так.",
              "scenario": "Сценарій: Завантаження профілю поточного користувача при запуску застосунку.",
              "errors": "Помилки: `401 Unauthorized`."
            },
            "updateUser": {
              "title": "`mutation updateUser(id: ID!, input: UserInput!): User!`",
              "description": "Оновлює дані профілю користувача.",
              "input": "`UserInput`: `{ name: String, email: String, password: String, avatarUrl: String }`. Поля опціональні.",
              "authRequired": "Потрібна автентифікація: Так (і користувач має бути власником профілю або мати права адміністратора).",
              "scenario": "Сценарій: Користувач редагує свій профіль.",
              "errors": "Помилки: `400 Bad Request` (невірний формат даних), `401 Unauthorized`, `403 Forbidden` (немає прав на редагування цього користувача), `404 Not Found`."
            },
            "deleteUser": {
              "title": "`mutation deleteUser(id: ID!): Boolean!`",
              "description": "Видаляє обліковий запис користувача.",
              "authRequired": "Потрібна автентифікація: Так (і користувач має бути власником облікового запису).",
              "scenario": "Сценарій: Користувач вирішує видалити свій обліковий запис.",
              "returns": "Повертає: `true` при успішному видаленні.",
              "errors": "Помилки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            }
          },
          "chats": {
            "title": "2.2.3. Чати (Chats)",
            "getChats": {
              "title": "`query getChats: [Chat!]!`",
              "description": "Отримує список усіх чатів, в яких бере участь поточний користувач.",
              "authRequired": "Потрібна автентифікація: Так.",
              "scenario": "Сценарій: Завантаження списку чатів на головному екрані.",
              "errors": "Помилки: `401 Unauthorized`."
            },
            "getChat": {
              "title": "`query getChat(id: ID!): Chat`",
              "description": "Отримує дані конкретного чату за ID.",
              "authRequired": "Потрібна автентифікація: Так (і користувач має бути учасником цього чату).",
              "scenario": "Сценарій: Відкриття конкретного чату.",
              "errors": "Помилки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            },
            "createChat": {
              "title": "`mutation createChat(input: CreateChatInput!): Chat!`",
              "description": "Створює новий чат.",
              "input": "`CreateChatInput`: `{ type: String!, name: String, userIds: [ID!]! }`. `type` може бути \"personal\", \"group\", \"channel\". `name` обов'язковий для \"group\" та \"channel\". `userIds` включає ID творця та інших учасників (для \"personal\" та \"group\").",
              "authRequired": "Потрібна автентифікація: Так.",
              "scenario": "Сценарій: Користувач створює новий чат або групу.",
              "errors": "Помилки: `400 Bad Request` (невірний тип, відсутні userIds тощо), `401 Unauthorized`, `403 Forbidden` (немає прав на створення такого типу чату)."
            },
            "getMessages": {
              "title": "`query getMessages(chatId: ID!, pagination: PaginationInput): [Message!]!`",
              "description": "Отримує список повідомлень для заданого чату. Підтримує пагінацію.",
              "authRequired": "Потрібна автентифікація: Так (і користувач має бути учасником чату).",
              "scenario": "Сценарій: Відкриття чату, підвантаження старих повідомлень при прокрутці.",
              "errors": "Помилки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            },
            "sendMessage": {
              "title": "`mutation sendMessage(chatId: ID!, content: String!, fileUrl: String, fileMetadata: JSON): Message!`",
              "description": "Відправляє нове повідомлення в чат. Може містити текст або посилання на файл.",
              "input": "`chatId`: ID чату. `content`: Текст повідомлення. `fileUrl`: URL файлу в R2 (опціонально). `fileMetadata`: Метадані файлу (опціонально).",
              "authRequired": "Потрібна автентифікація: Так (і користувач має бути учасником чату).",
              "scenario": "Сценарій: Користувач відправляє текстове повідомлення або файл.",
              "errors": "Помилки: `400 Bad Request`, `401 Unauthorized`, `403 Forbidden` (немає прав писати в цей чат), `404 Not Found` (чат не знайдений)."
            },
            "deleteMessage": {
              "title": "`mutation deleteMessage(messageId: ID!): Boolean!`",
              "description": "Видаляє повідомлення.",
              "authRequired": "Потрібна автентифікація: Так (і користувач має бути відправником повідомлення або мати права адміністратора чату).",
              "scenario": "Сценарій: Користувач видаляє своє повідомлення.",
              "returns": "Повертає: `true` при успішному видаленні.",
              "errors": "Помилки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            }
          },
          "externalIntegrations": {
            "title": "2.2.4. Зовнішні Інтеграції (через API Backend)",
            "sendVerificationCode": {
              "title": "`mutation sendVerificationCode(email: String!): Boolean!`",
              "description": "Запускає процес відправлення коду підтвердження на вказаний email (використовуючи Gmail API). Використовується при реєстрації або скиданні пароля.",
              "authRequired": "Потрібна автентифікація: Ні.",
              "scenario": "Сценарій: Користувач вводить email на екрані реєстрації/відновлення пароля.",
              "returns": "Повертає: `true` при успішній постановці задачі на відправлення.",
              "errors": "Помилки: `400 Bad Request` (невірний формат email), `429 Too Many Requests` (захист від спаму)."
            },
            "verifyEmailCode": {
              "title": "`mutation verifyEmailCode(email: String!, code: String!): Boolean!`",
              "description": "Перевіряє код підтвердження, отриманий по email.",
              "authRequired": "Потрібна автентифікація: Ні.",
              "scenario": "Сценарій: Користувач вводить код з email.",
              "returns": "Повертає: `true` при успішній перевірці.",
              "errors": "Помилки: `400 Bad Request` (невірний код або email), `404 Not Found` (для даного email немає активного коду)."
            },
            "enableTwoFactorAuth": {
              "title": "`mutation enableTwoFactorAuth(userId: ID!): Boolean!`",
              "description": "Вмикає/вимикає двофакторну автентифікацію для користувача. Вимагає попередньої верифікації email. Код для 2FA відправляється на email (Gmail API) при кожному вході після увімкнення.",
              "authRequired": "Потрібна автентифікація: Так (користувач має керувати своїм обліковим записом).",
              "scenario": "Сценарій: Користувач налаштовує безпеку облікового запису.",
              "errors": "Помилки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`, `400 Bad Request` (email не верифікований)."
            },
            "disableTwoFactorAuth": {
              "title": "`mutation disableTwoFactorAuth(userId: ID!): Boolean!`",
              "description": "Вмикає/вимикає двофакторну автентифікацію для користувача. Вимагає попередньої верифікації email. Код для 2FA відправляється на email (Gmail API) при кожному вході після увімкнення.",
              "authRequired": "Потрібна автентифікація: Так (користувач має керувати своїм обліковим записом).",
              "scenario": "Сценарій: Користувач налаштовує безпеку облікового запису.",
              "errors": "Помилки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`, `400 Bad Request` (email не верифікований)."
            },
            "sendTwoFactorCode": {
              "title": "`mutation sendTwoFactorCode(userId: ID!): Boolean!`",
              "description": "Відправляє код двофакторної автентифікації на email користувача.",
              "authRequired": "Потрібна автентифікація: Часткова (наприклад, після введення пароля, але до введення 2FA коду). Логіка залежить від потоку автентифікації.",
              "scenario": "Сценарій: Користувач входить до облікового запису з увімкненою 2FA.",
              "errors": "Помилки: `404 Not Found` (користувач не знайдений або 2FA не увімкнена), `429 Too Many Requests`."
            },
            "createPaymentSession": {
              "title": "`mutation createPaymentSession(input: PaymentInput!): PaymentSessionPayload!`",
              "description": "Створює сесію оплати через Stripe для оформлення Premium підписки.",
              "input": "`PaymentInput`: `{ planId: ID!, returnUrl: String! }` (ID обраного тарифного плану, URL для редиректу після оплати).",
              "authRequired": "Потрібна автентифікація: Так.",
              "scenario": "Сценарій: Користувач натискає \"Підписатися\" на Premium екрані.",
              "errors": "Помилки: `400 Bad Request` (невірний planId), `401 Unauthorized`."
            }
          }
        }
      },
      "errorHandling": {
        "title": "3. Обробка Помилок API: Чіткий Зворотний Зв'язок (Принцип 3, 14)",
        "description": "API повертає стандартизовані помилки для <strong>чіткого зворотного зв'язку</strong> (Принцип 14) з клієнтом та підтримки <strong>якості</strong> (Принцип 3).",
        "errorFormatTitle": "Формат помилок (відповідно до специфікації GraphQL):",
        "errorFormatCode": "{\n  \"data\": null, // Зазвичай null при помилках верхнього рівня\n  \"errors\": [\n    {\n      \"message\": \"Опис помилки (може бути локалізовано - див. DocLocIn)\",\n      \"locations\": [...], // Розташування помилки в запиті\n      \"path\": [...],      // Шлях до поля, що викликало помилку\n      \"extensions\": {\n        \"code\": \"КОД_ПОМИЛКИ\", // Стандартизований код помилки (наприклад, \"UNAUTHENTICATED\", \"FORBIDDEN\", \"BAD_USER_INPUT\", \"NOT_FOUND\")\n        \"http\": { // Якщо застосовно, HTTP статус код\n          \"status\": 401,\n          \"headers\": {}\n        },\n         \"details\": {} // Додаткові деталі про помилку (опціонально)\n      }\n    }\n    // ... можуть бути інші помилки\n  ]\n}",
        "keyErrorCodesTitle": "Ключові коди помилок (extensions.code):",
        "keyErrorCodesList": [
          "`UNAUTHENTICATED`: Потрібна автентифікація, але токен відсутній або недійсний (`HTTP 401`).",
          "`FORBIDDEN`: Автентифікація пройдена, але користувач не має прав на виконання операції (`HTTP 403`).",
          "`BAD_USER_INPUT`: Помилка валідації вхідних даних (`HTTP 400`). Деталі можуть бути в `extensions.details`.",
          "`NOT_FOUND`: Запитуваний ресурс не знайдено (`HTTP 404`).",
          "`CONFLICT`: Конфлікт даних (наприклад, спроба зареєструвати email, який вже існує) (`HTTP 409`).",
          "`INTERNAL_SERVER_ERROR`: Неочікувана помилка на сервері (`HTTP 500`).",
          "`RATE_LIMITED`: Перевищено ліміт запитів (`HTTP 429`)."
        ],
        "localizationErrorsTitle": "Локалізація помилок:",
        "localizationErrorsContent": "Повідомлення про помилки (`message`) можуть бути локалізовані на стороні Backend на основі заголовка `Accept-Language` або переваг користувача (див. DocLocIn)."
      },
      "notes": {
        "title": "4. Примітки",
        "dataTypes": {
          "title": "Типи даних:",
          "list": [
            "`ID`: Унікальний ідентифікатор ресурсу (зазвичай рядок).",
            "`String`: Текстовий рядок.",
            "`Int`, `Float`: Числа.",
            "`Boolean`: Логічне значення (`true`/`false`).",
            "`DateTime`: Дата та час у форматі ISO 8601 (наприклад, \"2025-03-14T10:30:00Z\").",
            "`JSON`: Кастомний скаляр для передачі довільних JSON-об'єктів (наприклад, для `fileMetadata`).",
            "`!` в кінці типу означає, що поле <strong>не може бути null</strong>."
          ]
        },
        "pagination": {
          "title": "Пагінація:",
          "content": "Для списків, які можуть бути довгими (`messages`), використовуйте пагінацію для ефективного завантаження даних (Принцип 9)."
        },
        "validation": {
          "title": "Валідація:",
          "content": "Backend виконує сувору валідацію всіх вхідних даних (через DTO та `class-validator`), повертаючи помилки `BAD_USER_INPUT` при їх некоректності. Це частина <strong>системи забезпечення якості</strong> (Принцип 3)."
        },
        "security": {
          "title": "Безпека:",
          "content": "Усі запити, що працюють з чутливими даними або змінюють стан системи (окрім реєстрації/входу), вимагають автентифікації."
        },
        "testingTools": {
          "title": "Інструменти тестування API:",
          "content": "Використовуйте GraphQL Playground (часто доступний за адресою `/graphql` у dev-режимі Backend), Postman або Apollo Studio для відправлення запитів та тестування API."
        }
      }
    },
    "technicalDocs": {
      "title": "Технічна документація BrainMessenger (Система та Основа)",
      "subtitle": "Загальна інформація: Архітектура цифрового активу",
      "generalInfo": {
        "title": "1. Загальна інформація: Архітектура цифрового активу",
        "description": "BrainMessenger — це сучасний месенджер, побудований як <strong>надійна, масштабована та безпечна система</strong> (Принцип 9), що служить <strong>ключовим цифровим АКТИВОМ</strong> (Принцип 10). Цей документ надає високорівневий огляд <strong>технічної основи</strong> (Принцип 8) проєкту, описуючи основні компоненти, технології та їх взаємодію.",
        "projectNameTitle": "Назва проєкту:",
        "projectNameContent": "BrainMessenger",
        "purposeTitle": "Мета:",
        "purposeContent": "Надати загальне розуміння структури BrainMessenger, використовуваного технологічного стеку та принципів, що лежать в основі його побудови, для всіх членів команди та зацікавлених сторін.",
        "principlesTitle": "Принципи, відображені в технічній структурі:",
        "principlesList": [
          "<strong>Системність та Оптимізація (Принцип 9):</strong> Проєкт спроєктовано як набір взаємопов'язаних, оптимізованих компонентів.",
          "<strong>Довгострокове мислення (Принцип 8):</strong> Вибір технологій та архітектури з урахуванням майбутніх потреб масштабування та розвитку.",
          "<strong>Якість > Кількість (Принцип 3):</strong> Використання перевірених, надійних рішень та фокус на якості коду та інфраструктури.",
          "<strong>Прагматизм та Реалізм (Принцип 12):</strong> Використання готових сервісів (Neon, R2, Firebase) там, де це виправдано, замість побудови всього з нуля.",
          "<strong>Створення цінності (Принцип 2):</strong> Технічна структура спрямована на надання ключових функцій месенджера (зв'язок, файли, дзвінки) на високому рівні."
        ]
      },
      "techStack": {
        "title": "2. Стек технологій: Інструменти для побудови системи",
        "description": "Ми використовуємо сучасний та гнучкий набір технологій, що дозволяє нам ефективно створювати та масштабувати BrainMessenger.",
        "frontend": {
          "title": "Фронтенд (Клієнтські застосунки):",
          "list": [
            "<strong>React Native (Android, Windows Desktop):</strong> Єдина кодова база для мобільних та десктопних застосунків. Обрано за кросплатформність та великий набір готових бібліотек.",
            "<strong>Next.js (Web):</strong> React-фреймворк для веб-застосунку з підтримкою SSR/SSG для продуктивності та SEO.",
            "<strong>TypeScript:</strong> Сувора типізація всього Frontend-коду. Збільшує надійність та спрощує рефакторинг."
          ]
        },
        "backend": {
          "title": "Бекенд (Серверна логіка):",
          "list": [
            "<strong>Node.js:</strong> Високопродуктивне середовище виконання JavaScript/TypeScript.",
            "<strong>NestJS:</strong> Модульний фреймворк для Node.js. Забезпечує структуровану архітектуру (модулі, сервіси, контролери/резолвери) та підтримку TypeScript.",
            "<strong>GraphQL:</strong> API-протокол. Дозволяє клієнтам запитувати саме ті дані, які їм потрібні, зменшуючи надлишковість."
          ]
        },
        "databaseCaching": {
          "title": "База даних та кешування:",
          "list": [
            "<strong>PostgreSQL (через Neon):</strong> Надійна реляційна СУБД. Використовується як основне сховище для структурованих даних (користувачі, чати, повідомлення, метадані). Neon надає керований сервіс з можливостями масштабування та реплікації.",
            "<strong>Prisma ORM:</strong> Інструмент для взаємодії з PostgreSQL з NestJS. Забезпечує типізацію та безпеку запитів.",
            "<strong>Redis:</strong> Сховище даних в оперативній пам'яті. Використовується для кешування, Rate Limiting, керування станом WebSocket-з'єднань (присутність користувача)."
          ]
        },
        "fileStorage": {
          "title": "Файлове сховище:",
          "list": [
            "<strong>Cloudflare R2:</strong> Об'єктне сховище, сумісне з S3 API. Використовується для зберігання користувацьких файлів (фото, відео, документи, аватари, записи дзвінків), зашифрованих даних. Обрано через низьку вартість та відсутність плати за вихідний трафік."
          ]
        },
        "asyncProcessing": {
          "title": "Асинхронна обробка:",
          "list": [
            "<strong>Kafka:</strong> Розподілена система черг повідомлень. Використовується для надійної асинхронної обробки завдань (наприклад, обробка зображень, надсилання сповіщень) поза основним потоком API."
          ]
        },
        "infrastructureDeployment": {
          "title": "Інфраструктура та розгортання:",
          "list": [
            "<strong>Docker:</strong> Контейнеризація застосунків. Забезпечує ізоляцію та портативність.",
            "<strong>Kubernetes:</strong> Оркестрація контейнерів. Керує розгортанням, масштабуванням та самовідновленням сервісів у кластері.",
            "<strong>Terraform:</strong> Інфраструктура як код (IaC). Автоматизує створення та керування хмарними ресурсами."
          ]
        },
        "testingMonitoringLogging": {
          "title": "Тестування, Моніторинг, Логування:",
          "list": [
            "<strong>Jest, Cypress, Detox:</strong> Інструменти для модульного, інтеграційного та E2E тестування.",
            "<strong>Prometheus, Grafana:</strong> Система моніторингу. Збір та візуалізація метрик продуктивності та стану системи.",
            "<strong>Winston, Sentry:</strong> Система логування та відстеження помилок."
          ]
        }
      },
      "architecture": {
        "title": "3. Архітектура проєкту: Взаємозв'язок компонентів системи",
        "description": "Архітектура BrainMessenger слідує принципам <strong>модульності та розділення відповідальності</strong> (Принцип 9).",
        "clientApplications": {
          "title": "Клієнтські застосунки (Фронтенд):",
          "list": [
            "Веб (Next.js), Мобільні та Десктопні (React Native).",
            "Містять користувацький інтерфейс та логіку взаємодії з користувачем.",
            "Взаємодіють з Бекендом виключно через <strong>GraphQL API</strong>.",
            "Можуть безпосередньо завантажувати файли з Cloudflare R2 (у разі публічного доступу) або через Бекенд (якщо потрібна автентифікація або підписання URL)."
          ]
        },
        "apiGateway": {
          "title": "API Gateway (У майбутньому):",
          "content": "Єдина точка входу для всіх клієнтських запитів. Може виконувати автентифікацію, Rate Limiting, маршрутизацію до необхідних Бекенд-сервісів. На старті сам Бекенд виступає в ролі Gateway."
        },
        "backendService": {
          "title": "Бекенд-сервіс (NestJS):",
          "list": [
            "Основний серверний компонент.",
            "Містить <strong>бізнес-логіку BrainMessenger</strong> (керування користувачами, чатами, повідомленнями, дзвінками, платежами).",
            "Надає <strong>GraphQL API</strong> для клієнтських застосунків.",
            "Взаємодіє з <strong>Базою даних (Neon/PostgreSQL через Prisma)</strong> для читання/запису структурованих даних.",
            "Взаємодіє з <strong>Файловим сховищем (Cloudflare R2)</strong> для завантаження/отримання файлів (через AWS SDK).",
            "Взаємодіє з <strong>Кешем (Redis)</strong> для швидких операцій.",
            "Ставить завдання в <strong>Чергу (Kafka)</strong> для асинхронної обробки.",
            "Використовує зовнішні сервіси (Firebase, Stripe, Gmail API)."
          ]
        },
        "database": {
          "title": "База даних (Neon/PostgreSQL):",
          "content": "Зберігає структуровані дані. Масштабується незалежно."
        },
        "fileStorage": {
          "title": "Файлове сховище (Cloudflare R2):",
          "content": "Зберігає неструктуровані бінарні дані. Масштабується за обсягом."
        },
        "caching": {
          "title": "Кешування (Redis):",
          "content": "Швидкий доступ до тимчасових даних."
        },
        "messageQueue": {
          "title": "Черга повідомлень (Kafka):",
          "content": "Буферизація та надійна доставка повідомлень між сервісами для асинхронної обробки."
        },
        "workers": {
          "title": "Воркери (Kafka Consumers):",
          "list": [
            "Окремі сервіси, які зчитують завдання з Kafka та виконують важкі або тривалі операції (обробка зображень, надсилання масових розсилок).",
            "Масштабуються незалежно."
          ]
        },
        "externalServices": {
          "title": "Зовнішні сервіси (Firebase, Stripe, Gmail API):",
          "list": [
            "Надають спеціалізований функціонал (сповіщення, платежі, електронна пошта).",
            "Використовуються Бекенд-сервісом."
          ]
        },
        "mermaidDiagram": {
          "title": "Діаграма архітектури:",
          "code": "graph TD\n    A[Frontend Web (Next.js)] -->|GraphQL API| B(API Gateway / Backend);\n    A -->|Direct File Access (Opt.)| E(Cloudflare R2);\n    F[Frontend Mobile/Desktop (React Native)] -->|GraphQL API| B;\n    F -->|Direct File Access (Opt.)| E;\n    B -->|Prisma Queries/Mutations| C(Neon/PostgreSQL);\n    B -->|AWS SDK (S3 API)| E;\n    B -->|ioredis| D(Redis Cache);\n    B -->|kafkajs Producer| G(Kafka Queue);\n    B -->|Firebase Admin SDK| H(Firebase FCM);\n    B -->|Stripe SDK| I(Stripe);\n    B -->|Google APIs Client| J(Gmail API);\n    G -->|kafkajs Consumer| K(Kafka Workers);\n    K -->|sharp| K; % Image processing\n    K -->|AWS SDK (S3 API)| E;\n    K -->|GraphQL API / Other Service Calls| B; % Report completion, send chat message\n    C -->|Replication (for scaling)| C;\n    C -->|Partitioning/Sharding (for scaling)| C;\n    E -->|CDN| A; % File delivery to Frontend\n    Prometheus(Prometheus) -->|Scrape Metrics| B;\n    Prometheus -->|Scrape Metrics| C;\n    Prometheus -->|Scrape Metrics| D;\n    Prometheus -->|Scrape Metrics| G;\n    Grafana(Grafana) -->|Visualize Metrics| Prometheus;\n    Sentry(Sentry) -->|Error Reports| B;\n    Sentry -->|Error Reports| A;"
        }
      },
      "api": {
        "title": "4. API: Інтерфейс взаємодії",
        "description": "API BrainMessenger реалізовано з використанням GraphQL на NestJS.",
        "endpointTitle": "Кінцева точка:",
        "endpointContent": "`/graphql`",
        "structureTitle": "Структура:",
        "structureContent": "Визначається GraphQL-схемою (типи User, Chat, Message тощо) та набором Queries (для отримання даних) і Mutations (для зміни даних).",
        "authenticationTitle": "Автентифікація:",
        "authenticationContent": "JWT-токени в заголовку `Authorization: Bearer <token>`.",
        "externalApiIntegrationsTitle": "Інтеграції із зовнішніми API:",
        "externalApiIntegrationsContent": "Взаємодія із зовнішніми сервісами (Gmail, Stripe) відбувається через Бекенд, який надає відповідні Mutations у GraphQL API (див. Специфікацію API).",
        "keyFunctionalAreas": {
          "title": "Ключові функціональні області API:",
          "list": [
            "Автентифікація (реєстрація, вхід, вихід, 2FA).",
            "Керування користувачами (отримання/оновлення/видалення профілю).",
            "Керування чатами (створення, отримання списку, отримання даних чату).",
            "Обробка повідомлень (надсилання текстових повідомлень, надсилання файлів, отримання історії).",
            "Керування контактами.",
            "Налаштування застосунку (тема, сповіщення, мова).",
            "Керування преміум-підписками.",
            "Керування файлами (завантаження в R2 через Бекенд).",
            "(У майбутньому) Дзвінки та відеодзвінки (керування сесіями дзвінків)."
          ]
        },
        "detailedSpecTitle": "Детальна специфікація API описана в:",
        "detailedSpecContent": "DocSpec.md"
      },
      "database": {
        "title": "5. База даних (Neon/PostgreSQL): Основне сховище даних",
        "description": "",
        "technologyTitle": "Технологія:",
        "technologyContent": "PostgreSQL 15.x.",
        "hostingTitle": "Хостинг:",
        "hostingContent": "Neon.",
        "roleTitle": "Роль:",
        "roleContent": "Реляційна база даних для всіх структурованих даних.",
        "keyTables": {
          "title": "Ключові таблиці (визначені в backend/prisma/schema.prisma):",
          "list": [
            "User: Інформація про користувача (id, email, password_hash, name, avatarUrl, createdAt, updatedAt, is2FaEnabled).",
            "Chat: Інформація про чат (id, type, name, createdAt, updatedAt, lastMessageAt).",
            "UserChat: Таблиця зв'язку для відношення Many-to-Many між User та Chat (userId, chatId, joinedAt, lastReadMessageId).",
            "Message: Повідомлення в чатах (id, chatId, senderId, content, fileUrl, fileMetadata (JSON), createdAt, updatedAt).",
            "Contact: Список контактів користувача (id, userId, contactId).",
            "Transaction: Історія платежів (для Premium) (id, userId, amount, currency, status, provider, createdAt).",
            "Code: Тимчасові коди (для верифікації email, 2FA) (id, userId/email, code, type, expiresAt)."
          ]
        },
        "interactionTitle": "Взаємодія:",
        "interactionContent": "Тільки Бекенд через Prisma ORM.",
        "optimizationScalingTitle": "Оптимізація та масштабування:",
        "optimizationScalingContent": "Використовуються індекси, оптимізація запитів Prisma, матеріалізовані подання, партиціонування, реплікація (див. DocOptimizationIn)."
      },
      "fileStorage": {
        "title": "6. Файлове сховище (Cloudflare R2): Зберігання медіа та бінарних активів",
        "description": "",
        "technologyTitle": "Технологія:",
        "technologyContent": "Об'єктне сховище, S3-сумісний API.",
        "hostingTitle": "Хостинг:",
        "hostingContent": "Cloudflare R2.",
        "roleTitle": "Роль:",
        "roleContent": "Сховище для всіх неструктурованих даних (файли користувачів, аватари, записи дзвінків).",
        "interactionTitle": "Взаємодія:",
        "interactionContent": "Бекенд завантажує файли, Бекенд або Фронтенд отримує файли (безпосередньо або через підписані URL).",
        "structureTitle": "Структура:",
        "structureContent": "Файли організовані за папками/ключами (наприклад, `avatars/`, `chat-images/`, `sensitive-data/`).",
        "securityTitle": "Безпека:",
        "securityContent": "Шифрування в стані спокою, обмежений доступ, шифрування конфіденційних даних на рівні застосунку перед завантаженням (див. DocInt, DocSecurity)."
      },
      "projectStructure": {
        "title": "7. Структура проєкту (Монорепозиторій): Організація коду",
        "description": "Проєкт організовано як монорепозиторій з використанням Turborepo.",
        "purposeTitle": "Мета:",
        "purposeContent": "Спрощення керування кількома застосунками/пакетами (backend, web, mobile-desktop, core) та повторного використання коду.",
        "packages": {
          "title": "Пакети:",
          "list": [
            "core: Спільний код.",
            "backend: Серверна логіка.",
            "web: Веб-застосунок.",
            "mobile-desktop: Мобільний/десктопний застосунок (React Native).",
            "Infrastructure: Файли конфігурації для розгортання (infrastructure/).",
            "Documentation: Документація проєкту (docs/)."
          ]
        },
        "detailedDescriptionTitle": "Детальний опис структури монорепозиторію можна знайти в:",
        "detailedDescriptionContent": "DocDevIn.md (розділ 2)."
      },
      "security": {
        "title": "8. Безпека: Фундаментальний аспект системи",
        "description": "Безпека вбудована на всіх рівнях (детальніше див. у Посібнику з безпеки BrainMessenger).",
        "authenticationTitle": "Автентифікація:",
        "authenticationContent": "JWT, 2FA через email.",
        "authorizationTitle": "Авторизація:",
        "authorizationContent": "Перевірка прав доступу до ресурсів на Бекенді.",
        "encryptionTitle": "Шифрування:",
        "encryptionContent": "TLS/SSL для передачі даних, хешування паролів (bcrypt/argon2), шифрування конфіденційних даних на рівні застосунку перед збереженням у R2.",
        "validationTitle": "Валідація:",
        "validationContent": "Сувора валідація вхідних даних на Бекенді.",
        "attackProtectionTitle": "Захист від атак:",
        "attackProtectionContent": "Rate Limiting, безпечні HTTP-заголовки.",
        "principleTitle": "Принцип:",
        "principleContent": "Безпека — це безперервний процес навчання (Принцип 1) та вдосконалення (Принцип 9), заснований на відповідальності (Принцип 6)."
      },
      "deployment": {
        "title": "9. Розгортання: Доставка системи користувачам",
        "description": "Процес розгортання автоматизований.",
        "containerizationTitle": "Контейнеризація:",
        "containerizationContent": "Образи Docker для Бекенда, Kafka Consumers.",
        "orchestrationTitle": "Оркестрація:",
        "orchestrationContent": "Kubernetes керує контейнерами в хмарі.",
        "iacTitle": "Інфраструктура як код:",
        "iacContent": "Terraform (IaC). Автоматизує створення та керування хмарними ресурсами.",
        "ciCdTitle": "CI/CD:",
        "ciCdContent": "GitHub Actions автоматизує збірку, тестування та розгортання.",
        "webAppDeploymentTitle": "Веб-застосунок може бути розгорнутий окремо (наприклад, на Vercel або Cloudflare Pages).",
        "webAppDeploymentContent": "",
        "detailedDescriptionTitle": "Детальний опис процесу розгортання можна знайти в:",
        "detailedDescriptionList": [
          "DocDevIn.md (розділ 9)",
          "Посібник з розгортання"
        ]
      },
      "monitoringLogging": {
        "title": "10. Моніторинг та логування: Видимість стану системи",
        "description": "",
        "monitoringTitle": "Моніторинг:",
        "monitoringList": [
          "Збір та візуалізація метрик продуктивності та стану системи (CPU, RAM, затримки API/БД, помилки).",
          "Інструменти: Prometheus, Grafana. Дозволяє завчасно виявляти проблеми (Принцип 9: Кайдзен)."
        ],
        "loggingTitle": "Логування:",
        "loggingList": [
          "Збір структурованих логів з усіх компонентів (Бекенд, воркери).",
          "Інструменти: Winston (для Node.js), Sentry (для відстеження помилок)."
        ],
        "detailedDescriptionTitle": "Детальний опис можна знайти в:",
        "detailedDescriptionList": [
          "Посібник з оптимізації BrainMessenger (розділ 14)",
          "Посібник з моніторингу"
        ]
      },
      "externalApiIntegrations": {
        "title": "11. Інтеграції із зовнішніми API: Використання зовнішніх важелів",
        "description": "Бекенд взаємодіє з декількома зовнішніми сервісами через їхні API.",
        "gmailApiTitle": "Gmail API:",
        "gmailApiContent": "Надсилання транзакційних листів (підтвердження, 2FA).",
        "stripeTitle": "Stripe:",
        "stripeContent": "Обробка платежів та підписок.",
        "firebaseFCMTitle": "Firebase FCM:",
        "firebaseFCMContent": "Надсилання push-сповіщень на мобільні пристрої.",
        "principleTitle": "Принцип:",
        "principleContent": "Використання цих сервісів — прагматичний (Принцип 12) спосіб швидко додати функціональність, використовуючи готові, надійні (Принцип 3) рішення.",
        "detailedDescriptionTitle": "Детальний опис інтеграцій можна знайти в:",
        "detailedDescriptionContent": "DocInt.md"
      },
      "notes": {
        "title": "12. Примітки",
        "description": "Ця документація надає високорівневий огляд технічної системи BrainMessenger. Для більш детального розуміння окремих частин звертайтеся до відповідних документів:",
        "apiSpecLinkTitle": "Специфікація API:",
        "apiSpecLinkContent": "DocSpec.md",
        "devGuideLinkTitle": "Посібник розробника:",
        "devGuideLinkContent": "DocDevIn.md",
        "optimizationGuideLinkTitle": "Посібник з оптимізації:",
        "optimizationGuideLinkContent": "DocOptimizationIn.md",
        "integrationsDocsLinkTitle": "Документація з інтеграцій:",
        "integrationsDocsLinkContent": "DocInt.md",
        "designDocsLinkTitle": "Документація з дизайну:",
        "designDocsLinkContent": "DocDesign.md",
        "userGuideLinkTitle": "Посібник користувача:",
        "userGuideLinkContent": "DocUser.md",
        "longTermInvestmentTitle": "Розробка та підтримка цієї технічної системи — це довгострокова інвестиція (Принцип 8) та безперервний процес навчання та вдосконалення (Принцип 1, 9)."
      }
    }
  },
    "footer": {
      "sectionTitle": {
      "brand": "BrainMessenger"
    },
      "brandContent": "Ваша розумна платформа для спілкування",
      "copyright": "© 2025 BrainMessenger. Всі права захищено."
    }
  }
}