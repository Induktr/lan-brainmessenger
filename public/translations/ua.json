{
  "header": {
    "features": "Features",
    "news": "News",
    "faq": "FAQ",
    "faqLink": "FAQ",
    "docs": "Docs",
    "updates": "Updates",
    "selectLanguage": "Select language",
    "changeLanguageTooltip": "Change language",
    "lightMode": "Light Mode",
    "darkMode": "Dark Mode",
    "openMenu": "Open menu",
    "closeMenu": "Close menu",
    "settings": "Settings",
    "signOut": "Sign Out",
    "deleteAccount": "Delete Account",
    "deleteAccountConfirmTitle": "Confirm Account Deletion",
    "deleteAccountConfirmMessage": "Are you sure you want to delete your account? This action cannot be undone.",
    "cancel": "Cancel",
    "confirmDelete": "Confirm Deletion",
    "signIn": "Sign In"
  },
  "hero": {
    "title": "Welcome to BrainMessenger",
    "subtitle": "Your Smart Communication Platform",
    "getStarted": "Get Started",
    "learnMore": "Learn More",
    "connectSmarterTitle": "Connect Smarter with BrainMessenger",
    "connectSmarterSubtitle": "Experience the next generation of messaging with advanced features, unparalleled security, and seamless communication across all your devices.",
    "downloadButton": "Download",
    "downloadAndroid": "Download for Android"
  },
  "features": {
    "featuresTitle": "Key Features",
    "featuresSubtitle": "Discover what makes us unique",
    "secureMessaging": "Secure Messaging",
    "secureMessagingDesc": "End-to-end encryption for your privacy",
    "smartAssistant": "Smart Assistant",
    "smartAssistantDesc": "AI-powered help at your fingertips",
    "crossPlatform": "Cross Platform",
    "crossPlatformDesc": "Use on any device, anywhere",
    "groupChats": "Group Chats",
    "groupChatsDesc": "Connect with multiple people at once",
    "privacyFirst": "Privacy First",
    "privacyFirstDesc": "Your data is yours, always"
  },
  "news": {
    "latestNews": "Latest news",
    "readMore": "Read More",
    "previousButton": "Previous news item",
    "nextButton": "Next news item",
    "pauseAutoplay": "Pause autoplay",
    "playAutoplay": "Play autoplay"
  },
  "roadmap": {
    "title": {
      "section": "Roadmap",
      "projectLaunch": "Project Launch",
      "enhancedSecurity": "Enhanced Security",
      "advancedCollaboration": "Advanced Collaboration",
      "mobileEnhancement": "Mobile Enhancement",
      "aiIntegration": "AI Integration",
      "globalExpansion": "Global Expansion",
      "enterpriseSolutions": "Enterprise Solutions",
      "futureInnovation": "Future Innovation"
    },
    "subtitle": {
      "section": "Our Future Vision"
    },
    "status": {
      "completed": "Completed",
      "inProgress": "In Progress",
      "upcoming": "Upcoming"
    },
    "description": {
      "projectLaunch": "Initial launch of BrainMessenger with core features.",
      "enhancedSecurity": "Strengthening security protocols and features.",
      "advancedCollaboration": "Introducing advanced collaboration tools.",
      "mobileEnhancement": "Enhancing mobile application experience.",
      "aiIntegration": "Integrating AI-powered features for smarter communication.",
      "globalExpansion": "Expanding BrainMessenger's reach globally.",
      "enterpriseSolutions": "Developing solutions for enterprise clients.",
      "futureInnovation": "Exploring and implementing future technologies."
    },
    "features": {
      "secureMessagingInfrastructure": "Secure messaging infrastructure",
      "crossPlatformCompatibility": "Cross-platform compatibility",
      "basicUserInterface": "Basic user interface",
      "endToEndEncryption": "End-to-end encryption",
      "twoFactorAuthentication": "Two-factor authentication",
      "fileSharingCapabilities": "File sharing capabilities",
      "teamWorkspaces": "Team workspaces",
      "realTimeCollaboration": "Real-time collaboration",
      "advancedFileSharing": "Advanced file sharing",
      "nativeMobileApps": "Native mobile apps",
      "offlineFunctionality": "Offline functionality",
      "pushNotifications": "Push notifications",
      "smartMessageCategorization": "Smart message categorization",
      "automatedResponses": "Automated responses",
      "contentAnalysis": "Content analysis",
      "multiLanguageSupport": "Multi-language support",
      "regionalDataCenters": "Regional data centers",
      "culturalAdaptations": "Cultural adaptations",
      "advancedAdminControls": "Advanced admin controls",
      "customIntegrations": "Custom integrations",
      "enterpriseSupport": "Enterprise support",
      "emergingTechnologies": "Emerging technologies",
      "communityDrivenFeatures": "Community-driven features",
      "platformExpansion": "Platform expansion"
    },
    "date": {
      "jan2024": "January 2024",
      "mar2024": "March 2024",
      "jun2024": "June 2024",
      "sep2024": "September 2024",
      "nov2024": "November 2024",
      "jan2025": "January 2025",
      "mar2025": "March 2025",
      "jun2025": "June 2025",
      "beyond2025": "Beyond 2025"
    }
  },
  "faq": {
    "title": "Frequently Asked Questions",
    "subtitle": "Find answers to common questions about BrainMessenger",
    "searchAlt": "Search icon",
    "searchPlaceholder": "Search questions...",
    "allQuestions": "All Questions",
    "noResults": "No questions found matching your search.",
    "categories": {
      "general": "General",
      "technical": "Technical",
      "security": "Security",
      "pricing": "Pricing",
      "generalProject": "General Project Questions",
      "technicalQuestions": "Technical Questions",
      "developmentProcesses": "Development Processes",
      "statusRoadmapFuture": "Status, Roadmap, and Future",
      "challengesOpportunitiesLimitations": "Challenges, Opportunities, and Limitations",
      "learnMoreContribute": "Learn More and Contribute"
    },
    "questionsData": {
      "generalProject": {
        "q1": {
          "question": "What is the main idea behind BrainMessenger? What makes it special?",
          "answer": "BrainMessenger is not just another messenger. Our main idea is to create a Digital ASSET (Principle 10) that simplifies complex interaction (Margulan Seisembayev's principle) and serves as a reliable tool for effective communication. We are focused on quality (Principle 3), security (Principle 5), and reliability (Principle 3), not just a set of features. We are building a SYSTEM (Principle 9) that reflects our principles and is constantly improving."
        },
        "q2": {
          "question": "What key principles underpin the development of BrainMessenger?",
          "answer": "The project is based on a set of 15 key principles (see My Key Principles), inspired by Margulan Seisembayev and IT industry best practices. The most important ones influencing code and processes are: Continuous Learning (Principle 1), Value Creation (Principle 2), Quality > Quantity (Principle 3), System and Optimization (Kaizen, Principle 9), Long-Term Thinking (Principle 8), Pragmatism and Realism (Principle 12), Persistence (Principle 13), Bias for Action (Principle 15). We strive for these principles to permeate all aspects of the project."
        },
        "q3": {
          "question": "Who is behind the project? Is it an open community or a team?",
          "answer": "Currently, the project is at an early stage and is actively being developed by one person (you), who is the driving force and bears responsibility (Principle 6) for its construction. In the future, it is planned to attract contributors and possibly form a team. The project is open for contributions (see CONTRIBUTING.md)."
        }
      },
      "technicalQuestions": {
        "q1": {
          "question": "Why was this particular technology stack chosen (TypeScript, NestJS, React/RN, PostgreSQL/Neon, GraphQL, Kafka, Redis, Cloudflare R2, etc.)?",
          "answer": "The choice of stack is based on pragmatism (Principle 12), long-term thinking (Principle 8), and the pursuit of quality (Principle 3) and scalability (NFR-14, NFR-15).\n*   TypeScript: Increases code reliability and maintainability through strong typing.\n*   NestJS: Provides a powerful, modular architecture for the Backend, simplifying the construction of scalable applications.\n*   React/React Native/Next.js: Allow building UI for different platforms from a single codebase (cross-platform) and provide good performance.\n*   PostgreSQL (Neon): A reliable, proven relational database with extensive scaling and optimization capabilities. Neon as a managed service reduces operational overhead (Pragmatism).\n*   Prisma: Chosen as a reliable ORM, providing type safety and built-in protection against SQL injection (Quality, Security).\n*   GraphQL: Allows clients to request only the data they actually need with a single query, optimizing network interaction (especially for mobile clients) and reducing data redundancy compared to REST. GraphQL also simplifies fetching related data (solving N+1 problems with DataLoader).\n*   Kafka: Chosen for reliable asynchronous task processing, which is critical for scalability and fault tolerance.\n*   Redis: High-performance In-memory store for caching, Rate Limiting, and real-time state management.\n*   Cloudflare R2: Object storage with very favorable terms (no egress fees), ideal for storing user files (Pragmatism, ASSET).\n\nThis stack allows laying a solid technical foundation (Principle 8) for future development."
        },
        "q2": {
          "question": "Why is a monolithic architecture used at the start, rather than microservices immediately?",
          "answer": "Using a monolithic architecture at the start (MVP) is a pragmatic and realistic decision (Principle 12). It allows for rapid development and iteration of basic functionality, minimizing complexity at an early stage when the team is small. Launching the MVP is more important than building an overly complex architecture. Once the MVP will be completed and the project starts to grow, a phased transition to microservices is planned (see Microservice Migration Plan)."
        },
        "q3": {
          "question": "What approaches are used to ensure security?",
          "answer": "Security is a fundamental aspect (Principle 5) and a priority (see Security Guide).\n*   Data encryption in transit (TLS 1.2+) and at rest (AES for sensitive data, encryption in R2).\n*   Strong password hashing (bcrypt/argon2).\n*   Using Prisma to prevent SQL injection.\n*   Validation of all input data on the Backend.\n*   Two-factor authentication (2FA) via email.\n*   Rate Limiting to protect against brute-force and DDoS attacks.\n*   Regular vulnerability scanning.\n*   Storing secrets in secure locations (Kubernetes Secrets)."
        },
        "q4": {
          "question": "How is real-time functionality implemented (message exchange)?",
          "answer": "Real-time functionality (message exchange) is implemented using WebSockets. The Backend (NestJS Gateway) manages WebSocket connections, and clients subscribe to chat events. Message delivery occurs via WebSocket. For scaling WebSockets in a microservice architecture, Redis Pub/Sub or Kafka will be used."
        },
        "q5": {
          "question": "Why is GraphQL used instead of REST API?",
          "answer": "GraphQL allows clients to request only the data they actually need with a single query. This optimizes network interaction (especially for mobile clients) and reduces data redundancy compared to REST. GraphQL also simplifies fetching related data (solving N+1 problems with DataLoader)."
        },
        "q6": {
          "question": "How are large volumes of data and files managed?",
          "answer": "*   Structured data (messages, users, chats): Stored in PostgreSQL (Neon). Indexes and query optimization (Prisma) are used for fast retrieval. As it grows, table partitioning and database replication are planned.\n*   Unstructured data (files, images): Stored in Cloudflare R2. Asynchronous processing (Kafka) is used for image optimization before uploading. R2 is chosen for scalability and favorable traffic rates."
        }
      },
      "developmentProcesses": {
        "q1": {
          "question": "What is the approach to project and task management?",
          "answer": "The project is managed using a planning system (see My Planning System 2025-2026) in Notion. Global goals are decomposed into stages (Roadmap), weekly planning, and a task tracker are used. An important element is the Kaizen Hour (Principle 9) for daily reflection, analyzing bottlenecks, and finding ways to improve."
        },
        "q2": {
          "question": "How is code quality ensured?",
          "answer": "Code quality is ensured through systematic approaches (Principle 3, 9):\n*   Using TypeScript with strict typing.\n*   Adhering to coding standards (ESLint, Prettier).\n*   Code review of all changes.\n*   Automated testing at different levels (Unit, Integration, E2E).\n*   Continuous Integration (CI) for automatic code and test checks on every commit/PR."
        },
        "q3": {
          "question": "What testing strategy is used?",
          "answer": "A multi-level testing strategy is used (see Testing Guide), combining manual and automated testing: Unit, Integration, API, E2E, Load, Security, Regression. Tests are integrated into CI/CD. The focus is on verifying key requirements (FRs, NFRs)."
        },
        "q4": {
          "question": "How are errors handled?",
          "answer": "Errors are handled centrally and uniformly on the Backend (NestJS Exception Filters) and converted to a standard API response format with codes (extensions.code). On the Frontend, errors are processed based on these codes, displaying a clear message to the user and suggesting an action. All errors are thoroughly logged (Winston → ELK) and sent to Sentry for tracking and analysis (see Error Specification, Monitoring Guide)."
        },
        "q5": {
          "question": "How is the project deployed?",
          "answer": "Deployment is automated through a CI/CD pipeline (GitHub Actions). Docker is used for containerization and Kubernetes for orchestration in the cloud. Infrastructure is described as code (Terraform). The process includes automatic build, testing, image publishing, and Rolling Updates in Kubernetes for zero-downtime deployment (see Deployment Guide)."
        },
        "q6": {
          "question": "How is the system monitored in production?",
          "answer": "The monitoring system is the eyes and ears of the project (Principle 9, 5). The following are used:\n*   Prometheus for collecting performance and resource metrics.\n*   Grafana for visualizing metrics and dashboards.\n*   Sentry for tracking application errors (Frontend and Backend).\n*   ELK Stack (or Kibana with Winston) for centralized logging and analysis.\n*   Alertmanager for configuring automatic alerts about problems.\nThese tools allow for proactive problem identification and optimization (see Monitoring Guide)."
        }
      },
      "statusRoadmapFuture": {
        "q1": {
          "question": "What is the current status of the project?",
          "answer": "The project is in the active development phase of the Minimum Viable Product (MVP). The main technological foundation has been laid, key UI elements and basic security have been implemented. The core messaging, file handling, and group/channel creation are in progress. (See BrainMessenger Project Requirements (MVP) Guide)."
        },
        "q2": {
          "question": "What are the next steps after completing the MVP?",
          "answer": "After completing the MVP, the next steps include adding advanced functions (audio/video calls, Premium, extended security, full set of animations and localization), further performance optimization, and preparing for scaling. A detailed plan is presented in the BrainMessenger Roadmap (see Roadmap)."
        },
        "q3": {
          "question": "Is a transition to a microservice architecture planned?",
          "answer": "Yes, the transition to microservices is part of the long-term development strategy (Principle 8). It is planned in stages, starting from Q1 2026, using the Strangler Pattern approach. This will allow components to be scaled independently, increasing fault tolerance and flexibility (see Microservice Migration Plan)."
        }
      },
      "challengesOpportunitiesLimitations": {
        "q1": {
          "question": "What are the main technical challenges (pitfalls) in the project?",
          "answer": "*   Implementing reliable real-time functionality (WebSockets): Managing thousands of simultaneous connections, reliable message delivery, managing online/offline status.\n*   Scaling the database with large data volumes: Managing the growth of the messages table (partitioning), optimizing complex queries.\n*   Handling and delivering files: Efficient uploading, image optimization, secure downloading from Cloudflare R2.\n*   Transitioning to microservices: Increased operational complexity, configuring inter-service communication (Kafka, GraphQL Federation), data migration.\n*   Maintaining high quality and performance: Continuous optimization at all levels (Backend, Frontend, Infrastructure) as load and functionality grow."
        },
        "q2": {
          "question": "What opportunities and advantages does the project's architecture and stack provide?",
          "answer": "*   High scalability: The chosen technologies (NestJS, Kubernetes, Kafka, Redis, Neon, R2) allow the application to be scaled horizontally to support a large number of users.\n*   Reliability and fault tolerance: Using reliable services, asynchronous processing (Kafka), monitoring, and, in the future, microservices increases the system's resilience to failures.\n*   High performance: GraphQL, caching, query optimization, asynchronous processing contribute to the application's fast operation.\n*   Cross-platform compatibility: React Native and Next.js allow creating applications for all major platforms from a single codebase (for UI).\n*   Code quality and maintainability: TypeScript, NestJS, Prisma, coding standards, testing simplify development and reduce the number of defects.\n*   Cost-effectiveness (at the start): Using free/affordable tiers (Neon, R2) and proven open-source solutions.\n*   Rich ecosystem: Using popular technologies with a large community and many ready-made libraries."
        },
        "q3": {
          "question": "What are the project's limitations at the current stage (MVP)?",
          "answer": "*   Limited set of features compared to the vision (no calls, Premium, enhanced security).\n*   Limited multilingualism and accessibility options (expansion planned).\n*   The architecture is currently monolithic, which imposes limitations on independent scaling of individual parts.\n*   There may be performance limitations under load significantly exceeding the target for MVP (~1000 simultaneous users) before implementing deep optimizations and microservices."
        }
      }
    }
  },
  "docs": {
    "general": {
      "title": "BrainMessenger - Ваш Цифровий Актив для Ефективної Комунікації",
      "subtitle": "Вступ: Побудова Системи Цінності",
      "introduction": {
        "title": "Вступ: Побудова Системи Цінності",
        "content": "Ласкаво просимо до репозиторію BrainMessenger. Це не просто черговий месенджер. Це цілеспрямований проект, що має на меті створення <strong>надійної, масштабованої та безпечної СИСТЕМИ</strong> (Принцип 9), яка стане <strong>ключовим цифровим АКТИВОМ</strong> (Принцип 10) для кожного користувача. Наша головна мета — <strong>спрощувати складність</strong> (принцип Маргулана Сейсембаєва), надаючи інтуїтивно зрозумілі та потужні інструменти для ефективного спілкування та взаємодії в сучасному цифровому світі.<br/><br/>BrainMessenger будується на <strong>міцному фундаменті</strong> (Принцип 8) глибоких принципів, усвідомленого планування та <strong>безперервного навчання</strong> (Принцип 1). Кожен рядок коду, кожне прийняте рішення – це <strong>довгострокова інвестиція</strong> (Принцип 8) у <strong>якість</strong> (Принцип 3) та <strong>цінність</strong> (Принцип 2) нашого продукту."
      },
      "visionAndMission": {
        "title": "Бачення та Місія: Наш Довгостроковий Погляд",
        "visionTitle": "Наше Бачення:",
        "visionContent": "Створити провідний цифровий актив для комунікації, який допоможе мільйонам користувачів по всьому світу ефективно обмінюватися інформацією, будувати спільноти та досягати своїх цілей.",
        "missionTitle": "Наша Місія:",
        "missionContent": "Спрощувати складну взаємодію, надаючи надійний, безпечний та зручний месенджер, побудований на принципах якості, прозорості та безперервного вдосконалення."
      },
      "keyPrinciples": {
        "title": "Ключові Принципи: Фундамент Нашої Системи",
        "intro": "Наші дії та рішення керуються набором ключових принципів, які слугують <strong>фундаментом</strong> (Принцип 8) всього проекту BrainMessenger. Це не просто слова, а <strong>особисті алгоритми та стандарти (Кайдзен, Принцип 9)</strong>, вироблені через досвід та рефлексію (Принцип 1):",
        "principles": [
          "<strong>Безперервне Навчання та Зростання (Принцип 1):</strong> Процес створення BrainMessenger – це полігон для глибокого навчання в технологіях, архітектурі та психології користувача. Ми навчаємось на кожному кроці, перетворюючи помилки на уроки.",
          "<strong>Створення Цінності (Принцип 2):</strong> Користь користувача лежить в основі всього. Ми будуємо те, що по-справжньому вирішує проблеми та робить життя кращим.",
          "<strong>Якість понад Кількість (Принцип 3):</strong> Ми прагнемо робити речі добре, а не просто швидко. Надійність, продуманість та увага до деталей – наші пріоритети.",
          "<strong>Усвідомленість та Присутність (Принцип 4):</strong> Бути уважним до процесу, користувачів та команди.",
          "<strong>Здоров'я як Фундамент (Принцип 5):</strong> Фізичне та ментальне благополуччя команди (та майбутніх користувачів) – основа продуктивності та стійкості.",
          "<strong>Відповідальність та Проактивність (Принцип 6):</strong> Ми беремо на себе відповідальність за результат і діємо на випередження.",
          "<strong>Цілісність (Принцип 7):</strong> Наші слова відповідають нашим діям.",
          "<strong>Довгострокове Мислення (Принцип 8):</strong> Ми інвестуємо час та зусилля з прицілом на майбутнє.",
          "<strong>Система та Оптимізація (Принцип 9):</strong> Ми будуємо процеси та архітектуру як систему, постійно шукаємо способи підвищення ефективності (Кайдзен).",
          "<strong>Створення Багатства > Заробляння Грошей (Принцип 10):</strong> Фокус на створенні АКТИВУ (BrainMessenger), який приносить цінність та працює в довгостроковій перспективі.",
          "<strong>Гнучкість та Адаптивність (Принцип 11):</strong> Готовність змінювати тактику та інструменти, зберігаючи бачення.",
          "<strong>Прагматизм та Реалізм (Принцип 12):</strong> Прийняття рішень на основі реальних даних та можливостей.",
          "<strong>Наполегливість (Принцип 13):</strong> Не здаватися перед труднощами, витягуючи уроки з невдач.",
          "<strong>Використання Зовнішньої Експертизи та Зворотного Зв'язку (Принцип 14):</strong> Ми вчимося у інших, прислухаємося до конструктивної критики.",
          "<strong>Схильність до Дії (Принцип 15):</strong> На ранніх етапах важливіше почати робити та отримувати зворотний зв'язок, ніж безкінечно планувати."
        ],
        "outro": "Ці принципи, натхненні філософією Маргулана Сейсембаєва та практиками провідних IT-компаній, формують нашу культуру та підхід до розробки."
      },
      "aboutMVP": {
        "title": "Про Проект BrainMessenger (Фокус на MVP)",
        "intro": "Наш поточний фокус – на розробці <strong>Мінімально Життєздатного Продукту (MVP)</strong>. MVP – це перший, <strong>прагматичний</strong> (Принцип 12) крок до реалізації нашого бачення. Ми будуємо <strong>міцний технічний фундамент</strong> (Принцип 8), який дозволить нам швидко та ефективно розвивати продукт у майбутньому.",
        "featuresTitle": "MVP включає базові, але <strong>високоякісні та надійні</strong> (Принцип 3) функції, що надають ключову <strong>цінність</strong> (Принцип 2):",
        "features": [
          "<strong>Базове Листування:</strong> Надсилання та отримання текстових повідомлень у особистих чатах та групах/каналах.",
          "<strong>Обмін Файлами:</strong> Завантаження та завантаження файлів (з оптимізацією зображень).",
          "<strong>Канали та Групи:</strong> Базове створення груп/каналів, приєднання до публічних каналів та читання контенту.",
          "<strong>Базове Управління Обліковим Записом:</strong> Реєстрація, вхід/вихід, редагування профілю (ім'я, аватар), базові налаштування безпеки.",
          "<strong>Основні Налаштування UI:</strong> Вибір теми (Світла/Темна), базові налаштування сповіщень та мови.",
          "<strong>Базова Безпека:</strong> Шифрування даних (TLS, хешування паролів, базові заходи проти SQLi/XSS/DDoS), підтвердження електронної пошти під час реєстрації.",
          "<strong>Адаптивний UI:</strong> Інтерфейс, адаптований для мобільних (Android, iOS) та веб-платформ.",
          "<strong>Базова Багатомовність:</strong> Підтримка кількох мов інтерфейсу (англійська, російська та інші згідно з DocLocIn.md)."
        ],
        "outro": "Функціональність за межами MVP (аудіо/відеодзвінки, розширені функції безпеки/приватності, преміум-підписка, повний набір анімацій, інтеграції зі ШІ) планується на наступні етапи Дорожньої карти."
      },
      "howWeBuild": {
        "title": "Як Ми Будуємо: Історія Створення та Процес Кайдзен",
        "intro": "Процес створення BrainMessenger – це жива історія, заснована на наших принципах. Ми будуємо його <strong>системно</strong> (Принцип 9), крок за кроком, документуючи кожен етап та безперервно шукаючи можливості для <strong>покращення (Кайдзен)</strong>.",
        "steps": [
          "<strong>Усвідомлене Планування (Принцип 4):</strong> Проект розпочався з чіткого визначення глобальних цілей та їх декомпозиції на досяжні етапи (Дорожня карта).",
          "<strong>Вибір Фундаменту (Принцип 8, 12):</strong> Ми ретельно відібрали технологічний стек – надійні та <strong>прагматичні</strong> інструменти (TypeScript, NestJS, React/RN, PostgreSQL/Neon, Cloudflare R2, Kafka, Redis), які формують <strong>міцний технічний фундамент</strong>.",
          "<strong>Побудова Ядра MVP:</strong> Реалізація розпочалася з базових, критично важливих частин системи (Аутентифікація, Базовий UI, Інфраструктура, Робота з файлами). Ми застосовуємо <strong>Схильність до Дії</strong> (Принцип 15), фокусуючись на створенні працюючих компонентів, нехай поки й мінімальних.",
          "<strong>Безперервне Навчання та Застосування Знань (Принцип 1):</strong> Кожне нове завдання, особливо пов'язане з вивченням або інтеграцією технологій (як видно у <a href=\"https://www.notion.so/2025-2026-1576e78881b7435e9c3c2cf174e61b91?pvs=4\" target=\"_blank\" rel=\"noopener noreferrer\">Video Tracker</a> та завданнях), розглядається як можливість для зростання. Ми документуємо цей процес через відео та рефлексію (Кайдзен-Година).",
          "<strong>Системний Підхід до Якості (Принцип 3, 9):</strong> Ми інтегруємо тестування на ранніх етапах циклу розробки (Unit-тести), налаштовуємо CI/CD пайплайни для автоматичних перевірок, використовуємо інструменти моніторингу (Prometheus, Grafana, Sentry) та логування (Winston, ELK) для постійного контролю за <strong>здоров'ям системи</strong> (Принцип 5) у реальному часі.",
          "<strong>Документація як Частина Системи Знань:</strong> Весь процес розробки, архітектурні рішення, стандарти та вимоги ретельно документуються. Це не просто формальність, а частина створення <strong>системи знань</strong>, яка прискорює онбординг, спрощує підтримку та дозволяє приймати обґрунтовані рішення в майбутньому."
        ],
        "outro": "Ми будуємо BrainMessenger як живий організм, що розвивається, постійно адаптуючись та покращуючись на основі наших принципів та зворотного зв'язку від процесу розробки та майбутніх користувачів."
      },
      "technologyStack": {
        "title": "Технологічний Стек: Наші Інструменти для Створення Активу",
        "intro": "Ми обрали стек, який є <strong>прагматичним</strong> (Принцип 12), <strong>надійним</strong> (Принцип 3) та <strong>масштабованим</strong> (Принцип 8) для створення нашого <strong>цифрового АКТИВУ</strong>.",
        "stack": [
          "<strong>Мова:</strong> <a href=\"https://www.typescriptlang.org/\" target=\"_blank\" rel=\"noopener noreferrer\">TypeScript</a> - Статична типізація для підвищення якості та надійності коду.",
          "<strong>Бекенд:</strong> <a href=\"https://nodejs.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Node.js</a>, <a href=\"https://nestjs.com/\" target=\"_blank\" rel=\"noopener noreferrer\">NestJS</a> - Ефективний та структурований фреймворк для серверної логіки та GraphQL API.",
          "<strong>Фронтенд:</strong> <a href=\"https://react.dev/\" target=\"_blank\" rel=\"noopener noreferrer\">React</a>, <a href=\"https://nextjs.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Next.js</a> (Веб), <a href=\"https://reactnative.dev/\" target=\"_blank\" rel=\"noopener noreferrer\">React Native</a> (Мобільні/Десктоп) - Кроссплатформна розробка UI з фокусом на продуктивність.",
          "<strong>API:</strong> <a href=\"https://graphql.org/\" target=\"_blank\" rel=\"noopener noreferrer\">GraphQL</a> - Гнучка взаємодія між клієнтом та сервером.",
          "<strong>Реальний час:</strong> WebSockets - Миттєва доставка повідомлень.",
          "<strong>База даних:</strong> <a href=\"https://www.postgresql.org/\" target=\"_blank\" rel=\"noopener noreferrer\">PostgreSQL</a> (через <a href=\"https://neon.tech/\" target=\"_blank\" rel=\"noopener noreferrer\">Neon</a>) - Надійна та масштабована база даних. Neon як керований сервіс знижує операційні витрати (Прагматизм).",
          "<strong>ORM:</strong> <a href=\"https://www.prisma.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Prisma</a> - Типобезпечна та надійна взаємодія з БД, захист від SQL-ін'єкцій (Якість, Безпека).",
          "<strong>Кешування:</strong> <a href=\"https://redis.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Redis</a> - Високопродуктивне кешування та управління станом.",
          "<strong>Черги:</strong> <a href=\"https://kafka.apache.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Kafka</a> - Надійна асинхронна обробка завдань.",
          "<strong>Зберігання файлів:</strong> <a href=\"https://www.cloudflare.com/developer/r2/\" target=\"_blank\" rel=\"noopener noreferrer\">Cloudflare R2</a> - Об'єктне сховище з вигідними цінами та без плати за вихідний трафік (Прагматизм, АКТИВ).",
          "<strong>Сповіщення:</strong> <a href=\"https://firebase.google.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Firebase</a> - Керований сервіс для Push-сповіщень.",
          "<strong>Електронна пошта/2FA:</strong> <a href=\"https://developers.google.com/gmail/api\" target=\"_blank\" rel=\"noopener noreferrer\">Gmail API</a> - Надійна доставка транзакційних листів (коди підтвердження, 2FA).",
          "<strong>Платежі:</strong> <a href=\"https://stripe.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Stripe</a>, Cryptomus (За межами MVP) - Монетизація АКТИВУ, Прагматизм.",
          "<strong>Тестування:</strong> Jest, Cypress, Detox, k6, OWASP ZAP/Burp Suite (план) - Комплексний підхід до забезпечення якості.",
          "<strong>Розгортання:</strong> <a href=\"https://vercel.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Vercel</a> (Веб), Docker, <a href=\"https://kubernetes.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Kubernetes</a> - Автоматизоване та масштабоване розгортання.",
          "<strong>Моніторинг:</strong> Prometheus, Grafana, Sentry (план) - Видимість системи та аналіз Кайдзен."
        ]
      },
      "architecture": {
        "title": "Архітектура: Еволюція Системи",
        "intro": "Наразі BrainMessenger реалізовано як <strong>монолітну програму на базі NestJS</strong>. Це <strong>прагматичне</strong> (Принцип 12) рішення для MVP, що дозволяє швидко запустити продукт та перевірити основні гіпотези.",
        "future": "У майбутньому, у міру зростання проекту та збільшення навантаження, ми плануємо поетапний перехід до <strong>мікросервісної архітектури</strong> з використанням <strong>Strangler Pattern</strong>. Це <strong>довгострокова стратегія</strong> (Принцип 8), яка дозволить незалежно масштабувати та розвивати окремі компоненти (чати, дзвінки, ШІ, платежі), підвищуючи загальну <strong>надійність та гнучкість</strong> системи (Принцип 3, 11).",
        "interaction": "Взаємодія між компонентами здійснюватиметься через <strong>GraphQL API</strong> (синхронно) та <strong>Kafka</strong> (асинхронно), використовуючи <strong>Apollo Federation</strong> (у майбутньому) для побудови єдиної схеми API з багатьох мікросервісів."
      },
      "projectStatus": {
        "title": "Статус Проекту: Поточний Етап (MVP)",
        "content": "На даний момент проект перебуває на активній стадії розробки <strong>MVP</strong> (згідно з <a href=\"https://www.notion.so/MVP-11a2a21315e54eb3b3c90171b4c7493d?pvs=4\" target=\"_blank\" rel=\"noopener noreferrer\">Інструкцією щодо вимог MVP</a>). Ми зосереджені на завершенні основної функціональності обміну повідомленнями, обробки файлів, створення груп/каналів та базових налаштувань, одночасно зміцнюючи <strong>технічний фундамент</strong> (Принцип 8) та впроваджуючи процеси <strong>безперервного навчання</strong> та <strong>Кайдзен</strong> у нашу щоденну роботу.",
        "progress": "Прогрес документується через завдання, код у репозиторії та відеозаписи, які демонструють наш шлях та <strong>процес створення</strong> (Принцип 1)."
      },
      "gettingStarted": {
        "title": "Початок Роботи (Для Розробників)",
        "intro": "Хочете приєднатися до нас у створенні цього цифрового АКТИВУ? Ось як почати:",
        "steps": [
          "Клонуйте репозиторій:<br/>```bash<br/>git clone <URL of your repository><br/>cd BrainMessenger<br/>```",
          "Встановіть залежності:<br/>```bash<br/>npm install # Turborepo встановить залежності для всіх пакетів<br/>```",
          "Налаштуйте змінні середовища: Скопіюйте `.env.example` у `.env` та заповніть необхідні дані для інтеграцій (Neon, R2, Firebase тощо). <strong>Не коммітьте ваш файл `.env`!</strong><br/>```bash<br/>cp .env.example .env<br/># Заповніть .env<br/>```",
          "Налаштуйте базу даних: Запустіть локальний PostgreSQL або використовуйте інстанс Neon, потім застосуйте міграції Prisma.<br/>```bash<br/>cd backend<br/>npx prisma migrate dev --name initial_setup # Або npx prisma migrate deploy для продакшну<br/>cd ..<br/>```",
          "Запустіть сервіси в режимі розробки:<br/>```bash<br/>turbo run dev # Це запустить бекенд та фронтенд сервери розробки<br/># Або перейдіть до конкретних пакетів та запустіть їхні скрипти розробки:<br/># cd backend && npm run start:dev<br/># cd packages/web && npm run dev<br/># cd packages/mobile-desktop && npm run android / npm run windows<br/>```"
        ],
        "outro": "Більш детальні інструкції щодо локального налаштування та розробки можна знайти в <a href=\"link_to_development_guide_doc\" target=\"_blank\" rel=\"noopener noreferrer\">Керівництві з Розробки</a>."
      },
      "documentationSystem": {
        "title": "Документація: Наша Система Знань",
        "intro": "Цей README надає загальний огляд. Вся детальна інформація про проект міститься в нашій <strong>комплексній системі документації</strong>. Вивчення цих документів є частиною процесу <strong>навчання</strong> (Принцип 1) та розуміння <strong>системи</strong> (Принцип 9):",
        "links": [
          "<a href=\"docs/AllRequirements/Docs/Planning/DocReq.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Документація Вимог</strong></a>: Що ми будуємо (функціональні та нефункціональні вимоги).",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocDevIn.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Керівництво з Розробки</strong></a>: Як ми пишемо код (структура, стандарти, інструменти, процес CI/CD).",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocTech.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Технічна Документація</strong></a>: Високорівневий огляд архітектури та стеку.",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocSpec.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Специфікація API</strong></a>: Як компоненти взаємодіють (опис GraphQL API).",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocInt.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Документація Інтеграцій</strong></a>: Як ми використовуємо зовнішні сервіси (Neon, R2, Firebase, Stripe тощо) як <strong>важелі</strong>.",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocSecurity.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Керівництво з Безпеки</strong></a>: Як ми захищаємо АКТИВ та дані (принципи, методи, інструменти, процес).",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocPer.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Керівництво з Продуктивності</strong></a>: Як ми робимо систему швидкою (метрики, техніки, інструменти оптимізації).",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocMonLog.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Керівництво з Моніторингу та Логування</strong></a>: Як ми бачимо стан системи (метрики, логи, сповіщення).",
          "<a href=\"docs/AllRequirements/Docs/Design/Design/DocUI.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Документація UI</strong></a>: Як виглядає програма і чому (макети, компоненти, принципи дизайну).",
          "<a href=\"docs/AllRequirements/Docs/Sound/DocSound.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Аудіо Керівництво</strong></a>: Як аудіо використовується для покращення UX.",
          "<a href=\"docs/AllRequirements/Docs/Support/DocSupport.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Керівництво з Підтримки та Обслуговування</strong></a>: Як ми підтримуємо систему та користувачів після релізу.",
          "<a href=\"docs/AllRequirements/Docs/Testing/DocSpecError.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Специфікація Помилок</strong></a>: Як ми обробляємо та повідомляємо про помилки.",
          "<a href=\"docs/AllRequirements/Docs/Testing/DocTesting.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Керівництво з Тестування</strong></a>: Як ми перевіряємо якість та надійність.",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocMigrationMicro.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>План Міграції на Мікросервіси</strong></a>: Наша довгострокова стратегія архітектурної еволюції.",
          "<a href=\"docs/AllRequirements/Docs/Planning/DocReq.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Інструкція щодо Вимог MVP</strong></a>: Детальний аналіз вимог MVP та статусу реалізації."
        ]
      },
      "contribution": {
        "title": "Внесок",
        "content": "Ми вітаємо внесок у створення цього цифрового АКТИВУ! Якщо у вас є ідеї, пропозиції або ви хочете допомогти з кодом, будь ласка, зверніться до <a href=\"CONTRIBUTING.md\" target=\"_blank\" rel=\"noopener noreferrer\">Керівництва з Внеску</a> (якщо доступно)."
      }
    },
    "design": {
      "title": "Документація Дизайну BrainMessenger",
      "subtitle": "Система Якості та Цінності",
      "section1": {
        "title": "1. Вступ: Дизайн як Фундамент Цінності",
        "name": "Система Дизайну BrainMessenger",
        "description": "Ця дизайн-система визначає візуальні та функціональні стандарти для інтерфейсу BrainMessenger. Наша мета — створити інтерфейс, який не просто виглядає добре, але й є <strong>інтуїтивно зрозумілим, ефективним та доступним</strong> (Принцип 2: Створення Цінності), спираючись на принципи <strong>якості > кількості</strong> (Принцип 3) та <strong>прагматизму</strong> (Принцип 12) у виборі рішень.",
        "goal": "Забезпечити <strong>одноманітність, надійність та позитивний досвід користувача</strong> на всіх платформах (Windows, Android, веб), роблячи BrainMessenger <strong>корисним АКТИВОМ</strong> (Принцип 10) для користувачів.",
        "principles_title": "Принципи, якими керується дизайн:",
        "principles": [
          "<strong>Створення Цінності (Принцип 2):</strong> Дизайн має бути функціональним і вирішувати завдання користувача максимально зручно та ефективно.",
          "<strong>Якість > Кількість (Принцип 3):</strong> Фокус на відточеності ключових елементів, а не на безлічі непродуманих деталей. Дизайн має бути <strong>надійним</strong> та <strong>продуманим</strong>.",
          "<strong>Прагматизм та Реалізм (Принцип 12):</strong> Вибір дизайнерських рішень, що реалізуються з урахуванням технічних обмежень (наприклад, оптимізація анімацій).",
          "<strong>Цілісність (Принцип 7):</strong> Візуальна та функціональна цілісність на всіх платформах.",
          "<strong>Здоров'я як Фундамент (Принцип 5):</strong> Увага до доступності (WCAG), щоб дизайн не створював зайвого навантаження (зорового, когнітивного) на користувача."
        ]
      },
      "section2": {
        "title": "2. Колірна палітра: Візуальна мова BrainMessenger",
        "intro": "Кольори розділені для Light та Dark режимів, підтримуючи перемикання теми (функція \"Нічний режим\"). Усі кольори задані в HEX.",
        "light_mode_title": "2.1. Light Mode",
        "light_mode_table": [
          ["Категорія", "Колір (HEX)", "Призначення"],
          ["<strong>Primary Gradient</strong>", "`#A7F43A` → `#00C853`", "Основний градієнт для акцентних елементів (кнопки \"Get Started\", іконки)"],
          ["<strong>Accent</strong>", "`#FF6347`", "Акцентні елементи (помилки, важливі повідомлення)"],
          ["<strong>Secondary</strong>", "`#00BFFF`", "Другорядні кнопки, посилання, інтерактивні елементи"],
          ["<strong>Success</strong>", "`#96C93D`", "Підтвердження, успішні дії"],
          ["<strong>Background</strong>", "`#FFFFFF`", "Основний фон"],
          ["<strong>Surface</strong>", "`#F0F0F0`", "Картки, панелі, фони повідомлень"],
          ["<strong>Text Primary</strong>", "`#333333`", "Основний текст"],
          ["<strong>Text Secondary</strong>", "`#4D4D4D`", "Вторинний текст, підказки, метадані"],
          ["<strong>Disabled</strong>", "`#B0B0B0`", "Неактивні елементи"],
          ["<strong>Border</strong>", "`#E8E8D9`", "Межі, роздільники"]
        ],
        "dark_mode_title": "2.2. Dark Mode",
        "dark_mode_table": [
          ["Категорія", "Колір (HEX)", "Призначення"],
          ["<strong>Primary Gradient</strong>", "`#F2F047` → `#1ED94F`", "Основний градієнт для акцентних елементів"],
          ["<strong>Accent</strong>", "`#FF6347`", "Акцентні елементи (помилки)"],
          ["<strong>Secondary</strong>", "`#00BFFF`", "Другорядні кнопки, посилання"],
          ["<strong>Success</strong>", "`#96C93D`", "Підтвердження, успішні дії"],
          ["<strong>Background</strong>", "`#1A1A1A`", "Основний фон"],
          ["<strong>Surface</strong>", "`#333333`", "Картки, панелі, фони повідомлень"],
          ["<strong>Text Primary</strong>", "`#FFFFFF`", "Основний текст"],
          ["<strong>Text Secondary</strong>", "`#D9E8D9`", "Вторинний текст, підказки"],
          ["<strong>Disabled</strong>", "`#4D4D4D`", "Неактивні елементи"],
          ["<strong>Border</strong>", "`#B0B0B0`", "Межі, роздільники"]
        ],
        "premium_colors_title": "2.3. Кольори Преміум-Функцій (Візуальне виділення Цінності)",
        "premium_colors": [
          "<strong>Premium Accent:</strong> `#FFD600` (Золотий)",
          "<strong>Premium Secondary:</strong> `#2196F3` (Синій)",
          "Використовуються для візуального виділення преміум-функцій (наприклад, в анімаціях нейронних зв'язків, спеціальних елементах UI), підкреслюючи їх <strong>додаткову цінність</strong> (Принцип 2, 10)."
        ],
        "color_application_title": "2.4. Застосування Кольорів (Приклади)",
        "color_application": [
          {
            "title": "Welcome Screen (зі скріншота):",
            "items": [
              "Фон: `#1A1A1A` (Dark Mode).",
              "Кнопка \"Get Started\": Градієнт `#F2F047` → `#1ED94F`.",
              "Іконка чату: `#F2F047` (обведення) з білим символом всередині.",
              "Текст: `#FFFFFF` (Welcome to Brain Messenger), `#D9E8D9` (підказка)."
            ]
          },
          {
            "title": "Перемикання теми:",
            "items": [
              "Реалізовано через глобальний прапор `themeMode` (`Light`/`Dark`).",
              "Приклад у React Native:\n```jsx\nimport { useColorScheme } from 'react-native';\nconst themeMode = useColorScheme() === 'dark' ? 'Dark' : 'Light';\nconst backgroundColor = themeMode === 'Dark' ? '#1A1A1A' : '#FFFFFF'; // Приклад вибору фону\n```"
            ]
          }
        ],
        "usage_recommendations_title": "2.5. Рекомендації щодо Використання Кольорів",
        "usage_recommendations": [
          "<strong>Градієнти:</strong> Використовуйте `#A7F43A` → `#00C853` або `#F2F047` → `#1ED94F` (залежно від теми) для ключових дій та акцентних елементів, що привертають увагу до <strong>цінності</strong> (Принцип 2).",
          "<strong>Темна тема:</strong> Використовуйте `#1A1A1A` або `#212121` як основний фон для зниження навантаження на очі (зв'язок з Принципом 5: Здоров'я).",
          "<strong>Контраст:</strong> Завжди перевіряйте контрастність тексту та елементів для забезпечення <strong>доступності</strong> (WCAG 2.1 AA) та відповідності Принципу 7 (Цілісність). Використовуйте інструменти на кшталт WebAIM Contrast Checker."
        ]
      },
      "section3": {
        "title": "3. Типографіка: Читабельність як Основа Ефективності",
        "intro": "Вибір шрифту та його застосування ґрунтуються на забезпеченні максимальної читабельності та доступності, що є критично важливим для ефективного засвоєння інформації та зниження когнітивного навантаження (зв'язок з Принципом 5: Здоров'я та Принципом 2: Цінність).",
        "primary_font_title": "3.1. Основний шрифт",
        "primary_font": [
          "<strong>Сімейство:</strong> Roboto (Google Fonts)",
          "<strong>Запасний:</strong> Sans-serif",
          "<strong>Причина:</strong> Висока читабельність на різних розмірах екрану, широка підтримка символів (багатомовність), відкрита ліцензія та доступність."
        ],
        "sizes_styles_title": "3.2. Розміри та стилі (Шкала для Ієрархії)",
        "sizes_styles_table": [
          ["Рівень", "Розмір", "Начертання", "Використання"],
          ["H1 (Заголовок)", "24px", "Bold", "Основні заголовки екранів (наприклад, \"Чати\")"],
          ["H2 (Підзаголовок)", "18px", "Medium", "Другорядні заголовки, назви груп"],
          ["Body", "16px", "Regular", "Основний текст повідомлень, список чатів"],
          ["Caption", "14px", "Regular", "Підписи під фото, час повідомлень, дрібний текст"],
          ["Button", "16px", "Medium", "Текст кнопок дій"]
        ],
        "notes_title": "Примітки:",
        "notes": [
          "<strong>Висота рядка (Line Height):</strong> Мінімум 1.5 для основного тексту для покращення читабельності.",
          "<strong>Кастомізація (Принцип 2):</strong> Користувач може вибрати альтернативний шрифт у налаштуваннях (наприклад, Open Sans) для адаптації під свої вподобання.",
          "<strong>Доступність:</strong> Дотримання контрасту та мінімального розміру шрифту для відповідності WCAG."
        ]
      },
      "section4": {
        "title": "4. Анімації: Оптимізація та Зміст (Принцип 12: Прагматизм)",
        "intro": "Анімації в BrainMessenger використовуються для покращення користувацького досвіду, надання візуального зворотного зв'язку та надання інтерфейсу жвавості. Однак вони повинні бути <strong>прагматичними, оптимізованими</strong> (<2 ГБ RAM), і <strong>не створювати зайвого навантаження</strong> (зв'язок з Принципом 5: Здоров'я).",
        "principles_title": "4.1. Принципи Анімацій",
        "principles": [
          "<strong>Зміст:</strong> Кожна анімація повинна мати чітку мету – пояснити перехід, привернути увагу до важливого, підтвердити дію.",
          "<strong>Плавність:</strong> Використання `ease-in-out` або `ease-out` для натурального руху.",
          "<strong>Оптимізація:</strong> Анімації не повинні уповільнювати інтерфейс або споживати багато ресурсів. Тривалість підібрана для балансу між плавністю та швидкістю.",
          "<strong>Доступність:</strong> Уникнення занадто швидких або миготливих анімацій, які можуть викликати дискомфорт або напади у чутливих користувачів."
        ],
        "list_title": "4.2. Список Анімацій (Приклади)",
        "list_table": [
          ["Назва", "Опис", "Тригер", "Параметри", "Зв'язок з Принципами", "Кольори (Light/Dark)"],
          ["Перемикання слайдів", "Зсув слайдів (Welcome Screen)", "Свайп/клік по стрілці", "0.3 сек, slide left/right", "P2 (Онбординг)", "#96C93D / #96C93D"],
          ["Відкриття чату", "Чат з'являється знизу вгору", "Клік по чату в списку", "0.3 сек, ease-in-out", "P2 (Навігація)", "#00BFFF / #00BFFF"],
          ["Натискання кнопки", "Візуальний фідбек при кліку (зменшення)", "Клік по кнопці", "0.2 сек, scale", "P2 (Фідбек)", "Градиент #F2F047→#1ED94F"],
          ["Надсилання повідомлення", "Повідомлення з'являється з плавним згасанням", "Клік \"Відправити\"", "0.3 сек, fade-in", "P2 (Фідбек)", "#96C93D / #96C93D"],
          ["Перехід між екранами", "Зсув екрану вправо/вліво (базова навігація)", "Навігація", "0.3 сек, slide", "P2 (Навігація)", "#B0B0B0 / #4D4D4D"],
          ["Анімація іконок (Morph)", "Перетворення іконки (наприклад, mute → unmute)", "Клік (перемикання стану)", "0.4 сек, morph", "P2 (Стан)", "#FF6347 / #FF6347"],
          ["Хвилі при натисканні (Ripple)", "Радіальні хвилі від точки натискання (фідбек)", "Клік по кнопці/елементу", "0.3 сек, ripple", "P2 (Фідбек)", "#F2F047 / #F2F047"],
          ["Глітч-ефект (Premium)", "Спотворення тексту для преміум (візуалізація)", "Активація підписки", "0.2 сек, glitch", "P2, P10 (Виділення)", "#FF6347 / #FF6347"],
          ["Нейронні зв'язки (Premium)", "Пульсуючі лінії (візуалізація Активу)", "Преміум-екран", "0.5 сек, pulse", "P2, P10 (Виділення)", "#96C93D / #96C93D"]
        ],
        "implementation_examples_title": "4.3. Приклади Реалізації (Фрагменти коду)",
        "css_ripple_title": "CSS для Ripple-ефекту:",
        "css_ripple_code": ".ripple {\n  background: linear-gradient(45deg, #F2F047, #1ED94F); /* Або інші кольори/градієнт */\n  border-radius: 50%;\n  animation: ripple 0.3s ease-out;\n}\n@keyframes ripple {\n  to { transform: scale(2); opacity: 0; }\n}",
        "rn_icon_title": "React Native для анімованої іконки:",
        "rn_icon_code": "import Animated from 'react-native-reanimated'; // Приклад бібліотеки\nimport Icon from 'react-native-vector-icons/MaterialIcons'; // Приклад бібліотеки\n\nconst color = themeMode === 'Dark' ? '#FFFFFF' : '#333333';\n// Створення анімованого компонента Icon\nconst AnimatedIcon = Animated.createAnimatedComponent(Icon);\n\n// Приклад використання з анімацією scale (припускаючи, що 'scale' - це Animated.Value)\n<AnimatedIcon name=\"volume-up\" color={color} style={{ transform: [{ scale: scale }] }} />"
      },
      "section5": {
        "title": "5. Вирівнювання та Сітка: Структура та Порядок (Принцип 9: Система)",
        "intro": "Використання послідовної системи вирівнювання та модульної сітки — це основа для створення <strong>системного, легко підтримуваного та візуально гармонійного</strong> інтерфейсу (Принцип 9: Система).",
        "base_grid": "<strong>Базова Сітка:</strong> 8px (базовий крок для визначення розмірів елементів, відступів, інтервалів). Усі значення повинні бути кратні 8 (або 4 для дуже дрібних елементів).",
        "alignment_title": "<strong>Вирівнювання:</strong>",
        "alignment": [
          "Використовується принцип <strong>візуальної ієрархії</strong>: важливіші елементи розташовуються вище або візуально домінують.",
          "<strong>Вертикальний потік:</strong> Контент на екранах організовується зверху вниз: Заголовок → Поле введення → Кнопка дії.",
          "<strong>Горизонтальне вирівнювання:</strong> Елементи в контейнерах вирівнюються за лівим краєм (для LTR) або правим краєм (для RTL), якщо немає необхідності в центруванні (наприклад, заголовки в шапці).",
          "<strong>Відступи (Padding/Margin):</strong> Використовуються значення зі шкали, кратної 8px (8, 16, 24, 32, 40, 48 px тощо) для створення чітких інтервалів між елементами та групами елементів."
        ],
        "adaptability_title": "<strong>Адаптивність та Чуйність:</strong>",
        "adaptability": [
          "Дизайн адаптується під різні розміри екрану для забезпечення <strong>цінності</strong> (Принцип 2) на будь-якому пристрої.",
          "<strong>Мобільні пристрої:</strong> 320px–767px (Зазвичай одноколонковий макет).",
          "<strong>Планшети:</strong> 768px–1023px (Можливо, двоколонковий макет, бічні панелі).",
          "<strong>Десктоп:</strong> 1024px+ (Широкий макет, багатоколонковий дизайн, бічні панелі)."
        ]
      },
      "section6": {
        "title": "6. Принципи Доступності (WCAG 2.1 AA): Дизайн для Всіх (Принцип 5: Здоров'я, Принцип 7: Цілісність)",
        "intro": "<strong>Доступність — це не опція, а фундаментальна вимога</strong> (схоже з Принципом 5: Здоров'я як Фундамент) для створення <strong>цілісного</strong> (Принцип 7) та <strong>цінного</strong> (Принцип 2) продукту, яким можуть користуватися всі, незалежно від їхніх здібностей або використовуваних технологій. Ми прагнемо відповідати рівню WCAG 2.1 AA.",
        "principles": [
          "<strong>Контрастність Кольорів:</strong> Текстові елементи повинні мати мінімальний контраст 4.5:1 (для звичайного тексту) та 3:1 (для великого тексту або іконок) по відношенню до фону. Це перевіряється для обох тем (Light/Dark).",
          "<strong>Навігація з Клавіатури:</strong> Усі інтерактивні елементи (кнопки, посилання, поля введення) повинні бути доступними для навігації за допомогою клавіатури (Tab, Shift+Tab) та активації (Enter, Space).",
          "<strong>Підтримка Екранних Читалок (Screen Readers):</strong> Використання семантичної розмітки (HTML) та ARIA-атрибутів для надання контексту та інформації користувачам екранних читалок (наприклад, описи для іконок, стани елементів).",
          "<strong>Візуальний Індикатор Фокусу:</strong> Для користувачів клавіатури має бути чіткий та видимий індикатор поточного сфокусованого елемента (наприклад, синя обводка `#007BFF`).",
          "<strong>Обробка Помилок:</strong> Повідомлення про помилки повинні бути чіткими, зрозумілими та легко визначальними користувачами, включаючи користувачів екранних читалок.",
          "<strong>Підтримка RTL (Справа Наліво):</strong> Дизайн адаптується для мов з напрямком письма справа наліво (наприклад, арабська), включаючи дзеркальне відображення макета, іконок та тексту (див. DocLocIn.md)."
        ]
      },
      "section7": {
        "title": "7. Примітки та Рекомендації",
        "notes": [
          "<strong>Кастомізація Користувачем:</strong> Пам'ятайте, що деякі аспекти дизайну (кольори чатів, шрифти) користувач може змінювати в налаштуваннях. Дизайн системи має враховувати цю гнучкість.",
          "<strong>Тестування на Реальних Пристроях:</strong> Усі компоненти дизайну необхідно тестувати на різноманітних пристроях, з різними роздільними здатностями екрану та в різних умовах освітлення, щоб переконатися в їх ефективності та доступності.",
          "<strong>Жива Документація:</strong> Ця дизайн-система — живий документ. Вона буде доповнюватися новими компонентами, шаблонами та рекомендаціями в міру розвитку продукту, відображаючи принципи <strong>безперервного вдосконалення</strong> (Принцип 1) та <strong>системного підходу</strong> (Принцип 9).",
          "<strong>Дизайн як частина Процесу Кайдзен:</strong> Дизайн-рішення аналізуються та покращуються на основі зворотного зв'язку та реального використання, інтегруючись у загальний процес Кайдзен (Принцип 9, 14)."
        ]
      }
    },
    "localizationGuide": {
      "title": "Руководство по Локализации BrainMessenger",
      "subtitle": "Доступность и Масштабирование",
      "section1": {
        "title": "1. Введение: Расширение Ценности через Доступность",
        "name": "BrainMessenger Design System",
        "description": "Это руководство описывает процесс локализации BrainMessenger — ключевой шаг для обеспечения доступности и ценности (Принцип 2) продукта для широкой аудитории по всему миру. Мы рассматриваем локализацию не просто как перевод строк, а как систематический процесс (Принцип 9) адаптации интерфейса и контента, который позволит нам масштабировать наше влияние (Принцип 2, 8).",
        "goal": "Сделать BrainMessenger понятным и удобным для пользователей из разных культур, начиная с базового набора языков и создавая надежную систему (Принцип 9) для легкого добавления новых в будущем.",
        "current_status": "Базовая поддержка английского языка (MVP). Идет планирование и подготовка к добавлению новых языков в рамках текущих этапов разработки (см. Дорожную карту).",
        "principles_title": "Принципы, которыми руководствуется локализация:",
        "principles": [
          "Создание Ценности (Принцип 2): Локализация напрямую повышает ценность продукта для неанглоязычных пользователей.",
          "Система и Оптимизация (Принцип 9): Процесс локализации строится как четкая, повторяемая система для эффективности.",
          "Прагматизм и Реализм (Принцип 12): Выбор начального набора языков основывается на потенциальном охвате и ресурсах.",
          "Внешняя Экспертиза и Обратная Связь (Принцип 14): Привлечение профессиональных переводчиков и сбор обратной связи от пользователей на разных языках."
        ]
      },
      "section2": {
        "title": "2. Цели Локализации",
        "goals": [
          "Обеспечить поддержку минимум 5 ключевых языков (Английский, Испанский, Французский, Русский, Арабский) для старта MVP — (Требование NFR-11, соответствующее Принципу 12: Прагматизм).",
          "Реализовать адаптацию пользовательского интерфейса для языков с направлением письма справа налево (RTL), таких как арабский (Принцип 2: Доступность).",
          "Поддерживать единообразие терминологии и стиля во всех переводах, используя централизованные инструменты (Принцип 9: Система).",
          "Создать эффективный и простой процесс добавления новых языков по мере роста базы пользователей и поступления запросов (Принцип 9: Масштабирование, Принцип 12: Прагматизм, Принцип 14: Обратная связь)."
        ]
      },
      "section3": {
        "title": "3. Инструменты и Технологии: Надежный Фундамент (Принцип 8, 9)",
        "intro": "Выбор инструментов основан на прагматизме (Принцип 12), надежности и поддержке системного подхода (Принцип 9).",
        "tools_table": [
          ["Инструмент", "Назначение", "Установка/Конфигурация"],
          ["i18next", "Основная библиотека для управления переводами в Frontend (React Native). Поддерживает интерполяцию, контексты.", "npm install i18next react-i18next"],
          ["react-intl", "Библиотека для локализованного форматирования дат, чисел, валют в Frontend.", "npm install react-intl"],
          ["Transifex", "Профессиональная платформа для управления переводами, привлечения переводчиков и обеспечения качества перевода.", "Регистрация на transifex.com"],
          ["rtlcss", "Утилита для автоматической трансформации CSS-стилей для поддержки RTL-языков.", "npm install -g rtlcss (глобально) или npm install rtlcss --save-dev"],
          ["JSON файлы", "Формат хранения переводов.", "Стандартный."]
        ]
      },
      "section4": {
        "title": "4. Структура Файлов Переводов: Порядок в Системе (Принцип 9)",
        "intro": "Переводы организованы в четкой файловой структуре для удобства управления (Принцип 9: Система).",
        "location_title": "4.1. Расположение",
        "location_content": "Файлы переводов хранятся в директории locales внутри frontend/src:\n\nfrontend/\n├── src/\n│ ├── locales/\n│ │ ├── en.json # Английский (базовый)\n│ │ ├── es.json # Испанский\n│ │ ├── fr.json # Французский\n│ │ ├── ru.json # Русский\n│ │ ├── ar.json # Арабский (пример RTL)\n│ └── index.ts # Конфигурация i18next",
        "format_title": "4.2. Формат JSON: Контекст и Гибкость",
        "format_content": "Ключи: Используется camelCase. Ключи должны быть описательными и отражать контекст использования строки (например, sendButton вместо просто send).\n\nЗначения: Содержат переводимый текст. Поддерживается интерполяция для вставки динамических данных (например, имена пользователей).",
        "format_example": "Пример en.json:\n\n```json\n{\n  \"welcomeTitle\": \"Welcome to BrainMessenger!\",\n  \"sendButton\": \"Send\",\n  \"errors\": {\n    \"unauthorized\": \"Please log in again to continue.\",\n    \"notFound\": \"The requested item could not be found.\"\n  },\n  \"chat\": {\n    \"newMessageNotification\": \"New message from {{name}}\",\n    \"unreadCount\": \"{{count}} unread messages\"\n  },\n  \"settings\": {\n    \"language\": \"Language\",\n    \"theme\": \"Theme\"\n  }\n}\n```",
        "rtl_flag_title": "4.3. RTL-флаг: Адаптация Интерфейса",
        "rtl_flag_content": "Для языков с направлением справа налево в начало соответствующего JSON-файла добавляется метаданные для индикации:",
        "rtl_flag_example": "```json\n{\n  \"rtl\": true,\n  \"welcomeTitle\": \"مرحبًا بك في BrainMessenger!\"\n  // ... остальные переводы\n}\n```\n\nЭтот флаг используется Frontend-приложением для соответствующей адаптации стилей и макета."
      },
      "section5": {
        "title": "5. Настройка Локализации: Интеграция в Систему (Принцип 9)",
        "intro": "Локализация интегрируется как в Frontend (для отображения переведенного UI), так и в Backend (для возврата локализованных ошибок или уведомлений).",
        "frontend_title": "5.1. Frontend (React Native): Использование i18next",
        "frontend_init_title": "Инициализация i18next:",
        "frontend_init_code": "В главном файле приложения или файла конфигурации (frontend/src/index.ts или подобном):\n\n```jsx\nimport i18n from 'i18next'\nimport { initReactI18next } from 'react-i18next'\n\n// Импорт всех файлов локалей\nimport en from './locales/en.json'\nimport es from './locales/es.json'\nimport fr from './locales/fr.json'\nimport ru from './locales/ru.json'\nimport ar from './locales/ar.json'\n\n// Определение ресурсов\nconst resources = {\n  en: { translation: en },\n  es: { translation: es },\n  fr: { translation: fr },\n  ru: { translation: ru },\n  ar: { translation: ar },\n};\n\ni18n\n  .use(initReactI18next) // Подключение react-i18next\n  .init({\n    resources,\n    lng: 'en', // Язык по умолчанию при первом запуске (может определяться по системным настройкам или выбору пользователя)\n    fallbackLng: 'en', // Резервный язык, если текущий перевод отсутствует\n    interpolation: {\n      escapeValue: false // Позволяет использовать HTML теги в переводах (осторожно!)\n    }\n  });\n\nexport default i18n;\n```",
        "frontend_usage_title": "Использование перевода в компонентах:",
        "frontend_usage_code": "Используйте хук useTranslation для доступа к функции t и объекту i18n.\n\n```jsx\nimport { useTranslation } from 'react-i18next';\nimport { Text, Button, View } from 'react-native';\n\nconst WelcomeScreen = () => {\n  const { t, i18n } = useTranslation(); // Получаем функцию t и объект i18n\n\n  return (\n    <View>\n      {/* Использование простого перевода */}\n      <Text>{t('welcomeTitle')}</Text>\n      \n      {/* Использование перевода с интерполяцией */}\n      {/* Предполагается, что где-то есть состояние unreadCount */}\n      <Text>{t('chat.unreadCount', { count: 5 })}</Text> \n\n      {/* Использование перевода для текста кнопки */}\n      <Button title={t('sendButton')} onPress={sendMessage} />\n      \n      {/* Пример смены языка */}\n      <Button title={t('settings.language')} onPress={() => i18n.changeLanguage('ar')} />\n    </View>\n  );\n};\n```",
        "frontend_change_title": "Смена языка:",
        "frontend_change_content": "Язык меняется вызовом i18n.changeLanguage('код_языка'). Обычно это делается в настройках пользователя.",
        "backend_title": "5.2. Backend (NestJS): Локализация Ошибок и Уведомлений",
        "backend_intro": "Backend может возвращать локализованные сообщения об ошибках или уведомления, опираясь на язык, переданный Frontend (например, в заголовке Accept-Language или настройках пользователя).",
        "backend_code": "Использование локализованных сообщений при выбрасывании ошибок:\n\n```typescript\nimport { HttpException, HttpStatus } from '@nestjs/common';\nimport { t } from 'i18next'; // Предполагается, что i18next инициализирован и в Backend\n\n// В сервисе или контроллере\nif (!user) {\n  // Определяем язык пользователя (например, из request.headers['accept-language'])\n  const userLang = determineUserLanguage(request); \n  throw new HttpException(t('errors.unauthorized', { lng: userLang }), HttpStatus.UNAUTHORIZED);\n}\n```",
        "backend_note": "Локаль пользователя определяется из заголовка Accept-Language (стандартный подход) или сохраняется в профиле пользователя в базе данных после его выбора в настройках приложения.",
        "rtl_adaptation_title": "5.3. RTL-адаптация (Справа Налево): Зеркальное Отображение Системы",
        "rtl_adaptation_intro": "Для языков с RTL (арабский, иврит и др.) необходимо зеркально отобразить макет и некоторые элементы интерфейса.",
        "rtl_css_title": "Стили (CSS/CSS-in-JS):",
        "rtl_css_code": "Используйте rtlcss в процессе сборки или условные стили в коде. rtlcss автоматически преобразует свойства вроде margin-left, padding-right, text-align: left и т.п. в их RTL-эквиваленты (margin-right, padding-left, text-align: right).\n\n```css\n/* Исходный CSS для LTR */\n.message-bubble {\n  margin-left: 10px;\n  text-align: left;\n}\n/* После обработки rtlcss для RTL */\n.message-bubble {\n  margin-right: 10px;\n  text-align: right;\n}\n```",
        "rtl_rn_title": "React Native:",
        "rtl_rn_code": "React-Native имеет встроенную поддержку RTL через I18nManager.\n\n```jsx\nimport { I18nManager } from 'react-native';\nimport i18n from './index'; // Ваш файл инициализации i18next\n\n// В главном файле приложения, перед рендером\nconst isRTL = i18n.language === 'ar' || i18n.language === 'he'; // Проверяем, является ли текущий язык RTL\n\n// ForceRTL может потребовать перезагрузки приложения для полной силы\nif (isRTL !== I18nManager.isRTL) {\n  I18nManager.forceRTL(isRTL);\n  // Optional: Restart the app to apply RTL layout fully\n  // RNRestart.Restart(); \n}\n\n// Некоторые стили могут требовать ручной адаптации, если auto-conversion недостаточно\nconst containerStyle = {\n  flexDirection: isRTL ? 'row-reverse' : 'row',\n  textAlign: isRTL ? 'right' : 'left',\n};\n```",
        "rtl_icons_title": "Иконки:",
        "rtl_icons_content": "Некоторые иконки (например, стрелки \"назад\", \"далее\") должны быть зеркально отображены для RTL. Это можно делать условно в коде или использовать RTL-ready наборы иконок."
      },
      "section6": {
        "title": "6. Процесс Добавления Нового Языка: Масштабируемая Система (Принцип 9)",
        "intro": "Процесс добавления нового языка построен как четкая, повторяемая последовательность действий для обеспечения эффективности (Принцип 9).",
        "file_title": "Создание базового файла перевода:",
        "file_content": "Скопируйте актуальный en.json (или другой наиболее полный файл) в frontend/src/locales/<code>.json, где <code> — двухбуквенный код нового языка (например, de.json для немецкого).\nДобавьте rtl: true в начало файла, если новый язык RTL.",
        "transifex_title": "Загрузка на платформу переводов (Transifex):",
        "transifex_content": "Загрузите новый файл <code>.json в проект BrainMessenger на Transifex. Система автоматически определит, какие строки нуждаются в переводе.",
        "process_title": "Организация процесса перевода:",
        "process_content": "Назначьте переводчиков (профессионалов или проверенных участников сообщества, Принцип 14) для нового языка в Transifex.\nОтвечайте на их вопросы по контексту строк.\nКонтролируйте прогресс перевода в Transifex.",
        "export_title": "Экспорт и Интеграция перевода:",
        "export_content": "После завершения перевода экспортируйте готовый файл <code>.json из Transifex.\nПоместите его обратно в директорию frontend/src/locales/.\nИмпортируйте новый ресурс в файле инициализации i18next (frontend/src/index.ts) и добавьте его в объект resources.",
        "ui_title": "Добавление опции выбора языка в UI:",
        "ui_content": "Добавьте новый язык в список доступных языков в разделе \"Настройки\" > \"Язык\".",
        "testing_title": "Тестирование:",
        "testing_intro": "Критически важный шаг (Принцип 3: Качество). Переключите язык в настройках приложения.",
        "testing_scenarios": [
          "Корректность перевода всех строк в UI.",
          "Отсутствие обрезки текста (некоторые языки длиннее английского).",
          "Корректное отображение UI для RTL-языков (зеркальность, выравнивание).",
          "Интерполяция и Форматирование: Проверьте экраны, где используются динамические данные (имена, счетчики, даты, числа), убедитесь, что они форматируются правильно для текущей локали.",
          "Локализованные ошибки: Инициируйте различные ошибки (неправильный логин, отсутствие элемента), проверьте, что сообщения об ошибках приходят на выбранном языке."
        ]
      },
      "section7": {
        "title": "7. Поддерживаемые Языки (Начальный Список и План)",
        "intro": "Начальный список языков, выбранный по прагматическим соображениям (Принцип 12) и потенциальному охвату.",
        "languages_table": [
          ["Код", "Язык", "Направление", "Статус", "План (Q 2025)"],
          ["en", "Английский", "LTR", "Реализован (Базовый)", "-"],
          ["es", "Испанский", "LTR", "В плане (Q3)", "Q3"],
          ["fr", "Французский", "LTR", "В плане (Q3)", "Q3"],
          ["ru", "Русский", "LTR", "В плане (Q3)", "Q3"],
          ["ar", "Арабский", "RTL", "В плане (Q3, требуется RTL)", "Q3"]
        ],
        "expansion_note": "Расширение списка: Новые языки будут добавляться на основе обратной связи (Принцип 14) и анализа потенциальной ценности (Принцип 2) для роста аудитории (например, если >10% запросов о поддержке нового языка)."
      },
      "section8": {
        "title": "8. Рекомендации: Лучшие Практики Локализации",
        "dev_title": "8.1. Для Разработчиков (Пишем Код, Готовый к Миру)",
        "dev_points": [
          "Не хардкодьте строки! Все строки, которые видит пользователь, должны быть вынесены в файлы локализации и использоваться через функцию t('ключ') (Принцип 9: Система).",
          "Используйте интерполяцию для строк с переменными данными (t('chat.newMessageNotification', { name: user.name })), а не конкатенацию строк в коде.",
          "Учитывайте плюрализацию (формы единственного/множественного числа) при работе со счетчиками ({{count}} unread messages). i18next и react-intl поддерживают это.",
          "Используйте react-intl для всех операций с датами, числами, валютами, чтобы их формат был корректным для каждой локали (Принцип 3: Качество, Принцип 2: Ценность).",
          "Тестируйте UI с длинными переводами (например, немецкий, который часто длиннее английского) и RTL-языками, чтобы убедиться, что макет не ломается и текст не обрезается (Принцип 3: Качество)."
        ],
        "design_title": "8.2. Для Дизайнеров (Рисуем Макеты, Гибкие к Языкам)",
        "design_points": [
          "Учитывайте, что текст на других языках может быть на 30% (и более) длиннее английского. Оставляйте достаточно пространства в компонентах.",
          "Проектируйте макеты с учетом зеркального отображения для RTL. Иконки направлений, расположение текста и элементов должны меняться (Принцип 2: Доступность)."
        ],
        "translator_title": "8.3. Для Переводчиков (Создаем Понятный Контент)",
        "translator_points": [
          "Сохраняйте контекст. Одно и то же английское слово может переводиться по-разному в зависимости от того, где оно используется (например, \"Send\" для сообщения или для заявки). Платформы вроде Transifex помогают добавлять контекстные комментарии.",
          "Придерживайтесь последовательной терминологии, используйте глоссарий, если он есть.",
          "Сохраняйте тон приложения (дружелюбный, но профессиональный, особенно в системных сообщениях и ошибках).",
          "Используйте возможности интерполяции и плюрализации в файлах перевода."
        ]
      },
      "section9": {
        "title": "9. Форматирование (Даты, Числа, Валюты): Детали, Создающие Качество (Принцип 3)",
        "intro": "Корректное отображение локализованных данных критически важно для качества (Принцип 3) и удобства (Принцип 2).",
        "dates_title": "Даты и Время:",
        "dates_code": "```jsx\nimport { FormattedDate, FormattedTime } from 'react-intl';\n\n// Отобразит дату в формате, соответствующем текущей локали\n<FormattedDate value={new Date()} /> // Например, \"3/14/2025\" (en-US) или \"14.3.2025\" (de-DE)\n<FormattedDate value={new Date()} weekday=\"long\" year=\"numeric\" month=\"long\" day=\"numeric\" /> // \"Friday, March 14, 2025\"\n\n// Отобразит время\n<FormattedTime value={new Date()} /> // Например, \"3:00:00 PM\" (en-US) или \"15:00:00\" (de-DE)\n```",
        "numbers_title": "Числа и Валюты:",
        "numbers_code": "```jsx\nimport { FormattedNumber, FormattedCurrency } from 'react-intl';\n\n// Отобразит число с локальным разделителем тысяч и десятичным знаком\n<FormattedNumber value={1234.56} /> // \"1,234.56\" (en-US) или \"1.234,56\" (de-DE)\n\n// Отобразит число как процент\n<FormattedNumber value={0.75} style=\"percent\" /> // \"75%\"\n\n// Отобразит число как валюту (требует кода валюты)\n<FormattedCurrency value={123.45} currency=\"USD\" /> // \"$123.45\" (en-US)\n```\n\nДля работы с react-intl необходимо обернуть ваше приложение в IntlProvider и загрузить соответствующие данные локали (react-intl/locale-data)."
      },
      "section10": {
        "title": "10. Тестирование Локализации: Гарантия Качества (Принцип 3, 9)",
        "intro": "Тестирование — неотъемлемая часть системы обеспечения качества (Принцип 3, 9).",
        "scenarios_title": "Сценарии Тестирования:",
        "scenarios_points": [
          "Переключение языка: Убедитесь, что смена языка в настройках мгновенно (или после перезапуска, если требуется I18nManager) применяет новый перевод и RTL-макет.",
          "Отображение всех строк: Проверьте основные экраны и диалоги, чтобы убедиться, что все видимые пользователю строки переведены.",
          "Длинный текст: Проверьте UI с языками, известными своей длиной (например, немецкий, русский), чтобы убедиться, что текст не обрезается, элементы не накладываются друг на друга.",
          "RTL-интерфейс: Тщательно проверьте UI на арабском (или другом RTL-языке): направление текста, выравнивание элементов, отображение иконок направлений, положение скроллбаров.",
          "Интерполяция и Форматирование: Проверьте экраны, где используются динамические данные (имена, счетчики, даты, числа), убедитесь, что они форматируются правильно для текущей локали.",
          "Локализованные ошибки: Инициируйте различные ошибки (неправильный логин, отсутствие элемента), проверьте, что сообщения об ошибках приходят на выбранном языке."
        ],
        "tools_title": "Инструменты:",
        "tools_points": [
          "Ручное тестирование: Основной метод. Тестирование на реальных устройствах с разными локалями.",
          "Автоматизированные тесты (Cypress/detox): Можно написать тесты, которые проверяют наличие определенных ключей перевода на странице или даже делают скриншоты UI для сравнения LTR/RTL макетов (Принцип 9: Система)."
        ],
        "criteria_title": "Критерии Успеха Тестирования:",
        "criteria_points": [
          "100% пользовательских строк переведены.",
          "Отсутствие обрезки или наложения текста в UI.",
          "Корректное и полное RTL-отображение для соответствующих языков.",
          "Правильное локализованное форматирование дат, чисел, валют."
        ]
      },
      "section11": {
        "title": "11. Примечания",
        "notes": [
          "План: Полная реализация поддержки 5 ключевых языков запланирована на Q3 2025 (см. Дорожную карту), после завершения этапа построения технологического фундамента и начала разработки MVP.",
          "Масштабирование: Система разработана так, чтобы добавление новых языков в будущем было эффективным (Принцип 9). Основные затраты — это сам перевод.",
          "Ограничения: Технические логи, сообщения сервера для отладки не переводятся. Локализация касается только пользовательского интерфейса и сообщений, предназначенных для конечного пользователя."
        ]
      }
    },
    "userGuide": {
      "title": "Посібник користувача BrainMessenger",
      "subtitle": "Ваш центр для ефективного спілкування та зростання",
      "introduction": {
        "title": "1. Вступ: Ласкаво просимо до Вашої системи взаємодії",
        "p1": "<strong>Ласкаво просимо до BrainMessenger!</strong>",
        "p2": "BrainMessenger — це не просто месенджер, а <strong>ваша особиста система</strong> для безпечного, зручного та <strong>ефективного спілкування і взаємодії</strong> (Принцип 2: Створення цінності, Принцип 9: Система). Ми створили цей <strong>цифровий АКТИВ</strong> (Принцип 10), щоб <strong>спростити складність</strong> (Маргулан), надаючи вам надійний інструмент для зв'язку з іншими та організації вашого спілкування.",
        "p3": "Цей посібник — ваш компас у світі BrainMessenger. Він структурований так, щоб ви могли швидко освоїти ключові функції та використовувати додаток максимально <strong>ефективно</strong> (Принцип 9).",
        "p4": "<strong>Для кого:</strong> BrainMessenger розроблений для широкої аудиторії та доступний на всіх основних платформах: iOS (версія 13+), Android (версія 9+), а також повноцінна веб-версія для сучасних браузерів (Chrome, Firefox, Safari, Edge). Ми прагнемо до максимальної <strong>доступності</strong> (Принцип 5) для кожного.",
        "p5": "<strong>Як почати:</strong> Найбільш <strong>прагматичний</strong> (Принцип 12) спосіб — встановити додаток з відповідного магазину додатків або відкрити веб-сайт `https://brainmessenger.com`."
      },
      "gettingStarted": {
        "title": "2. Початок роботи: Перші кроки в системі BrainMessenger",
        "p1": "Ваш процес реєстрації та входу в систему розроблений як <strong>проста та безпечна система</strong> (Принцип 9, 5).",
        "registration": {
          "title": "2.1. Реєстрація: Створення Вашого профілю в системі",
          "steps": [
            "1. Відкрийте додаток або перейдіть на веб-сайт.",
            "2. Натисніть кнопку <strong>\"Почати\"</strong> (Зареєструватися) на екрані привітання.",
            "3. Дотримуйтесь покрокових інструкцій:",
            "<strong>Введіть Email:</strong> Ваша активна електронна адреса (наприклад, `user@example.com`). Вона буде використовуватися для сповіщень, входу та відновлення доступу. Переконайтеся, що формат електронної пошти правильний.",
            "<strong>Створіть Пароль:</strong> Придумайте <strong>надійний пароль</strong> (мінімум 8 символів, включаючи хоча б одну цифру та один спеціальний символ, наприклад, `MyStrongP@ss!1`). Безпека вашого облікового запису є частиною нашої <strong>основи</strong> (Принцип 5, 8).",
            "<strong>Введіть Ім'я:</strong> Ваше відображуване ім'я в BrainMessenger.",
            "<strong>Підтвердіть Email:</strong> Ми надішлемо 8-значний код підтвердження на вказаний Email (див. API Specification, DocInt). Перевірте пошту (в тому числі папку \"Спам\"). Введіть код у додатку.",
            "4. Натисніть кнопку підтвердження на кожному кроці."
          ],
          "result": "*Результат:* Ваш обліковий запис успішно створено. Ви стаєте частиною <strong>системи BrainMessenger</strong>."
        },
        "login": {
          "title": "2.2. Вхід: Доступ до Вашої мережі взаємодії",
          "steps": [
            "1. На екрані привітання виберіть <strong>\"Увійти\"</strong> (Sign In).",
            "2. Введіть зареєстрований email та пароль.",
            "3. Натисніть <strong>\"Увійти\"</strong> (Sign In)."
          ],
          "note": "*Примітка:* Якщо у вас увімкнено двофакторну автентифікацію (2FA) для додаткової безпеки (див. розділ 3.5), вам потрібно буде ввести додатковий код, отриманий електронною поштою, після введення пароля."
        },
        "logout": {
          "title": "2.3. Вихід: Завершення Вашої поточної сесії",
          "steps": [
            "1. Відкрийте головне меню (зазвичай значок \"гамбургер\" або ваш аватар у верхньому куті).",
            "2. Перейдіть до розділу <strong>\"Налаштування\"</strong>.",
            "3. Прокрутіть униз і виберіть <strong>\"Вийти\"</strong>.",
            "4. Підтвердіть свою дію, якщо потрібно."
          ]
        }
      },
      "mainFunctions": {
        "title": "3. Ключові функції: Інструменти для ефективного спілкування (Принцип 2)",
        "p1": "BrainMessenger надає набір <strong>інструментів</strong> (Принцип 10) для різних типів спілкування, орієнтованих на надання вам <strong>цінності</strong> (Принцип 2).",
        "chatsAndMessages": {
          "title": "3.1. Чати та повідомлення: Ваш особистий простір системи комунікації",
          "sections": [
            "<strong>Перегляд чатів:</strong> На головному екрані відображається <strong>систематично організований</strong> (Принцип 9) список усіх ваших чатів (особисті, групові, канали). Чати з новими повідомленнями завжди знаходяться зверху.",
            "<strong>Створення нового чату:</strong>",
            "1. Натисніть на піктограму <strong>\"+\"</strong> (зазвичай у верхньому правому куті).",
            "2. Виберіть <strong>\"Новий чат\"</strong> або \"Нова група\", \"Новий канал\".",
            "3. Виберіть контакти або додайте учасників, вкажіть ім'я (для груп/каналів).",
            "4. Натисніть <strong>\"Створити\"</strong>.",
            "<strong>Надсилання повідомлення:</strong>",
            "1. Відкрийте потрібний чат.",
            "2. Введіть текст у поле введення повідомлення внизу.",
            "3. Натисніть піктограму <strong>\"Надіслати\"</strong>.",
            "<strong>Надсилання файлів:</strong>",
            "1. У полі введення повідомлення натисніть піктограму скріпки.",
            "2. Виберіть файл (фото, відео, документ). Максимальний розмір файлу для завантаження — 100 МБ.",
            "3. Натисніть <strong>\"Надіслати\"</strong>. Файли безпечно зберігаються в Cloudflare R2 (див. DocInt).",
            "<strong>Пошук чатів та повідомлень:</strong> Використовуйте рядок пошуку у верхній частині головного екрана. Пошук швидкий та <strong>ефективний</strong> (Принцип 9).",
            "<strong>Архівування чатів:</strong> Щоб видалити чат з основного списку, не видаляючи його, проведіть по ньому ліворуч (на мобільному пристрої) або скористайтеся контекстним меню та виберіть <strong>\"Архівувати\"</strong>. Доступ до архіву здійснюється через головне меню. Частина вашої <strong>системи організації</strong> робочого простору (Принцип 9)."
          ]
        },
        "calls": {
          "title": "3.2. Дзвінки та відеодзвінки: Пряма взаємодія",
          "sections": [
            "<strong>Почати дзвінок:</strong> У відкритому чаті натисніть на піктограму телефону (аудіо) або камери (відео).",
            "<strong>Конференції:</strong> Створіть груповий чат і використовуйте функцію \"Почати дзвінок\".",
            "<strong>Історія дзвінків:</strong> Перегляньте список усіх минулих дзвінків у розділі <strong>\"Дзвінки\"</strong> головного меню.",
            "<strong>Налаштування якості:</strong> Під час дзвінка ви можете вибрати якість відео/аудіо (низька, середня, висока) для <strong>прагматичного</strong> (Принцип 12) використання інтернет-трафіку."
          ]
        },
        "filesAndMedia": {
          "title": "3.3. Файли та медіа: Централізований доступ до обміну",
          "sections": [
            "<strong>Перегляд файлів з чату:</strong> У відкритому чаті перейдіть до інформації про чат (натисніть на ім'я/аватар у заголовку) та виберіть розділ <strong>\"Медіа\"</strong>. Тут зібрані всі файли, якими ви обмінювалися в цьому чаті. Ви можете фільтрувати їх за типом."
          ]
        },
        "contacts": {
          "title": "3.4. Контакти: Керування Вашою мережею зв'язків",
          "sections": [
            "<strong>Список контактів:</strong> Доступний у розділі <strong>\"Контакти\"</strong> головного меню.",
            "<strong>Пошук та додавання:</strong> Шукайте існуючих користувачів або додавайте нових за email/номером телефону."
          ]
        },
        "settings": {
          "title": "3.5. Налаштування: Адаптація системи під себе (Принцип 2)",
          "p1": "Розділ \"Налаштування\" дозволяє вам персоналізувати BrainMessenger, роблячи його більш <strong>цінним та зручним</strong> саме для вас.",
          "sections": [
            "<strong>Профіль:</strong> Змініть ім'я, фото, email, пароль. Налаштуйте параметри безпеки (наприклад, увімкніть <strong>двофакторну автентифікацію (2FA)</strong> для додаткового захисту облікового запису). Пов'язано з <strong>відповідальністю</strong> (Принцип 6) за безпеку ваших даних.",
            "<strong>Сповіщення:</strong> Налаштуйте типи сповіщень, звуки, вібрацію.",
            "<strong>Зовнішній вигляд (Тема):</strong> Виберіть <strong>\"Світлу\"</strong> або <strong>\"Темну\"</strong> тему. Темна тема може зменшити навантаження на очі (пов'язано з Принципом 5: Здоров'я).",
            "<strong>Мова:</strong> Виберіть мову інтерфейсу зі списку доступних мов. Зміни застосовуються швидко. Підтримуються мови з письмом справа наліво (RTL), що робить додаток <strong>доступним</strong> (Принцип 2, 5) для різних регіонів (див. DocLocIn).",
            "<strong>Налаштування батареї та анімації:</strong> Увімкніть або вимкніть анімацію інтерфейсу. Це <strong>прагматичне</strong> (Принцип 12) рішення для економії заряду батареї та ресурсів пристрою (Принцип 5).",
            "<strong>Налаштування чату (Налаштування):</strong> У кожному чаті ви можете змінити його візуальне оформлення (кольори фону, шрифти), що додає <strong>цінності</strong> (Принцип 2) за рахунок персоналізації."
          ]
        },
        "premiumSubscription": {
          "title": "3.6. Преміум-підписка: Додаткові функції та підтримка розвитку Активу (Принцип 2, 10)",
          "p1": "Преміум-підписка надає доступ до розширених функцій, які підвищують <strong>цінність</strong> (Принцип 2) вашого досвіду, і є способом підтримки <strong>довгострокового розвитку</strong> (Принцип 8) BrainMessenger як <strong>цифрового Активу</strong> (Принцип 10).",
          "sections": [
            "<strong>Переваги:</strong> Ознайомтеся з ексклюзивними Преміум-функціями в розділі <strong>\"Налаштування\" → \"Преміум\"</strong>.",
            "<strong>Придбання:</strong> Виберіть тарифний план і оформіть підписку через захищену платіжну систему (Stripe, див. DocInt).",
            "<strong>Історія платежів:</strong> Переглядайте інформацію про ваші транзакції."
          ]
        }
      },
      "faq": {
        "title": "4. Часті питання (FAQ): Швидкі відповіді із системи знань",
        "p1": "Цей розділ містить відповіді на типові питання, засновані на нашому <strong>накопиченому досвіді</strong> (Принцип 1, 14).",
        "q1": {
          "question": "З: Що робити, якщо я не отримав код підтвердження під час реєстрації?",
          "answer": "В: Перевірте папку \"Спам\" у вашій електронній пошті. Якщо коду немає, поверніться на екран введення коду та натисніть <strong>\"Надіслати код повторно\"</strong>."
        },
        "q2": {
          "question": "З: Як відновити пароль?",
          "answer": "В: На екрані входу натисніть <strong>\"Забули пароль?\"</strong> та дотримуйтесь інструкцій, надісланих на ваш email."
        },
        "q3": {
          "question": "З: Як видалити мій обліковий запис та дані?",
          "answer": "В: Ви можете ініціювати видалення облікового запису в <strong>\"Налаштування\" → \"Профіль\"</strong>, вибравши <strong>\"Видалити обліковий запис\"</strong>. Ваші дані будуть надійно видалені відповідно до політики конфіденційності (див. DocSecurity)."
        },
        "q4": {
          "question": "З: Чи підтримує BrainMessenger наскрізне шифрування?",
          "answer": "В: Так, безпека та <strong>цілісність</strong> (Принцип 7) ваших даних — наш пріоритет. Усі особисті чати використовують наскрізне шифрування."
        }
      },
      "tips": {
        "title": "5. Корисні поради: Оптимізація Вашого досвіду (Принцип 9)",
        "p1": "Кілька порад для більш <strong>ефективного</strong> (Принцип 9) використання BrainMessenger:",
        "sections": [
          "<strong>Використовуйте онбординг:</strong> Перший екран зі слайдером містить корисну інформацію про додаток.",
          "<strong>Оптимізуйте продуктивність на вашому пристрої:</strong> Якщо додаток працює повільно або сильно споживає батарею, спробуйте вимкнути анімації в <strong>\"Налаштування\" → \"Батарея та Анімації\"</strong>. Це <strong>прагматичний</strong> крок для збереження <strong>здоров'я</strong> вашого пристрою (Принцип 5).",
          "<strong>Підтримуйте порядок у чатах:</strong> Використовуйте функцію архівування, щоб приховати менш актуальні діалоги.",
          "<strong>Дослідіть налаштування:</strong> Дослідіть усі опції в \"Налаштуваннях\", щоб повністю адаптувати додаток під себе."
        ]
      },
      "support": {
        "title": "6. Підтримка: Ми готові допомогти (Принцип 2, 14)",
        "p1": "Якщо у вас виникнуть питання або проблеми, будь ласка, зв'яжіться з нами. Ваш <strong>відгук</strong> допомагає нам <strong>покращувати систему</strong> (Принцип 9).",
        "sections": [
          "<strong>Через додаток:</strong> Відкрийте головне меню, виберіть <strong>\"Підтримка\"</strong> → <strong>\"Зв'язатися з нами\"</strong>.",
          "<strong>За електронною поштою:</strong> Ви також можете написати нам безпосередньо на `support@brainmessenger.com`."
        ],
        "p2": "Ми прагнемо швидко відповідати на запити та надавати вам найкориснішу <strong>допомогу</strong> (Маргулан)."
      }
    },
    "devGuide": {
      "title": "Посібник з розробки BrainMessenger",
      "subtitle": "Застосування принципів у коді",
      "introduction": {
        "title": "1. Вступ: Процес розробки як система вдосконалення",
        "description": "Цей документ — ваш посібник з процесу розробки BrainMessenger. Ми будуємо цей проєкт не хаотично, а як <strong>цілісну систему</strong> (Принцип 9), де кожен член команди (або ви самі) діє відповідно до <strong>чітких стандартів та принципів</strong>, прагнучи до <strong>безперервного вдосконалення</strong> (Принцип 1, 9). Цей процес безпосередньо впливає на <strong>якість</strong> (Принцип 3) кінцевого продукту та його перетворення на <strong>цінний АКТИВ</strong> (Принцип 10).",
        "goal": "Забезпечити <strong>єдиний, ефективний та масштабований</strong> процес розробки, спростити онбординг для нових учасників та підтримувати високий рівень <strong>якості коду та архітектури</strong> на кожному етапі, включно з глибоким навчанням та застосуванням технологій (як видно у відео трекері).",
        "audience": "Усі, хто пише код або керує процесом розробки BrainMessenger (Frontend, Backend, Mobile, Desktop, DevOps розробники).",
        "principles_title": "Принципи, що керують процесом розробки:",
        "principles": [
          "<strong>Система та Оптимізація (Принцип 9):</strong> Структура репозиторію, стандарти кодування, CI/CD, використання інструментів — все спрямовано на створення ефективної та передбачуваної системи. <strong>Кайдзен</strong> застосовується до самого процесу розробки.",
          "<strong>Якість > Кількість (Принцип 3):</strong> Пріоритет надається написанню чистого, тестованого та підтримуваного коду, навіть якщо це займає більше часу на початковому етапі.",
          "<strong>Безперервне Навчання (Принцип 1):</strong> Процес розробки включає вивчення нових технологій, їх прагматичне застосування та рефлексію над набутим досвідом (як задокументовано у відео трекері та годинах Кайдзен).",
          "<strong>Прагматизм та Реалізм (Принцип 12):</strong> Вибір інструментів та підходів, що підходять для поточного етапу проєкту, без зайвого ускладнення.",
          "<strong>Довгострокове Мислення (Принцип 8):</strong> Архітектурні рішення приймаються з урахуванням майбутньої масштабованості та підтримуваності. Код пишеться так, щоб його можна було легко розвивати.",
          "<strong>Відповідальність та Проактивність (Принцип 6):</strong> Кожен розробник несе відповідальність за якість свого коду, тестів та активно бере участь у вдосконаленні процесу."
        ]
      },
      "repoStructure": {
        "title": "2. Структура репозиторію: Монорепозиторій як система організації коду",
        "description": "Проєкт організований як <strong>монорепозиторій</strong>, використовуючи <strong>Turborepo</strong> для управління пакетами. Це свідомий вибір, покликаний підвищити <strong>ефективність</strong> (Принцип 9) за рахунок повторного використання коду та <strong>оптимізації</strong> (Принцип 9) процесів збирання та тестування.",
        "core_title": "<code>core</code>:",
        "core_content": "Містить код, який є <strong>ядром системи</strong> (Принцип 9) і придатний для використання на будь-якій платформі (API-клієнт, спільні утиліти, бізнес-логіка, не прив'язана до UI/сервера). Повторне використання підвищує <strong>ефективність</strong> (Принцип 9) та <strong>послідовність</strong> (Принцип 7).",
        "mobile_desktop_title": "<code>mobile-desktop</code>:",
        "mobile_desktop_content": "Містить код для <strong>клієнтського Активу</strong> (Принцип 10) на мобільних та настільних платформах.",
        "web_title": "<code>web</code>:",
        "web_content": "Містить код для <strong>клієнтського Активу</strong> на веб-платформі.",
        "backend_title": "<code>backend</code>:",
        "backend_content": "Містить код для <strong>серверної частини системи</strong>, що обробляє запити, взаємодіє з базою даних та зовнішніми сервісами. Це критично важливий <strong>важіль</strong> (Маргулан) для всього застосунку.",
        "infrastructure_title": "<code>infrastructure</code>:",
        "infrastructure_content": "Містить конфігурації для <strong>розгортання системи</strong> (Принцип 9) на хмарних ресурсах.",
        "docs_title": "<code>docs</code>:",
        "docs_content": "Містить <strong>документацію — частину системи знань</strong> (Принцип 1), необхідну для ефективної роботи та онбордингу.",
        "turbo_title": "<code>turbo.json</code>:",
        "turbo_content": "Визначає, як Turborepo керує завданнями (збирання, тестування, лінтинг) по всьому монорепозиторію, використовуючи <strong>кешування та паралельне виконання</strong> для <strong>оптимізації</strong> (Принцип 9) часу розробки."
      },
      "techStack": {
        "title": "3. Стек технологій: Інструменти для побудови фундаменту (Принцип 8)",
        "intro": "Вибір стеку базується на <strong>прагматизмі, надійності та потенціалі для довгострокового розвитку</strong> (Принцип 8, 12). Ми використовуємо <strong>перевірені технології</strong>, які дозволяють швидко будувати, закладаючи при цьому <strong>міцний фундамент</strong> (Принцип 8).",
        "table": [
          ["Компонент", "Технологія", "Версія", "Призначення", "Зв'язок з принципами"],
          ["Frontend: Mobile", "React Native", "0.72+", "Створення UI для Android з єдиної кодової бази.", "П9 (Система), П12 (Прагматизм), П2 (Цінність - кросплатформа)."],
          ["Frontend: Desktop", "React Native for Windows (RNW)", "0.72+", "Створення UI для Windows з єдиної кодової бази.", "П9 (Система), П12 (Прагматизм), П2 (Цінність - кросплатформа)."],
          ["Frontend: Web", "Next.js, Tailwind CSS", "14.x", "Веб-застосунок з SSR/SSG для SEO та продуктивності, стилізація на основі утиліт.", "П2 (Цінність), П9 (Система - фреймворк), П12 (Прагматизм)."],
          ["Frontend: General", "TypeScript", "5.x", "Сильна статична типізація для підвищення <strong>якості та надійності</strong> коду.", "П3 (Якість), П9 (Система - передбачуваність)."],
          ["Backend", "Node.js, NestJS", "22.x, 10.x", "Серверна логіка, GraphQL API, висока продуктивність Node.js, модульність NestJS.", "П9 (Система - модульність), П8 (Довгостроковість - масштабованість Node.js)."],
          ["ORM", "Prisma", "5.x", "Зручна та безпечна робота з базою даних (PostgreSQL).", "П3 (Якість - безпека запитів), П9 (Система - абстракція БД)."],
          ["База даних", "PostgreSQL (Neon)", "15.x", "Основне сховище структурованих даних. Надійна реляційна СУБД.", "П8 (Довгостроковість), П9 (Система), П12 (Прагматизм)."],
          ["Файлове сховище", "Cloudflare R2 (S3-сумісне)", "-", "Зберігання медіафайлів та бінарних даних. Економічне та масштабоване.", "П10 (Активи), П12 (Прагматизм), П8 (Довгостроковість)."],
          ["Кешування", "Redis", "7.x", "Кешування даних, обмеження частоти запитів (Rate Limiting), управління присутністю WebSocket.", "П9 (Система - ефективність), П3 (Якість - зниження навантаження), П5 (Здоров'я - чуйність)."],
          ["Асинхронність", "Kafka", "3.x", "Надійна асинхронна обробка фонових завдань (обробка зображень).", "П9 (Система - розділення відповідальності), П3 (Якість - надійність)."],
          ["Оркестрація", "Kubernetes", "1.24+", "Управління контейнерами, автоматичне масштабування, самовідновлення.", "П8 (Довгостроковість), П9 (Система - управління складністю), П3 (Якість - відмовостійкість)."],
          ["Інфраструктура", "Terraform", "1.5+", "Автоматизація створення та управління інфраструктурою (IaC).", "П9 (Система - автоматизація), П3 (Якість - передбачуваність інфраструктури)."],
          ["Тестування", "Jest, Cypress, Detox", "-", "Модульні, інтеграційні, E2E тести для забезпечення <strong>якості</strong>.", "П3 (Якість), П9 (Система - автоматична верифікація)."],
          ["Профілювання", "V8 Profiler, Chrome DevTools", "-", "Інструменти для <strong>вимірювання та оптимізації продуктивності</strong>.", "П1 (Навчання), П9 (Система - Кайдзен), П13 (Наполегливість)."],
          ["Моніторинг Kafka", "Kafdrop", "-", "Візуальний моніторинг черг Kafka.", "П9 (Система), П5 (Здоров'я - систем, видимість проблем)."]
        ]
      },
      "codingStandards": {
        "title": "4. Стандарти кодування: Дисципліна як основа якості (Принцип 3, 9)",
        "intro": "Дотримання стандартів кодування — це вияв <strong>дисципліни</strong> та частина <strong>системи забезпечення якості</strong>. Це робить код передбачуваним, легко читабельним та підтримуваним іншими розробниками (або вами самими в майбутньому).",
        "generalPrinciples": {
          "title": "4.1. Загальні принципи",
          "principles": [
            "<strong>DRY (Don’t Repeat Yourself):</strong> Уникайте дублювання коду. Використовуйте спільні функції, компоненти, хуки в пакеті <code>core</code>.",
            "<strong>KISS (Keep It Simple, Stupid):</strong> Прагніть до простих рішень. Не ускладнюйте без необхідності. <strong>Спрощення складного</strong> (Маргулан) застосовне й до коду.",
            "<strong>Іменування:</strong> Використовуйте англійську для всіх ідентифікаторів (змінних, функцій, класів), коментарів. Будьте послідовними.",
            "<strong>Коментарі:</strong> Обов'язкові для:",
            "Складної бізнес-логіки (наприклад, обробка платежів, управління WebSocket-з'єднаннями).",
            "Інтеграцій із зовнішніми сервісами (де можуть бути неочевидні деталі API).",
            "Критичних ділянок коду (аутентифікація, шифрування, операції з множинами).",
            "Неочевидних рішень або обхідних шляхів (з поясненням)."
          ]
        },
        "namingConventions": {
          "title": "4.2. Угоди про іменування",
          "conventions": [
            "<strong>Змінні та функції:</strong> <code>camelCase</code> (наприклад, <code>getUserProfile</code>, <code>chatMessage</code>).",
            "<strong>Класи та модулі:</strong> <code>PascalCase</code> (наприклад, <code>UserService</code>, <code>ChatModule</code>).",
            "<strong>Константи:</strong> <code>UPPER_SNAKE_CASE</code> (наприклад, <code>MAX_FILE_SIZE</code>, <code>DEFAULT_TIMEOUT</code>).",
            "<strong>Файли та папки:</strong> <code>kebab-case</code> (наприклад, <code>user-service.ts</code>, <code>chat-screen.tsx</code>, <code>image-processing</code>).",
            "<strong>API Endpoints (у контексті GraphQL):</strong> Резолвери та їх поля іменуються відповідно до доменної моделі, часто дотримуючись REST-подібної логіки (наприклад, query <code>getUser</code>, mutation <code>sendMessage</code>)."
          ]
        },
        "formattingLinting": {
          "title": "4.3. Форматування та лінтинг: Автоматизація підтримки порядку",
          "intro": "Використовуйте автоматичні інструменти для забезпечення уніфікованого форматування та дотримання базових правил кодування. Це частина <strong>автоматизованої системи якості</strong> (Принцип 9).",
          "prettier_title": "<strong>Форматування:</strong> <strong>Prettier</strong> — автоматичний форматер коду.",
          "prettier_content": "Налаштуйте <code>.prettierrc</code> у корені проєкту. Рекомендовані налаштування: 2 пробіли для відступів, без крапок з комою в кінці рядків, одинарні лапки для рядків.",
          "prettier_code": "```json\n{\n  \"tabWidth\": 2,\n  \"semi\": false,\n  \"singleQuote\": true,\n  \"trailingComma\": \"es5\"\n}\n```",
          "eslint_title": "<strong>Лінтинг:</strong> <strong>ESLint</strong> — статичний аналізатор коду для виявлення проблем.",
          "eslint_content": "Використовуйте конфігурацію, таку як Airbnb або Standard, адаптовану для TypeScript, React/React Native, NestJS. Налаштуйте правила в <code>.eslintrc.js</code>.\nІнтегруйте ESLint у ваш редактор коду для зворотного зв'язку в реальному часі."
        },
        "codeStructure": {
          "title": "4.4. Структура коду: Модульність та чіткі межі",
          "intro": "Код організовано модульно всередині кожного пакета, дотримуючись принципів <strong>систематизації</strong> (Принцип 9) та розділення відповідальності.",
          "corePackage": {
            "title": "Core (<code>packages/core</code>):",
            "points": [
              "<code>api/</code>: Код для взаємодії з GraphQL API BrainMessenger (Apollo Client).",
              "<code>hooks/</code>: Перевикористовувані хуки для React/React Native.",
              "<code>utils/</code>: Чисті утилітарні функції, незалежні від конкретної платформи."
            ]
          },
          "mobileDesktopPackage": {
            "title": "Mobile-Desktop (<code>packages/mobile-desktop</code>):",
            "points": [
              "<code>components/</code>: Невеликі, перевикористовувані UI-компоненти (<code>Button</code>, <code>MessageBubble</code>).",
              "<code>screens/</code>: Компоненти, що представляють цілі екрани (<code>ChatScreen</code>, <code>SettingsScreen</code>).",
              "<code>theme/</code>: Файли з колірними схемами та типографією, визначені в DocDesign.",
              "<code>platform/</code>: Код, специфічний для Android або Windows (наприклад, робота з нативними модулями)."
            ]
          },
          "webPackage": {
            "title": "Web (<code>packages/web</code>):",
            "points": [
              "<code>pages/</code>: Компоненти сторінок Next.js.",
              "<code>components/</code>: UI-компоненти для вебу (можуть перевикористовувати логіку з <code>core/hooks</code> або <code>core/utils</code>).",
              "<code>styles/</code>: Файли стилів (Tailwind CSS)."
            ]
          },
          "backendPackage": {
            "title": "Backend (<code>backend</code>):",
            "points": [
              "Структура NestJS: Модулі (<code>auth</code>, <code>user</code>, <code>chat</code>, <code>message</code>), сервіси (<code>AuthService</code>, <code>UserService</code>), контролери (для REST, якщо є) або резолвери (для GraphQL), DTO (об'єкти передачі даних), Entities (визначаються Prisma).",
              "<code>src/</code>: Вихідний код.",
              "<code>test/</code>: Тести."
            ]
          }
        }
      },
      "libraries": {
        "title": "5. Використовувані бібліотеки: Вибір правильних інструментів (Принцип 12)",
        "intro": "Ми обираємо бібліотеки, які вирішують проблеми <strong>прагматично</strong> (Принцип 12), забезпечують <strong>якість</strong> (Принцип 3) та добре інтегруються в нашу <strong>систему</strong> (Принцип 9).",
        "common": {
          "title": "5.1. Загальні (Core)",
          "libs": [
            "<code>@apollo/client</code> (та пов'язані): GraphQL-клієнт для виконання запитів до Backend API. Використовується в <code>core</code> та імпортується в <code>mobile-desktop</code> та <code>web</code>. Забезпечує <strong>ефективність</strong> (Принцип 9) за рахунок управління кешем."
          ]
        },
        "mobileDesktop": {
          "title": "5.2. Мобільні-Десктопні (React Native)",
          "libs": [
            "<code>react-native-reanimated</code>, <code>moti</code>, <code>lottie-react-native</code>: Бібліотеки для створення <strong>плавних та продуктивних анімацій</strong> (див. DocDesign). Стосуються Принципу 3 (Якість UI) та Принципу 5 (Здоров'я - зниження навантаження).",
            "<code>@react-navigation/native</code> (та пов'язані): Навігація між екранами застосунку. <strong>Систематичне</strong> (Принцип 9) управління переходами.",
            "<code>react-native-sound</code>: Базова бібліотека для відтворення звуків (повідомлення, дзвінки). Див. Sound Documentation."
          ]
        },
        "web": {
          "title": "5.3. Веб (Next.js)",
          "libs": [
            "<code>next</code>, <code>react</code>, <code>react-dom</code>: Фундамент веб-застосунку. Next.js надає <strong>систему</strong> (Принцип 9) для SSR, SSG, маршрутизації та <strong>оптимізації</strong> (див. DocOptimizationIn).",
            "<code>tailwindcss</code>: CSS-фреймворк з акцентом на утиліти для швидкої та <strong>прагматичної</strong> (Принцип 12) стилізації.",
            "<code>framer-motion</code>: Бібліотека для <strong>якісних</strong> (Принцип 3) анімацій на вебі."
          ]
        },
        "backend": {
          "title": "5.4. Backend (NestJS)",
          "libs": [
            "<code>@nestjs/*</code>: Основні пакети NestJS (core, common, platform-express/fastify, graphql, typeorm/prisma, jwt, passport, websockets тощо). Надають <strong>модульну, масштабовану систему</strong> (Принцип 9).",
            "<code>@nestjs/prisma</code>: Інтеграція NestJS та Prisma.",
            "<code>graphql</code>, <code>@nestjs/graphql</code>, <code>apollo-server-express</code>: Реалізація GraphQL API.",
            "<code>@prisma/client</code>: Prisma ORM клієнт для взаємодії з Neon (PostgreSQL).",
            "<code>@aws-sdk/client-s3</code>, <code>@aws-sdk/s3-request-presigner</code>: Робота з Cloudflare R2 (S3-сумісним).",
            "<code>ioredis</code>: Redis-клієнт для кешування та інших завдань.",
            "<code>kafkajs</code>: Kafka-клієнт для асинхронних завдань.",
            "<code>firebase-admin</code>: Firebase SDK (Push-сповіщення).",
            "<code>stripe</code>: Stripe SDK (Платежі).",
            "<code>googleapis</code>: Google APIs SDK (Gmail API).",
            "<code>bcrypt</code> або <code>argon2</code>: Бібліотека для <strong>безпечного</strong> (Принцип 3, 5) хешування паролів."
          ]
        },
        "crossPackage": {
          "title": "5.5. Загальні (Cross-Package)",
          "libs": [
            "<code>typescript</code>: Мова розробки.",
            "<code>winston</code> або <code>pino</code>: Бібліотека для <strong>структурованого логування</strong> (Принцип 9).",
            "<code>@sentry/node</code>, <code>@sentry/react</code>, <code>@sentry/react-native</code>: Клієнти Sentry для <strong>відстеження помилок у продакшені</strong> (частина системи <strong>якості</strong> та <strong>Кайдзен</strong>).",
            "<code>core-js</code>, <code>regenerator-runtime</code>: Поліфіли для підтримки сучасних функцій JavaScript у старих середовищах (наприклад, нові методи Set в ES2024).",
            "<code>zod</code> або <code>class-validator</code>/<code>class-transformer</code>: Бібліотеки для <strong>валідації даних</strong>, що забезпечують <strong>якість</strong> (Принцип 3) на вході до системи."
          ]
        },
        "setMethods": {
          "title": "5.6. Робота з Sets в ES2024+: Приклад застосування нових знань (Принцип 1)",
          "intro": "<strong>Безперервне навчання</strong> (Принцип 1) та застосування <strong>прагматичних</strong> (Принцип 12) мовних інструментів — частина нашої філософії. Нові методи об'єкта <code>Set</code> в ECMAScript 2024 (підтримуються в Node.js 22+, сучасних браузерах) надають <strong>чистіший, читабельніший і часто ефективніший</strong> (Принцип 9) спосіб роботи з унікальними наборами даних порівняно з ручними циклами або перетвореннями в масиви.",
          "areas": {
            "title": "Області застосування в BrainMessenger:",
            "points": [
              "Управління списками користувачів у групових чатах (додавання/видалення учасників).",
              "Відстеження унікальних активних сесій або WebSocket-з'єднань.",
              "Управління правами доступу (перевірка, чи входить набір дозволів до доступних).",
              "Синхронізація списків (наприклад, контактів, чатів) між клієнтом та сервером, виявлення доданих/видалених елементів."
            ]
          },
          "keys": {
            "title": "Ключові методи (з ES2024):",
            "points": [
              "<code>union(iterable)</code>: Повертає новий <code>Set</code> з усіма унікальними елементами з поточного <code>Set</code> та переданого ітерованого об'єкта.",
              "<code>intersection(iterable)</code>: Повертає новий <code>Set</code> з елементами, присутніми в <strong>обох</strong> множинах.",
              "<code>difference(iterable)</code>: Повертає новий <code>Set</code> з елементами, присутніми в поточному <code>Set</code>, але <strong>не</strong> в переданому ітерованому об'єкті.",
              "<code>symmetricDifference(iterable)</code>: Повертає новий <code>Set</code> з елементами, які знаходяться в <strong>одній</strong>, але не в <strong>обох</strong> множинах.",
              "<code>isSubsetOf(iterable)</code>: Перевіряє, чи є всі елементи поточного <code>Set</code> підмножиною переданого ітерованого об'єкта (<code>true</code> або <code>false</code>).",
              "<code>isSupersetOf(iterable)</code>: Перевіряє, чи містить поточний <code>Set</code> усі елементи переданого ітерованого об'єкта (<code>true</code> або <code>false</code>).",
              "<code>isDisjointFrom(iterable)</code>: Перевіряє, чи не мають поточний <code>Set</code> та переданий ітерований об'єкт спільних елементів (<code>true</code> або <code>false</code>)."
            ]
          },
          "examples": {
            "title": "Приклади використання в коді (TypeScript):",
            "code": "```typescript\n// backend/src/chat/chat.service.ts (example of group member management)\nasync updateGroupMembers(groupId: string, currentMemberIds: Set<string>, newMemberIds: Set<string>) {\n  // Principle 9: Optimization and clarity\n  const addedMembers = newMemberIds.difference(currentMemberIds);\n  const removedMembers = currentMemberIds.difference(newMemberIds);\n  const unchangedMembers = currentMemberIds.intersection(newMemberIds); // For verification\n\n  console.log('Added:', addedMembers);\n  console.log('Removed:', removedMembers);\n\n  // Perform add/remove operations in the database via Prisma\n  if (addedMembers.size > 0) {\n    await this.prisma.userChat.createMany({\n      data: Array.from(addedMembers).map(userId => ({ groupId, userId })),\n    });\n  }\n  if (removedMembers.size > 0) {\n    await this.prisma.userChat.deleteMany({\n      where: {\n        groupId: groupId,\n        userId: { in: Array.from(removedMembers) },\n      },\n    });\n  }\n\n  // Permissions check: Ensure the current user has permission to modify group membership\n  const requiredPermission = new Set(['manage_members']);\n  const userPermissions = new Set(await this.getUserPermissions(userId, groupId)); // Get user permissions\n  const hasPermission = requiredPermission.isSubsetOf(userPermissions); // Check using new method\n  if (!hasPermission) {\n      throw new ForbiddenException(\"Insufficient permissions to modify group membership.\");\n  }\n}\n\n// frontend/src/hooks/useChats.ts (example of chat list synchronization)\nfunction useSyncChats(localChats: Set<string>, serverChats: string[]) {\n    // Principle 9: Synchronization efficiency\n    const serverChatsSet = new Set(serverChats);\n    const newChats = serverChatsSet.difference(localChats);\n    const removedChats = localChats.difference(serverChatsSet);\n\n    console.log('New chats:', newChats);\n    console.log('Removed chats:', removedChats);\n\n    // Update local state/UI based on newChats and removedChats\n    // ...\n}\n",
            "recommendations": [
              "Застосовуйте їх для операцій з унікальними наборами даних. Вони спеціально для цього призначені і часто більш продуктивні, ніж аналогічні операції з масивами, особливо для великих обсягів даних.",
              "Враховуйте сумісність: Нові методи доступні в Node.js 22+ та сучасних браузерах. Якщо вам потрібно підтримувати старіші середовища, використовуйте поліфіли (core-js/proposals/set-methods-v2).",
              "Типізація TypeScript: Завжди вказуйте тип елементів у Set (наприклад, Set<string>, Set<number>) для кращої перевірки типів та автодоповнення."
            ]
          }
        }
      },
      "devProcess": {
        "title": "6. Процес розробки: Наша система робочого процесу (Принцип 9)",
        "intro": "Чіткий процес розробки забезпечує систематизацію, якість та передбачуваність (Принцип 9).",
        "envSetup": {
          "title": "6.1. Налаштування середовища: Підготовка до роботи",
          "intro": "Клонувати репозиторій:",
          "cloneRepo": {
            "title": "Клонувати репозиторій:",
            "code": "```bash\ngit clone <https://github.com/xAI/BrainMessenger.git> # Приклад\ncd BrainMessenger\n```"
          },
          "installDeps": {
            "title": "Встановити залежності:",
            "code": "```bash\nnpm install\n```"
          },
          "envVars": {
            "title": "Налаштувати змінні середовища:",
            "code": "```bash\ncp .env.example .env\n# Заповнити .env даними для Neon, R2, Redis, Kafka, API Gateways, Stripe, Firebase, Gmail API\n```",
            "note": "Важливо мати робочі локальні або тестові інстанси БД, Redis, Kafka або використовувати їх хмарні версії для розробки."
          },
          "prismaClient": {
            "title": "Згенерувати Prisma Client:",
            "code": "```bash\ncd backend\nnpx prisma generate\ncd ..\n```"
          },
          "localDb": {
            "title": "Налаштувати локальну БД (якщо не використовується хмарна):",
            "code": "```bash\ncd backend\nnpx prisma migrate dev --name initial_setup\ncd ..\n```"
          }
        },
        "localRun": {
          "title": "6.2. Локальний запуск: Активізація системи для розробки",
          "intro": "Використовуйте команди <code>turbo run</code> або команди конкретних пакетів.",
          "runAll": {
            "title": "Запустити всі сервіси (Backend, Web) для розробки:",
            "code": "```bash\nturbo run dev # Запустить dev-сервери для всіх пакетів із завданням 'dev' у turbo.json\n```"
          },
          "runBackend": {
            "title": "Окремий запуск Backend:",
            "code": "```bash\ncd backend\nnpm run start:dev # або npm run start:debug для налагодження\n```"
          },
          "runMobileDesktop": {
            "title": "Окремий запуск Mobile-Desktop (React Native):",
            "code": "```bash\ncd packages/mobile-desktop\nnpm run android # для запуску на Android емуляторі/пристрої\nnpm run windows # для запуску на Windows\n```"
          },
          "runWeb": {
            "title": "Окремий запуск Web (Next.js):",
            "code": "```bash\ncd packages/web\nnpm run dev\n```"
          }
        },
        "commitsBranches": {
          "title": "6.3. Коміти та гілки: Структура еволюції коду (Принцип 9)",
          "intro": "Ми використовуємо чітку стратегію гілкування та стандарти комітів для підтримки порядку (Принцип 9) та чіткої історії змін (Принцип 7).",
          "mainBranches": {
            "title": "Основна гілка розробки:",
            "points": [
              "<code>develop</code>. Тут інтегруються всі нові функції та виправлення.",
              "Стабільна гілка: <code>main</code>. Лише перевірений код з <code>develop</code> (через PR релізів)."
            ]
          },
          "workBranches": {
            "title": "Робочі гілки:",
            "points": [
              "<code>feature/<feature_name></code>: Для розробки нової функціональності (наприклад, <code>feature/graphql-auth</code>).",
              "<code>fix/<fix_name></code>: Для виправлення помилок (наприклад, <code>fix/chat-message-scroll</code>).",
              "<code>refactor/<name></code>: Для рефакторингу коду."
            ]
          },
          "commitFormat": {
            "title": "Формат комітів:",
            "example": "Використовуйте Conventional Commits. Це спрощує генерацію changelog та розуміння призначення кожного коміту.\n\nПриклад:\n\n<code>feat(backend/auth): add JWT authentication</code> (нова функція в модулі аутентифікації бекенда)\n\n<code>fix(mobile/chat): resolve message display bug on scroll</code> (виправлення помилки відображення повідомлень у мобільному чаті при прокрутці)\n\n<code>docs(roadmap): update Q3 2025 plan</code> (оновлення документації)\n\n<code>chore(deps): update prisma to 5.x</code> (рутинне завдання, оновлення залежностей)",
            "structure": "Структура: <code>type(scope): description</code>\n\n<code>type</code>: <code>feat</code>, <code>fix</code>, <code>docs</code>, <code>chore</code>, <code>style</code>, <code>refactor</code>, <code>test</code>, <code>ci</code>, <code>perf</code>, <code>build</code>\n\n<code>scope</code>: Необов'язково, вказує пакет або область (<code>backend</code>, <code>web</code>, <code>mobile-desktop</code>, <code>core</code>, <code>auth</code>, <code>chat</code>, <code>ui</code>, <code>infra</code> тощо)."
          }
        },
        "prCodeReview": {
          "title": "6.4. Pull Request (PR) та Code Review: Колективне забезпечення якості (Принцип 3, 14)",
          "intro": "Кожен Pull Request — це можливість отримати зворотний зв'язок (Принцип 14), покращити код та забезпечити якість (Принцип 3) перед інтеграцією в основну гілку.",
          "prDescription": {
            "title": "Опис PR:",
            "points": [
              "Чітко опишіть, яку проблему вирішує PR або яку функцію він додає.",
              "Посилайтеся на відповідне завдання Jira (наприклад, [BM-123]) або інше місце відстеження завдань.",
              "Опишіть основні зміни та будь-які потенційні ризики чи питання."
            ]
          },
          "prRequirements": {
            "title": "Вимоги до PR:",
            "points": [
              "Код має відповідати стандартам кодування (лінтер, форматер).",
              "Усі тести повинні проходити (<code>npm test</code>). Налаштуйте перевірки в GitHub Actions.",
              "Має бути щонайменше 1 схвалення від іншого розробника (або від вас самих, якщо працюєте самостійно, але прагніть до ідеального code review).",
              "Нетривіальні зміни можуть вимагати рев'ю від більш досвідченого розробника або архітектора."
            ]
          }
        },
        "testing": {
          "title": "6.5. Тестування: Перевірка надійності системи (Принцип 3)",
          "intro": "Тестування є невід'ємною частиною процесу забезпечення якості (Принцип 3). Ми використовуємо багаторівневий підхід.",
          "runAllTests": {
            "title": "Запустити всі тести:",
            "code": "```bash\nnpm run test # Запустить тести для всіх пакетів (модульні, інтеграційні)\n```"
          },
          "testTypes": {
            "title": "Типи тестів:",
            "points": [
              "Модульні тести: Тестування окремих функцій або класів ізольовано (Jest). Фокус: Коректність роботи невеликих частин коду.",
              "Інтеграційні тести: Тестування взаємодії між кількома компонентами (наприклад, сервіс -> БД, API -> сервіс) (Jest). Фокус: Коректність зв'язків між частинами системи.",
              "E2E тести (Наскрізні тести): Тестування користувацьких сценаріїв у застосунку (Cypress для Web, Detox для React Native). Фокус: Загальна працездатність системи з точки зору користувача."
            ]
          },
          "ciCdTests": {
            "title": "Налаштувати автоматичний запуск тестів у CI/CD (GitHub Actions) при кожному PR та пуші в гілку develop.",
            "content": "Налаштувати автоматичний запуск тестів у CI/CD (GitHub Actions) при кожному PR та пуші в гілку develop."
          }
        }
      },
      "devRecommendations": {
        "title": "7. Рекомендації з розробки: Кращі практики для створення Активу",
        "intro": "Застосовуйте ці рекомендації для створення якісного, підтримуваного коду, який стане фундаментом вашого цифрового Активу (Принцип 3, 10).",
        "corePackage": {
          "title": "7.1. Пакет Core: Повторне використання для ефективності",
          "points": [
            "API-клієнт (<code>@apollo/client</code>): Використовуйте його для всіх GraphQL-запитів з Frontend. Налаштуйте кешування (InMemoryCache) та обробку помилок. Це зменшує дублювання коду та забезпечує уніфікований спосіб взаємодії з API.",
            "Спільні хуки/утиліти: Виділяйте сюди логіку, яка повторюється на різних платформах (форматування даних, валідація, обробка токенів)."
          ]
        },
        "mobileDesktop": {
          "title": "7.2. Мобільні-Десктопні (React Native)",
          "points": [
            "Функціональні компоненти: Використовуйте React Hooks та функціональні компоненти. Розділяйте компоненти на «розумні» (з логікою) та «прості» (лише UI).",
            "Стилізація: Використовуйте StyleSheet.create для продуктивності або бібліотеки типу styled-components / NativeBase для узгодженості.",
            "Нативна оптимізація: Вивчіть специфіку RNW та RN (наприклад, робота з нативними модулями для підвищення продуктивності критичних ділянок, анімації на нативному потоці з Reanimated)."
          ]
        },
        "web": {
          "title": "7.3. Веб (Next.js)",
          "points": [
            "Маршрутизація та отримання даних: Використовуйте можливості Next.js (File-system routing, getStaticProps, getServerSideProps, getStaticPaths) для оптимізації завантаження сторінок (SSR/SSG) та SEO (Принцип 2).",
            "Стилізація: Tailwind CSS прискорює розробку UI. Дотримуйтесь принципів з DocDesign.",
            "Оптимізація зображень: Використовуйте next/image для автоматичної оптимізації зображень."
          ]
        },
        "backend": {
          "title": "7.4. Backend (NestJS)",
          "points": [
            "GraphQL API: Дотримуйтесь принципів GraphQL (запитуйте лише те, що потрібно). Використовуйте DataLoader для вирішення проблеми N+1 (див. DocOptimizationIn).",
            "Prisma: Використовуйте ORM для всіх взаємодій з БД. Це забезпечує безпеку (захист від SQL-ін'єкцій - Принцип 3, 5) та типізацію.",
            "Сервіси: Виділяйте основну бізнес-логіку в сервіси. Контролери/резолвери мають бути тонкими (лише обробка запитів та виклик сервісів).",
            "Інтеграції: Взаємодія із зовнішніми сервісами (R2, Firebase, Stripe, Gmail API) має бути інкапсульована в окремі сервіси (наприклад, StorageService, NotificationService). Це робить код більш модульним та тестованим (Принцип 9).",
            "Обробка помилок: Використовуйте фільтри винятків NestJS для централізованої обробки помилок та повернення стандартизованих API-відповідей (див. DocSpec). Детально логуйте помилки (Winston, Sentry)."
          ]
        },
        "security": {
          "title": "7.5. Безпека: Захист вашого Активу (Принцип 3, 5, 10)",
          "intro": "Безпека — це не функція, а фундаментальний аспект якості (Принцип 3), безпосередньо пов'язаний зі здоров'ям системи (Принцип 5) та захистом цифрового активу (Принцип 10: ваш продукт та дані користувачів).",
          "points": [
            "Аутентифікація: Використовуйте JWT для stateless-аутентифікації з коротким терміном дії access-токенів та refresh-токенів. Надійно зберігайте JWT-секрет.",
            "Хешування паролів: Ніколи не зберігайте паролі у відкритому вигляді. Використовуйте сильні алгоритми хешування (bcrypt, argon2).",
            "Валідація вхідних даних: Суворо валідуйте всі вхідні дані на Backend (наприклад, використовуючи class-validator та DTO).",
            "Захист від атак: Реалізуйте Rate Limiting (<code>@nestjs/throttler</code>) для захисту від brute-force атак або DDoS на рівні API. Використовуйте helmet для встановлення безпечних HTTP-заголовків.",
            "Шифрування конфіденційних даних: Шифруйте дані перед збереженням у R2 (див. DocInt). Ключ шифрування зберігайте окремо від даних.",
            "2FA: Реалізуйте двофакторну аутентифікацію як опцію для користувачів."
          ]
        }
      },
      "optimization": {
        "title": "8. Оптимізація проєкту: Безперервне вдосконалення (Принцип 9, 1)",
        "content": "Оптимізація — це ітеративний процес (Принцип 9: Кайдзен), заснований на вимірюваннях та навчанні (Принцип 1). Див. докладний посібник з оптимізації BrainMessenger."
      },
      "deployProcess": {
        "title": "9. Процес розгортання: Доставка системи користувачам (Принцип 9)",
        "intro": "Процес розгортання має бути автоматизованим, надійним та передбачуваним (Принцип 9, 3).",
        "points": [
          "Контейнеризація (Docker): Створюйте Docker-образи для Backend та інших сервісів. Використовуйте багатоступеневі збірки для оптимізації розміру образів (див. CI/CD Optimization Guide).",
          "Оркестрація (Kubernetes): Розгортайте контейнери в Kubernetes. Використовуйте маніфести в папці <code>infrastructure/k8s</code>. K8s забезпечує автоматичне масштабування, самовідновлення та управління навантаженням.",
          "Інфраструктура як код (Terraform): Керуйте хмарними ресурсами (кластер K8s, мережі) за допомогою Terraform (<code>infrastructure/main.tf</code>). Це робить інфраструктуру версіонованою та відтворюваною.",
          "CI/CD (GitHub Actions): Налаштуйте автоматичні пайплайни для збирання, тестування та розгортання (див. CI/CD Optimization Guide)."
        ],
        "process": "Процес: Код пушиться в <code>develop</code> → CI/CD запускає тести та збірки → Після успішних тестів та рев'ю, PR зливається в <code>develop</code> → (опціонально) автоматичне розгортання dev/staging середовища → Release PR з <code>develop</code> у <code>main</code> → Продакшн розгортання."
      },
      "devCommands": {
        "title": "10. Корисні команди розробника: Інструментарій системи",
        "table": [
          ["Команда", "Опис", "Розташування"],
          ["<code>npm install</code>", "Встановлює залежності для всіх пакетів (Turborepo).", "Корінь"],
          ["<code>turbo run <task></code>", "Запускає завдання (build, test, lint, dev) для всіх пакетів або за фільтром.", "Корінь"],
          ["<code>npm run lint</code>", "Запускає лінтери для всіх пакетів.", "Корінь"],
          ["<code>npm run format</code>", "Форматує код для всіх пакетів (Prettier).", "Корінь"],
          ["<code>npm run build</code>", "Збирає production версії всіх пакетів.", "Корінь"],
          ["<code>npm run test</code>", "Запускає тести для всіх пакетів.", "Корінь"],
          ["<code>cd backend && npx prisma migrate dev --name <name></code>", "Створює та застосовує нову міграцію БД.", "Корінь/backend"],
          ["<code>cd backend && npx prisma studio</code>", "Запускає графічний інтерфейс для перегляду БД.", "Корінь/backend"],
          ["<code>cd backend && npm run start:dev</code>", "Запускає бекенд у режимі розробки.", "Корінь/backend"],
          ["<code>cd packages/web && npm run dev</code>", "Запускає веб-застосунок у режимі розробки.", "Корінь/packages/web"],
          ["<code>cd packages/mobile-desktop && npm run android</code>", "Запускає мобільний застосунок на Android.", "Корінь/packages/mobile-desktop"],
          ["<code>cd packages/mobile-desktop && npm run windows</code>", "Запускає десктопний застосунок на Windows.", "Корінь/packages/mobile-desktop"],
          ["<code>cd infrastructure && terraform plan</code>", "Показує план змін інфраструктури.", "Корінь/infrastructure"],
          ["<code>cd infrastructure && terraform apply</code>", "Застосовує зміни інфраструктури.", "Корінь/infrastructure"]
        ]
      },
      "notes": {
        "title": "11. Примітки: Безперервне навчання та Кайдзен",
        "points": [
          "Онбординг: Нові розробники повинні почати з вивчення цієї документації, а також Технічної документації (загальний огляд), Документації з дизайну (візуальні стандарти) та Посібника з оптимізації (як писати продуктивний код).",
          "Живий документ: Ця документація — живий документ. Вона буде оновлюватися в міру розвитку проєкту, вивчення нових технологій та вдосконалення процесів. Ваші пропозиції щодо вдосконалення вітаються! (Принцип 1, 14).",
          "Сумісність з ECMAScript 2024: Переконайтеся, що ви використовуєте Node.js 22+ (для бекенда) та актуальні версії браузерів/React Native (для фронтенда) для повної підтримки нових методів Set. За потреби використовуйте поліфіли.",
          "Питання та зворотний зв'язок: Якщо щось незрозуміло, або ви бачите можливість покращити процес — задавайте питання в командному чаті (#dev-team у Slack або іншому інструменті) та пропонуйте зміни. Це частина Сили Взаємодії та Співпраці (Маргулан), яка робить систему сильнішою."
        ]
      }
    },
    "integrationsGuide": {
      "title": "Документація Інтеграцій BrainMessenger",
      "subtitle": "Побудова Надійної Системи із Зовнішніми Важелями",
      "introduction": {
        "title": "1. Вступ: Інтеграції як Частина Фундаменту Системи",
        "description": "Цей документ описує, як BrainMessenger інтегрується з ключовими зовнішніми сервісами. Ми обираємо ці інтеграції <strong>прагматично</strong> (Принцип 12), розглядаючи їх як <strong>важелі</strong> (принцип Маргулана), які дозволяють нам не винаходити колесо, а використовувати <strong>надійні та масштабовані</strong> (Принцип 8, 9) сторонні рішення для прискорення розробки та забезпечення <strong>якості</strong> (Принцип 3) нашого продукту. Ці інтеграції є невід'ємною частиною нашого <strong>технологічного фундаменту</strong> (Принцип 8).",
        "principlesTitle": "Принципи, якими керується вибір та налаштування інтеграцій:",
        "principles": [
          "<strong>Система та Оптимізація (Принцип 9):</strong> Інтеграції повинні бути частиною єдиної, добре продуманої системи, де кожен компонент виконує свою роль ефективно.",
          "<strong>Прагматизм та Реалізм (Принцип 12):</strong> Вибір сервісів з урахуванням поточних потреб, бюджету (безкоштовні/доступні тарифи на старті) та простоти інтеграції.",
          "<strong>Довгострокове Мислення (Принцип 8):</strong> Вибір сервісів, здатних масштабуватися разом із зростанням проєкту.",
          "<strong>Якість > Кількість (Принцип 3):</strong> Фокус на надійності та продуктивності інтеграцій, навіть якщо їх список на старті невеликий.",
          "<strong>Створення Цінності (Принцип 2):</strong> Кожна інтеграція повинна додавати реальну цінність для кінцевого користувача (наприклад, надійне зберігання файлів, миттєві сповіщення)."
        ]
      },
      "overview": {
        "title": "2. Огляд Ключових Інтеграцій: Наші Зовнішні Компоненти Системи",
        "table": [
          ["Сервіс", "Призначення", "Роль у BrainMessenger", "Основні функції", "Зв'язок з Принципами"],
          ["<strong>Neon</strong>", "Керована PostgreSQL БД", "Зберігання всіх <strong>структурованих даних</strong> (користувачі, чати, повідомлення, метадані файлів). Фундамент даних.", "Хостинг PostgreSQL, масштабування, доступ через рядок підключення.", "P8 (Довгострокове), P9 (Система), P12 (Прагматизм - безкоштовний тариф)."],
          ["<strong>Cloudflare R2</strong>", "Хмарне Сховище (S3-сумісне)", "Зберігання всіх <strong>неструктурованих даних</strong> (файли користувачів, аватарки, записи дзвінків, зашифровані метадані). Сховище Активів.", "Надійне зберігання об'єктів, CDN-доставка, відсутність плати за вихідний трафік.", "P8 (Довгострокове), P10 (Активи), P12 (Прагматизм - безкоштовний тариф, немає плати за трафік), P3 (Якість - CDN)."],
          ["<strong>Firebase</strong>", "Push-сповіщення", "Миттєва доставка сповіщень користувачам на мобільні пристрої.", "Відправлення push-сповіщень (FCM).", "P2 (Цінність - інформування), P9 (Система - надійна доставка), P12 (Прагматизм - готове рішення)."],
          ["<strong>Stripe</strong>", "Платіжна Система", "Обробка платежів за Premium-підписку. Доступ до платежів як до важеля створення Цінності/Багатства.", "Прийом платежів, управління підписками.", "P2 (Цінність - преміум), P10 (Багатство/Активи), P9 (Система - автоматизація платежів)."],
          ["<strong>Gmail API</strong>", "Сервіс відправки email", "Відправлення критично важливих email (коди підтвердження для реєстрації та 2FA).", "Відправлення транзакційних email.", "P3 (Якість - надійна доставка email), P9 (Система - частина автентифікації), P5 (Здоров'я - безпека користувача)."]
        ]
      },
      "neonIntegration": {
        "title": "3. Інтеграція з Neon: Фундамент Структурованих Даних",
        "generalInfo": {
          "title": "3.1. Загальна Інформація",
          "description": "Neon надає керований сервіс PostgreSQL. Ми використовуємо його як <strong>основне сховище структурованих даних</strong>, таких як інформація про користувачів, чати, повідомлення та метадані файлів.",
          "advantages": [
            "<strong>Прагматизм (P12):</strong> Безкоштовний тариф на старті (30 ГБ) повністю покриває початкові потреби.",
            "<strong>Система та Довгострокове Мислення (P9, P8):</strong> Керований сервіс знижує операційне навантаження, автоматичне масштабування та реплікація доступні на платних планах, забезпечуючи готовність до зростання.",
            "<strong>Якість (P3):</strong> Надійність та продуктивність PostgreSQL як перевіреної СУБД."
          ],
          "role": "Роль: Ядро, до якого звертається Backend для всіх CRUD-операцій над метаданими."
        },
        "configuration": {
          "title": "3.2. Конфігурація: Підключення до Системи Даних",
          "steps": [
            "1. <strong>Реєстрація та Створення Проєкту:</strong>",
            "Створіть обліковий запис на `https://neon.tech`.",
            "Створіть новий проєкт (наприклад, `brainmessenger-prod`) у консолі Neon.",
            "2. <strong>Налаштування Бази Даних:</strong>",
            "Neon автоматично надає інстанс PostgreSQL.",
            "<strong>Застосуйте схему бази даних:</strong> Використовуйте Prisma Migrate для ініціалізації структури таблиць (див. `database/schema.prisma` та Посібник з розробки).",
            "3. <strong>Змінні Середовища:</strong>",
            "Отримайте <strong>рядок підключення</strong> (Connection Details) з консолі Neon (Settings → Connection Details).",
            "Додайте у ваш `.env` файл:"
          ],
          "envExample": "```env\n# Рядок підключення до бази даних Neon\nDATABASE_URL=postgresql://<user>:<password>@<neon-host>/<dbname>?sslmode=require\n```",
          "note1": "*Примітка:* Використовуйте `sslmode=require` для безпечного з'єднання.",
          "backendCode": "4. <strong>Підключення Backend (NestJS + Prisma):</strong>\nPrisma використовує `DATABASE_URL` для підключення. Переконайтеся, що Prisma Client згенеровано (`npx prisma generate`).\nВикористовуйте `PrismaService` (з `nestjs-prisma`) для всіх операцій з БД.\n```typescript\n// backend/src/app.module.ts (або db.module.ts)\nimport { Module } from '@nestjs/common';\nimport { PrismaService } from 'nestjs-prisma'; // Переконайтеся, що PrismaModule імпортовано в app.module\n\n@Module({\n  providers: [PrismaService], // PrismaService доступний для ін'єкції\n  exports: [PrismaService],\n})\nexport class DbModule {}\n```"
        },
        "interactionScenarios": {
          "title": "3.3. Методи та Сценарії Взаємодії: API Даних",
          "description": "Усі взаємодії з Neon відбуваються через Prisma ORM у Backend, що забезпечує <strong>типізацію, безпеку та системність</strong> (Принцип 3, 9).",
          "signup": {
            "title": "Сценарій: Реєстрація користувача:",
            "interaction": "<strong>Взаємодія:</strong> Backend отримує дані користувача → Використовує `PrismaService` для створення нового запису в таблиці `users`.",
            "code": "<strong>Приклад коду (Backend Service):</strong>\n```typescript\n// backend/src/auth/auth.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { PrismaService } from 'nestjs-prisma';\nimport { Prisma } from '@prisma/client'; // Імпорт типів Prisma\n\n@Injectable()\nexport class AuthService {\n  constructor(private prisma: PrismaService) {}\n\n  async signUp(data: Prisma.UserCreateInput) {\n    // Приклад: пароль має бути захейшований ДО збереження\n    const hashedPassword = await hashPassword(data.password); // Використання утиліти для хешування\n    return this.prisma.user.create({\n      data: {\n        email: data.email,\n        name: data.name,\n        password: hashedPassword, // Зберігаємо захейшований пароль\n        // ... інші поля за схемою\n      },\n    });\n  }\n}\n```",
            "result": "<strong>Результат:</strong> Дані користувача надійно збережено в Neon."
          },
          "getChats": {
            "title": "Сценарій: Отримання списку чатів користувача:",
            "interaction": "<strong>Взаємодія:</strong> Frontend запитує чати через GraphQL API → Backend використовує `PrismaService` для виконання запиту до таблиці `chats` (можливо, з фільтрацією за `userId` та `include` для метаданих).",
            "code": "<strong>Приклад коду (Backend Service):</strong>\n```typescript\n// backend/src/chat/chat.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { PrismaService } from 'nestjs-prisma';\n\n@Injectable()\nexport class ChatService {\n  constructor(private prisma: PrismaService) {}\n\n  async getUserChats(userId: string) {\n    // Використовуємо індекси @@index([userId]) для оптимізації (Принцип 9, Оптимізація)\n    return this.prisma.chat.findMany({\n      where: {\n        users: { // Передбачається зв'язок Many-to-Many з таблицею UserChat\n          some: {\n            userId: userId,\n          },\n        },\n      },\n      select: { // Обираємо лише необхідні поля (Принцип 9, Оптимізація)\n        id: true,\n        name: true,\n        type: true,\n        // ... інші потрібні поля\n      },\n      orderBy: { // Сортування за датою останнього повідомлення для актуальності (Принцип 2, Цінність)\n        lastMessageAt: 'desc',\n      },\n    });\n  }\n}\n```"
          },
          "saveMessage": {
            "title": "Сценарій: Збереження повідомлення:",
            "interaction": "<strong>Взаємодія:</strong> Користувач відправляє повідомлення → Frontend відправляє його через GraphQL API → Backend використовує `PrismaService` для створення нового запису в таблиці `messages`, пов'язуючи його з `chatId` та `userId`.",
            "code": "<strong>Приклад коду (Backend Service):</strong>\n```typescript\n// backend/src/message/message.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { PrismaService } from 'nestjs-prisma';\nimport { Prisma } from '@prisma/client';\n\n@Injectable()\nexport class MessageService {\n  constructor(private prisma: PrismaService) {}\n\n  async createMessage(data: Prisma.MessageCreateInput) {\n    // Використовуємо транзакцію, якщо потрібно оновити дату останнього повідомлення в чаті\n    return this.prisma.$transaction(async (tx) => {\n      const message = await tx.message.create({ data });\n      await tx.chat.update({\n        where: { id: data.chatId },\n        data: { lastMessageAt: message.createdAt }, // Оновлюємо час останнього повідомлення\n      });\n      return message;\n    });\n  }\n}\n```"
          }
        },
        "errorHandling": {
          "title": "3.4. Обробка Помилок Інтеграції: Підтримка Якості Системи",
          "description": "Надійна система повинна вміти обробляти помилки зовнішніх залежностей (Принцип 3: Якість).",
          "connectionError": {
            "title": "Connection Error:",
            "cause": "Причина: Неможливо встановити з'єднання з Neon. Невірний рядок підключення (`DATABASE_URL`), проблеми з мережею, недоступність сервісу Neon.",
            "solution": "Рішення: Перевірити змінну середовища `DATABASE_URL`, статус сервісу Neon. Логувати помилку на Backend (Sentry/Winston)."
          },
          "queryError": {
            "title": "Database Query Error:",
            "cause": "Причина: Помилка виконання запиту до БД (наприклад, порушення унікальності, невірний тип даних). Помилка в логіці Backend, невідповідність схеми БД.",
            "solution": "Рішення: Відлагодити запит у Backend, перевірити логи Prisma. Логувати помилку."
          },
          "rateLimitError": {
            "title": "Rate Limit Exceeded (на платних тарифах):",
            "cause": "Причина: Перевищено ліміти на кількість запитів або обчислювальні ресурси в Neon. Високе навантаження, неоптимізовані запити, недостатній тарифний план.",
            "solution": "Рішення: Оптимізувати запити (див. Посібник з оптимізації), розглянути перехід на вищий тарифний план Neon."
          }
        }
      },
      "r2Integration": {
        "title": "4. Інтеграція з Cloudflare R2: Сховище Цифрових Активів",
        "generalInfo": {
          "title": "4.1. Загальна Інформація",
          "description": "Cloudflare R2 — це сервіс об'єктного сховища, сумісний з S3 API. Ми використовуємо його для зберігання <strong>всіх файлів користувачів</strong>, таких як зображення, відео, документи, а також зашифровані дані.",
          "advantages": [
            "<strong>Прагматизм (P12), Створення Багатства/Активів (P10):</strong> <strong>Відсутність плати за вихідний трафік</strong> — критично важлива перевага для месенджера, де користувачі активно обмінюються файлами. Безкоштовний тариф 10 ГБ на старті.",
            "<strong>Якість (P3):</strong> Висока продуктивність та надійність завдяки глобальній мережі Cloudflare.",
            "<strong>Довгострокове Мислення (P8), Система (P9):</strong> S3-сумісний API дозволяє легко використовувати стандартні бібліотеки та інструменти, забезпечуючи гнучкість у майбутньому."
          ],
          "role": "Роль: Децентралізоване сховище для великих бінарних об'єктів, що знижує навантаження на основну базу даних."
        },
        "configuration": {
          "title": "4.2. Конфігурація: Підключення до Сховища Активів",
          "steps": [
            "1. <strong>Створення Бакета:</strong>",
            "Увійдіть у Cloudflare Dashboard → R2.",
            "Натисніть <strong>\"Create Bucket\"</strong>.",
            "Назвіть бакет (наприклад, `brainmessenger-files`). Назва має бути унікальною в рамках усіх облікових записів Cloudflare.",
            "<strong>Налаштування:</strong> Увімкніть шифрування у стані спокою (Encryption at rest) — це частина нашої <strong>системи безпеки</strong> (Принцип 3, 5). Обмежте публічний доступ до бакету, доступ буде здійснюватися через підписані URL (якщо потрібно) або через Backend.",
            "2. <strong>Ключі Доступу:</strong>",
            "У Cloudflare Dashboard перейдіть до R2 → Manage R2 API Tokens.",
            "Створіть новий API-токен. Надайте йому мінімально необхідні дозволи (наприклад, Read and Write to specific buckets).",
            "Скопіюйте `Access Key ID` та `Secret Access Key`.",
            "3. <strong>Змінні Середовища:</strong>",
            "Додайте у ваш `.env` файл:"
          ],
          "envExample": "```env\n# Cloudflare R2 Credentials\nR2_ENDPOINT=<Your R2 Endpoint> # Формат: https://<account-id>.r2.cloudflarestorage.com\nR2_ACCESS_KEY=<Your Access Key ID>\nR2_SECRET_KEY=<Your Secret Access Key>\nR2_BUCKET=brainmessenger-files # Назва вашого бакета\n\n# Ключ шифрування для конфіденційних даних (важливо для P3, P5, P10)\nENCRYPTION_KEY=<Your 32-byte (256-bit) hex or base64 encryption key> # Згенеруйте надійний ключ!\n```",
          "note": "*Примітка:* <strong>Не комітьте ці ключі в Git!</strong> (Принцип 3, 5, 6). Використовуйте `.env.example` без чутливих даних. <strong>ENCRYPTION_KEY</strong> має бути згенерований надійно та зберігатися в безпеці.",
          "backendCode": "4. <strong>Підключення Backend (`@aws-sdk/client-s3`):</strong>\nR2 сумісний з S3 API, тому можна використовувати стандартний AWS SDK для S3.\nВстановіть SDK: `npm install @aws-sdk/client-s3`.\nІніціалізуйте S3 Client у вашому Backend-сервісі (наприклад, `StorageService`).\n```typescript\n// backend/src/storage/storage.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3';\nimport { getSignedUrl } from '@aws-sdk/s3-request-presigner'; // Для підписаних URL\nimport { createCipheriv, randomBytes, createDecipheriv } from 'crypto'; // Для шифрування\n\n@Injectable()\nexport class StorageService {\n  private r2: S3Client;\n  private encryptionKey: Buffer; // Ключ для шифрування\n\n  constructor() {\n    this.r2 = new S3Client({\n      region: 'auto', // R2 не використовує регіони в класичному розумінні\n      endpoint: process.env.R2_ENDPOINT,\n      credentials: {\n        accessKeyId: process.env.R2_ACCESS_KEY,\n        secretAccessKey: process.env.R2_SECRET_KEY,\n      },\n    });\n    // Важливо: ENCRYPTION_KEY має бути Buffer 32 байти для aes-256-cbc\n    this.encryptionKey = Buffer.from(process.env.ENCRYPTION_KEY, 'hex'); // Або 'base64'\n    if (this.encryptionKey.length !== 32) {\n         // Логувати помилку або викинути виняток - ключ невірної довжини\n         console.error(\"Invalid ENCRYPTION_KEY length. Must be 32 bytes for aes-256-cbc.\");\n         // process.exit(1); // Можливо, варто зупинити додаток\n    }\n  }\n\n  // Утиліта для шифрування (частина системи безпеки - P3, P5)\n  private encrypt(data: string): { encrypted: string, iv: string } {\n    const iv = randomBytes(16); // Initialization Vector, 16 байт для aes-256-cbc\n    const cipher = createCipheriv('aes-256-cbc', this.encryptionKey, iv);\n    let encrypted = cipher.update(data, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    return { encrypted, iv: iv.toString('hex') };\n  }\n\n  // Утиліта для дешифрування\n  private decrypt(encrypted: string, iv: string): string {\n      const decipher = createDecipheriv('aes-256-cbc', this.encryptionKey, Buffer.from(iv, 'hex'));\n      let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n      decrypted += decipher.final('utf8');\n      return decrypted;\n  }\n\n  // ... методи для роботи з R2 (завантаження, скачування, видалення)\n}\n```"
        },
        "interactionScenarios": {
          "title": "4.3. Методи та Сценарії Взаємодії: API Сховища",
          "description": "Взаємодія з R2 здійснюється через Backend, що дозволяє контролювати доступ, обробляти файли (наприклад, оптимізація зображень перед завантаженням) та керувати метаданими в БД (Принцип 9: Система).",
          "uploadFile": {
            "title": "Сценарій: Завантаження файлу користувачем:",
            "interaction": "<strong>Взаємодія:</strong> Користувач прикріплює файл у чаті → Frontend відправляє файл на Backend → Backend (`StorageService`) завантажує файл у R2 → Backend зберігає метадані файлу (URL, тип, розмір) у Neon → Backend відправляє повідомлення в чат з посиланням на файл.",
            "code": "<strong>Приклад коду (Backend Service):</strong>\n```typescript\n// backend/src/storage/storage.service.ts (продовження)\n// ... S3Client та encryptionKey ініціалізація ...\n\nasync uploadFile(fileBuffer: Buffer, fileName: string, mimeType: string): Promise<string> {\n  const key = `uploads/${Date.now()}-${fileName}`; // Унікальний ключ файлу\n  const params = {\n    Bucket: process.env.R2_BUCKET,\n    Key: key,\n    Body: fileBuffer,\n    ContentType: mimeType, // Важливо для віддачі файлу\n  };\n  const command = new PutObjectCommand(params);\n  await this.r2.send(command); // Асинхронне завантаження\n\n  // Повертаємо URL для збереження в БД. R2 дозволяє прямі посилання, якщо налаштовано публічний домен.\n  // АБО генеруємо підписаний URL для обмеженого доступу (більш безпечно).\n  // Приклад прямого посилання (вимагає налаштування Public Access URL у CF Dashboard):\n  // const publicUrl = `${process.env.R2_ENDPOINT.replace('.r2.cloudflarestorage.com', '.r2.dev')}/${process.env.R2_BUCKET}/${key}`;\n  // Для власного домену (бажано):\n  const fileUrl = `https://r2.brainmessenger.com/${key}`; // Ваш налаштований домен Cloudflare Workers/Pages\n\n  return fileUrl;\n}\n\n//backend/src/chat/chat.service.ts (інтеграція uploadFile)\n// ... constructor з StorageService ...\nasync sendFileMessage(chatId: string, userId: string, file: Express.Multer.File): Promise<Message> {\n   // Опціонально: обробка зображення перед завантаженням (див. DocOptimizationIn)\n   // const processedFileBuffer = await this.imageProcessingService.processImage(file.buffer, 800, 600); // Приклад\n   const fileUrl = await this.storageService.uploadFile(file.buffer, file.originalname, file.mimetype);\n\n   // Створюємо повідомлення в БД з посиланням на файл\n   return this.prisma.message.create({\n     data: {\n       chatId,\n       userId,\n       content: '[File]', // Або інше позначення файлу\n       fileUrl: fileUrl, // Зберігаємо посилання на файл у БД\n       // fileMetadata: { type: file.mimetype, size: file.size }, // Опціонально: збереження метаданих у JSON полі або окремій таблиці\n     },\n   });\n}\n```",
            "result": "<strong>Результат:</strong> Файл надійно зберігається в R2, посилання на нього доступне в БД для відображення в чаті."
          },
          "sensitiveData": {
            "title": "Сценарій: Зберігання конфіденційних даних (наприклад, зашифровані метадані):",
            "interaction": "<strong>Взаємодія:</strong> При реєстрації або оновленні профілю Backend шифрує чутливі дані (наприклад, резервні email, секретні питання) та зберігає їх у R2 в окремому бакеті або папці.",
            "code": "<strong>Приклад коду (Backend Service):</strong>\n```typescript\n// backend/src/storage/storage.service.ts (продовження)\n// ... методи encrypt/decrypt ...\n\nasync storeSensitiveData(userId: string, sensitiveInfo: any): Promise<string> {\n   const encryptedData = {};\n   for (const key in sensitiveInfo) {\n       if (sensitiveInfo.hasOwnProperty(key)) {\n           const { encrypted, iv } = this.encrypt(JSON.stringify(sensitiveInfo[key])); // Шифруємо кожне поле або весь об'єкт\n           encryptedData[key] = { encrypted, iv };\n       }\n   }\n\n   const key = `sensitive/${userId}/metadata.json`;\n   const params = {\n       Bucket: process.env.R2_BUCKET, // Або окремий бакет для чутливих даних\n       Key: key,\n       Body: JSON.stringify(encryptedData),\n       ContentType: 'application/json',\n   };\n   const command = new PutObjectCommand(params);\n   await this.r2.send(command);\n   return `https://r2.brainmessenger.com/${key}`; // Посилання для внутрішнього використання\n}\n\n// backend/src/user/user.service.ts (інтеграція storeSensitiveData)\n// ... constructor з StorageService ...\nasync createUserWithSensitiveData(userData: any, sensitiveData: any) {\n    // Створюємо користувача в БД\n    const user = await this.prisma.user.create({ data: userData });\n    // Зберігаємо зашифровані дані в R2\n    const sensitiveDataUrl = await this.storageService.storeSensitiveData(user.id, sensitiveData);\n    // Зберігаємо посилання на зашифровані дані в БД (опціонально)\n    await this.prisma.user.update({\n        where: { id: user.id },\n        data: { sensitiveDataUrl: sensitiveDataUrl } // Додати поле sensitiveDataUrl у схему Prisma\n    });\n    return user;\n}\n```",
            "result": "<strong>Результат:</strong> Конфіденційні дані надійно зашифровані та зберігаються окремо від основної БД в R2. Доступ до них можливий лише через Backend з використанням ключа шифрування."
          },
          "getFile": {
            "title": "Сценарій: Отримання файлу (для відображення або скачування):",
            "interaction": "<strong>Взаємодія:</strong> Frontend отримує URL файлу з метаданих повідомлення (з Neon) → Frontend (або Backend, якщо потрібна автентифікація/підписані URL) використовує цей URL для скачування файлу безпосередньо з R2.",
            "code": "<strong>Реалізація:</strong> Якщо бакет R2 налаштований з Public Access URL (через Cloudflare Workers/Pages), Frontend може звертатися безпосередньо. Якщо доступ обмежений, Backend може генерувати тимчасові підписані URL через `@aws-sdk/s3-request-presigner`.\n```typescript\n// backend/src/storage/storage.service.ts (продовження)\n// ... S3Client ініціалізація ...\n\n// Метод для генерації підписаного URL (більш безпечний підхід для приватних файлів)\nasync getSignedFileUrl(fileKey: string): Promise<string> {\n    const command = new GetObjectCommand({\n        Bucket: process.env.R2_BUCKET,\n        Key: fileKey,\n    });\n    // Згенерувати підписаний URL, дійсний, наприклад, 60 секунд\n    const signedUrl = await getSignedUrl(this.r2, command, { expiresIn: 60 });\n    return signedUrl;\n}\n```"
          }
        },
        "errorHandling": {
          "title": "4.4. Обробка Помилок Інтеграції: Сховище Активів",
          "forbidden": {
            "title": "403 Forbidden:",
            "cause": "Причина: Помилка доступу до бакету R2. Невірні ключі доступу (`R2_ACCESS_KEY`, `R2_SECRET_KEY`), невірні дозволи токена, спроба доступу до приватного файлу без автентифікації/підписаного URL.",
            "solution": "Рішення: Перевірити змінні середовища, дозволи токена R2. Переконатися, що логіка доступу (публічний URL vs підписаний URL) реалізована коректно. Логувати помилку."
          },
          "notFound": {
            "title": "404 Not Found:",
            "cause": "Причина: Файл відсутній у R2. Невірний ключ файлу (`Key`), файл було видалено.",
            "solution": "Рішення: Перевірити ключ файлу, який було збережено в Neon. Переконатися, що файл дійсно було завантажено. Логувати помилку."
          },
          "tooManyRequests": {
            "title": "429 Too Many Requests:",
            "cause": "Причина: Перевищено ліміт запитів до R2 API. Висока частота запитів завантаження/скачування.",
            "solution": "Рішення: Впровадити Rate Limiting на Backend (див. Посібник з оптимізації). Оптимізувати логіку роботи з файлами."
          },
          "encryptionError": {
            "title": "Encryption/Decryption Error:",
            "cause": "Причина: Помилка шифрування/дешифрування. Невірний ключ шифрування (`ENCRYPTION_KEY`), пошкоджений IV, пошкоджені зашифровані дані.",
            "solution": "Рішення: Переконатися, що використовується правильний ключ (`ENCRYPTION_KEY`), який збігається з ключем, використаним при шифруванні. Перевірити цілісність даних та IV. Логувати критичну помилку."
          }
        }
      },
      "neonR2Interaction": {
        "title": "5. Взаємодія Neon та Cloudflare R2: Оптимізація Зберігання Даних (Принцип 9, 12)",
        "description": "Ми використовуємо Neon та R2 спільно, щоб створити оптимізовану систему зберігання даних, де кожен сервіс виконує свою найкращу функцію (Принцип 9).",
        "scenario": [
          "<strong>Neon (PostgreSQL):</strong> Зберігає <strong>структуровані метадані</strong>, які часто запитуються і за якими виконуються складні запити (користувачі, чати, текстові повідомлення, посилання на файли).",
          "<strong>Cloudflare R2:</strong> Зберігає <strong>неструктуровані бінарні дані</strong> великого розміру (файли), які рідше запитуються і не вимагають складної логіки вибірки за вмістом).",
          "<strong>Сценарій комплексного взаємодії:</strong>",
          "1. Користувач відправляє файл через чат (Frontend -> Backend).",
          "2. Backend (`StorageService`) <strong>завантажує файл у Cloudflare R2</strong> (використовуючи S3 API). Отримує URL файлу (або ключ).",
          "3. Backend (`ChatService`) <strong>зберігає метадані повідомлення в Neon через Prisma</strong>, включаючи отриманий URL/ключ файлу.",
          "4. Коли інший користувач відкриває чат, Backend (`ChatService`) <strong>отримує список повідомлень з Neon через Prisma</strong>, включаючи URL/ключі файлів.",
          "5. Frontend відображає список повідомлень та використовує URL/ключі для <strong>скачування файлів безпосередньо з R2</strong> (або через Backend, якщо потрібна автентифікація)."
        ],
        "advantagesTitle": "Переваги такого розділення:",
        "advantages": [
          "<strong>Оптимізація продуктивності БД:</strong> PostgreSQL не \"засмічується\" великими бінарними даними, що покращує швидкість текстових запитів (Принцип 9).",
          "<strong>Зниження вартості:</strong> R2 пропонує дуже вигідні тарифи для зберігання великих обсягів даних без плати за вихідний трафік, що <strong>прагматично</strong> (Принцип 12) та сприяє створенню <strong>активу</strong> (Принцип 10).",
          "<strong>Масштабованість:</strong> Кожен сервіс масштабується незалежно відповідно до свого типу навантаження (Neon для транзакцій, R2 для обсягу/трафіку файлів).",
          "<strong>Надійність:</strong> Розділення відповідальності між сервісами підвищує загальну відмовостійкість системи."
        ]
      },
      "otherIntegrations": {
        "title": "6. Інші Інтеграції: Розширення Функціоналу Системи (Принцип 2, 12)",
        "description": "Ці інтеграції додають <strong>цінність</strong> (Принцип 2) та використовують <strong>прагматичні, готові рішення</strong> (Принцип 12).",
        "firebase": {
          "title": "6.1. Firebase (Push-сповіщення)",
          "purpose": "Призначення: Миттєва доставка сповіщень про нові повідомлення, дзвінки та системні події користувачам мобільних додатків.",
          "role": "Роль: <strong>Критично важливий компонент системи сповіщень</strong> (Принцип 9) для підтримки залученості користувачів та оперативного інформування (Принцип 2).",
          "configuration": "Конфігурація: Змінна середовища: `FIREBASE_CREDENTIALS_PATH` (шлях до JSON-файлу облікових даних сервісного облікового запису Firebase). <strong>Зберігайте цей файл безпечно!</strong>",
          "example": "Використовується бібліотека `firebase-admin` у Backend NestJS. Приклад використання: Відправлення сповіщення при отриманні нового повідомлення (див. Посібник з оптимізації для батчингу та тем)."
        },
        "stripe": {
          "title": "6.2. Stripe (Платежі)",
          "purpose": "Призначення: Обробка підписок на Premium-функціонал BrainMessenger.",
          "role": "Роль: <strong>Фінансовий важіль</strong> для підтримки розвитку проєкту (Принцип 10: Створення Багатства) та надання додаткової <strong>цінності</strong> (Принцип 2) преміум-користувачам.",
          "configuration": "Конфігурація: Змінна середовища: `STRIPE_SECRET_KEY`.",
          "example": "Використовується бібліотека `stripe` у Backend NestJS. Приклад використання: Створення сесії оплати при спробі оформити підписку. Обробка вебхуків для підтвердження успішної оплати."
        },
        "gmailApi": {
          "title": "6.3. Gmail API (Відправлення Email)",
          "purpose": "Призначення: Відправлення транзакційних email, таких як коди підтвердження для реєстрації та двофакторної автентифікації (2FA), сповіщення про скидання пароля.",
          "role": "Роль: <strong>Критично важливий компонент системи автентифікації та безпеки</strong> (Принцип 9, 5).",
          "configuration": "Конфігурація: Вимагає налаштування сервісного облікового запису Google Cloud та отримання облікових даних (див. Технічну документацію, розділ 10.1). Змінні середовища для облікових даних сервісного облікового запису або API-ключів.",
          "example": "Приклад використання: Виклик API для відправлення листа з кодом підтвердження після введення email при реєстрації або ввімкненні 2FA (див. Специфікацію API, розділ 2.4)."
        }
      },
      "recommendations": {
        "title": "7. Рекомендації щодо Інтеграцій: Підтримка Здоров'я Системи (Принцип 3, 5, 9)",
        "intro": "Щоб інтеграції залишалися <strong>надійними, безпечними та ефективними</strong> (Принцип 3, 9), дотримуйтесь цих рекомендацій, пов'язаних з підтримкою \"здоров'я\" системи (Принцип 5, стосовно техніки):",
        "security": {
          "title": "Безпека:",
          "points": [
            "<strong>Ніколи не комітьте ключі та секрети в Git.</strong> Використовуйте змінні середовища та системи управління секретами в продакшен-середовищі (наприклад, Kubernetes Secrets, HashiCorp Vault).",
            "Регулярно проводьте <strong>ротацію API-токенів</strong> (R2, Firebase, Gmail, Stripe) для підвищення безпеки.",
            "Використовуйте <strong>принцип мінімальних привілеїв</strong> при створенні API-токенів: надавайте їм лише ті дозволи, які дійсно необхідні."
          ]
        },
        "scaling": {
          "title": "Масштабування:",
          "points": [
            "<strong>Моніторте використання ресурсів</strong> (місце в Neon/R2, запити до API Firebase/Stripe) через консолі відповідних сервісів. Будьте готові перейти на платний тариф при зростанні навантаження (Принцип 8, 12).",
            "Використовуйте <strong>оптимізаційні підходи</strong> (наприклад, батчинг запитів до Firebase, індексування в Neon, див. Посібник з оптимізації), щоб відкласти необхідність переходу на дорожчі тарифи."
          ]
        },
        "monitoring": {
          "title": "Моніторинг та Логування:",
          "points": [
            "Налаштуйте <strong>логування помилок інтеграцій</strong> у NestJS (Winston, Sentry).",
            "Використовуйте <strong>системи моніторингу</strong> (Prometheus/Grafana) для відстеження метрик запитів до зовнішніх сервісів (затримки, кількість помилок) — це частина <strong>Кайдзен</strong> (Принцип 9), що дозволяє виявляти проблеми на ранній стадії."
          ]
        },
        "errorHandling": {
          "title": "Обробка Помилок:",
          "points": [
            "Реалізуйте <strong>грамотну обробку помилок</strong> від зовнішніх сервісів на Backend. Логуйте їх детально.",
            "Для критично важливих операцій (наприклад, реєстрація, платежі) передбачте механізми <strong>повторних спроб (retries)</strong> або <strong>компенсуючих дій</strong> (наприклад, позначка платежу як незавершеного) при тимчасових збоях зовнішніх сервісів."
          ]
        },
        "documentation": {
          "title": "Документація:",
          "content": "Підтримуйте цю документацію в актуальному стані, відображаючи зміни у використовуваних сервісах або додаванні нових інтеграцій (Принцип 1: Навчання, Принцип 9: Система)."
        }
      }
    },
    "optimizationGuide": {
      "title": "Посібник з Оптимізації BrainMessenger (Принцип Кайдзен у Дії)",
      "subtitle": "Вступ: Оптимізація як Безперервний Процес Покращення",
      "introduction": {
        "title": "1. Вступ: Оптимізація як Безперервний Процес Покращення",
        "description": "Цей документ детально описує підходи, інструменти та техніки, які ми використовуємо для оптимізації продуктивності BrainMessenger. Оптимізація — це не одноразове завдання, а <strong>безперервний процес покращення</strong> (Принцип 1, 9: Кайдзен), який дозволяє нам забезпечити <strong>високу якість, надійність та масштабованість</strong> (Принцип 3, 8) застосунку.",
        "goalTitle": "Мета:",
        "goalContent": "Ідентифікувати та усувати вузькі місця у продуктивності на всіх рівнях системи (Frontend, Backend, База даних, Інфраструктура), щоб BrainMessenger залишався <strong>швидким, чуйним та ефективним</strong> (Принцип 2) навіть при значному навантаженні (ціль — 1 мільйон активних користувачів), підтримуючи <strong>здоров'я системи</strong> (Принцип 5, стосовно техніки).",
        "audienceTitle": "Аудиторія:",
        "audienceContent": "Backend, Frontend, Mobile, Desktop та DevOps розробники, сфокусовані на продуктивності та масштабуванні.",
        "principlesTitle": "Принципи, якими керується оптимізація:",
        "principles": [
          "<strong>Система та Оптимізація (Принцип 9: Кайдзен):</strong> Оптимізація є ключовим аспектом нашої системи розробки. Використовується циклічний підхід: Вимірювання → Аналіз → Покращення → Перевірка.",
          "<strong>Якість > Кількість (Принцип 3):</strong> Краще мати кілька критично важливих оптимізацій, ніж багато дрібних, що не дають значного ефекту.",
          "<strong>Прагматизм та Реалізм (Принцип 12):</strong> Оптимізуємо те, що дійсно впливає на продуктивність та користувацький досвід, ґрунтуючись на реальних даних, а не на здогадках.",
          "<strong>Постійне Навчання (Принцип 1):</strong> Вивчення нових технік та інструментів оптимізації, аналіз результатів та уроків.",
          "<strong>Наполегливість (Принцип 13):</strong> Оптимізація може бути складною. Потрібна наполегливість для виявлення та вирішення глибоких проблем продуктивності.",
          "<strong>Здоров'я як Фундамент (Принцип 5):</strong> Оптимізація системи (наприклад, зниження споживання пам'яті/CPU) безпосередньо впливає на \"здоров'я\" серверів та пристроїв користувачів.",
          "<strong>Зовнішня Експертиза (Принцип 14):</strong> Використання стандартних інструментів (Prometheus, Grafana, V8 Profiler), вивчення досвіду інших команд (Google, Next.js тощо)."
        ]
      },
      "generalPrinciple": {
        "title": "2. Загальний Принцип Оптимізації (Цикл Кайдзен)",
        "intro": "Наш підхід до оптимізації слідує <strong>циклу Кайдзен (Принцип 9)</strong>:",
        "step1": {
          "title": "1. Вимірювання (Measure):",
          "content": "Зберіть дані про продуктивність. Використовуйте інструменти моніторингу (Prometheus, Sentry), профілювання (V8 Profiler), аналізу бандлів (Webpack Bundle Analyzer, `@next/bundle-analyzer`)."
        },
        "step2": {
          "title": "2. Аналіз (Analyze):",
          "content": "Визначте <strong>вузькі місця (bottlenecks)</strong> на основі зібраних даних. Де система витрачає найбільше часу або ресурсів?"
        },
        "step3": {
          "title": "3. Покращення (Improve):",
          "content": "Застосуйте конкретні техніки оптимізації, описані в цьому посібнику, для усунення виявлених вузьких місць."
        },
        "step4": {
          "title": "4. Перевірка (Verify):",
          "content": "Знову виміряйте продуктивність після внесених змін. Переконайтеся, що оптимізація дала очікуваний ефект і не викликала регресій (не погіршила інші аспекти)."
        },
        "step5": {
          "title": "5. Повторення:",
          "content": "Продуктивність може змінюватися зі зростанням навантаження та функціоналу. Повторюйте цикл Кайдзен безперервно."
        }
      },
      "imageProcessing": {
        "title": "3. Оптимізація Обробки Зображень: Ефективність та Швидкість (Принцип 9, 2)",
        "intro": "Обробка зображень може бути ресурсоємною. <strong>Оптимізація цього процесу безпосередньо впливає на швидкість завантаження контенту та чуйність застосунку</strong> (Принцип 2: Цінність).",
        "libraryTitle": "Бібліотека:",
        "libraryContent": "`sharp` (на базі `libvips`). Обрано як <strong>прагматичне</strong> (Принцип 12) та <strong>високопродуктивне</strong> (Принцип 9) рішення для Node.js.",
        "applicationAreasTitle": "Області застосування:",
        "applicationAreasContent": "Зміна розміру, стиснення, конвертація формату для аватарів, зображень у чатах.",
        "keyTechniqueTitle": "Ключова техніка:",
        "keyTechniqueContent": "<strong>Асинхронна обробка</strong> у фоновому режимі через Kafka.",
        "implementationStepsTitle": "Кроки з впровадження (Backend):",
        "step1": {
          "title": "1. Встановіть `sharp`:",
          "content": "Переконайтеся, що `libvips` встановлено у вашій операційній системі або Docker-образі.",
          "code": "```bash\\nnpm install sharp\\n```"
        },
        "step2": {
          "title": "2. Створіть сервіс обробки зображень:",
          "content": "Інкапсулюйте логіку в окремому сервісі (частина <strong>системи</strong> - Принцип 9).",
          "code": "```typescript\\n// backend/src/image-processing/image-processing.service.ts\\nimport { Injectable } from '@nestjs/common';\\nimport sharp from 'sharp';\\n\\n@Injectable()\\nexport class ImageProcessingService {\\n  // Метод для зміни розміру, стиснення та конвертації в WebP\\n  async processImage(buffer: Buffer, width: number, height?: number): Promise<Buffer> {\\n    // resize({ width, height, withoutEnlargement: true }) - уникаємо збільшення, якщо оригінал менший\\n    // webp({ quality: 80 }) - стиснення у формат WebP (гарне стиснення при збереженні якості)\\n    // withMetadata({ orientation: true }) - зберігаємо орієнтацію з EXIF, решту видаляємо (економія розміру - Принцип 9)\\n    return sharp(buffer)\\n      .resize(width, height, { withoutEnlargement: true })\\n      .webp({ quality: 80 })\\n      .withMetadata({ orientation: true })\\n      .toBuffer();\\n  }\\n\\n  // Метод для простої зміни розміру\\n  async resizeImage(buffer: Buffer, width: number, height?: number): Promise<Buffer> {\\n       return sharp(buffer)\\n           .resize(width, height, { withoutEnlargement: true })\\n           .toBuffer();\\n  }\\n\\n   // Метод для конвертації в певний формат\\n   async convertToFormat(buffer: Buffer, format: keyof sharp.Format): Promise<Buffer> {\\n       return sharp(buffer).toFormat(format).toBuffer();\\n   }\\n}\\n```"
        },
        "step3": {
          "title": "3. Інтеграція із завантаженням файлів (Backend Controller/Service):",
          "content": "",
          "code": "```typescript\\n// backend/src/upload/upload.controller.ts (приклад обробки завантаження аватара)\\nimport { Controller, Post, UploadedFile, UseInterceptors, Body, Inject } from '@nestjs/common';\\nimport { FileInterceptor } from '@nestjs/platform-express';\\nimport { ImageProcessingService } from '../image-processing/image-processing.service';\\nimport { StorageService } from '../storage/storage.service';\\nimport { UserService } from '../user/user.service';\\n\\n@Controller('upload')\\nexport class UploadController {\\n  constructor(\\n    private imageProcessingService: ImageProcessingService,\\n    private storageService: StorageService,\\n    private userService: UserService,\\n    // ... ін'єкція Kafka продюсера для асинхронної обробки\\n  ) {}\\n\\n  @Post('avatar')\\n  @UseInterceptors(FileInterceptor('file')) // 'file' - ім'я поля форми\\n  async uploadAvatar(@UploadedFile() file: Express.Multer.File, @Body('userId') userId: string) {\\n    // Оптимізація: Обробка зображення перед завантаженням в R2\\n    const processedImageBuffer = await this.imageProcessingService.processImage(file.buffer, 300, 300); // Змінити розмір та стиснути\\n    const fileName = `avatars/${userId}-${Date.now()}.webp`; // Унікальне ім'я файлу в папці avatars\\n    const mimeType = 'image/webp'; // Відповідає формату WebP\\n\\n    // Завантаження обробленого файлу в Cloudflare R2\\n    const avatarUrl = await this.storageService.uploadFile(processedImageBuffer, fileName, mimeType);\\n\\n    // Оновлення посилання на аватар у профілі користувача в Neon\\n    await this.userService.updateUserAvatar(userId, avatarUrl);\\n\\n    // Повертаємо URL аватара клієнту\\n    return { avatarUrl };\\n  }\\n\\n  @Post('chat-image')\\n  @UseInterceptors(FileInterceptor('file'))\\n  async uploadChatImage(@UploadedFile() file: Express.Multer.File, @Body('chatId') chatId: string, @Body('userId') userId: string) {\\n      // Надсилання завдання на обробку зображення в Kafka для асинхронної обробки (Принцип 9)\\n      const taskPayload = { fileBuffer: file.buffer.toString('base64'), fileName: file.originalname, mimeType: file.mimetype, chatId, userId };\\n      // Передбачається, що у вас є Kafka продюсер сервіс\\n      // await this.kafkaProducerService.sendMessage('image-processing-topic', JSON.stringify(taskPayload));\\n\\n      // Негайна відповідь клієнту, що файл прийнято до обробки\\n      return { status: 'processing', originalFileName: file.originalname };\\n\\n      // АБО, якщо синхронна обробка прийнятна для невеликих файлів:\\n      /*\\n      const processedImageBuffer = await this.imageProcessingService.processImage(file.buffer, 800); // Змінити розмір\\n      const fileName = `chat-images/${chatId}-${Date.now()}.webp`;\\n      const mimeType = 'image/webp';\\n      const imageUrl = await this.storageService.uploadFile(processedImageBuffer, fileName, mimeType);\\n\\n      // Створення повідомлення типу 'image' у чаті\\n      // await this.chatService.sendImageMessage(chatId, userId, imageUrl);\\n\\n      return { imageUrl };\\n      */\\n  }\\n}\\n```"
        },
        "step4": {
          "title": "4. Асинхронність через Kafka (для важких завдань):",
          "content": "Для обробки зображень у чатах (які можуть бути великими) використовуйте <strong>Kafka</strong> (див. розділ 8) для <strong>асинхронної обробки</strong>. Backend швидко приймає файл від клієнта і ставить завдання в чергу Kafka. Окремий воркер (consumer Kafka) забирає завдання, обробляє зображення за допомогою `sharp`, завантажує в R2 і тільки після цього створює повідомлення в чаті через API. Це <strong>знижує час відповіді API</strong> (Принцип 9) та покращує користувацький досвід."
        }
      },
      "dbOptimization": {
        "title": "4. Оптимізація Бази Даних (Neon/PostgreSQL): Прискорення Доступу до Даних (Принцип 9, 8)",
        "intro": "База даних часто стає вузьким місцем. Оптимізація запитів та структури БД критично важлива для <strong>довгострокової продуктивності</strong> (Принцип 8) та <strong>ефективності системи</strong> (Принцип 9).",
        "platformTitle": "Платформа:",
        "platformContent": "Neon (керований PostgreSQL).",
        "toolTitle": "Інструмент:",
        "toolContent": "Prisma ORM.",
        "analysisToolTitle": "Інструмент аналізу:",
        "analysisToolContent": "`EXPLAIN ANALYZE` у SQL-клієнті Neon або `prisma.queryRaw` з `EXPLAIN ANALYZE`.",
        "monitoringToolTitle": "Інструмент моніторингу:",
        "monitoringToolContent": "Prometheus + `postgres_exporter` (див. розділ 14).",
        "indexing": {
          "title": "4.1. Індексація: Прискорення Пошуку та Фільтрації",
          "intro": "Індекси дозволяють базі даних швидше знаходити потрібні рядки.",
          "whenTitle": "Коли використовувати:",
          "whenContent": "На полях, які часто використовуються в `WHERE`, `JOIN`, `ORDER BY`.",
          "applicationAreasTitle": "Області застосування в BrainMessenger:",
          "applicationAreasContent": "`userId`, `chatId`, `createdAt` (у таблиці `Message`), `email` (у таблиці `User`), поля для пошуку.",
          "prismaTitle": "Реалізація (Prisma):",
          "prismaContent": "Додавайте `@index` до `schema.prisma`.",
          "prismaCode": "```prisma\\n// schema.prisma\\nmodel Message {\\n  id        String   @id @default(cuid())\\n  content   String\\n  createdAt DateTime @default(now()) @map(\\\"created_at\\\") // Приклад @map для snake_case в БД\\n  chatId    String @map(\\\"chat_id\\\")\\n  userId    String @map(\\\"user_id\\\")\\n  chat      Chat     @relation(fields: [chatId], references: [id])\\n  user      User     @relation(fields: [userId], references: [id])\\n\\n  // Комбінований індекс для швидких запитів повідомлень у чаті за часом\\n  @@index([chatId, createdAt])\\n  // Індекс для швидкого отримання повідомлень за користувачем (наприклад, для статистики)\\n  @@index([userId])\\n  // Індекс для пошуку за вмістом (якщо потрібен повнотекстовий пошук - розглянути tsearch)\\n  // @@index([content]) // Тільки для простих фільтрів LIKE\\n}\\n\\nmodel User {\\n    id    String @id @default(cuid())\\n    email String @unique // Унікальний індекс для швидкого пошуку за email (логін, реєстрація)\\n    name  String\\n    // ... інші поля\\n}\\n\\nmodel Chat {\\n   id          String @id @default(cuid())\\n   lastMessageAt DateTime? @map(\\\"last_message_at\\\") // Для сортування чатів (потрібен індекс)\\n   // ... інші поля\\n   @@index([lastMessageAt]) // Індекс для сортування списку чатів\\n}\\n```",
          "applicationTitle": "Застосування:",
          "applicationContent": "Після зміни `schema.prisma` виконайте міграцію (`npx prisma migrate dev`)."
        },
        "queryOptimization": {
          "title": "4.2. Оптимізація Запитів (Prisma): Пишемо Ефективний Код Взаємодії з БД",
          "intro": "",
          "selectFieldsTitle": "Обирайте лише потрібні поля (`select`):",
          "selectFieldsContent": "Не запитуйте `SELECT *`. Вказуйте поля, які вам дійсно потрібні. Це зменшує обсяг даних, що передаються мережею та обробляються БД.",
          "selectFieldsCode": "```typescript\\n// Погано\\nconst user = await prisma.user.findUnique({ where: { id: userId } }); // Вибере всі поля\\n\\n// Добре (якщо потрібні лише email та name)\\nconst user = await prisma.user.findUnique({\\n  where: { id: userId },\\n  select: {\\n    email: true,\\n    name: true,\\n  },\\n});\\n```",
          "nPlus1Title": "Уникайте N+1 проблем (`include`):",
          "nPlus1Content": "Якщо вам потрібні пов'язані дані (наприклад, автор повідомлення при отриманні списку повідомлень), використовуйте `include` або `select` із вкладеними полями замість виконання окремого запиту для кожного елемента.",
          "nPlus1Code": "```typescript\\n// Погано (N+1 проблема - окремий запит за кожним користувачем)\\nconst messages = await prisma.message.findMany({ where: { chatId: chatId } });\\nfor (const message of messages) {\\n  const sender = await prisma.user.findUnique({ where: { id: message.userId } });\\n  // ... використовувати sender\\n}\\n\\n// Добре (використовуємо include для отримання автора повідомлення одним запитом)\\nconst messagesWithSender = await prisma.message.findMany({\\n  where: { chatId: chatId },\\n  include: {\\n    user: { // Включаємо дані користувача, пов'язаного з повідомленням через поле 'user' в моделі Message\\n      select: { id: true, name: true, avatarUrl: true } // Вибираємо лише потрібні поля користувача\\n    },\\n  },\\n  orderBy: { createdAt: 'asc' }, // Приклад: повідомлення в хронологічному порядку\\n  take: 50, // Приклад: пагінація\\n});\\n```",
          "paginationTitle": "Пагінація (`skip`, `take`, `cursor`):",
          "paginationContent": "Для отримання великих списків (повідомлення в чаті, список чатів) використовуйте пагінацію, щоб не завантажувати всі дані одразу. `cursor`-пагінація краща для нескінченної прокрутки.",
          "paginationCode": "```typescript\\n// Приклад пагінації з take та skip\\nconst messages = await prisma.message.findMany({\\n    where: { chatId: chatId },\\n    orderBy: { createdAt: 'asc' },\\n    skip: (page - 1) * pageSize, // Пропустити N повідомлень\\n    take: pageSize, // Взяти M повідомлень\\n});\\n\\n// Приклад Cursor-based пагінації (для \\\"показати ще\\\")\\nconst messages = await prisma.message.findMany({\\n    where: { chatId: chatId },\\n    orderBy: { createdAt: 'asc' },\\n    cursor: { id: lastMessageId }, // Почати після останнього повідомлення\\n    skip: 1, // Пропустити саме останнє повідомлення\\n    take: pageSize,\\n});\\n```"
        },
        "prismaAccelerate": {
          "title": "4.3. Prisma Accelerate: Глобальний Кеш та Пул З'єднань",
          "intro": "Prisma Accelerate надає глобальну мережу серверів (Edge locations), які кешують результати запитів та керують пулом з'єднань до вашої БД Neon.",
          "whenTitle": "Коли використовувати:",
          "whenContent": "Для зниження затримки запитів (latency) для користувачів по всьому світу та оптимізації використання пулу з'єднань БД.",
          "implementationTitle": "Реалізація:",
          "implementationContent": "Налаштовується в консолі Prisma. Ваша `DATABASE_URL` замінюється на URL Prisma Accelerate."
        },
        "materializedViews": {
          "title": "4.4. Матеріалізовані Представлення: Кешування Складних Агрегацій",
          "intro": "Матеріалізовані представлення — це по суті кешовані результати складних запитів або агрегацій (наприклад, кількість повідомлень у чаті, останні активні користувачі в групі). Вони зберігаються на диску та можуть бути швидко прочитані.",
          "whenTitle": "Коли використовувати:",
          "whenContent": "Для запитів, які виконуються часто, але вимагають складних обчислень (JOINs, GROUP BY, агрегатні функції) над великими таблицями, і дані в яких не повинні бути абсолютно актуальними кожну мілісекунду.",
          "applicationAreasTitle": "Області застосування:",
          "applicationAreasContent": "Статистика чатів (загальна кількість повідомлень, учасників), списки \"топ\" користувачів (наприклад, за кількістю відправлених повідомлень).",
          "implementationTitle": "Реалізація (SQL, через Prisma `queryRaw` або SQL-клієнт Neon):",
          "implementationContent": "```sql\\n-- Створити матеріалізоване представлення для підрахунку повідомлень у кожному чаті\\nCREATE MATERIALIZED VIEW chat_message_counts AS\\nSELECT\\n    \\\"chatId\\\",\\n    COUNT(*) as \\\"messageCount\\\"\\nFROM \\\"Message\\\"\\nGROUP BY \\\"chatId\\\";\\n\\n-- Створити індекс на представленні для швидкого пошуку за chatId (необов'язково, але часто корисно)\\nCREATE INDEX idx_chat_message_counts_chat_id ON chat_message_counts (\\\"chatId\\\");\\n```",
          "updateTitle": "Оновлення:",
          "updateContent": "Матеріалізовані представлення потрібно <strong>періодично оновлювати</strong>, щоб відобразити зміни в базових таблицях. Це робиться командою `REFRESH MATERIALIZED VIEW <view_name>;`. Частота оновлення залежить від того, наскільки актуальними повинні бути дані (наприклад, раз на годину, раз на день).",
          "updateCode": "```sql\\n-- Оновити представлення (може блокувати читання під час виконання)\\nREFRESH MATERIALIZED VIEW chat_message_counts;\\n\\n-- Оновити представлення без блокування читання (для великих представлень)\\nREFRESH MATERIALIZED VIEW CONCURRENTLY chat_message_counts; -- Вимагає унікального індексу\\n```",
          "usageTitle": "Використання в Prisma:",
          "usageContent": "Запитуйте як звичайну таблицю.",
          "usageCode": "```typescript\\nconst chatStats = await prisma.chatMessageCounts.findMany({\\n  select: { chatId: true, messageCount: true },\\n  where: { chatId: 'some-chat-id' },\\n});\\n```"
        },
        "partitioning": {
          "title": "4.5. Партиціонування Таблиць: Розділення Великих Обсягів Даних",
          "intro": "Партиціонування фізично розділяє дуже великі таблиці (наприклад, `Message`) на менші частини (партиції) на основі значення в певному стовпці (наприклад, `createdAt` або `chatId`).",
          "whenTitle": "Коли використовувати:",
          "whenContent": "Коли таблиця стає настільки великою (мільярди рядків), що індекси вже не справляються, і запити починають сповільнюватися через необхідність сканувати занадто багато даних.",
          "applicationAreasTitle": "Області застосування:",
          "applicationAreasContent": "Таблиця `Message` — ідеальний кандидат для партиціонування за часом створення (`createdAt`) або за ID чату (`chatId`).",
          "implementationTitle": "Реалізація (SQL, через Prisma `queryRaw` або SQL-клієнт Neon):",
          "implementationContent": "PostgreSQL підтримує нативне партиціонування.",
          "implementationCode": "```sql\\n-- Створити головну партиціоновану таблицю за діапазоном дат\\nCREATE TABLE messages (\\n    id TEXT NOT NULL,\\n    content TEXT NOT NULL,\\n    created_at TIMESTAMP WITH TIME ZONE NOT NULL,\\n    chat_id TEXT NOT NULL,\\n    user_id TEXT NOT NULL,\\n    PRIMARY KEY (id, created_at) -- Ключ партиціонування має бути частиною первинного ключа\\n) PARTITION BY RANGE (created_at); -- Партиціонуємо за діапазоном поля created_at\\n\\n-- Створити партиції (наприклад, за місяцями)\\nCREATE TABLE messages_2025_03 PARTITION OF messages\\n    FOR VALUES FROM ('2025-03-01 00:00:00+00') TO ('2025-04-01 00:00:00+00');\\n\\nCREATE TABLE messages_2025_04 PARTITION OF messages\\n    FOR VALUES FROM ('2025-04-01 00:00:00+00') TO ('2025-05-01 00:00:00+00');\\n\\n-- ... створювати нові партиції в міру необхідності (автоматично або вручну)\\n\\n-- Створити індекси для партиціонованої таблиці (застосовуються до всіх партицій)\\nCREATE INDEX ON messages (\\\"chat_id\\\", \\\"created_at\\\");\\nCREATE INDEX ON messages (\\\"user_id\\\");\\n```",
          "advantagesTitle": "Переваги:",
          "advantagesContent": "Запити, що включають фільтр за ключем партиціонування (наприклад, `WHERE created_at BETWEEN ...`), скануватимуть лише потрібні партиції, що значно прискорює їх виконання. Управління старими даними (видалення) стає простішим (можна просто видалити старі партиції).",
          "prismaRelationTitle": "Зв'язок з Prisma:",
          "prismaRelationContent": "Prisma працює з партиціонованою таблицею як зі звичайною."
        }
      },
      "graphqlOptimization": {
        "title": "5. Оптимізація GraphQL API (NestJS + Prisma): Ефективна Передача Даних",
        "intro": "GraphQL сам по собі є інструментом <strong>оптимізації</strong> (Принцип 9) порівняно з REST (клієнт запитує лише потрібні дані). Однак і його можна оптимізувати.",
        "analysisToolTitle": "Інструмент аналізу:",
        "analysisToolContent": "`graphql-query-complexity` для захисту від складних запитів.",
        "dataloader": {
          "title": "5.1. DataLoader: Вирішення Проблеми N+1 у GraphQL",
          "intro": "DataLoader — це утиліта, яка допомагає вирішити проблему N+1 запитів при роботі з графами даних. Якщо у вас є список об'єктів, і для кожного об'єкта потрібно підтягнути пов'язаний з ним об'єкт (наприклад, список повідомлень і для кожного повідомлення його автора), DataLoader збере всі ID пов'язаних об'єктів і зробить один пакетний запит до БД.",
          "whenTitle": "Коли використовувати:",
          "whenContent": "У резолверах GraphQL, коли вам потрібно отримати пов'язані об'єкти для списку батьківських об'єктів.",
          "applicationAreasTitle": "Області застосування:",
          "applicationAreasContent": "Отримання даних автора для кожного повідомлення в чаті, отримання списку учасників для кожного чату у списку чатів користувача.",
          "implementationTitle": "Реалізація:",
          "implementationContent": "Створіть окремі DataLoader для кожного типу об'єкта, який потрібно підтягувати. Інтегруйте їх у контекст GraphQL запиту.",
          "implementationCode": "```typescript\\n// backend/src/graphql/loaders/user.loader.ts\\nimport { Injectable, Scope } from '@nestjs/common';\\nimport DataLoader from 'dataloader';\\nimport { PrismaService } from 'nestjs-prisma';\\nimport { User } from '@prisma/client'; // Імпорт моделі Prisma\\n\\n// Scope.REQUEST - важливо, щоб DataLoader був унікальним для кожного запиту GraphQL\\n@Injectable({ scope: Scope.REQUEST })\\nexport class UserLoader {\\n  private loader: DataLoader<string, User>;\\n\\n  constructor(private prisma: PrismaService) {\\n    // Створюємо новий DataLoader. Функція batchLoadFn приймає масив ключів (user IDs)\\n    this.loader = new DataLoader<string, User>(\\n      async (ids: readonly string[]) => {\\n        // Виконуємо ОДИН запит до БД, щоб отримати ВСІх користувачів за їх ID\\n        const users = await this.prisma.user.findMany({\\n          where: {\\n            id: { in: Array.from(ids) }, // Array.from(ids) для сумісності з Prisma\\n          },\\n        });\\n\\n        // Важливо: Повернути масив результатів, упорядкований за вихідним масивом ids\\n        const userMap = new Map(users.map(user => [user.id, user]));\\n        return ids.map(id => userMap.get(id)); // Повертаємо користувачів у тому ж порядку, що й запитали\\n      },\\n      { cache: true } // Включаємо кешування всередині запиту GraphQL\\n    );\\n  }\\n\\n  // Метод для завантаження одного користувача за ID\\n  load(id: string): Promise<User> {\\n    return this.loader.load(id);\\n  }\\n\\n  // Метод для завантаження списку користувачів за ID\\n  loadMany(ids: string[]): Promise<(Error | User)[]> {\\n      return this.loader.loadMany(ids);\\n  }\\n}\\n```\\nІнтегруйте лоадери в контекст GraphQL (`backend/src/graphql/graphql.module.ts` або `app.module.ts`):\\n```typescript\\n// backend/src/graphql/graphql.module.ts\\nimport { Module } from '@nestjs/common';\\nimport { GraphQLModule } from '@nestjs/graphql';\\nimport { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';\\nimport { UserLoader } from './loaders/user.loader'; // Імпорт лоадера\\n// ... інші імпорти резолверів та модулів\\n\\n@Module({\\n  imports: [\\n    GraphQLModule.forRoot<ApolloDriverConfig>({\\n      driver: ApolloDriver,\\n      // ... інші налаштування GraphQL (schema path, context, etc.)\\n      context: ({ req, connection }) => {\\n        // Створюємо контекст для кожного запиту\\n        const context = { req }; // Додаємо об'єкт запиту\\n         if (connection) {\\n           // Для WebSocket (підписки)\\n           // context.loaders = new Loaders(); // Якщо лоадери створюються тут\\n         } else {\\n           // Для HTTP запитів (queries/mutations)\\n           // Створюємо лоадери та додаємо їх у контекст\\n           context.loaders = {\\n              userLoader: new UserLoader(/* залежності */), // Потрібно інжектувати PrismaService\\n              // ... інші лоадери\\n           };\\n           // Приклад ін'єкції залежностей в лоадер (може вимагати FactoryProvider)\\n           // context.loaders = {\\n           //     userLoader: req.loaders.userLoader, // Якщо використовуєте Request-scoped провайдери NestJS\\n           // };\\n         }\\n        return context;\\n      },\\n      // plugins: [complexityPlugin], // Плагін для аналізу складності запитів\\n    }),\\n    // ... імпорт інших модулів\\n  ],\\n   providers: [UserLoader], // Додаємо лоадер як провайдер (для Request scope)\\n})\\nexport class GraphqlModule {}\\n```",
          "usageTitle": "Використовуйте лоадери в резолверах:",
          "usageContent": "",
          "usageCode": "```typescript\\n// backend/src/message/message.resolver.ts\\nimport { Resolver, ResolveField, Parent, Context } from '@nestjs/graphql';\\nimport { Message } from '@prisma/client'; // Імпорт моделі Prisma\\nimport { UserLoader } from '../graphql/loaders/user.loader'; // Імпорт лоадера\\n\\n@Resolver('Message') // Вказуємо GraphQL тип, до якого відноситься резолвер\\nexport class MessageResolver {\\n  @ResolveField('user') // Визначаємо резолвер для поля 'user' у типі Message\\n  async resolveUser(@Parent() message: Message, @Context() context: any) {\\n    // Використовуємо userLoader з контексту для завантаження користувача за message.userId\\n    // DataLoader автоматично збере всі message.userId в поточному запиті та завантажить їх пакетом\\n    return context.loaders.userLoader.load(message.userId);\\n  }\\n}\\n```"
        },
        "queryComplexityAnalysis": {
          "title": "5.2. Аналіз Складності Запитів: Захист від \"Важких\" Запитів",
          "intro": "GraphQL дозволяє клієнту запитувати дані довільної вкладеності, що може призвести до дуже \"важких\" запитів, що сильно навантажують сервер та БД.",
          "toolTitle": "Інструмент:",
          "toolContent": "`graphql-query-complexity`.",
          "whenTitle": "Коли використовувати:",
          "whenContent": "Завжди включайте захист від складності в продакшені.",
          "principleTitle": "Принцип роботи:",
          "principleContent": "Плагін аналізує запит до його виконання та обчислює його \"складність\" (наприклад, як суму \"вартості\" кожного поля). Якщо складність перевищує заданий поріг, запит відхиляється.",
          "implementationTitle": "Реалізація:",
          "implementationContent": "Налаштуйте плагін у NestJS GraphQLModule (див. Посібник з розробки)."
        },
        "persistedQueries": {
          "title": "5.3. Persisted Queries: Кешування Запитів на Рівні Мережі",
          "intro": "Persisted Queries дозволяють клієнту надсилати на сервер не повний текст GraphQL запиту, а лише його хеш. Сервер за цим хешем знаходить повний запит (якщо він йому знайомий) і виконує його.",
          "whyTitle": "Чому:",
          "whyContent": "Зменшує обсяг даних, що передаються мережею, що прискорює запити, особливо на мобільних пристроях. Покращує ефективність кешування на CDN.",
          "whenTitle": "Коли використовувати:",
          "whenContent": "Для часто повторюваних запитів від клієнта.",
          "implementationTitle": "Реалізація:",
          "implementationContent": "Вимагає підтримки як на стороні клієнта (Apollo Client підтримує), так і на стороні сервера (Apollo Server підтримує). На сервері потрібно зберігати відповідність хешів та запитів (наприклад, у Redis)."
        }
      },
      "backendLogicOptimization": {
        "title": "6. Оптимізація Backend Логіки (NestJS): Ефективність Коду",
        "intro": "",
        "toolsTitle": "Інструменти:",
        "toolsContent": "Профілювання Node.js (V8 Profiler), виявлення витоків пам'яті (`heapdump`).",
        "whenTitle": "Коли використовувати:",
        "whenContent": "Для виявлення \"гарячих\" ділянок коду, що споживають багато CPU або пам'яті, та діагностики проблем з пам'яттю.",
        "processTitle": "Процес:",
        "processContent": "Використовуйте інструменти профілювання для <strong>вимірювання</strong> (Крок 1 Кайдзен). Аналізуйте результати (Крок 2). Вносьте зміни в код (Крок 3). Повторіть (Крок 4).",
        "recommendationsTitle": "Рекомендації:",
        "recommendationsContent": "Уникайте синхронних операцій, що блокують основний потік Node.js. Використовуйте асинхронні API. Оптимізуйте цикли, роботу з великими масивами/об'єктами."
      },
      "caching": {
        "title": "7. Кешування (Redis): Зниження Навантаження на БД та Прискорення (Принцип 9)",
        "intro": "Кешування дозволяє зберігати часто запитувані дані у швидкій пам'яті (Redis), щоб не звертатися до повільнішої БД (Neon) при кожному запиті. Це ключовий <strong>важіль</strong> для підвищення <strong>ефективності системи</strong> (Принцип 9).",
        "libraryTitle": "Бібліотека:",
        "libraryContent": "`ioredis`, `@nestjs/cache-manager`, `cache-manager-redis-store`.",
        "patternTitle": "Патерн:",
        "patternContent": "Cache-Aside (читання з кешу, якщо немає — читання з БД та запис у кеш).",
        "applicationAreasTitle": "Області застосування:",
        "applicationAreasContent": "Часто запитувані, відносно рідко змінювані дані (профілі користувачів, налаштування застосунку, результати складних запитів/агрегацій, матеріалізованих представлень).",
        "implementationTitle": "Реалізація:",
        "implementationContent": "Налаштуйте Redis у NestJS та використовуйте його в сервісах.",
        "invalidationTitle": "Ключовий аспект:",
        "invalidationContent": "<strong>Інвалідація кешу</strong>. При зміні даних у БД видаляйте відповідні ключі з Redis, щоб клієнти не отримували застарілі дані."
      },
      "asyncProcessing": {
        "title": "8. Асинхронна Обробка (Kafka): Надійність та Чуйність (Принцип 9, 2)",
        "intro": "Використовуйте <strong>Kafka</strong> для виконання завдань, які не вимагають негайної відповіді користувачеві (відправлення email, обробка зображень, нотифікації, аналітика).",
        "libraryTitle": "Бібліотека:",
        "libraryContent": "`kafkajs`.",
        "whyTitle": "Чому:",
        "whyContent": "Kafka — <strong>надійна розподілена система черг</strong>, що гарантує доставку повідомлень і дозволяє масштабувати обробку завдань незалежно від основного API (воркери-консюмери).",
        "applicationAreasTitle": "Області застосування:",
        "applicationAreasContent": [
          "Обробка зображень/відео після завантаження.",
          "Відправлення великих обсягів push-сповіщень.",
          "Генерація звітів або статистики.",
          "Архівування старих повідомлень/файлів."
        ],
        "patternTitle": "Патерн:",
        "patternContent": "<strong>Producer-Consumer</strong>. Backend-API ставить завдання в топік Kafka (Producer). Окремі сервіси/воркери (Consumer) читають завдання з топіка та виконують їх у фоновому режимі.",
        "partitioningTitle": "Партиціонування в Kafka:",
        "partitioningContent": "Використовуйте ключі повідомлень (наприклад, `userId`, `chatId`), щоб повідомлення, що стосуються одного користувача/чату, потрапляли в одну партицію. Це гарантує порядок обробки всередині партиції, що може бути важливим для деяких завдань.",
        "monitoringTitle": "Моніторинг:",
        "monitoringContent": "Використовуйте <strong>Kafdrop</strong> для візуального моніторингу топіків, повідомлень та стану консюмер-груп."
      },
      "pushNotificationsOptimization": {
        "title": "9. Оптимізація Push-сповіщень (Firebase FCM): Ефективна Доставка Інформації (Принцип 2)",
        "intro": "Push-сповіщення — важливий канал зв'язку з користувачем (Принцип 2: Цінність). Оптимізація їх доставки важлива для користувацького досвіду.",
        "platformTitle": "Платформа:",
        "platformContent": "Firebase Cloud Messaging (FCM).",
        "techniquesTitle": "Техніки:",
        "techniquesContent": [
          "<strong>Батчінг:</strong> Надсилайте кілька сповіщень одним викликом API FCM (`sendMulticast`) для зниження мережевих накладних витрат.",
          "<strong>Теми (Topics):</strong> Використовуйте теми для масових розсилок (наприклад, сповіщення про нове повідомлення в каналі), щоб FCM керував списком підписників.",
          "<strong>Data Messages:</strong> Використовуйте Data Messages для повного контролю над відображенням сповіщення на клієнті та можливості прикріплювати кастомні дані."
        ]
      },
      "clientApiDbInteraction": {
        "title": "10. Оптимізація Взаємодії Клієнт-API-БД: Скорочення Шляху Даних (Принцип 9)",
        "intro": "",
        "clientLevelTitle": "На Рівні Клієнта:",
        "clientLevelContent": "Використовуйте бібліотеки для управління станом та кешування даних, отриманих мережею (`@apollo/client`, `react-query`/`@tanstack/react-query`). Це дозволяє уникнути повторних запитів за одними й тими ж даними та швидко показувати кешовані дані.",
        "networkLevelTitle": "На Рівні Мережі:",
        "networkLevelContent": "Увімкніть сучасні протоколи (HTTP/2, HTTP/3) та стиснення (Gzip/Brotli) на вашому API Gateway або Backend сервері для зменшення обсягу переданих даних та зниження затримки.",
        "backendLevelTitle": "На Рівні Backend:",
        "backendLevelContent": "Оптимізуйте взаємодію з БД (розділ 4) та зовнішніми сервісами (розділ 7)."
      },
      "authenticationOptimization": {
        "title": "11. Оптимізація Автентифікації: Швидкість та Безпека",
        "intro": "",
        "statelessJwtTitle": "Stateless (JWT):",
        "statelessJwtContent": "Використання JWT знижує навантаження на сервер, оскільки йому не потрібно зберігати стан сесій користувачів.",
        "rateLimitingTitle": "Rate Limiting (`@nestjs/throttler`):",
        "rateLimitingContent": "Захист ендпоінтів автентифікації від Brute Force атак, що також знижує навантаження.",
        "secureHeadersTitle": "Безпечні Заголовки (`helmet`):",
        "secureHeadersContent": "Додавання HTTP-заголовків для захисту від XSS, CSRF та інших атак."
      },
      "chatWebSocketOptimization": {
        "title": "12. Оптимізація Чатів (WebSocket): Низька Затримка та Масштабування",
        "intro": "WebSocket використовується для обміну повідомленнями в реальному часі. <strong>Оптимізація WebSocket-з'єднань критична для чуйності чатів</strong> (Принцип 2).",
        "libraryTitle": "Бібліотека:",
        "libraryContent": "NestJS Gateways (`@nestjs/websockets`), Socket.IO (якщо потрібна крос-браузерна сумісність та fallback).",
        "techniquesTitle": "Техніки:",
        "techniquesContent": [
          "<strong>Бінарні Формати:</strong> Передача повідомлень у бінарному форматі (наприклад, MessagePack) замість текстового JSON може зменшити обсяг даних.",
          "<strong>Батчінг Повідомлень:</strong> Буферизуйте повідомлення на клієнті та сервері та надсилайте їх пачками (наприклад, кожні 50 мс), а не по одному. Знижує кількість пакетів.",
          "<strong>Управління Присутністю:</strong> Використовуйте Redis для швидкого відстеження статусу онлайн/офлайн користувачів. Heartbeats (пінг-понг) для підтримки з'єднання та виявлення відключень.",
          "<strong>Вертикальне/Горизонтальне Масштабування:</strong> NestJS Gateways можуть працювати в кластерному режимі. Використовуйте Redis або інший Pub/Sub механізм (наприклад, Kafka) для обміну повідомленнями між інстансами Backend, щоб повідомлення доставлялися всім підписникам, незалежно від того, до якого інстансу Backend вони підключені."
        ]
      },
      "animationsOptimization": {
        "title": "13. Оптимізація Анімацій: Плавність та Продуктивність (Принцип 3, 5)",
        "intro": "Продуктивні анімації роблять інтерфейс <strong>якісним</strong> (Принцип 3) та знижують навантаження на пристрій (Принцип 5: Здоров'я).",
        "mobileDesktopTitle": "Mobile-Desktop (React Native):",
        "mobileDesktopContent": "Використовуйте `react-native-reanimated` для анімацій, які виконуються на нативному потоці, не блокуючи потік JavaScript.",
        "webTitle": "Web (Next.js):",
        "webContent": "Використовуйте `framer-motion` для декларативного створення плавних анімацій.",
        "docDesignTitle": "DocDesign:",
        "docDesignContent": "У DocDesign описані принципи та параметри анімацій, включаючи можливість їх відключення користувачем (Принцип 12: Прагматизм)."
      },
      "monitoring": {
        "title": "14. Моніторинг з Prometheus та Grafana: Вимірювання як Основа Кайдзен (Принцип 9)",
        "intro": "Система моніторингу — це ваші <strong>очі</strong> та <strong>вимірювальні інструменти</strong> (Крок 1 Кайдзен).",
        "toolsTitle": "Інструменти:",
        "toolsContent": "Prometheus (збір метрик), Grafana (візуалізація), Alertmanager (сповіщення про аномалії).",
        "whenTitle": "Коли використовувати:",
        "whenContent": "Завжди. Налаштуйте моніторинг на всіх рівнях: Backend (затримки API, помилки), БД (час запитів, навантаження), Redis (попадання в кеш, використання пам'яті), Kafka (кількість повідомлень у топіках, лаг консюмерів), Інфраструктура (CPU, RAM, мережа).",
        "implementationTitle": "Реалізація:",
        "implementationContent": "Див. докладні кроки з налаштування в Посібнику з розробки (розділ 14).",
        "principleTitle": "Принцип:",
        "principleContent": "Використовуйте метрики для <strong>виявлення вузьких місць</strong> (Крок 2 Кайдзен) та оцінки <strong>ефективності</strong> (Принцип 9) ваших оптимізацій. Налаштуйте <strong>алерти</strong> для проактивного виявлення проблем."
      },
      "ciCdOptimization": {
        "title": "15. Оптимізація CI/CD: Прискорення Циклу Розробки (Принцип 9)",
        "intro": "Ефективний CI/CD пайплайн прискорює доставку коду, що є частиною <strong>оптимізації всього процесу розробки</strong> (Принцип 9).",
        "toolsTitle": "Інструменти:",
        "toolsContent": "Turborepo (кешування, паралелізація), GitHub Actions (автоматизація).",
        "techniquesTitle": "Техніки:",
        "techniquesContent": [
          "<strong>Кешування з Turborepo:</strong> Кешуйте результати збірки та тестів між запусками в CI та локально.",
          "<strong>Паралельне виконання:</strong> Запускайте завдання (lint, build, test) для різних пакетів або частин тестів паралельно.",
          "<strong>Оптимізація Docker-образів:</strong> Використовуйте багатоступеневу збірку та `.dockerignore` для зменшення розміру образів та прискорення збірки/деплою."
        ]
      },
      "frontendOptimization": {
        "title": "16. Оптимізація Фронтенду: Швидкість та Чуйність для Користувача (Принцип 2, 3)",
        "intro": "Фронтенд має бути <strong>швидким та чуйним</strong>, щоб користувач відчув <strong>цінність</strong> (Принцип 2) продукту.",
        "webTechniquesTitle": "Техніки (Web - Next.js):",
        "webTechniquesContent": [
          "<strong>Code Splitting / Dynamic Imports:</strong> Завантажуйте код лише тоді, коли він потрібен (`next/dynamic`).",
          "<strong>SSR/SSG:</strong> Використовуйте серверний рендеринг або генерацію статики для прискорення першого відтворення та SEO (`getStaticProps`, `getServerSideProps`).",
          "<strong>Оптимізація Зображень:</strong> Використовуйте `next/image` або `<picture>` та сучасні формати (WebP).",
          "<strong>Аналіз Бандла:</strong> Використовуйте `@next/bundle-analyzer` для виявлення найважчих модулів."
        ],
        "reactNativeTechniquesTitle": "Техніки (React Native):",
        "reactNativeTechniquesContent": [
          "<strong>Лениве Завантаження:</strong> Використовуйте `React.lazy` та `Suspense` для екранів та компонентів, які не потрібні під час старту.",
          "<strong>Продуктивні Списки:</strong> Використовуйте `FlatList` або `SectionList` з правильним налаштуванням (`getItemLayout`, `windowSize`) для великих списків повідомлень або чатів.",
          "<strong>Оптимізація Зображень:</strong> Використовуйте `react-native-fast-image`.",
          "<strong>Профілювання:</strong> Використовуйте Performance Monitor у Debugger Menu React Native для виявлення вузьких місць UI."
        ],
        "generalTechniquesTitle": "Загальні техніки:",
        "generalTechniquesContent": [
          "Видалення невикористовуваного коду (Tree Shaking), заміна важких бібліотек на легкі аналоги (наприклад, `dayjs` замість `moment`), стиснення бандлів (Gzip/Brotli)."
        ]
      },
      "dbScaling": {
        "title": "17. Масштабування Бази Даних (Реплікація та Шардинг): Підготовка до Зростання (Принцип 8)",
        "intro": "Ці техніки стають актуальними при значному зростанні обсягу даних та навантаження. Вони є частиною <strong>довгострокової стратегії масштабування</strong> (Принцип 8).",
        "replicationTitle": "Реплікація (Master-Slave):",
        "replicationContent": "Створення копій БД тільки для читання (read replicas). Дозволяє розподілити навантаження на читання.",
        "shardingTitle": "Шардинг:",
        "shardingContent": "Розділення даних великої таблиці на частини (шарди) за певним ключем (`chatId`, `userId`), розподіляючи їх по різних серверах. Дозволяє масштабувати як читання, так і запис. Реалізується логічно (у застосунку) або за допомогою розширень (Citus для PostgreSQL).",
        "whenToApplyTitle": "Коли застосовувати:",
        "whenToApplyContent": "Ґрунтуючись на <strong>вимірюваннях</strong> навантаження та продуктивності БД (Принцип 9), а не заздалегідь."
      },
      "notes": {
        "title": "18. Примітки: Безперервний Кайдзен в Оптимізації",
        "prioritizationTitle": "Пріоритезація:",
        "prioritizationContent": "Починайте оптимізацію з тих місць, які приносять найбільший ефект на поточному етапі проєкту (Принцип 12). Для MVP це може бути швидкість завантаження Frontend, продуктивність основних API-запитів.",
        "automationTitle": "Автоматизація:",
        "automationContent": "Максимально автоматизуйте процеси вимірювання та перевірки оптимізацій (CI/CD, алерти в моніторингу) — це частина <strong>Системи</strong> (Принцип 9).",
        "documentationNotesTitle": "Документування:",
        "documentationNotesContent": "Фіксуйте проведені оптимізації, їх ефект та уроки в цій документації або в завданнях/коммітах (Принцип 1: Навчання, Принцип 9: Кайдзен).",
        "cultureTitle": "Культура:",
        "cultureContent": "Створіть культуру, де кожен розробник несе відповідальність за продуктивність свого коду та активно бере участь у пошуку та усуненні вузьких місць (Принцип 6)."
      }
    },
    "apiSpec": {
      "title": "Спецификация API BrainMessenger (Интерфейс Системы)",
      "subtitle": "Интерфейс Системы",
      "generalInfo": {
        "title": "1. Общая Информация: API как Точка Взаимодействия с Системой",
        "description": "Этот документ описывает GraphQL API BrainMessenger — <strong>основной интерфейс</strong> (Принцип 9), через который клиентские приложения (Web, Mobile, Desktop) взаимодействуют с серверной частью системы и получают доступ к данным и функциональности. GraphQL выбран за его <strong>эффективность и гибкость</strong> (Принцип 9, 2), позволяя клиентам запрашивать только те данные, которые им необходимы.",
        "projectNameTitle": "Название проекта:",
        "projectNameContent": "BrainMessenger",
        "apiPurposeTitle": "Цель:",
        "apiPurposeContent": "Предоставить четкое и полное описание доступных запросов (Queries) и мутаций (Mutations), их входных и выходных данных, а также правил аутентификации и форматов ошибок. Это обеспечивает <strong>системность</strong> (Принцип 9) взаимодействия между Frontend и Backend и повышает <strong>качество</strong> (Принцип 3) разработки.",
        "baseUrlTitle": "Базовый URL:",
        "baseUrlContent": "`https://api.brainmessenger.com/graphql` (адрес API Gateway, который перенаправляет запросы на Backend Service).",
        "requestFormatTitle": "Формат запросов:",
        "requestFormatContent": "GraphQL-запросы (POST-запросы с `Content-Type: application/json` и телом в формате GraphQL).",
        "authenticationTitle": "Аутентификация:",
        "authenticationContent": "Для большинства методов требуется передать JWT-токен в заголовке `Authorization: Bearer <token>`. Токен получается после успешного логина. Это часть нашей <strong>системы безопасности</strong> (Принцип 3, 5).",
        "relatedDocsTitle": "Связь с другими документами:",
        "relatedDocsContent": [
          "DocTech.md: Общая архитектура системы, включая Backend и API Gateway.",
          "DocDevIn.md: Детали реализации Backend на NestJS и GraphQL.",
          "DocInt.md: Описание интеграций, которые Backend использует (Neon, R2, Firebase и др.).",
          "DocOptimizationIn.md: Подходы к оптимизации производительности API."
        ]
      },
      "graphqlSchema": {
        "title": "2. Схема GraphQL: Структура Доступных Данных и Операций",
        "description": "Полная схема GraphQL доступна по адресу API через инструменты интроспекции (например, GraphQL Playground, Apollo Studio). Ниже приведены основные типы и операции.",
        "dataTypes": {
          "title": "2.1. Типы Данных (Schemas): Описание Структуры Информации",
          "user": {
            "title": "User:",
            "code": "type User {\n  id: ID!\n  email: String!\n  name: String!\n  avatarUrl: String # URL аватара пользователя (хранится в R2)\n  createdAt: DateTime!\n  updatedAt: DateTime!\n  # ... другие поля (например, статус онлайн/оффлайн)\n}"
          },
          "chat": {
            "title": "Chat:",
            "code": "type Chat {\n  id: ID!\n  name: String! # Название чата (для групп/каналов)\n  type: String! # Тип чата (\"personal\", \"group\", \"channel\")\n  users: [User!] # Список участников чата\n  messages(pagination: PaginationInput): [Message!] # Сообщения в чате (с пагинацией)\n  lastMessageAt: DateTime # Время последнего сообщения (для сортировки списка чатов)\n  createdAt: DateTime!\n  updatedAt: DateTime!\n  # ... другие поля (например, фото группы/канала, описание)\n}"
          },
          "message": {
            "title": "Message:",
            "code": "type Message {\n  id: ID!\n  content: String! # Текст сообщения (для текстовых сообщений)\n  fileUrl: String # URL файла, если сообщение является файлом (хранится в R2)\n  fileMetadata: JSON # Метаданные файла (тип, размер, имя) (хранится в Neon/R2)\n  sender: User! # Отправитель сообщения\n  chat: Chat! # Чат, которому принадлежит сообщение\n  createdAt: DateTime! # Время отправки сообщения\n  updatedAt: DateTime!\n  # ... другие поля (например, статус прочтения, реакции)\n}"
          },
          "paginationInput": {
            "title": "PaginationInput:",
            "code": "input PaginationInput {\n  take: Int # Максимальное количество элементов\n  skip: Int # Пропустить элементов (для offset-based пагинации)\n  cursor: String # Курсор (ID) для cursor-based пагинации\n}"
          },
          "authPayload": {
            "title": "AuthPayload:",
            "code": "type AuthPayload {\n  token: String! # JWT токен доступа\n  user: User! # Данные аутентифицированного пользователя\n}"
          },
          "dateTimeJson": {
            "title": "DateTime, JSON:",
            "content": "Стандартные скалярные типы или кастомные скаляры, определенные на Backend."
          }
        },
        "operations": {
          "title": "2.2. Операции (Queries и Mutations): Доступ к Функционалу Системы",
          "authentication": {
            "title": "2.2.1. Аутентификация (Authentication)",
            "registerUser": {
              "title": "`mutation registerUser(input: RegisterInput!): AuthPayload!`",
              "description": "Регистрирует нового пользователя в системе.",
              "input": "`RegisterInput`: `{ email: String!, password: String!, name: String! }` (password min 8 chars, digit, special char - см. валидацию).",
              "authRequired": "Требуется аутентификация: Нет.",
              "scenario": "Сценарий: Пользователь заполняет форму регистрации.",
              "errors": "Ошибки: `400 Bad Request` (неверный формат данных/валидация), `409 Conflict` (email уже используется)."
            },
            "loginUser": {
              "title": "`mutation loginUser(input: LoginInput!): AuthPayload!`",
              "description": "Аутентифицирует пользователя по email и паролю.",
              "input": "`LoginInput`: `{ email: String!, password: String! }`.",
              "authRequired": "Требуется аутентификация: Нет.",
              "scenario": "Сценарий: Пользователь вводит учетные данные для входа.",
              "errors": "Ошибки: `401 Unauthorized` (неверный email или пароль)."
            },
            "logoutUser": {
              "title": "`mutation logoutUser: Boolean!`",
              "description": "Инвалидирует текущий JWT токен на сервере (если реализовано хранение токенов или их черных списков).",
              "authRequired": "Требуется аутентификация: Да (используется текущий токен).",
              "scenario": "Сценарий: Пользователь нажимает \"Выйти\".",
              "returns": "Возвращает: `true` при успешном выходе.",
              "errors": "Ошибки: `401 Unauthorized` (токен недействителен)."
            }
          },
          "user": {
            "title": "2.2.2. Пользователь (User)",
            "getUser": {
              "title": "`query getUser(id: ID!): User`",
              "description": "Получает данные пользователя по его уникальному ID.",
              "authRequired": "Требуется аутентификация: Да (для доступа к любым данным пользователя, кроме, возможно, публичного профиля).",
              "scenario": "Сценарий: Просмотр профиля пользователя.",
              "errors": "Ошибки: `404 Not Found` (пользователь с таким ID не найден)."
            },
            "getCurrentUser": {
              "title": "`query getCurrentUser: User!`",
              "description": "Получает данные текущего аутентифицированного пользователя.",
              "authRequired": "Требуется аутентификация: Да.",
              "scenario": "Сценарий: Загрузка профиля текущего пользователя при старте приложения.",
              "errors": "Ошибки: `401 Unauthorized`."
            },
            "updateUser": {
              "title": "`mutation updateUser(id: ID!, input: UserInput!): User!`",
              "description": "Обновляет данные профиля пользователя.",
              "input": "`UserInput`: `{ name: String, email: String, password: String, avatarUrl: String }`. Поля опциональны.",
              "authRequired": "Требуется аутентификация: Да (и пользователь должен быть владельцем профиля или иметь права администратора).",
              "scenario": "Сценарий: Пользователь редактирует свой профиль.",
              "errors": "Ошибки: `400 Bad Request` (неверный формат данных), `401 Unauthorized`, `403 Forbidden` (нет прав на редактирование этого пользователя), `404 Not Found`."
            },
            "deleteUser": {
              "title": "`mutation deleteUser(id: ID!): Boolean!`",
              "description": "Удаляет аккаунт пользователя.",
              "authRequired": "Требуется аутентификация: Да (и пользователь должен быть владельцем аккаунта).",
              "scenario": "Сценарий: Пользователь решает удалить свою учетную запись.",
              "returns": "Возвращает: `true` при успешном удалении.",
              "errors": "Ошибки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            }
          },
          "chats": {
            "title": "2.2.3. Чаты (Chats)",
            "getChats": {
              "title": "`query getChats: [Chat!]!`",
              "description": "Получает список всех чатов, в которых участвует текущий пользователь.",
              "authRequired": "Требуется аутентификация: Да.",
              "scenario": "Сценарий: Загрузка списка чатов на главном экране.",
              "errors": "Ошибки: `401 Unauthorized`."
            },
            "getChat": {
              "title": "`query getChat(id: ID!): Chat`",
              "description": "Получает данные конкретного чата по ID.",
              "authRequired": "Требуется аутентификация: Да (и пользователь должен быть участником этого чата).",
              "scenario": "Сценарий: Открытие конкретного чата.",
              "errors": "Ошибки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            },
            "createChat": {
              "title": "`mutation createChat(input: CreateChatInput!): Chat!`",
              "description": "Создает новый чат.",
              "input": "`CreateChatInput`: `{ type: String!, name: String, userIds: [ID!]! }`. `type` может быть \"personal\", \"group\", \"channel\". `name` обязателен для \"group\" и \"channel\". `userIds` включает ID создателя и других участников (для \"personal\" и \"group\").",
              "authRequired": "Требуется аутентификация: Да.",
              "scenario": "Сценарий: Пользователь создает новый чат или группу.",
              "errors": "Ошибки: `400 Bad Request` (неверный тип, отсутствуют userIds и т.п.), `401 Unauthorized`, `403 Forbidden` (нет прав на создание такого типа чата)."
            },
            "getMessages": {
              "title": "`query getMessages(chatId: ID!, pagination: PaginationInput): [Message!]!`",
              "description": "Получает список сообщений для заданного чата. Поддерживает пагинацию.",
              "authRequired": "Требуется аутентификация: Да (и пользователь должен быть участником чата).",
              "scenario": "Сценарий: Открытие чата, подгрузка старых сообщений при прокрутке.",
              "errors": "Ошибки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            },
            "sendMessage": {
              "title": "`mutation sendMessage(chatId: ID!, content: String!, fileUrl: String, fileMetadata: JSON): Message!`",
              "description": "Отправляет новое сообщение в чат. Может содержать текст или ссылку на файл.",
              "input": "`chatId`: ID чата. `content`: Текст сообщения. `fileUrl`: URL файла в R2 (опционально). `fileMetadata`: Метаданные файла (опционально).",
              "authRequired": "Требуется аутентификация: Да (и пользователь должен быть участником чата).",
              "scenario": "Сценарий: Пользователь отправляет текстовое сообщение или файл.",
              "errors": "Ошибки: `400 Bad Request`, `401 Unauthorized`, `403 Forbidden` (нет прав писать в этот чат), `404 Not Found` (чат не найден)."
            },
            "deleteMessage": {
              "title": "`mutation deleteMessage(messageId: ID!): Boolean!`",
              "description": "Удаляет сообщение.",
              "authRequired": "Требуется аутентификация: Да (и пользователь должен быть отправителем сообщения или иметь права администратора чата).",
              "scenario": "Сценарий: Пользователь удаляет свое сообщение.",
              "returns": "Возвращает: `true` при успешном удалении.",
              "errors": "Ошибки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            }
          },
          "externalIntegrations": {
            "title": "2.2.4. Внешние Интеграции (через API Backend)",
            "sendVerificationCode": {
              "title": "`mutation sendVerificationCode(email: String!): Boolean!`",
              "description": "Запускает процесс отправки кода подтверждения на указанный email (используя Gmail API). Используется при регистрации или сбросе пароля.",
              "authRequired": "Требуется аутентификация: Нет.",
              "scenario": "Сценарий: Пользователь вводит email на экране регистрации/восстановления пароля.",
              "returns": "Возвращает: `true` при успешной постановке задачи на отправку.",
              "errors": "Ошибки: `400 Bad Request` (неверный формат email), `429 Too Many Requests` (защита от спама)."
            },
            "verifyEmailCode": {
              "title": "`mutation verifyEmailCode(email: String!, code: String!): Boolean!`",
              "description": "Проверяет код подтверждения, полученный по email.",
              "authRequired": "Требуется аутентификация: Нет.",
              "scenario": "Сценарий: Пользователь вводит код из email.",
              "returns": "Возвращает: `true` при успешной проверке.",
              "errors": "Ошибки: `400 Bad Request` (неверный код или email), `404 Not Found` (для данного email нет активного кода)."
            },
            "enableTwoFactorAuth": {
              "title": "`mutation enableTwoFactorAuth(userId: ID!): Boolean!`",
              "description": "Включает/отключает двухфакторную аутентификацию для пользователя. Требует предварительной верификации email. Код для 2FA отправляется на email (Gmail API) при каждом логине после включения.",
              "authRequired": "Требуется аутентификация: Да (пользователь должен управлять своим аккаунтом).",
              "scenario": "Сценарий: Пользователь настраивает безопасность аккаунта.",
              "errors": "Ошибки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`, `400 Bad Request` (email не верифицирован)."
            },
            "disableTwoFactorAuth": {
              "title": "`mutation disableTwoFactorAuth(userId: ID!): Boolean!`",
              "description": "Включает/отключает двухфакторную аутентификацию для пользователя. Требует предварительной верификации email. Код для 2FA отправляется на email (Gmail API) при каждом логине после включения.",
              "authRequired": "Требуется аутентификация: Да (пользователь должен управлять своим аккаунтом).",
              "scenario": "Сценарий: Пользователь настраивает безопасность аккаунта.",
              "errors": "Ошибки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`, `400 Bad Request` (email не верифицирован)."
            },
            "sendTwoFactorCode": {
              "title": "`mutation sendTwoFactorCode(userId: ID!): Boolean!`",
              "description": "Отправляет код двухфакторной аутентификации на email пользователя.",
              "authRequired": "Требуется аутентификация: Частичная (например, после ввода пароля, но до ввода 2FA кода). Логика зависит от флоу аутентификации.",
              "scenario": "Сценарий: Пользователь входит в аккаунт с включенной 2FA.",
              "errors": "Ошибки: `404 Not Found` (пользователь не найден или 2FA не включена), `429 Too Many Requests`."
            },
            "createPaymentSession": {
              "title": "`mutation createPaymentSession(input: PaymentInput!): PaymentSessionPayload!`",
              "description": "Создает сессию оплаты через Stripe для оформления Premium подписки.",
              "input": "`PaymentInput`: `{ planId: ID!, returnUrl: String! }` (ID выбранного тарифного плана, URL для редиректа после оплаты).",
              "authRequired": "Требуется аутентификация: Да.",
              "scenario": "Сценарий: Пользователь нажимает \"Подписаться\" на Premium экране.",
              "errors": "Ошибки: `400 Bad Request` (неверный planId), `401 Unauthorized`."
            }
          }
        }
      },
      "errorHandling": {
        "title": "3. Обработка Ошибок API: Ясная Обратная Связь (Принцип 3, 14)",
        "description": "API возвращает стандартизированные ошибки для <strong>ясной обратной связи</strong> (Принцип 14) с клиентом и поддержания <strong>качества</strong> (Принцип 3).",
        "errorFormatTitle": "Формат ошибок (в соответствии со спецификацией GraphQL):",
        "errorFormatCode": "{\n  \"data\": null, // Обычно null при ошибках верхнего уровня\n  \"errors\": [\n    {\n      \"message\": \"Описание ошибки (может быть локализовано - см. DocLocIn)\",\n      \"locations\": [...], // Расположение ошибки в запросе\n      \"path\": [...],      // Путь к полю, вызвавшему ошибку\n      \"extensions\": {\n        \"code\": \"КОД_ОШИБКИ\", // Стандартизированный код ошибки (например, \"UNAUTHENTICATED\", \"FORBIDDEN\", \"BAD_USER_INPUT\", \"NOT_FOUND\")\n        \"http\": { // Если применимо, HTTP статус код\n          \"status\": 401,\n          \"headers\": {}\n        },\n         \"details\": {} // Дополнительные детали об ошибке (опционально)\n      }\n    }\n    // ... могут быть другие ошибки\n  ]\n}",
        "keyErrorCodesTitle": "Ключевые коды ошибок (extensions.code):",
        "keyErrorCodesList": [
          "`UNAUTHENTICATED`: Требуется аутентификация, но токен отсутствует или недействителен (`HTTP 401`).",
          "`FORBIDDEN`: Аутентификация пройдена, но у пользователя нет прав на выполнение операции (`HTTP 403`).",
          "`BAD_USER_INPUT`: Ошибка валидации входных данных (`HTTP 400`). Детали могут быть в `extensions.details`.",
          "`NOT_FOUND`: Запрошенный ресурс не найден (`HTTP 404`).",
          "`CONFLICT`: Конфликт данных (например, попытка зарегистрировать email, который уже существует) (`HTTP 409`).",
          "`INTERNAL_SERVER_ERROR`: Неожиданная ошибка на сервере (`HTTP 500`).",
          "`RATE_LIMITED`: Превышен лимит запросов (`HTTP 429`)."
        ],
        "localizationErrorsTitle": "Локализация ошибок:",
        "localizationErrorsContent": "Сообщения об ошибках (`message`) могут быть локализованы на стороне Backend на основе заголовка `Accept-Language` или предпочтений пользователя (см. DocLocIn)."
      },
      "notes": {
        "title": "4. Примечания",
        "dataTypes": {
          "title": "Типы данных:",
          "list": [
            "`ID`: Уникальный идентификатор ресурса (обычно строка).",
            "`String`: Текстовая строка.",
            "`Int`, `Float`: Числа.",
            "`Boolean`: Логическое значение (`true`/`false`).",
            "`DateTime`: Дата и время в формате ISO 8601 (например, \"2025-03-14T10:30:00Z\").",
            "`JSON`: Кастомный скаляр для передачи произвольных JSON-объектов (например, для `fileMetadata`).",
            "`!` в конце типа означает, что поле <strong>не может быть null</strong>."
          ]
        },
        "pagination": {
          "title": "Пагинация:",
          "content": "Для списков, которые могут быть длинными (`messages`), используйте пагинацию для эффективной загрузки данных (Принцип 9)."
        },
        "validation": {
          "title": "Валидация:",
          "content": "Backend выполняет строгую валидацию всех входных данных (через DTO и `class-validator`), возвращая ошибки `BAD_USER_INPUT` при их некорректности. Это часть <strong>системы обеспечения качества</strong> (Принцип 3)."
        },
        "security": {
          "title": "Безопасность:",
          "content": "Все запросы, работающие с чувствительными данными или изменяющие состояние системы (кроме регистрации/логина), требуют аутентификации."
        },
        "testingTools": {
          "title": "Инструменты тестирования API:",
          "content": "Используйте GraphQL Playground (часто доступен по адресу `/graphql` в dev-режиме Backend), Postman или Apollo Studio для отправки запросов и тестирования API."
        }
      }
    },
    "technicalDocs": {
      "title": "BrainMessenger Technical Documentation (System and Foundation)",
      "subtitle": "General Information: Architecture of a Digital Asset",
      "generalInfo": {
        "title": "1. General Information: Architecture of a Digital Asset",
        "description": "BrainMessenger is a modern messenger built as a <strong>reliable, scalable, and secure system</strong> (Principle 9), which serves as a <strong>key digital ASSET</strong> (Principle 10). This document provides a high-level overview of the project's <strong>technical foundation</strong> (Principle 8), describing the main components, technologies, and their interaction.",
        "projectNameTitle": "Project Name:",
        "projectNameContent": "BrainMessenger",
        "purposeTitle": "Purpose:",
        "purposeContent": "To provide a general understanding of BrainMessenger's structure, the technology stack used, and the principles underlying its construction, for all team members and stakeholders.",
        "principlesTitle": "Principles reflected in the technical structure:",
        "principlesList": [
          "<strong>System and Optimization (Principle 9):</strong> The project is designed as a set of interconnected, optimized components.",
          "<strong>Long-Term Thinking (Principle 8):</strong> Selection of technologies and architecture considering future scaling and development needs.",
          "<strong>Quality > Quantity (Principle 3):</strong> Use of proven, reliable solutions and focus on code and infrastructure quality.",
          "<strong>Pragmatism and Realism (Principle 12):</strong> Use of ready-made services (Neon, R2, Firebase) where justified, instead of building everything from scratch.",
          "<strong>Value Creation (Principle 2):</strong> The technical structure aims to provide key messenger functions (communication, files, calls) at a high level."
        ]
      },
      "techStack": {
        "title": "2. Technology Stack: Tools for Building the System",
        "description": "We use a modern and flexible set of technologies, allowing us to effectively build and scale BrainMessenger.",
        "frontend": {
          "title": "Frontend (Client Applications):",
          "list": [
            "<strong>React Native (Android, Windows Desktop):</strong> A single codebase for mobile and desktop applications. Chosen for cross-platform compatibility and a large set of ready-made libraries.",
            "<strong>Next.js (Web):</strong> React-framework for web application with SSR/SSG support for performance and SEO.",
            "<strong>TypeScript:</strong> Strict typing for all Frontend code. Increases reliability and simplifies refactoring."
          ]
        },
        "backend": {
          "title": "Backend (Server Logic):",
          "list": [
            "<strong>Node.js:</strong> High-performance JavaScript/TypeScript runtime environment.",
            "<strong>NestJS:</strong> Modular framework for Node.js. Provides a structured architecture (modules, services, controllers/resolvers) and TypeScript support.",
            "<strong>GraphQL:</strong> API protocol. Allows clients to request exactly the data they need, reducing redundancy."
          ]
        },
        "databaseCaching": {
          "title": "Database and Caching:",
          "list": [
            "<strong>PostgreSQL (via Neon):</strong> Reliable relational DBMS. Used as the main storage for structured data (users, chats, messages, metadata). Neon provides a managed service with scaling and replication features.",
            "<strong>Prisma ORM:</strong> Tool for interacting with PostgreSQL from NestJS. Provides typing and query security.",
            "<strong>Redis:</strong> In-memory data store. Used for caching, Rate Limiting, managing WebSocket connection state (user presence)."
          ]
        },
        "fileStorage": {
          "title": "File Storage:",
          "list": [
            "<strong>Cloudflare R2:</strong> Object storage, compatible with S3 API. Used for storing user files (photos, videos, documents, avatars, call recordings), encrypted data. Chosen for low cost and no egress fees."
          ]
        },
        "asyncProcessing": {
          "title": "Asynchronous Processing:",
          "list": [
            "<strong>Kafka:</strong> Distributed message queue system. Used for reliable asynchronous task processing (e.g., image processing, sending notifications) outside the main API thread."
          ]
        },
        "infrastructureDeployment": {
          "title": "Infrastructure and Deployment:",
          "list": [
            "<strong>Docker:</strong> Application containerization. Provides isolation and portability.",
            "<strong>Kubernetes:</strong> Container orchestration. Manages deployment, scaling, and self-healing of services in a cluster.",
            "<strong>Terraform:</strong> Infrastructure as Code (IaC). Automates the creation and management of cloud resources."
          ]
        },
        "testingMonitoringLogging": {
          "title": "Testing, Monitoring, Logging:",
          "list": [
            "<strong>Jest, Cypress, Detox:</strong> Tools for unit, integration, and E2E testing.",
            "<strong>Prometheus, Grafana:</strong> Monitoring system. Collection and visualization of performance metrics and system status.",
            "<strong>Winston, Sentry:</strong> Logging and error tracking system."
          ]
        }
      },
      "architecture": {
        "title": "3. Project Architecture: Interconnection of System Components",
        "description": "BrainMessenger's architecture follows the principles of <strong>modularity and separation of concerns</strong> (Principle 9).",
        "clientApplications": {
          "title": "Client Applications (Frontend):",
          "list": [
            "Web (Next.js), Mobile & Desktop (React Native).",
            "Contain the user interface and user interaction logic.",
            "Interact with the Backend exclusively via <strong>GraphQL API</strong>.",
            "Can directly download files from Cloudflare R2 (if public access) or via Backend (if authentication or URL signing is required)."
          ]
        },
        "apiGateway": {
          "title": "API Gateway (In the future):",
          "content": "Single entry point for all client requests. Can perform authentication, Rate Limiting, routing to the necessary Backend services. At startup, the Backend itself acts as the Gateway."
        },
        "backendService": {
          "title": "Backend Service (NestJS):",
          "list": [
            "Main server component.",
            "Contains <strong>BrainMessenger's business logic</strong> (user management, chats, messages, calls, payments).",
            "Provides <strong>GraphQL API</strong> for client applications.",
            "Interacts with the <strong>Database (Neon/PostgreSQL via Prisma)</strong> for reading/writing structured data.",
            "Interacts with <strong>File Storage (Cloudflare R2)</strong> for uploading/retrieving files (via AWS SDK).",
            "Interacts with <strong>Cache (Redis)</strong> for fast operations.",
            "Queues tasks in <strong>Queue (Kafka)</strong> for asynchronous processing.",
            "Uses external services (Firebase, Stripe, Gmail API)."
          ]
        },
        "database": {
          "title": "Database (Neon/PostgreSQL):",
          "content": "Stores structured data. Scales independently."
        },
        "fileStorage": {
          "title": "File Storage (Cloudflare R2):",
          "content": "Stores unstructured binary data. Scales by volume."
        },
        "caching": {
          "title": "Caching (Redis):",
          "content": "Fast access to temporary data."
        },
        "messageQueue": {
          "title": "Message Queue (Kafka):",
          "content": "Buffering and reliable message delivery between services for asynchronous processing."
        },
        "workers": {
          "title": "Workers (Kafka Consumers):",
          "list": [
            "Separate services that read tasks from Kafka and perform heavy or long operations (image processing, sending large mailings).",
            "Scale independently."
          ]
        },
        "externalServices": {
          "title": "External Services (Firebase, Stripe, Gmail API):",
          "list": [
            "Provide specialized functionality (notifications, payments, email).",
            "Used by the Backend service."
          ]
        },
        "mermaidDiagram": {
          "title": "Architecture Diagram:",
          "code": "graph TD\n    A[Frontend Web (Next.js)] -->|GraphQL API| B(API Gateway / Backend);\n    A -->|Direct File Access (Opt.)| E(Cloudflare R2);\n    F[Frontend Mobile/Desktop (React Native)] -->|GraphQL API| B;\n    F -->|Direct File Access (Opt.)| E;\n    B -->|Prisma Queries/Mutations| C(Neon/PostgreSQL);\n    B -->|AWS SDK (S3 API)| E;\n    B -->|ioredis| D(Redis Cache);\n    B -->|kafkajs Producer| G(Kafka Queue);\n    B -->|Firebase Admin SDK| H(Firebase FCM);\n    B -->|Stripe SDK| I(Stripe);\n    B -->|Google APIs Client| J(Gmail API);\n    G -->|kafkajs Consumer| K(Kafka Workers);\n    K -->|sharp| K; % Image processing\n    K -->|AWS SDK (S3 API)| E;\n    K -->|GraphQL API / Other Service Calls| B; % Report completion, send chat message\n    C -->|Replication (for scaling)| C;\n    C -->|Partitioning/Sharding (for scaling)| C;\n    E -->|CDN| A; % File delivery to Frontend\n    Prometheus(Prometheus) -->|Scrape Metrics| B;\n    Prometheus -->|Scrape Metrics| C;\n    Prometheus -->|Scrape Metrics| D;\n    Prometheus -->|Scrape Metrics| G;\n    Grafana(Grafana) -->|Visualize Metrics| Prometheus;\n    Sentry(Sentry) -->|Error Reports| B;\n    Sentry -->|Error Reports| A;"
        }
      },
      "api": {
        "title": "4. API: Interaction Interface",
        "description": "BrainMessenger's API is implemented using GraphQL with NestJS.",
        "endpointTitle": "Endpoint:",
        "endpointContent": "`/graphql`",
        "structureTitle": "Structure:",
        "structureContent": "Defined by the GraphQL Schema (User, Chat, Message types, etc.) and a set of Queries (for data retrieval) and Mutations (for data modification).",
        "authenticationTitle": "Authentication:",
        "authenticationContent": "JWT tokens in the `Authorization: Bearer <token>` header.",
        "externalApiIntegrationsTitle": "External API Integrations:",
        "externalApiIntegrationsContent": "Interaction with external services (Gmail, Stripe) is done via the Backend, which provides corresponding Mutations in the GraphQL API (see API Specification).",
        "keyFunctionalAreas": {
          "title": "Key functional areas of the API:",
          "list": [
            "Authentication (registration, login, logout, 2FA).",
            "User management (get/update/delete profile).",
            "Chat management (create, get list, get chat data).",
            "Message handling (send text messages, send files, get history).",
            "Contact management.",
            "Application settings (theme, notifications, language).",
            "Premium subscription management.",
            "File management (upload to R2 via Backend).",
            "(In the future) Calls and video calls (call session management)."
          ]
        },
        "detailedSpecTitle": "Detailed API specification is described in:",
        "detailedSpecContent": "DocSpec.md"
      },
      "database": {
        "title": "5. Database (Neon/PostgreSQL): Main Data Storage",
        "description": "",
        "technologyTitle": "Technology:",
        "technologyContent": "PostgreSQL 15.x.",
        "hostingTitle": "Hosting:",
        "hostingContent": "Neon.",
        "roleTitle": "Role:",
        "roleContent": "Relational database for all structured data.",
        "keyTables": {
          "title": "Key tables (defined in backend/prisma/schema.prisma):",
          "list": [
            "User: User information (id, email, password_hash, name, avatarUrl, createdAt, updatedAt, is2FaEnabled).",
            "Chat: Chat information (id, type, name, createdAt, updatedAt, lastMessageAt).",
            "UserChat: Linking table for Many-to-Many relationship between User and Chat (userId, chatId, joinedAt, lastReadMessageId).",
            "Message: Messages in chats (id, chatId, senderId, content, fileUrl, fileMetadata (JSON), createdAt, updatedAt).",
            "Contact: User's contact list (id, userId, contactId).",
            "Transaction: Payment history (for Premium) (id, userId, amount, currency, status, provider, createdAt).",
            "Code: Temporary codes (for email verification, 2FA) (id, userId/email, code, type, expiresAt)."
          ]
        },
        "interactionTitle": "Interaction:",
        "interactionContent": "Backend only via Prisma ORM.",
        "optimizationScalingTitle": "Optimization and Scaling:",
        "optimizationScalingContent": "Indexes, Prisma query optimization, materialized views, partitioning, replication are used (see DocOptimizationIn)."
      },
      "fileStorage": {
        "title": "6. File Storage (Cloudflare R2): Storage for Media and Binary Assets",
        "description": "",
        "technologyTitle": "Technology:",
        "technologyContent": "Object storage, S3-compatible API.",
        "hostingTitle": "Hosting:",
        "hostingContent": "Cloudflare R2.",
        "roleTitle": "Role:",
        "roleContent": "Storage for all unstructured data (user files, avatars, call recordings).",
        "interactionTitle": "Interaction:",
        "interactionContent": "Backend uploads files, Backend or Frontend retrieves files (directly or via signed URLs).",
        "structureTitle": "Structure:",
        "structureContent": "Files are organized by folders/keys (e.g., `avatars/`, `chat-images/`, `sensitive-data/`).",
        "securityTitle": "Security:",
        "securityContent": "Encryption at rest, restricted access, encryption of sensitive data at the application level before upload (see DocInt, DocSecurity)."
      },
      "projectStructure": {
        "title": "7. Project Structure (Monorepository): Code Organization",
        "description": "The project is organized as a monorepository using Turborepo.",
        "purposeTitle": "Purpose:",
        "purposeContent": "To simplify managing multiple applications/packages (backend, web, mobile-desktop, core) and code reuse.",
        "packages": {
          "title": "Packages:",
          "list": [
            "core: Common code.",
            "backend: Server logic.",
            "web: Web application.",
            "mobile-desktop: Mobile/desktop application (React Native).",
            "Infrastructure: Configuration files for deployment (infrastructure/).",
            "Documentation: Project documentation (docs/)."
          ]
        },
        "detailedDescriptionTitle": "Detailed description of the monorepository structure can be found in:",
        "detailedDescriptionContent": "DocDevIn.md (section 2)."
      },
      "security": {
        "title": "8. Security: Fundamental Aspect of the System",
        "description": "Security is built in at all levels (see more in BrainMessenger Security Guide).",
        "authenticationTitle": "Authentication:",
        "authenticationContent": "JWT, 2FA via email.",
        "authorizationTitle": "Authorization:",
        "authorizationContent": "Access rights verification for resources on the Backend.",
        "encryptionTitle": "Encryption:",
        "encryptionContent": "TLS/SSL for data transfer, password hashing (bcrypt/argon2), encryption of sensitive data at the application level before storing in R2.",
        "validationTitle": "Validation:",
        "validationContent": "Strict input data validation on the Backend.",
        "attackProtectionTitle": "Protection against Attacks:",
        "attackProtectionContent": "Rate Limiting, secure HTTP headers.",
        "principleTitle": "Principle:",
        "principleContent": "Security is a continuous process of learning (Principle 1) and improvement (Principle 9), based on responsibility (Principle 6)."
      },
      "deployment": {
        "title": "9. Deployment: Delivering the System to Users",
        "description": "The deployment process is automated.",
        "containerizationTitle": "Containerization:",
        "containerizationContent": "Docker images for Backend, Kafka Consumers.",
        "orchestrationTitle": "Orchestration:",
        "orchestrationContent": "Kubernetes manages containers in the cloud.",
        "iacTitle": "Infrastructure as Code:",
        "iacContent": "Terraform (IaC). Automates the creation and management of cloud resources.",
        "ciCdTitle": "CI/CD:",
        "ciCdContent": "GitHub Actions automates build, testing, and deployment.",
        "webAppDeploymentTitle": "Web application can be deployed separately (e.g., on Vercel or Cloudflare Pages).",
        "webAppDeploymentContent": "",
        "detailedDescriptionTitle": "Detailed description of the deployment process can be found in:",
        "detailedDescriptionList": [
          "DocDevIn.md (section 9)",
          "Deployment Guide"
        ]
      },
      "monitoringLogging": {
        "title": "10. Monitoring and Logging: Visibility into System State",
        "description": "",
        "monitoringTitle": "Monitoring:",
        "monitoringList": [
          "Collection and visualization of performance and system health metrics (CPU, RAM, API/DB latencies, errors).",
          "Tools: Prometheus, Grafana. Allows early problem detection (Principle 9: Kaizen)."
        ],
        "loggingTitle": "Logging:",
        "loggingList": [
          "Collection of structured logs from all components (Backend, workers).",
          "Tools: Winston (for Node.js), Sentry (for error tracking)."
        ],
        "detailedDescriptionTitle": "Detailed description can be found in:",
        "detailedDescriptionList": [
          "BrainMessenger Optimization Guide (section 14)",
          "Monitoring Guide"
        ]
      },
      "externalApiIntegrations": {
        "title": "11. External API Integrations: Using External Levers",
        "description": "The Backend interacts with several external services via their APIs.",
        "gmailApiTitle": "Gmail API:",
        "gmailApiContent": "Sending transactional emails (confirmation, 2FA).",
        "stripeTitle": "Stripe:",
        "stripeContent": "Payment processing and subscriptions.",
        "firebaseFCMTitle": "Firebase FCM:",
        "firebaseFCMContent": "Sending push notifications to mobile devices.",
        "principleTitle": "Principle:",
        "principleContent": "Using these services is a pragmatic (Principle 12) way to quickly add functionality, using ready-made, reliable (Principle 3) solutions.",
        "detailedDescriptionTitle": "Detailed description of integrations can be found in:",
        "detailedDescriptionContent": "DocInt.md"
      },
      "notes": {
        "title": "12. Notes",
        "description": "This documentation provides a high-level overview of the BrainMessenger technical system. For a more detailed understanding of individual parts, refer to related documents:",
        "apiSpecLinkTitle": "API Specification:",
        "apiSpecLinkContent": "DocSpec.md",
        "devGuideLinkTitle": "Development Guide:",
        "devGuideLinkContent": "DocDevIn.md",
        "optimizationGuideLinkTitle": "Optimization Guide:",
        "optimizationGuideLinkContent": "DocOptimizationIn.md",
        "integrationsDocsLinkTitle": "Integrations Documentation:",
        "integrationsDocsLinkContent": "DocInt.md",
        "designDocsLinkTitle": "Design Documentation:",
        "designDocsLinkContent": "DocDesign.md",
        "userGuideLinkTitle": "User Guide:",
        "userGuideLinkContent": "DocUser.md",
        "longTermInvestmentTitle": "Development and maintenance of this technical system is a long-term investment (Principle 8) and a continuous process of learning and improvement (Principle 1, 9)."
      }
    }
  },
  "footer": {
    "sectionTitle": {
      "brand": "BrainMessenger"
    },
    "brandContent": "Your Smart Communication Platform",
    "copyright": "© 2025 BrainMessenger. All rights reserved."
  }
}
