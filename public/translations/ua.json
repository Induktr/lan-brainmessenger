{
  "header": {
    "features": "Функції",
    "news": "Новини",
    "faq": "Поширені запитання",
    "faqLink": "Поширені запитання",
    "updates": "Оновлення",
    "selectLanguage": "Вибрати мову",
    "changeLanguageTooltip": "Змінити мову",
    "lightMode": "Світла тема",
    "darkMode": "Темна тема",
    "openMenu": "Відкрити меню",
    "closeMenu": "Закрити меню",
    "settings": "Налаштування",
    "signOut": "Вийти",
    "deleteAccount": "Видалити обліковий запис",
    "deleteAccountConfirmTitle": "Підтвердити видалення облікового запису",
    "deleteAccountConfirmMessage": "Ви впевнені, що хочете видалити свій обліковий запис? Цю дію не можна скасувати.",
    "cancel": "Скасувати",
    "confirmDelete": "Підтвердити видалення",
    "signIn": "Увійти",
    "docs": "Документація"
  },
  "hero": {
    "title": "Ласкаво просимо до BrainMessenger",
    "subtitle": "Ваша розумна платформа для спілкування",
    "getStarted": "Почати",
    "learnMore": "Дізнатись більше",
    "downloadButton": "Завантажити",
    "downloadAndroid": "Завантажити для Android"
  },
  "features": {
    "featuresTitle": "Ключові функції",
    "featuresSubtitle": "Дізнайтесь, що робить нас унікальними",
    "secureMessaging": "Безпечні повідомлення",
    "secureMessagingDesc": "Наскрізне шифрування для вашої конфіденційності",
    "smartAssistant": "Розумний асистент",
    "smartAssistantDesc": "ІІ-помічник завжди під рукою",
    "crossPlatform": "Крос-платформність",
    "crossPlatformDesc": "Використовуйте на будь-якому пристрої, де завгодно",
    "groupChats": "Групові чати",
    "groupChatsDesc": "Спілкуйтеся з кількома людьми одночасно",
    "privacyFirst": "Конфіденційність перш за все",
    "privacyFirstDesc": "Ваші дані - ваші, завжди"
  },
  "news": {
    "latestNews": "Останні новини",
    "readMore": "Читати далі",
    "newsDate": "Опубліковано"
  },
  "faq": {
    "title": "Поширені запитання",
    "subtitle": "Знайдіть відповіді на поширені запитання про BrainMessenger",
    "searchAlt": "Іконка пошуку",
    "searchPlaceholder": "Пошук запитань...",
    "allQuestions": "Всі запитання",
    "noResults": "За вашим запитом не знайдено жодного запитання.",
    "categories": {
      "general": "Загальні",
      "technical": "Технічні",
      "security": "Безпека",
      "pricing": "Ціни",
      "generalProject": "Загальні питання про проект",
      "technicalQuestions": "Технічні питання",
      "developmentProcesses": "Процеси розробки",
      "statusRoadmapFuture": "Статус, дорожня карта та майбутнє",
      "challengesOpportunitiesLimitations": "Виклики, можливості та обмеження",
      "learnMoreContribute": "Дізнатися більше та долучитися"
    },
    "questionsData": {
      "generalProject": {
        "q1": {
          "question": "Яка основна ідея BrainMessenger? Що робить його особливим?",
          "answer": "BrainMessenger - це платформа для спілкування, яка ставить на перше місце безпеку, інтелектуальні функції та зручність користувача. Його особливість полягає в поєднанні наскрізного шифрування, ШІ-асистента та крос-платформної доступності."
        },
        "q2": {
          "question": "Які ключові принципи лежать в основі розробки BrainMessenger?",
          "answer": "Розробка базується на принципах створення цінності для користувача, якості над кількістю, прагматизму, цілісності та здоров'я як фундаменту (включаючи доступність)."
        },
        "q3": {
          "question": "Хто стоїть за проектом? Це відкрита спільнота чи команда?",
          "answer": "На даний момент проект розробляється командою ентузіастів, але ми відкриті до співпраці та внесків від спільноти."
        }
      },
      "technicalQuestions": {
        "q1": {
          "question": "Чому було обрано саме такий стек технологій (TypeScript, NestJS, React/RN, PostgreSQL/Neon, GraphQL, Kafka, Redis, Cloudflare R2 тощо)?",
          "answer": "Вибір стеку обумовлений прагненням до надійності, масштабованості, швидкості розробки та використання сучасних підходів. TypeScript забезпечує типізацію, NestJS – структуру бекенду, React/RN – гнучкість UI, а інші технології – ефективну роботу з даними, повідомленнями та файлами."
        },
        "q2": {
          "question": "Чому на старті використовується монолітна архітектура, а не одразу мікросервіси?",
          "answer": "Монолітна архітектура на старті дозволяє швидше запустити MVP та перевірити основні гіпотези. Перехід до мікросервісів планується в майбутньому для кращої масштабованості та гнучкості."
        },
        "q3": {
          "question": "Які підходи використовуються для забезпечення безпеки?",
          "answer": "Ми використовуємо наскрізне шифрування (E2EE) для всіх приватних чатів, двофакторну автентифікацію (2FA), регулярні аудити безпеки та дотримуємося найкращих практик захисту даних."
        },
        "q4": {
          "question": "Як реалізовано функціональність реального часу (обмін повідомленнями)?",
          "answer": "Для обміну повідомленнями в реальному часі використовуються WebSockets та, можливо, Kafka для обробки потоків повідомлень, що забезпечує швидку та надійну доставку."
        },
        "q5": {
          "question": "Чому використовується GraphQL замість REST API?",
          "answer": "GraphQL дозволяє клієнтам запитувати лише ті дані, які їм потрібні, зменшуючи надлишковість та покращуючи продуктивність. Це також спрощує розробку API та еволюцію схеми даних."
        },
        "q6": {
          "question": "Як керуються великі обсяги даних та файлів?",
          "answer": "Для зберігання великих обсягів даних використовується PostgreSQL (можливо, з Neon для масштабованості), а для файлів – Cloudflare R2, що забезпечує надійне та ефективне зберігання."
        }
      },
      "developmentProcesses": {
        "q1": {
          "question": "Який підхід до управління проектом та завданнями?",
          "answer": "Ми використовуємо гнучкі методології розробки (Agile/Scrum) з регулярними спринтами, плануванням та ретроспективами. Завдання відстежуються в системі управління проектами."
        },
        "q2": {
          "question": "Як забезпечується якість коду?",
          "answer": "Якість коду забезпечується через код-рев'ю, статичний аналіз (лінтери, форматери), дотримання стандартів кодування та написання тестів."
        },
        "q3": {
          "question": "Яка стратегія тестування використовується?",
          "answer": "Наша стратегія включає юніт-тести, інтеграційні тести та E2E-тести для забезпечення надійності всіх компонентів системи."
        },
        "q4": {
          "question": "Як обробляються помилки?",
          "answer": "Помилки відстежуються за допомогою систем моніторингу, логуються та аналізуються для швидкого виправлення. На клієнті передбачені механізми обробки помилок для покращення UX."
        },
        "q5": {
          "question": "Як розгортається проект?",
          "answer": "Розгортання автоматизоване за допомогою CI/CD пайплайнів, що забезпечує швидку та надійну доставку оновлень."
        },
        "q6": {
          "question": "Як моніториться система в продакшені?",
          "answer": "Система моніториться за допомогою спеціалізованих інструментів, які відстежують продуктивність, доступність та помилки в реальному часі."
        }
      },
      "statusRoadmapFuture": {
        "q1": {
          "question": "Який поточний статус проекту?",
          "answer": "Проект знаходиться на стадії активної розробки MVP. Основні функції обміну повідомленнями та безпеки реалізовані."
        },
        "q2": {
          "question": "Які наступні кроки після завершення MVP?",
          "answer": "Після MVP планується розширення функціоналу, покращення продуктивності, додавання нових інтеграцій та поступовий перехід до мікросервісної архітектури."
        },
        "q3": {
          "question": "Чи планується перехід на мікросервісну архітектуру?",
          "answer": "Так, перехід на мікросервісну архітектуру планується для забезпечення кращої масштабованості, гнучкості та незалежності розробки окремих компонентів."
        }
      },
      "challengesOpportunitiesLimitations": {
        "q1": {
          "question": "Які основні технічні виклики (підводні камені) в проекті?",
          "answer": "Основні виклики включають забезпечення високого рівня безпеки, масштабування системи під великі навантаження та реалізацію складних ШІ-функцій."
        },
        "q2": {
          "question": "Які можливості та переваги надає архітектура та стек проекту?",
          "answer": "Обраний стек та архітектура забезпечують гнучкість, швидкість розробки, високу продуктивність та можливість легко впроваджувати нові технології."
        },
        "q3": {
          "question": "Які обмеження проекту на поточному етапі (MVP)?",
          "answer": "На етапі MVP функціонал буде обмежений основними можливостями для швидкого запуску та збору зворотного зв'язку. Деякі розширені функції будуть додані пізніше."
        }
      },
      "learnMoreContribute": {
        "q1": {
          "question": "Де я можу отримати більш детальну інформацію про проект?",
          "answer": "Більш детальну інформацію можна знайти в нашій документації (посилання буде додано пізніше) та на сторінці проекту на GitHub (якщо проект відкритий)."
        },
        "q2": {
          "question": "Як я можу долучитися до розробки проекту або зробити свій внесок?",
          "answer": "Ми завжди раді новим учасникам! Зв'яжіться з нами через контактну форму на сайті або через GitHub (якщо проект відкритий), щоб обговорити можливі варіанти співпраці."
        },
        "q3": {
          "question": "Де я можу поставити додаткові запитання?",
          "answer": "Додаткові запитання можна поставити через контактну форму на сайті, в нашому ком'юніті (посилання буде додано) або створивши issue на GitHub (якщо проект відкритий)."
    },
    "technicalDocs": {
      "title": "Технічна Документація BrainMessenger (Система та Фундамент)",
      "subtitle": "Загальна Інформація: Архітектура Цифрового Активу",
      "generalInfo": {
        "title": "1. Загальна Інформація: Архітектура Цифрового Активу",
        "description": "BrainMessenger — це сучасний месенджер, побудований як <strong>надійна, масштабована та безпечна система</strong> (Принцип 9), яка служить <strong>ключовим цифровим АКТИВОМ</strong> (Принцип 10). Цей документ надає високорівневий огляд <strong>технічного фундаменту</strong> (Принцип 8) проекту, описуючи основні компоненти, технології та їх взаємодію.",
        "projectNameTitle": "Назва проекту:",
        "projectNameContent": "BrainMessenger",
        "purposeTitle": "Мета:",
        "purposeContent": "Дати загальне розуміння структури BrainMessenger, використовуваного стеку технологій та принципів, що лежать в основі його побудови, для всіх членів команди та зацікавлених осіб.",
        "principlesTitle": "Принципи, відображені в технічній структурі:",
        "principlesList": [
          "<strong>Система та Оптимізація (Принцип 9):</strong> Проект спроектований як набір взаємопов'язаних, оптимізованих компонентів.",
          "<strong>Довгострокове Мислення (Принцип 8):</strong> Вибір технологій та архітектури з урахуванням майбутніх потреб масштабування та розвитку.",
          "<strong>Якість > Кількість (Принцип 3):</strong> Використання перевірених, надійних рішень та фокус на якості коду та інфраструктури.",
          "<strong>Прагматизм та Реалізм (Принцип 12):</strong> Використання готових сервісів (Neon, R2, Firebase) там, де це виправдано, замість створення всього з нуля.",
          "<strong>Створення Цінності (Принцип 2):</strong> Технічна структура спрямована на забезпечення ключових функцій месенджера (спілкування, файли, дзвінки) на високому рівні."
        ]
      },
      "techStack": {
        "title": "2. Технологічний Стек: Інструментарій для Побудови Системи",
        "description": "Ми використовуємо сучасний та гнучкий набір технологій, що дозволяє ефективно будувати та масштабувати BrainMessenger.",
        "frontend": {
          "title": "Фронтенд (Клієнтські Додатки):",
          "list": [
            "<strong>React Native (Android, Windows Desktop):</strong> Єдина кодова база для мобільного та десктопного додатку. Обраний за кросплатформність та великий набір готових бібліотек.",
            "<strong>Next.js (Web):</strong> React-фреймворк для веб-додатку з підтримкою SSR/SSG для продуктивності та SEO.",
            "<strong>TypeScript:</strong> Сувора типізація для всього Frontend-коду. Підвищує надійність та спрощує рефакторинг."
          ]
        },
        "backend": {
          "title": "Бекенд (Серверна Логіка):",
          "list": [
            "<strong>Node.js:</strong> Високопродуктивне середовище виконання JavaScript/TypeScript.",
            "<strong>NestJS:</strong> Модульний фреймворк для Node.js. Забезпечує структуровану архітектуру (модулі, сервіси, контролери/резолвери) та підтримку TypeScript.",
            "<strong>GraphQL:</strong> Протокол API. Дозволяє клієнтам запитувати точно ті дані, які потрібні, знижуючи надмірність."
          ]
        },
        "databaseCaching": {
          "title": "База Даних та Кешування:",
          "list": [
            "<strong>PostgreSQL (через Neon):</strong> Надійна реляційна СУБД. Використовується як основне сховище структурованих даних (користувачі, чати, повідомлення, метадані). Neon надає керований сервіс з функціями масштабування та реплікації.",
            "<strong>Prisma ORM:</strong> Інструмент для взаємодії з PostgreSQL з NestJS. Забезпечує типізацію та безпеку запитів.",
            "<strong>Redis:</strong> In-memory сховище даних. Використовується для кешування, Rate Limiting, управління станом WebSocket-з'єднань (присутність користувачів)."
          ]
        },
        "fileStorage": {
          "title": "Сховище Файлів:",
          "list": [
            "<strong>Cloudflare R2:</strong> Об'єктне сховище, сумісне з S3 API. Використовується для зберігання файлів користувачів (фото, відео, документи, аватари, записи дзвінків), зашифрованих даних. Обраний за низьку вартість та відсутність плати за вихідний трафік."
          ]
        },
        "asyncProcessing": {
          "title": "Асинхронна Обробка:",
          "list": [
            "<strong>Kafka:</strong> Розподілена система черг повідомлень. Використовується для надійної асинхронної обробки завдань (наприклад, обробка зображень, надсилання сповіщень) поза основним потоком API."
          ]
        },
        "infrastructureDeployment": {
          "title": "Інфраструктура та Розгортання:",
          "list": [
            "<strong>Docker:</strong> Контейнеризація додатків. Забезпечує ізоляцію та переносимість.",
            "<strong>Kubernetes:</strong> Оркестрація контейнерів. Керує розгортанням, масштабуванням та самовідновленням сервісів у кластері.",
            "<strong>Terraform:</strong> Інфраструктура як код (IaC). Автоматизує створення та управління хмарними ресурсами."
          ]
        },
        "testingMonitoringLogging": {
          "title": "Тестування, Моніторинг, Логування:",
          "list": [
            "<strong>Jest, Cypress, Detox:</strong> Інструменти для модульного, інтеграційного та E2E-тестування.",
            "<strong>Prometheus, Grafana:</strong> Система моніторингу. Збір та візуалізація метрик продуктивності та стану системи.",
            "<strong>Winston, Sentry:</strong> Система логування та відстеження помилок."
          ]
        }
      },
      "architecture": {
        "title": "3. Архітектура Проекту: Взаємозв'язок Компонентів Системи",
        "description": "Архітектура BrainMessenger дотримується принципів <strong>модульності та розділення відповідальності</strong> (Принцип 9).",
        "clientApplications": {
          "title": "Клієнтські Додатки (Фронтенд):",
          "list": [
            "Web (Next.js), Mobile & Desktop (React Native).",
            "Містять користувацький інтерфейс та логіку взаємодії з користувачем.",
            "Взаємодіють з Бекендом виключно через <strong>GraphQL API</strong>.",
            "Можуть безпосередньо завантажувати файли з Cloudflare R2 (якщо доступ публічний) або через Бекенд (якщо потрібна автентифікація або підпис URL)."
          ]
        },
        "apiGateway": {
          "title": "API Gateway (У майбутньому):",
          "content": "Єдина точка входу для всіх клієнтських запитів. Може виконувати автентифікацію, Rate Limiting, маршрутизацію на потрібні Backend-сервіси. На старті роль Gateway виконує сам Backend."
        },
        "backendService": {
          "title": "Backend Service (NestJS):",
          "list": [
            "Основний серверний компонент.",
            "Містить <strong>бізнес-логіку</strong> BrainMessenger (управління користувачами, чатами, повідомленнями, дзвінками, платежами).",
            "Надає <strong>GraphQL API</strong> для клієнтських додатків.",
            "Взаємодіє з <strong>Базою Даних (Neon/PostgreSQL через Prisma)</strong> для читання/запису структурованих даних.",
            "Взаємодіє з <strong>Сховищем Файлів (Cloudflare R2)</strong> для завантаження/отримання файлів (через AWS SDK).",
            "Взаємодіє з <strong>Кешем (Redis)</strong> для швидких операцій.",
            "Ставить завдання в <strong>Чергу (Kafka)</strong> для асинхронної обробки.",
            "Використовує зовнішні сервіси (Firebase, Stripe, Gmail API)."
          ]
        },
        "database": {
          "title": "База Даних (Neon/PostgreSQL):",
          "content": "Зберігає структуровані дані. Масштабується незалежно."
        },
        "fileStorage": {
          "title": "Сховище Файлів (Cloudflare R2):",
          "content": "Зберігає неструктуровані бінарні дані. Масштабується за обсягом."
        },
        "caching": {
          "title": "Кешування (Redis):",
          "content": "Швидкий доступ до тимчасових даних."
        },
        "messageQueue": {
          "title": "Черга Повідомлень (Kafka):",
          "content": "Буферизація та надійна доставка повідомлень між сервісами для асинхронної обробки."
        },
        "workers": {
          "title": "Воркери (Kafka Consumers):",
          "list": [
            "Окремі сервіси, що читають завдання з Kafka та виконують важкі або довгі операції (обробка зображень, надсилання великих розсилок).",
            "Масштабуються незалежно."
          ]
        },
        "externalServices": {
          "title": "Зовнішні Сервіси (Firebase, Stripe, Gmail API):",
          "list": [
            "Надають спеціалізований функціонал (сповіщення, платежі, email).",
            "Використовуються Backend-сервісом."
          ]
        },
        "mermaidDiagram": {
          "title": "Діаграма Архітектури:",
          "code": "graph TD\n    A[Frontend Web (Next.js)] -->|GraphQL API| B(API Gateway / Backend);\n    A -->|Direct File Access (Opt.)| E(Cloudflare R2);\n    F[Frontend Mobile/Desktop (React Native)] -->|GraphQL API| B;\n    F -->|Direct File Access (Opt.)| E;\n    B -->|Prisma Queries/Mutations| C(Neon/PostgreSQL);\n    B -->|AWS SDK (S3 API)| E;\n    B -->|ioredis| D(Redis Cache);\n    B -->|kafkajs Producer| G(Kafka Queue);\n    B -->|Firebase Admin SDK| H(Firebase FCM);\n    B -->|Stripe SDK| I(Stripe);\n    B -->|Google APIs Client| J(Gmail API);\n    G -->|kafkajs Consumer| K(Kafka Workers);\n    K -->|sharp| K; % Image processing\n    K -->|AWS SDK (S3 API)| E;\n    K -->|GraphQL API / Other Service Calls| B; % Report completion, send chat message\n    C -->|Replication (for scaling)| C;\n    C -->|Partitioning/Sharding (for scaling)| C;\n    E -->|CDN| A; % File delivery to Frontend\n    Prometheus(Prometheus) -->|Scrape Metrics| B;\n    Prometheus -->|Scrape Metrics| C;\n    Prometheus -->|Scrape Metrics| D;\n    Prometheus -->|Scrape Metrics| G;\n    Grafana(Grafana) -->|Visualize Metrics| Prometheus;\n    Sentry(Sentry) -->|Error Reports| B;\n    Sentry -->|Error Reports| A;"
        }
      },
      "api": {
        "title": "4. API: Інтерфейс Взаємодії",
        "description": "API BrainMessenger реалізовано на GraphQL з використанням NestJS.",
        "endpointTitle": "Endpoint:",
        "endpointContent": "`/graphql`",
        "structureTitle": "Структура:",
        "structureContent": "Визначається GraphQL Схемою (типи User, Chat, Message тощо) та набором Queries (для отримання даних) і Mutations (для зміни даних).",
        "authenticationTitle": "Автентифікація:",
        "authenticationContent": "JWT-токени в заголовку `Authorization: Bearer <token>`.",
        "externalApiIntegrationsTitle": "Зовнішні API Інтеграції:",
        "externalApiIntegrationsContent": "Взаємодія із зовнішніми сервісами (Gmail, Stripe) здійснюється через Backend, який надає відповідні Mutations в GraphQL API (див. Специфікацію API).",
        "keyFunctionalAreas": {
          "title": "Ключові функціональні області API:",
          "list": [
            "Автентифікація (реєстрація, логін, логаут, 2FA).",
            "Управління користувачами (отримання/оновлення/видалення профілю).",
            "Управління чатами (створення, отримання списку, отримання даних чату).",
            "Робота з повідомленнями (надсилання текстових повідомлень, надсилання файлів, отримання історії).",
            "Управління контактами.",
            "Налаштування додатку (тема, сповіщення, мова).",
            "Управління Premium-підпискою.",
            "Управління файлами (завантаження в R2 через Backend).",
            "(У майбутньому) Дзвінки та відеодзвінки (управління сесіями дзвінків)."
          ]
        },
        "detailedSpecTitle": "Детальна специфікація API описана в:",
        "detailedSpecContent": "DocSpec.md"
      },
      "database": {
        "title": "5. База Даних (Neon/PostgreSQL): Сховище Основних Даних",
        "description": "",
        "technologyTitle": "Технологія:",
        "technologyContent": "PostgreSQL 15.x.",
        "hostingTitle": "Хостинг:",
        "hostingContent": "Neon.",
        "roleTitle": "Роль:",
        "roleContent": "Реляційна база даних для всіх структурованих даних.",
        "keyTables": {
          "title": "Ключові таблиці (визначені в backend/prisma/schema.prisma):",
          "list": [
            "User: Інформація про користувачів (id, email, password_hash, name, avatarUrl, createdAt, updatedAt, is2FaEnabled).",
            "Chat: Інформація про чати (id, type, name, createdAt, updatedAt, lastMessageAt).",
            "UserChat: Зв'язуюча таблиця для Many-to-Many зв'язку між User та Chat (userId, chatId, joinedAt, lastReadMessageId).",
            "Message: Повідомлення в чатах (id, chatId, senderId, content, fileUrl, fileMetadata (JSON), createdAt, updatedAt).",
            "Contact: Список контактів користувача (id, userId, contactId).",
            "Transaction: Історія платежів (для Premium) (id, userId, amount, currency, status, provider, createdAt).",
            "Code: Тимчасові коди (для email верифікації, 2FA) (id, userId/email, code, type, expiresAt)."
          ]
        },
        "interactionTitle": "Взаємодія:",
        "interactionContent": "Тільки Backend через Prisma ORM.",
        "optimizationScalingTitle": "Оптимізація та Масштабування:",
        "optimizationScalingContent": "Використовуються індекси, оптимізація запитів Prisma, матеріалізовані представлення, партиціонування, реплікація (див. DocOptimizationIn)."
      },
      "fileStorage": {
        "title": "6. Сховище Файлів (Cloudflare R2): Сховище Медіа та Бінарних Активів",
        "description": "",
        "technologyTitle": "Технологія:",
        "technologyContent": "Об'єктне сховище, S3-сумісний API.",
        "hostingTitle": "Хостинг:",
        "hostingContent": "Cloudflare R2.",
        "roleTitle": "Роль:",
        "roleContent": "Зберігання всіх неструктурованих даних (файли користувачів, аватарки, записи дзвінків).",
        "interactionTitle": "Взаємодія:",
        "interactionContent": "Backend завантажує файли, Backend або Frontend отримує файли (безпосередньо або через підписані URL).",
        "structureTitle": "Структура:",
        "structureContent": "Файли організовані за папками/ключами (наприклад, `avatars/`, `chat-images/`, `sensitive-data/`).",
        "securityTitle": "Безпека:",
        "securityContent": "Шифрування в спокої, обмежений доступ, шифрування чутливих даних на рівні додатку перед завантаженням (див. DocInt, DocSecurity)."
      },
      "projectStructure": {
        "title": "7. Проектна Структура (Монорепозиторій): Організація Коду",
        "description": "Проект організований як монорепозиторій з використанням Turborepo.",
        "purposeTitle": "Мета:",
        "purposeContent": "Спростити управління кількома додатками/пакетами (backend, web, mobile-desktop, core) та перевикористання коду.",
        "packages": {
          "title": "Пакети:",
          "list": [
            "core: Спільний код.",
            "backend: Серверна логіка.",
            "web: Веб-додаток.",
            "mobile-desktop: Мобільний/десктопний додаток (React Native).",
            "Інфраструктура: Файли конфігурації для розгортання (infrastructure/).",
            "Документація: Проектна документація (docs/)."
          ]
        },
        "detailedDescriptionTitle": "Детальний опис структури монорепозиторію див. у:",
        "detailedDescriptionContent": "DocDevIn.md (розділ 2)."
      },
      "security": {
        "title": "8. Безпека: Фундаментальний Аспект Системи",
        "description": "Безпека вбудована на всіх рівнях (див. докладніше в Посібнику з безпеки BrainMessenger).",
        "authenticationTitle": "Автентифікація:",
        "authenticationContent": "JWT, 2FA через email.",
        "authorizationTitle": "Авторизація:",
        "authorizationContent": "Перевірка прав доступу до ресурсів на Backend.",
        "encryptionTitle": "Шифрування:",
        "encryptionContent": "TLS/SSL для передачі даних, шифрування паролів (bcrypt/argon2), шифрування чутливих даних на рівні додатку перед зберіганням в R2.",
        "validationTitle": "Валідація:",
        "validationContent": "Сувора валідація вхідних даних на Backend.",
        "attackProtectionTitle": "Захист від Атак:",
        "attackProtectionContent": "Rate Limiting, безпечні HTTP-заголовки.",
        "principleTitle": "Принцип:",
        "principleContent": "Безпека — це постійний процес навчання (Принцип 1) та вдосконалення (Принцип 9), заснований на відповідальності (Принцип 6)."
      },
      "deployment": {
        "title": "9. Розгортання: Доставка Системи Користувачам",
        "description": "Процес розгортання автоматизований.",
        "containerizationTitle": "Контейнеризація:",
        "containerizationContent": "Docker-образи для Backend, Kafka Consumers.",
        "orchestrationTitle": "Оркестрація:",
        "orchestrationContent": "Kubernetes керує контейнерами в хмарі.",
        "iacTitle": "Інфраструктура як Код:",
        "iacContent": "Terraform (IaC). Автоматизує створення та управління хмарними ресурсами."
      },
      "monitoringLogging": {
        "title": "10. Моніторинг та Логування: Видимість Стану Системи",
        "description": "",
        "monitoringTitle": "Моніторинг:",
        "monitoringList": [
          "Збір та візуалізація метрик продуктивності та здоров'я системи (CPU, RAM, затримки API/БД, помилки).",
          "Інструменти: Prometheus, Grafana. Дозволяє виявляти проблеми на ранній стадії (Принцип 9: Кайдзен)."
        ],
        "loggingTitle": "Логування:",
        "loggingList": [
          "Збір структурованих логів від усіх компонентів (Backend, воркери).",
          "Інструменти: Winston (для Node.js), Sentry (для відстеження помилок)."
        ],
        "detailedDescriptionTitle": "Детальний опис див. у:",
        "detailedDescriptionList": [
          "Посібнику з оптимізації BrainMessenger (розділ 14)",
          "Посібнику з моніторингу"
        ]
      },
      "externalApiIntegrations": {
        "title": "11. Зовнішні API Інтеграції: Використання Зовнішніх Важелів",
        "description": "Backend взаємодіє з кількома зовнішніми сервісами через їх API.",
        "gmailApiTitle": "Gmail API:",
        "gmailApiContent": "Надсилання транзакційних email (підтвердження, 2FA).",
        "stripeTitle": "Stripe:",
        "stripeContent": "Обробка платежів та підписок.",
        "firebaseFCMTitle": "Firebase FCM:",
        "firebaseFCMContent": "Надсилання push-сповіщень на мобільні пристрої.",
        "principleTitle": "Принцип:",
        "principleContent": "Використання цих сервісів — прагматичний (Принцип 12) спосіб швидко додати функціонал, використовуючи готові, надійні (Принцип 3) рішення.",
        "detailedDescriptionTitle": "Детальний опис інтеграцій див. у:",
        "detailedDescriptionContent": "DocInt.md"
      },
      "notes": {
        "title": "12. Примітки",
        "description": "Ця документація надає високорівневий огляд технічної системи BrainMessenger. Для більш детального розуміння окремих частин звертайтеся до пов'язаних документів:",
        "apiSpecLinkTitle": "Специфікація API:",
        "apiSpecLinkContent": "DocSpec.md",
        "devGuideLinkTitle": "Посібник з розробки:",
        "devGuideLinkContent": "DocDevIn.md",
        "optimizationGuideLinkTitle": "Посібник з оптимізації:",
        "optimizationGuideLinkContent": "DocOptimizationIn.md",
        "integrationsDocsLinkTitle": "Документація інтеграцій:",
        "integrationsDocsLinkContent": "DocInt.md",
        "designDocsLinkTitle": "Документація дизайну:",
        "designDocsLinkContent": "DocDesign.md",
        "userGuideLinkTitle": "Посібник користувача:",
        "userGuideLinkContent": "DocUser.md",
        "longTermInvestmentTitle": "Розробка та підтримка цієї технічної системи — це довгострокова інвестиція (Принцип 8) та безперервний процес навчання та вдосконалення (Принцип 1, 9)."
      }
    }
  }
}
  },
  "docs": {
    "general": {
      "title": "BrainMessenger - Ваш Цифровий Актив для Ефективної Комунікації",
      "subtitle": "Вступ: Побудова Системи Цінності",
      "introduction": {
        "title": "Вступ: Побудова Системи Цінності",
        "content": "Ласкаво просимо до репозиторію BrainMessenger. Це не просто черговий месенджер. Це цілеспрямований проект, спрямований на створення <strong>надійної, масштабованої та безпечної СИСТЕМИ</strong> (Принцип 9), яка стане <strong>ключовим цифровим АКТИВОМ</strong> (Принцип 10) для кожного користувача. Наша головна мета – <strong>спростити складність</strong> (принцип Маргулана Сейсембаєва), надаючи інтуїтивно зрозумілі та потужні інструменти для ефективної комунікації та взаємодії в сучасному цифровому світі.<br/><br/>BrainMessenger побудований на <strong>міцному фундаменті</strong> (Принцип 8) глибоких принципів, свідомого планування та <strong>безперервного навчання</strong> (Принцип 1). Кожен рядок коду, кожне прийняте рішення – це <strong>довгострокова інвестиція</strong> (Принцип 8) у <strong>якість</strong> (Принцип 3) та <strong>цінність</strong> (Принцип 2) нашого продукту."
      },
      "visionAndMission": {
        "title": "Бачення та Місія: Наш Довгостроковий Погляд",
        "visionTitle": "Наше Бачення:",
        "visionContent": "Створити провідний цифровий актив для комунікації, який допомагатиме мільйонам користувачів по всьому світу ефективно обмінюватися інформацією, будувати спільноти та досягати своїх цілей.",
        "missionTitle": "Наша Місія:",
        "missionContent": "Спрощувати складну взаємодію, надаючи надійний, безпечний та зручний месенджер, побудований на принципах якості, прозорості та безперервного вдосконалення."
      },
      "keyPrinciples": {
        "title": "Ключові Принципи: Фундамент Нашої Системи",
        "intro": "Наші дії та рішення керуються набором ключових принципів, які слугують <strong>фундаментом</strong> (Принцип 8) всього проекту BrainMessenger. Це не просто слова, а <strong>особисті алгоритми та стандарти (Кайдзен, Принцип 9)</strong>, розроблені через досвід та рефлексію (Принцип 1):",
        "principles": [
          "<strong>Безперервне Навчання та Зростання (Принцип 1):</strong> Процес створення BrainMessenger – це полігон для глибокого навчання в технологіях, архітектурі та психології користувачів. Ми вчимося на кожному кроці, перетворюючи помилки на уроки.",
          "<strong>Створення Цінності (Принцип 2):</strong> Користь для користувача – в основі всього. Ми будуємо те, що справді вирішує проблеми та робить життя кращим.",
          "<strong>Якість Понад Кількість (Принцип 3):</strong> Ми прагнемо робити речі добре, а не просто швидко. Надійність, продуманість та увага до деталей – наші пріоритети.",
          "<strong>Усвідомленість та Присутність (Принцип 4):</strong> Бути уважним до процесу, користувачів та команди.",
          "<strong>Здоров'я як Фундамент (Принцип 5):</strong> Фізичне та ментальне благополуччя команди (та майбутніх користувачів) – основа продуктивності та стійкості.",
          "<strong>Відповідальність та Проактивність (Принцип 6):</strong> Ми беремо відповідальність за результат та діємо превентивно.",
          "<strong>Цілісність (Принцип 7):</strong> Наші слова відповідають нашим діям.",
          "<strong>Довгострокове Мислення (Принцип 8):</strong> Ми інвестуємо час та зусилля з прицілом на майбутнє.",
          "<strong>Система та Оптимізація (Принцип 9):</strong> Ми будуємо процеси та архітектуру як систему, постійно шукаючи шляхи підвищення ефективності (Кайдзен).",
          "<strong>Створення Багатства > Заробляння Грошей (Принцип 10):</strong> Фокус на створенні АКТИВУ (BrainMessenger), який приносить цінність та працює в довгостроковій перспективі.",
          "<strong>Гнучкість та Адаптивність (Принцип 11):</strong> Готовність змінювати тактику та інструменти, зберігаючи бачення.",
          "<strong>Прагматизм та Реалізм (Принцип 12):</strong> Прийняття рішень на основі реальних даних та можливостей.",
          "<strong>Наполегливість (Принцип 13):</strong> Не здаватися перед труднощами, витягувати уроки з невдач.",
          "<strong>Використання Зовнішньої Експертизи та Зворотного Зв'язку (Принцип 14):</strong> Ми вчимося в інших, прислухаємося до конструктивної критики.",
          "<strong>Схильність до Дії (Принцип 15):</strong> На ранніх етапах важливіше почати робити та отримувати зворотний зв'язок, ніж нескінченно планувати."
        ],
        "outro": "Ці принципи, натхненні філософією Маргулана Сейсембаєва та практиками провідних ІТ-компаній, формують нашу культуру та підхід до розробки."
      },
      "aboutMVP": {
        "title": "Про Проект BrainMessenger (Фокус на MVP)",
        "intro": "Наш поточний фокус – на розробці <strong>Мінімально Життєздатного Продукту (MVP)</strong>. MVP – це перший, <strong>прагматичний</strong> (Принцип 12) крок до реалізації нашого бачення. Ми будуємо <strong>міцний технічний фундамент</strong> (Принцип 8), який дозволить нам швидко та ефективно розвивати продукт у майбутньому.",
        "featuresTitle": "MVP включає базові, але <strong>високоякісні та надійні</strong> (Принцип 3) функції, що надають ключову <strong>цінність</strong> (Принцип 2):",
        "features": [
          "<strong>Базовий Обмін Повідомленнями:</strong> Надсилання та отримання текстових повідомлень в особистих чатах та групах/каналах.",
          "<strong>Обмін Файлами:</strong> Завантаження та завантаження файлів (з оптимізацією зображень).",
          "<strong>Канали та Групи:</strong> Базове створення груп/каналів, приєднання до публічних каналів та читання контенту.",
          "<strong>Базове Управління Обліковим Записом:</strong> Реєстрація, вхід/вихід, редагування профілю (ім'я, аватар), базові налаштування безпеки.",
          "<strong>Основні Налаштування UI:</strong> Вибір теми (Світла/Темна), базові налаштування сповіщень та мови.",
          "<strong>Базова Багатомовність:</strong> Підтримка кількох мов інтерфейсу (англійська, російська та інші згідно DocLocIn.md)."
        ],
        "outro": "Функціонал за межами MVP (аудіо/відеодзвінки, розширені функції безпеки/конфіденційності, преміум-підписка, повний набір анімацій, інтеграції ШІ) заплановано на наступні етапи Дорожньої карти."
      },
      "howWeBuild": {
        "title": "Як Ми Будуємо: Історія Створення та Процес Кайдзен",
        "intro": "Процес створення BrainMessenger – це жива історія, заснована на наших принципах. Ми будуємо його <strong>систематично</strong> (Принцип 9), крок за кроком, документуючи кожен етап та постійно шукаючи можливості для <strong>вдосконалення (Кайдзен)</strong>.",
        "steps": [
          "<strong>Усвідомлене Планування (Принцип 4):</strong> Проект розпочався з чіткого визначення глобальних цілей та їх декомпозиції на досяжні етапи (Дорожня карта).",
          "<strong>Вибір Фундаменту (Принцип 8, 12):</strong> Ми ретельно відібрали стек технологій – надійні та <strong>прагматичні</strong> інструменти (TypeScript, NestJS, React/RN, PostgreSQL/Neon, Cloudflare R2, Kafka, Redis), що формують <strong>міцний технічний фундамент</strong>.",
          "<strong>Побудова Ядра MVP:</strong> Реалізація розпочалася з базових, критично важливих частин системи (Аутентифікація, Базовий UI, Інфраструктура, Обробка Файлів). Ми застосовуємо <strong>Схильність до Дії</strong> (Принцип 15), зосереджуючись на побудові робочих компонентів, навіть якщо вони поки що мінімальні.",
          "<strong>Безперервне Навчання та Застосування Знань (Принцип 1):</strong> Кожне нове завдання, особливо пов'язане з вивченням або інтеграцією технологій (як видно у <a href=\"https://www.notion.so/2025-2026-1576e78881b7435e9c3c2cf174e61b91?pvs=4\" target=\"_blank\" rel=\"noopener noreferrer\">Відео Трекері</a> та завданнях), розглядається як можливість для зростання. Ми документуємо цей процес за допомогою відео та рефлексії (Кайдзен-Година).",
          "<strong>Системний Підхід до Якості (Принцип 3, 9):</strong> Ми інтегруємо тестування на ранніх етапах циклу розробки (Unit-тести), налаштовуємо CI/CD пайплайни для автоматичних перевірок, і використовуємо інструменти моніторингу (Prometheus, Grafana, Sentry) та логування (Winston, ELK) для безперервного контролю за <strong>здоров'ям системи</strong> (Принцип 5) в реальному часі.",
          "<strong>Документація як Частина Системи Знань:</strong> Весь процес розробки, архітектурні рішення, стандарти та вимоги ретельно документуються. Це не просто формальність, а частина створення <strong>системи знань</strong>, яка прискорює онбординг, спрощує підтримку та дозволяє приймати обґрунтовані рішення в майбутньому."
        ],
        "outro": "Ми будуємо BrainMessenger як живий, еволюціонуючий організм, постійно адаптуючись та вдосконалюючись на основі наших принципів та зворотного зв'язку від процесу розробки та майбутніх користувачів."
      },
      "technologyStack": {
        "title": "Стек Технологій: Наші Інструменти для Створення Активу",
        "intro": "Ми обрали стек, який є <strong>прагматичним</strong> (Принцип 12), <strong>надійним</strong> (Принцип 3) та <strong>масштабованим</strong> (Принцип 8) для створення нашого <strong>цифрового АКТИВУ</strong>.",
        "stack": [
          "<strong>Мова:</strong> <a href=\"https://www.typescriptlang.org/\" target=\"_blank\" rel=\"noopener noreferrer\">TypeScript</a> - Статична типізація для підвищення якості та надійності коду.",
          "<strong>Бекенд:</strong> <a href=\"https://nodejs.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Node.js</a>, <a href=\"https://nestjs.com/\" target=\"_blank\" rel=\"noopener noreferrer\">NestJS</a> - Ефективний та структурований фреймворк для серверної логіки та GraphQL API.",
          "<strong>Фронтенд:</strong> <a href=\"https://react.dev/\" target=\"_blank\" rel=\"noopener noreferrer\">React</a>, <a href=\"https://nextjs.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Next.js</a> (Веб), <a href=\"https://reactnative.dev/\" target=\"_blank\" rel=\"noopener noreferrer\">React Native</a> (Мобільний/Десктоп) - Крос-платформна розробка UI з фокусом на продуктивності.",
          "<strong>API:</strong> <a href=\"https://graphql.org/\" target=\"_blank\" rel=\"noopener noreferrer\">GraphQL</a> - Гнучка взаємодія між клієнтом та сервером.",
          "<strong>Реальний час:</strong> WebSockets - Миттєва доставка повідомлень.",
          "<strong>База даних:</strong> <a href=\"https://www.postgresql.org/\" target=\"_blank\" rel=\"noopener noreferrer\">PostgreSQL</a> (через <a href=\"https://neon.tech/\" target=\"_blank\" rel=\"noopener noreferrer\">Neon</a>) - Надійна та масштабована база даних. Neon як керований сервіс зменшує операційні витрати (Прагматизм).",
          "<strong>ORM:</strong> <a href=\"https://www.prisma.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Prisma</a> - Типобезопасное и надежное взаимодействие с базой данных, защита от SQL-инъекций (Качество, Безпека).",
          "<strong>Кешування:</strong> <a href=\"https://redis.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Redis</a> - Высокопродуктивное кеширование и управление состоянием.",
          "<strong>Черги:</strong> <a href=\"https://kafka.apache.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Kafka</a> - Надійна асинхронна обробка завдань.",
          "<strong>Зберігання файлів:</strong> <a href=\"https://www.cloudflare.com/developer/r2/\" target=\"_blank\" rel=\"noopener noreferrer\">Cloudflare R2</a> - Об'єктне сховище з вигідними тарифами та без плати за исходящий трафік (Прагматизм, АКТИВ).",
          "<strong>Сповіщення:</strong> <a href=\"https://firebase.google.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Firebase</a> - Керований сервіс для push-сповіщень.",
          "<strong>Електронна пошта/2FA:</strong> <a href=\"https://developers.google.com/gmail/api\" target=\"_blank\" rel=\"noopener noreferrer\">Gmail API</a> - Надійна доставка транзакційних писем (коди підтвердження, 2FA).",
          "<strong>Платежі:</strong> <a href=\"https://stripe.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Stripe</a>, Cryptomus (За пределами MVP) - Монетизация АКТИВУ, Прагматизм.",
          "<strong>Тестирование:</strong> Jest, Cypress, Detox, k6, OWASP ZAP/Burp Suite (план) - Комплексный подход к обеспечению качества.",
          "<strong>Развертывание:</strong> <a href=\"https://vercel.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Vercel</a> (Веб), Docker, <a href=\"https://kubernetes.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Kubernetes</a> - Автоматизованное и масштабированное развертывание.",
          "<strong>Мониторинг:</strong> Prometheus, Grafana, Sentry (план) - Видимость системы и анализ Кайдзен."
        ]
      },
      "architecture": {
        "title": "Архітектура: Еволюція Системи",
        "intro": "Наразі BrainMessenger реалізований як <strong>монолітний додаток на базі NestJS</strong>. Це <strong>прагматичне</strong> (Принцип 12) рішення для MVP, що дозволяє швидко запустити продукт та перевірити основні гіпотези.",
        "future": "У майбутньому, зі зростанням проекту та збільшенням навантаження, ми плануємо поетапний перехід до <strong>мікросервісної архітектури</strong> з використанням <strong>Strangler Pattern</strong>. Це <strong>довгострокова стратегія</strong> (Принцип 8), яка дозволить незалежно масштабувати та розвивати окремі компоненти (чати, дзвінки, ШІ, платежи), підвищуючи загальну <strong>надійність та гнучкість</strong> системи (Принцип 3, 11).",
        "interaction": "Взаємодія між компонентами відбуватиметься через <strong>GraphQL API</strong> (синхронно) та <strong>Kafka</strong> (асинхронно), використовуючи <strong>Apollo Federation</strong> (у майбутньому) для побудови єдиної схеми API з кількох мікросервісів."
      },
      "projectStatus": {
        "title": "Статус Проекту: Поточний Етап (MVP)",
        "content": "На даний момент проект знаходиться на етапі активної розробки <strong>MVP</strong> (згідно з <a href=\"https://www.notion.so/MVP-11a2a21315e54eb3b3c90171b4c7493d?pvs=4\" target=\"_blank\" rel=\"noopener noreferrer\">Інструкцією з Вимог до MVP</a>). Ми зосереджені на завершенні основної функціональності обміну повідомленнями, обробки файлів, створення груп/каналів та базових налаштувань, одночасно зміцнюючи <strong>технічний фундамент</strong> (Принцип 8) та впроваджуючи процеси <strong>безперервного навчання</strong> та <strong>Кайдзен</strong> у нашу щоденну роботу.",
        "progress": "Прогрес документується через завдання, код у репозиторії та відеозаписи, які демонструють наш шлях та <strong>процес створення</strong> (Принцип 1)."
      },
      "gettingStarted": {
        "title": "Початок Роботи (Для Розробників)",
        "intro": "Хочете приєднатися до нас у створенні цього цифрового АКТИВУ? Ось як почати:",
        "steps": [
          "Клонуйте репозиторій:<br/>```bash<br/>git clone <https://github.com/xAI/BrainMessenger.git> # Приклад<br/>cd BrainMessenger<br/>```",
          "Встановіть залежності:<br/>```bash<br/>npm install # Turborepo встановить залежності для всіх пакетів<br/>```",
          "Налаштуйте змінні середовища: Скопіюйте `.env.example` до `.env` та заповніть необхідні дані для інтеграцій (Neon, R2, Firebase тощо). <strong>Не комітьте ваш файл `.env`!</strong><br/>```bash<br/>cp .env.example .env<br/># Заповніть .env<br/>```",
          "Налаштуйте базу даних: Запустіть локальний PostgreSQL або використовуйте екземпляр Neon, потім застосуйте міграції Prisma.<br/>```bash<br/>cd backend<br/>npx prisma migrate dev --name initial_setup # Або npx prisma migrate deploy для продакшену<br/>cd ..<br/>```",
          "Запустіть сервіси в режимі розробки:<br/>```bash<br/>turbo run dev # Це запустить dev-сервери бекенду та фронтенду<br/># Або перейдіть до конкретних пакетів та запустіть їхні dev-скрипти:<br/># cd backend && npm run start:dev<br/># cd packages/web && npm run dev<br/># cd packages/mobile-desktop && npm run android / npm run windows<br/>```"
        ],
        "outro": "Більш детальні інструкції щодо локального налаштування та розробки можна знайти в <a href=\"link_to_development_guide_doc\" target=\"_blank\" rel=\"noopener noreferrer\">Посібнику з Розробки</a>."
      },
      "documentationSystem": {
        "title": "Документація: Наша Система Знань",
        "intro": "Цей README надає загальний огляд. Вся детальна інформація про проект міститься в нашій <strong>комплексній системі документації</strong>. Вивчення цих документів є частиною процесу <strong>навчання</strong> (Принцип 1) та розуміння <strong>системи</strong> (Принцип 9):",
        "links": [
          "<a href=\"docs/AllRequirements/Docs/Planning/DocReq.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Документація Вимог</strong></a>: Що ми будуємо (функціональні та нефункціональні вимоги).",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocDevIn.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Посібник з Розробки</strong></a>: Як ми пишемо код (структура, стандарти, інструменти, процес CI/CD).",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocTech.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Технічна Документація</strong></a>: Загальний огляд архітектури та стеку.",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocSpec.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Специфікація API</strong></a>: Як взаємодіють компоненти (опис GraphQL API).",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocInt.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Документація Інтеграцій</strong></a>: Як ми використовуємо зовнішні сервіси (Neon, R2, Firebase, Stripe тощо) як <strong>важелі</strong>.",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocSecurity.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Посібник з Безпеки</strong></a>: Як ми захищаємо АКТИВ та дані (принципи, методи, інструменти, процес).",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocPer.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Посібник з Продуктивності</strong></a>: Як ми робимо систему швидкою (метрики, техніки, інструменти оптимізації).",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocMonLog.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Посібник з Моніторингу та Логування</strong></a>: Як ми бачимо стан системи (метрики, логи, сповіщення).",
          "<a href=\"docs/AllRequirements/Docs/Design/Design/DocUI.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Документація UI</strong></a>: Як виглядає додаток і чому (макети, компоненти, принципи дизайну).",
          "<a href=\"docs/AllRequirements/Docs/Sound/DocSound.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Посібник з Аудіо</strong></a>: Як аудіо використовується для покращення UX.",
          "<a href=\"docs/AllRequirements/Docs/Support/DocSupport.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Посібник з Підтримки та Обслуговування</strong></a>: Як ми підтримуємо систему та користувачів після релізу.",
          "<a href=\"docs/AllRequirements/Docs/Testing/DocSpecError.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Специфікація Помилок</strong></a>: Як ми обробляємо та повідомляємо про помилки.",
          "<a href=\"docs/AllRequirements/Docs/Testing/DocTesting.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Посібник з Тестування</strong></a>: Як ми перевіряємо якість та надійність.",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocMigrationMicro.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>План Міграції Мікросервісів</strong></a>: Наша довгострокова стратегія архітектурної еволюції.",
          "<a href=\"docs/AllRequirements/Docs/Planning/DocReq.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Інструкція з Вимог до MVP</strong></a>: Детальний аналіз вимог до MVP та статус реалізації)."
        ]
      },
      "contribution": {
        "title": "Внесок",
        "content": "Ми вітаємо внески у створення цього цифрового АКТИВУ! Якщо у вас є ідеї, пропозиції або ви хочете допомогти з кодом, будь ласка, зверніться до <a href=\"CONTRIBUTING.md\" target=\"_blank\" rel=\"noopener noreferrer\">Посібника з Внесків</a> (якщо доступний)."
      }
    },
    "design": {
      "title": "Документація Дизайна BrainMessenger",
      "subtitle": "Система Качества и Ценности",
      "section1": {
        "title": "1. Введение: Дизайн как Фундамент Ценности",
        "name": "BrainMessenger Design System",
        "description": "Эта дизайн-система определяет визуальные и функциональные стандарты для интерфейса BrainMessenger. Наша цель — создать интерфейс, который не просто выглядит хорошо, но и является <strong>интуитивно понятным, эффективным и доступным</strong> (Принцип 2: Создание Ценности), опираясь на принципы <strong>качества > количества</strong> (Принцип 3) и <strong>прагматизма</strong> (Принцип 12) в выборе решений.",
        "goal": "Обеспечить <strong>единообразие, надежность и позитивный пользовательский опыт</strong> на всех платформах (Windows, Android, веб), делая BrainMessenger <strong>полезным АКТИВОМ</strong> (Принцип 10) для пользователей.",
        "principles_title": "Принципы, которыми руководствуется дизайн:",
        "principles": [
          "<strong>Создание Ценности (Принцип 2):</strong> Дизайн должен быть функциональным и решать задачи пользователя максимально удобно и эффективно.",
          "<strong>Качество > Количество (Принцип 3):</strong> Фокус на отточенности ключевых элементов, а не на множестве непродуманных деталей. Дизайн должен быть <strong>надежным</strong> и <strong>продуманным</strong>.",
          "<strong>Прагматизм и Реализм (Принцип 12):</strong> Выбор дизайнерских решений, реализуемых с учетом технических ограничений (например, оптимизация анимаций).",
          "<strong>Целостность (Принцип 7):</strong> Визуальная и функциональная целостность на всех платформах.",
          "<strong>Здоровье как Фундамент (Принцип 5):</strong> Внимание к доступности (WCAG), чтобы дизайн не создавал излишней нагрузки (зрительной, когнитивной) на пользователя."
        ]
      },
      "section2": {
        "title": "2. Цветовая палитра: Визуальный язык BrainMessenger",
        "intro": "Цвета разделены для Light и Dark режимов, поддерживая переключение темы (функция \"Night Mode\"). Все цвета заданы в HEX.",
        "light_mode_title": "2.1. Light Mode",
        "light_mode_table": [
          ["Категория", "Цвет (HEX)", "Назначение"],
          ["<strong>Primary Gradient</strong>", "`#A7F43A` → `#00C853`", "Основной градиент для акцентных элементов (кнопки \"Get Started\", иконки)"],
          ["<strong>Accent</strong>", "`#FF6347`", "Акцентные элементы (ошибки, важные сообщения)"],
          ["<strong>Secondary", "`#00BFFF`", "Второстепенные кнопки, ссылки"],
          ["<strong>Success</strong>", "`#96C93D`", "Подтверждение, успешные действия"],
          ["<strong>Background</strong>", "`#1A1A1A`", "Основной фон"],
          ["<strong>Surface</strong>", "`#333333`", "Карточки, панели, фоны сообщений"],
          ["<strong>Text Primary</strong>", "`#FFFFFF`", "Основной текст"],
          ["<strong>Text Secondary", "`#D9E8D9`", "Вторичный текст, подсказки"],
          ["<strong>Disabled</strong>", "`#4D4D4D`", "Неактивные элементы"],
          ["<strong>Border</strong>", "`#B0B0B0`", "Границы, разделители"]
        ],
        "premium_colors_title": "2.3. Цвета Премиум-Функций (Визуальное выделение Ценности)",
        "premium_colors": [
          "<strong>Premium Accent:</strong> `#FFD600` (Золотой)",
          "<strong>Premium Secondary:</strong> `#2196F3` (Синий)",
          "Используются для визуального выделения премиум-функций (например, в анимациях нейронных связей, специальных элементах UI), подчеркивая их <strong>дополнительную ценность</strong> (Принцип 2, 10)."
        ],
        "color_application_title": "2.4. Применение Цветов (Примеры)",
        "color_application": [
          {
            "title": "Welcome Screen (со скриншота):",
            "items": [
              "Фон: `#1A1A1A` (Dark Mode).",
              "Кнопка \"Get Started\": Градиент `#F2F047` → `#1ED94F`.",
              "Иконка чата: `#F2F047` (обводка) с белым символом внутри.",
            "Текст: `#FFFFFF` (Welcome to Brain Messenger), `#D9E8D9` (подсказка)."
            ]
          },
          {
            "title": "Переключение темы:",
            "items": [
              "Реализовано через глобальный флаг `themeMode` (`Light`/`Dark`).",
              "Пример в React Native:\n```jsx\nimport { useColorScheme } from 'react-native';\nconst themeMode = useColorScheme() === 'dark' ? 'Dark' : 'Light';\nconst backgroundColor = themeMode === 'Dark' ? '#1A1A1A' : '#FFFFFF'; // Пример выбора фона\n```"
            ]
          }
        ],
        "usage_recommendations_title": "2.5. Рекомендации по Использованию Цветов",
        "usage_recommendations": [
          "<strong>Градиенты:</strong> Используйте `#A7F43A` → `#00C853` или `#F2F047` → `#1ED94F` (в зависимости от темы) для ключевых действий и акцентных элементов, привлекающих внимание к <strong>ценности</strong> (Принцип 2).",
          "<strong>Темная тема:</strong> Используйте `#1A1A1A` или `#212121` как основной фон для снижения нагрузки на глаза (связь с Принципом 5: Здоров'я).",
          "<strong>Контраст:</strong> Всегда проверяйте контрастность текста и элементов для обеспечения <strong>доступности</strong> (WCAG 2.1 AA) и соответствия Принципу 7 (Целостность). Используйте инструменты вроде WebAIM Contrast Checker."
        ]
      },
      "section3": {
        "title": "3. Типографика: Читабельность как Основа Эффективности",
        "intro": "Выбор шрифта и его применение базируются на обеспечении максимальной читабельности и доступности, что является критически важным для эффективного усвоения информации и снижения когнитивной нагрузки (связь с Принципом 5: Здоров'я и Принципом 2: Ценность).",
        "primary_font_title": "3.1. Основной шрифт",
        "primary_font": [
          "<strong>Семейство:</strong> Roboto (Google Fonts)",
          "<strong>Запасной:</strong> Sans-serif",
          "<strong>Причина:</strong> Высокая читабельность на разных размерах экрана, широкая поддержка символов (мультиязычность), открытая лицензия и доступность."
        ],
        "sizes_styles_title": "3.2. Размеры и стили (Шкала для Иерархии)",
        "sizes_styles_table": [
          ["Уровень", "Размер", "Начертание", "Использование"],
          ["H1 (Заголовок)", "24px", "Bold", "Основные заголовки экранов (например, \"Чаты\")"],
          ["H2 (Подзаголовок)", "18px", "Medium", "Второстепенные заголовки, названия групп"],
          ["Body", "16px", "Regular", "Основной текст сообщений, список чатов"],
          ["Caption", "14px", "Regular", "Подписи под фото, время сообщений, дрібний текст"],
          ["Button", "16px", "Medium", "Текст кнопок дій"]
        ],
        "notes_title": "Примітки:",
        "notes": [
          "<strong>Висота рядка (Line Height):</strong> Мінімум 1.5 для основного тексту для покращення читабельності.",
          "<strong>Кастомизация (Принцип 2):</strong> Пользователь может выбрать альтернативный шрифт в настройках (например, Open Sans) для адаптации под свои предпочтения.",
          "<strong>Доступность:</strong> Соблюдение контраста и минимального размера шрифта для соответствия WCAG."
        ]
      },
      "section4": {
        "title": "4. Анімації: Оптимізація та Сенс (Принцип 12: Прагматизм)",
        "intro": "Анімації в BrainMessenger використовуються для покращення користувацького досвіду, надання візуального зворотного зв'язку та надання інтерфейсу жвавості. Однак вони мають бути <strong>прагматичними, оптимізованими</strong> (<2 ГБ RAM), і <strong>не створювати зайвого навантаження</strong> (зв'язок з Принципом 5: Здоров'я).",
        "principles_title": "4.1. Принципи Анімацій",
        "principles": [
          "<strong>Смысл:</strong> Каждая анимация должна иметь четкую цель – объяснить переход, привлечь внимание к важному, подтвердить действие.",
          "<strong>Плавность:</strong> Использование `ease-in-out` или `ease-out` для натурального движения.",
          "<strong>Оптимизация:</strong> Анимации не должны замедлять интерфейс или споживать много ресурсов. Тривалість підібрана для балансу между плавностью и скоростью.",
          "<strong>Доступность:</strong> Избегание слишком быстрых или мигающих анимаций, которые могут вызвать дискомфорт или приступы у чувствительных пользователей."
        ],
        "list_title": "4.2. Список Анімацій (Примеры)",
        "list_table": [
          ["Название", "Описание", "Триггер", "Параметры", "Связь с Принципами", "Кольоры (Light/Dark)"],
          ["Переключение слайдов", "Сдвиг слайдов (Welcome Screen)", "Свайп/клик по стрелке", "0.3 сек, slide left/right", "P2 (Онбординг)", "#96C93D / #96C93D"],
          ["Открытие чата", "Чат появляется снизу вверх", "Клик по чату в списке", "0.3 сек, ease-in-out", "P2 (Навигация)", "#00BFFF / #00BFFF"],
          ["Нажатие кнопки", "Визуальный фидбек при клике (уменьшение)", "Клик по кнопке", "0.2 сек, scale", "P2 (Фидбек)", "Градиент #F2F047→#1ED94F"],
          ["Отправка сообщения", "Сообщение появляется с плавным появлением", "Клик \"Отправить\"", "0.3 сек, fade-in", "P2 (Фидбек)", "#96C93D / #96C93D"],
          ["Переход между экранами", "Сдвиг экрана вправо/влево (базовая навигация)", "Навигация", "0.3 сек, slide", "P2 (Навигация)", "#B0B0B0 / #4D4D4D"],
          ["Анимация иконок (Morph)", "Преобразование иконки (например, mute → unmute)", "Клик (переключение состояния)", "0.4 сек, morph", "P2 (Состояние)", "#FF6347 / #FF6347"],
          ["Волны при нажатии (Ripple)", "Радиальные волны от точки нажатия (фидбек)", "Клик по кнопке/элементу", "0.3 сек, ripple", "P2 (Фидбек)", "#F2F047 / #F2F047"],
          ["Глитч-эффект (Premium)", "Искажение текста для премиум (визуализация)", "Активация подписки", "0.2 сек, glitch", "P2, P10 (Выделение)", "#FF6347 / #FF6347"],
          ["Нейронные связи (Premium)", "Пульсирующие линии (визуализация Актива)", "Премиум-экран", "0.5 сек, pulse", "P2, P10 (Выделение)", "#96C93D / #96C93D"]
        ],
        "implementation_examples_title": "4.3. Примеры Реализации (Фрагменты кода)",
        "css_ripple_title": "CSS для Ripple-эффекта:",
        "css_ripple_code": ".ripple {\\n  background: linear-gradient(45deg, #F2F047, #1ED94F); /* Або інші кольори/градієнт */\\n  border-radius: 50%;\\n  animation: ripple 0.3s ease-out;\\n}\\n@keyframes ripple {\\n  to { transform: scale(2); opacity: 0; }\\n}",
        "rn_icon_title": "React Native для анімованої іконки:",
        "rn_icon_code": "import Animated from 'react-native-reanimated'; // Пример библиотеки\\nimport Icon from 'react-native-vector-icons/MaterialIcons'; // Пример библиотеки\\n\\nconst color = themeMode === 'Dark' ? '#FFFFFF' : '#333333';\\n// Створення анімованого компонента Icon\\nconst AnimatedIcon = Animated.createAnimatedComponent(Icon);\\n\\n// Пример использования с анимацией scale (припускаючи, что 'scale' - это Animated.Value)\\n<AnimatedIcon name=\\\"volume-up\\\" color={color} style={{ transform: [{ scale: scale }] }} />"
      },
      "section5": {
        "title": "5. Вирівнювання та Сітка: Структура та Порядок (Принцип 9: Система)",
        "intro": "Використання послідовної системи вирівнювання та модульної сітки — это основа для создания <strong>системного, легко подтримуваемого и визуально гармоничного</strong> интерфейса (Принцип 9: Система).",
        "base_grid": "<strong>Базовая Сітка:</strong> 8px (базовый шаг для определения размеров элементов, отступов, интервалов). Все значения должны быть кратны 8 (или 4 для очень мелких элементов).",
        "alignment_title": "<strong>Вирівнювання:</strong>",
        "alignment": [
          "Используется принцип <strong>визуальной иерархии</strong>: более важные элементы располагаются выше или визуально доминируют.",
          "<strong>Вертикальный поток:</strong> Контент на экранах организуется сверху вниз: Заголовок → Поле ввода → Кнопка действия.",
          "<strong>Горизонтальное выравнивание:</strong> Элементы в контейнерах выравниваются по левому краю (для LTR) или правому краю (для RTL), если нет необходимости в центрировании (например, заголовки в шапке).",
          "<strong>Отступы (Padding/Margin):</strong> Используются значения из шкалы, кратной 8px (8, 16, 24, 32, 40, 48 px и т.д.) для создания четких интервалов между элементами и группами элементов."
        ],
        "adaptability_title": "<strong>Адаптивність та Респонсивність:</strong>",
        "adaptability": [
          "Дизайн адаптируется под различные размеры экрана для обеспечения <strong>ценности</strong> (Принцип 2) на любом устройстве.",
          "<strong>Мобільні пристрої:</strong> 320px–767px (Обычно одноколоночный макет).",
          "<strong>Планшеты:</strong> 768px–1023px (Возможно, двухколоночный макет, боковые панели).",
          "<strong>Десктоп:</strong> 1024px+ (Широкий макет, многоколоночный дизайн, боковые панели)."
        ]
      },
      "section6": {
        "title": "6. Принципи Доступності (WCAG 2.1 AA): Дизайн для Всіх (Принцип 5: Здоров'я, Принцип 7: Цілісність)",
        "intro": "<strong>Доступність — это не опция, а фундаментальное требование</strong> (схоже с Принципом 5: Здоров'я как Фундамент) для создания <strong>целостного</strong> (Принцип 7) и <strong>ценного</strong> (Принцип 2) продукта, которым могут пользоваться все, независимо от их способностей или используемых технологий. Мы стремимся соответствовать уровню WCAG 2.1 AA.",
        "principles": [
          "<strong>Контрастность Кольорів:</strong> Текстовые элементы должны иметь минимальный контраст 4.5:1 (для обычного текста) и 3:1 (для крупного текста или иконок) по отношению к фону. Это проверяется для обеих тем (Light/Dark).",
          "<strong>Навігація з Клавіатури:</strong> Все интерактивные элементы (кнопки, посилання, поля ввода) должны быть доступны для навигации с помощью клавиатуры (Tab, Shift+Tab) и активации (Enter, Space).",
          "<strong>Підтримка Екранних Читалок (Screen Readers):</strong> Использование семантической разметки (HTML) и ARIA-атрибутов для предоставления контекста и информации пользователям экранных читалок (например, описания для иконок, состояния элементов).",
          "<strong>Візуальний Индикатор Фокуса:</strong> Для пользователей клавиатуры должен быть четкий и видимый индикатор текущего сфокусированного элемента (например, синяя обводка `#007BFF`).",
          "<strong>Обробка Помилок:</strong> Сообщения об ошибках должны быть четкими, понятными и легко определяемыми пользователями, включая пользователей экранных читалок.",
          "<strong>Підтримка RTL (Справа Налево):</strong> Дизайн адаптируется для языков с направлением письма справа налево (например, арабский), включая зеркальное отображение макета, иконок и текста (см. DocLocIn.md)."
        ]
      },
      "section7": {
        "title": "7. Примітки та Рекомендації",
        "notes": [
          "<strong>Кастомизация Пользователем:</strong> Помните, что некоторые аспекты дизайна (цвета чатов, шрифты) пользователь может изменять в настройках. Дизайн системы должен учитывать эту гибкость.",
          "<strong>Тестирование на Реальных Устройствах:</strong> Все компоненты дизайна необходимо тестировать на разнообразных устройствах, с различными разрешениями экрана и в разных условиях освещения, чтобы убедиться в их эффективности и доступности.",
          "<strong>Живая Документация:</strong> Эта дизайн-система — живой документ. Она будет дополняться новыми компонентами, шаблонами и рекомендациями по мере развития продукта, отражая принципы <strong>непрерывного совершенствования</strong> (Принцип 1) и <strong>системного подхода</strong> (Принцип 9).",
          "<strong>Дизайн как часть Процесса Кайдзен:</strong> Дизайн-решения анализируются и улучшаются на основе обратной связи и реального использования, интегрируясь в общий процесс Кайдзен (Принцип 9, 14)."
        ]
      }
    },
    "localizationGuide": {
      "title": "Руководство по Локализации BrainMessenger",
      "subtitle": "Доступность и Масштабирование",
      "section1": {
        "title": "1. Введение: Расширение Ценности через Доступность",
        "name": "BrainMessenger Design System",
        "description": "Это руководство описывает процесс локализации BrainMessenger — ключевой шаг для обеспечения доступности и ценности (Принцип 2) продукта для широкой аудитории по всему миру. Мы рассматриваем локализацию не просто как перевод строк, а как систематический процесс (Принцип 9) адаптации интерфейса и контента, который позволит нам масштабировать наше влияние (Принцип 2, 8).",
        "goal": "Сделать BrainMessenger понятным и удобным для пользователей из разных культур, начиная с базового набора языков и создавая надежную систему (Принцип 9) для легкого добавления новых в будущем.",
        "current_status": "Базовая поддержка английского языка (MVP). Идет планирование и подготовка к добавлению новых языков в рамках текущих этапов разработки (см. Дорожную карту).",
        "principles_title": "Принципы, которыми руководствуется локализация:",
        "principles": [
          "Создание Ценности (Принцип 2): Локализация напрямую повышает ценность продукта для неанглоязычных пользователей.",
          "Система и Оптимизация (Принцип 9): Процесс локализации строится как четкая, повторяемая система для эффективности.",
          "Прагматизм и Реализм (Принцип 12): Выбор начального набора языков основывается на потенциальном охвате и ресурсах.",
          "Внешняя Экспертиза и Обратная Связь (Принцип 14): Привлечение профессиональных переводчиков и сбор обратной связи от пользователей на разных языках."
        ]
      },
      "section2": {
        "title": "2. Цели Локализации",
        "goals": [
          "Обеспечить поддержку минимум 5 ключевых языков (Английский, Испанский, Французский, Русский, Арабский) для старта MVP — (Требование NFR-11, соответствующее Принципу 12: Прагматизм).",
          "Реализовать адаптацию пользовательского интерфейса для языков с направлением письма справа налево (RTL), таких как арабский (Принцип 2: Доступность).",
          "Поддерживать единообразие терминологии и стиля во всех переводах, используя централизованные инструменты (Принцип 9: Система).",
          "Создать эффективный и простой процесс добавления новых языков по мере роста базы пользователей и поступления запросов (Принцип 9: Масштабирование, Принцип 12: Прагматизм, Принцип 14: Обратная связь)."
        ]
      },
      "section3": {
        "title": "3. Инструменты и Технологии: Надежный Фундамент (Принцип 8, 9)",
        "intro": "Выбор инструментов основан на прагматизме (Принцип 12), надежности и поддержке системного подхода (Принцип 9).",
        "tools_table": [
          ["Инструмент", "Назначение", "Установка/Конфигурация"],
          ["i18next", "Основная библиотека для управления переводами в Frontend (React Native). Поддерживает интерполяцию, контексты.", "npm install i18next react-i18next"],
          ["react-intl", "Библиотека для локализованного форматирования дат, чисел, валют в Frontend.", "npm install react-intl"],
          ["Transifex", "Профессиональная платформа для управления переводами, привлечения переводчиков и обеспечения качества перевода.", "Регистрация на transifex.com"],
          ["rtlcss", "Утилита для автоматической трансформации CSS-стилей для поддержки RTL-языков.", "npm install -g rtlcss (глобально) или npm install rtlcss --save-dev"],
          ["JSON файлы", "Формат хранения переводов.", "Стандартный."]
        ]
      },
      "section4": {
        "title": "4. Структура Файлов Переводов: Порядок в Системе (Принцип 9)",
        "intro": "Переводы организованы в четкой файловой структуре для удобства управления (Принцип 9: Система).",
        "location_title": "4.1. Расположение",
        "location_content": "Файлы переводов хранятся в директории locales внутри frontend/src:\\n\\nfrontend/\\n├── src/\\n│ ├── locales/\\n│ │ ├── en.json # Английский (базовый)\\n│ │ ├── es.json # Испанский\\n│ │ ├── fr.json # Французский\\n│ │ ├── ru.json # Русский\\n│ │ ├── ar.json # Арабский (пример RTL)\\n│ └── index.ts # Конфигурация i18next",
        "format_title": "4.2. Формат JSON: Контекст и Гибкость",
        "format_content": "Ключи: Используется camelCase. Ключи должны быть описательными и отражать контекст использования строки (например, sendButton вместо просто send).\\n\\nЗначения: Содержат переводимый текст. Поддерживается интерполяция для вставки динамических данных (например, имена пользователей).",
        "format_example": "Пример en.json:\\n\\n```json\\n{\\n  \\\"welcomeTitle\\\": \\\"Welcome to BrainMessenger!\\\",\\n  \\\"sendButton\\\": \\\"Send\\\",\\n  \\\"errors\\\": {\\n    \\\"unauthorized\\\": \\\"Please log in again to continue.\\\",\\n    \\\"notFound\\\": \\\"The requested item could not be found.\\\"\\n  },\\n  \\\"chat\\\": {\\n    \\\"newMessageNotification\\\": \\\"New message from {{name}}\\\",\\n    \\\"unreadCount\\\": \\\"{{count}} unread messages\\\"\\n  },\\n  \\\"settings\\\": {\\n    \\\"language\\\": \\\"Language\\\",\\n    \\\"theme\\\": \\\"Theme\\\"\\n  }\\n}\\n```",
        "rtl_flag_title": "4.3. RTL-флаг: Адаптация Интерфейса",
        "rtl_flag_content": "Для языков с направлением справа налево в начало соответствующего JSON-файла добавляется метаданные для индикации:",
        "rtl_flag_example": "```json\\n{\\n  \\\"rtl\\\": true,\\n  \\\"welcomeTitle\\\": \\\"مرحبًا بك في BrainMessenger!\\\"\\n  // ... остальные переводы\\n}\\n```\\n\\nЭтот флаг используется Frontend-приложением для соответствующей адаптации стилей и макета."
      },
      "section5": {
        "title": "5. Настройка Локализации: Интеграция в Систему (Принцип 9)",
        "intro": "Локализация интегрируется как в Frontend (для отображения переведенного UI), так и в Backend (для возврата локализованных ошибок или уведомлений).",
        "frontend_title": "5.1. Frontend (React Native): Использование i18next",
        "frontend_init_title": "Инициализация i18next:",
        "frontend_init_code": "В главном файле приложения или файла конфигурации (frontend/src/index.ts или подобном):\\n\\n```jsx\\nimport i18n from 'i18next'\\nimport { initReactI18next } from 'react-i18next'\\n\\n// Импорт всех файлов локалей\\nimport en from './locales/en.json'\\nimport es from './locales/es.json'\\nimport fr from './locales/fr.json'\\nimport ru from './locales/ru.json'\\nimport ar from './locales/ar.json'\\n\\n// Определение ресурсов\\nconst resources = {\\n  en: { translation: en },\\n  es: { translation: es },\\n  fr: { translation: fr },\\n  ru: { translation: ru },\\n  ar: { translation: ar },\\n};\\n\\ni18n\\n  .use(initReactI18next) // Подключение react-i18next\\n  .init({\\n    resources,\\n    lng: 'en', // Язык по умолчанию при первом запуске (может определяться по системным настройкам или выбору пользователя)\\n    fallbackLng: 'en', // Резервный язык, если текущий перевод отсутствует\\n    interpolation: {\\n      escapeValue: false // Позволяет использовать HTML теги в переводах (осторожно!)\\n    }\\n  });\\n\\nexport default i18n;\\n```",
        "frontend_usage_title": "Использование перевода в компонентах:",
        "frontend_usage_code": "Используйте хук useTranslation для доступа к функции t и объекту i18n.\\n\\n```jsx\\nimport { useTranslation } from 'react-i18next';\\nimport { Text, Button, View } from 'react-native';\\n\\nconst WelcomeScreen = () => {\\n  const { t, i18n } = useTranslation(); // Получаем функцию t и объект i18n\\n\\n  return (\\n    <View>\\n      {/* Использование простого перевода */}\\n      <Text>{t('welcomeTitle')}</Text>\\n      \\n      {/* Использование перевода с интерполяцией */}\\n      {/* Предполагается, что где-то есть состояние unreadCount */}\\n      <Text>{t('chat.unreadCount', { count: 5 })}</Text> \\n\\n      {/* Использование перевода для текста кнопки */}\\n      <Button title={t('sendButton')} onPress={sendMessage} />\\n      \\n      {/* Пример смены языка */}\\n      <Button title={t('settings.language')} onPress={() => i18n.changeLanguage('ar')} />\\n    </View>\\n  );\\n};\\n```",
        "frontend_change_title": "Смена языка:",
        "frontend_change_content": "Язык меняется вызовом i18n.changeLanguage('код_языка'). Обычно это делается в настройках пользователя.",
        "backend_title": "5.2. Backend (NestJS): Локализация Ошибок и Уведомлений",
        "backend_intro": "Backend может возвращать локализованные сообщения об ошибках или уведомления, опираясь на язык, переданный Frontend (например, в заголовке Accept-Language или настройках пользователя).",
        "backend_code": "Использование локализованных сообщений при выбрасывании ошибок:\\n\\n```typescript\\nimport { HttpException, HttpStatus }n from '@nestjs/common';\\nimport { t } from 'i18next'; // Предполагается, что i18next инициализирован и в Backend\\n\\n// В сервисе или контроллере\\nif (!user) {\\n  // Определяем язык пользователя (например, из request.headers['accept-language'])\\n  const userLang = determineUserLanguage(request); \\n  throw new HttpException(t('errors.unauthorized', { lng: userLang }), HttpStatus.UNAUTHORIZED);\\n}\\n```",
        "backend_note": "Локаль пользователя определяется из заголовка Accept-Language (стандартный подход) или сохраняется в профиле пользователя в базе данных после его выбора в настройках приложения.",
        "rtl_adaptation_title": "5.3. RTL-адаптация (Справа Налево): Зеркальное Отображение Системы",
        "rtl_adaptation_intro": "Для языков с RTL (арабский, иврит и др.) необходимо зеркально отобразить макет и некоторые элементы интерфейса.",
        "rtl_css_title": "Стили (CSS/CSS-in-JS):",
        "rtl_css_code": "Используйте rtlcss в процессе сборки или условные стили в коде. rtlcss автоматически преобразует свойства вроде margin-left, padding-right, text-align: left и т.п. в их RTL-эквиваленты (margin-right, padding-left, text-align: right).\\n\\n```css\\n/* Исходный CSS для LTR */\\n.message-bubble {\\n  margin-left: 10px;\\n  text-align: left;\\n}\\n/* После обработки rtlcss для RTL */\\n.message-bubble {\\n  margin-right: 10px;\\n  text-align: right;\\n}\\n```",
        "rtl_rn_title": "React Native:",
        "rtl_rn_code": "React-Native имеет встроенную поддержку RTL через I18nManager.\\n\\n```jsx\\nimport { I18nManager } from 'react-native';\\nimport i18n from './index'; // Ваш файл инициализации i18next\\n\\n// В главном файле приложения, перед рендером\\nconst isRTL = i18n.language === 'ar' || i18n.language === 'he'; // Проверяем, является ли текущий язык RTL\\n\\n// ForceRTL может потребовать перезагрузки приложения для полной силы\\nif (isRTL !== I18nManager.isRTL) {\\n  I18nManager.forceRTL(isRTL);\\n  // Optional: Restart the app to apply RTL layout fully\\n  // RNRestart.Restart(); \\n}\\n\\n// Некоторые стили могут требовать ручной адаптации, если auto-conversion недостаточно\\nconst containerStyle = {\\n  flexDirection: isRTL ? 'row-reverse' : 'row',\\n  textAlign: isRTL ? 'right' : 'left',\\n};\\n```",
        "rtl_icons_title": "Иконки:",
        "rtl_icons_content": "Некоторые иконки (например, стрелки \"назад\", \"далее\") должны быть зеркально отображены для RTL. Это можно делать условно в коде или использовать RTL-ready наборы иконок."
      },
      "section6": {
        "title": "6. Процесс Добавления Нового Языка: Масштабируемая Система (Принцип 9)",
        "intro": "Процесс добавления нового языка построен как четкая, повторяемая последовательность действий для обеспечения эффективности (Принцип 9).",
        "file_title": "Создание базового файла перевода:",
        "file_content": "Скопируйте актуальный en.json (или другой наиболее полный файл) в frontend/src/locales/<code>.json, где <code> — двухбуквенный код нового языка (например, de.json для немецкого).\\nДобавьте rtl: true в начало файла, если новый язык RTL.",
        "transifex_title": "Загрузка на платформу переводов (Transifex):",
        "transifex_content": "Загрузите новый файл <code>.json в проект BrainMessenger на Transifex. Система автоматически определит, какие строки нуждаются в переводе.",
        "process_title": "Организация процесса перевода:",
        "process_content": "Назначьте переводчиков (профессионалов или проверенных участников сообщества, Принцип 14) для нового языка в Transifex.\\nОтвечайте на их вопросы по контексту строк.\\nКонтролируйте прогресс перевода в Transifex.",
        "export_title": "Экспорт и Интеграция перевода:",
        "export_content": "После завершения перевода экспортируйте готовый файл <code>.json из Transifex.\\nПоместите его обратно в директорию frontend/src/locales/.\\nИмпортируйте новый ресурс в файле инициализации i18next (frontend/src/index.ts) и добавьте его в объект resources.",
        "ui_title": "Добавление опции выбора языка в UI:",
        "ui_content": "Добавьте новый язык в список доступных языков в разделе \"Настройки\" > \"Язык\".",
        "testing_title": "Тестирование:",
        "testing_intro": "Критически важный шаг (Принцип 3: Качество). Переключите язык в настройках приложения.",
        "testing_scenarios": [
          "Корректность перевода всех строк в UI.",
          "Отсутствие обрезки текста (некоторые языки длиннее английского).",
          "Корректное отображение UI для RTL-языков (зеркальность, выравнивание).",
          "Интерполяция и Форматирование: Проверьте экраны, где используются динамические данные (имена, счетчики, даты, числа), убедитесь, что они форматируются правильно для текущей локали.",
          "Локализованные ошибки: Инициируйте различные ошибки (неправильный логин, отсутствие элемента), проверьте, что сообщения об ошибках приходят на выбранном языке."
        ]
      },
      "section7": {
        "title": "7. Поддерживаемые Языки (Начальный Список и План)",
        "intro": "Начальный список языков, выбранный по прагматическим соображениям (Принцип 12) и потенциальному охвату.",
        "languages_table": [
          ["Код", "Язык", "Направление", "Статус", "План (Q 2025)"],
          ["en", "Английский", "LTR", "Реализован (Базовый)", "-"],
          ["es", "Испанский", "LTR", "В плане (Q3)", "Q3"],
          ["fr", "Франглийский", "LTR", "В плане (Q3)", "Q3"],
          ["ru", "Русский", "LTR", "В плане (Q3)", "Q3"],
          ["ar", "Арабский", "RTL", "В плане (Q3, требуется RTL)", "Q3"]
        ],
        "expansion_note": "Расширение списка: Новые языки будут добавляться на основе обратной связи (Принцип 14) и анализа потенциальной ценности (Принцип 2) для роста аудитории (например, если >10% запросов о поддержке нового языка)."
      },
      "section8": {
        "title": "8. Рекомендации: Лучшие Практики Локализации",
        "dev_title": "8.1. Для Разработчиков (Пишем Код, Готовый к Миру)",
        "dev_points": [
          "Не хардкодьте строки! Все строки, которые видит пользователь, должны быть вынесены в файлы локализации и использоваться через функцию t('ключ') (Принцип 9: Система).",
          "Используйте интерполяцию для строк с переменными данными (t('chat.newMessageNotification', { name: user.name })), а не конкатенацию строк в коде.",
          "Учитывайте плюрализацию (формы единственного/множественного числа) при работе со счетчиками ({{count}} unread messages). i18next и react-intl поддерживают это.",
          "Используйте react-intl для всех операций с датами, числами, валютами, чтобы их формат был корректным для каждой локали (Принцип 3: Качество, Принцип 2: Ценность).",
          "Тестируйте UI с длинными переводами (например, немецкий, который часто длиннее английского) и RTL-языками, чтобы убедиться, что макет не ломается и текст не обрезается (Принцип 3: Качество)."
        ],
        "design_title": "8.2. Для Дизайнеров (Рисуем Макеты, Гибкие к Языкам)",
        "design_points": [
          "Учитывайте, что текст на других языках может быть на 30% (и более) длиннее английского. Оставляйте достаточно пространства в компонентах.",
          "Проектируйте макеты с учетом зеркального отображения для RTL. Иконки направлений, расположение текста и элементов должны меняться (Принцип 2: Доступность)."
        ],
        "translator_title": "8.3. Для Переводчиков (Создаем Понятный Контент)",
        "translator_points": [
          "Сохраняйте контекст. Одно и то же английское слово может переводиться по-разному в зависимости от того, где оно используется (например, \"Send\" для сообщения или для заявки). Платформы вроде Transifex помогают добавлять контекстные комментарии.",
          "Придерживайтесь последовательной терминологии, используйте глоссарий, если он есть.",
          "Сохраняйте тон приложения (дружелюбный, но профессиональный, особенно в системных сообщениях и ошибках).",
          "Используйте возможности интерполяции и плюрализации в файлах перевода."
        ]
      },
      "section9": {
        "title": "9. Форматирование (Даты, Числа, Валюты): Детали, Создающие Качество (Принцип 3)",
        "intro": "Корректное отображение локализованных данных критически важно для качества (Принцип 3) и удобства (Принцип 2).",
        "dates_title": "Даты и Время:",
        "dates_code": "```jsx\\nimport { FormattedDate, FormattedTime } from 'react-intl';\\n\\n// Отобразит дату в формате, соответствующем текущей локали\\n<FormattedDate value={new Date()} /> // Например, \\\"3/14/2025\\\" (en-US) или \\\"14.3.2025\\\" (de-DE)\\n<FormattedDate value={new Date()} weekday=\\\"long\\\" year=\\\"numeric\\\" month=\\\"long\\\" day=\\\"numeric\\\" /> // \\\"Friday, March 14, 2025\\\"\\n\\n// Отобразит время\\n<FormattedTime value={new Date()} /> // Например, \\\"3:00:00 PM\\\" (en-US) или \\\"15:00:00\\\" (de-DE)\\n```",
        "numbers_title": "Числа и Валюты:",
        "numbers_code": "```jsx\\nimport { FormattedNumber, FormattedCurrency } from 'react-intl';\\n\\n// Отобразит число с локальным разделителем тысяч и десятичным знаком\\n<FormattedNumber value={1234.56} /> // \\\"1,234.56\\\" (en-US) или \\\"1.234,56\\\" (de-DE)\\n\\n// Отобразит число как процент\\n<FormattedNumber value={0.75} style=\\\"percent\\\" /> // \\\"75%\\\"\\n\\n// Отобразит число как валюту (требует кода валюты)\\n<FormattedCurrency value={123.45} currency=\\\"USD\\\" /> // \\\"$123.45\\\" (en-US)\\n```\\n\\nДля работы с react-intl необходимо обернуть ваше приложение в IntlProvider и загрузить соответствующие данные локали (react-intl/locale-data)."
      },
      "section10": {
        "title": "10. Тестирование Локализации: Гарантия Качества (Принцип 3, 9)",
        "intro": "Тестирование — неотъемлемая часть системы обеспечения качества (Принцип 3, 9).",
        "scenarios_title": "Сценарии Тестирования:",
        "scenarios_points": [
          "Переключение языка: Убедитесь, что смена языка в настройках мгновенно (или после перезапуска, если требуется I18nManager) применяет новый перевод и RTL-макет.",
          "Отображение всех строк: Проверьте основные экраны и диалоги, чтобы убедиться, что все видимые пользователю строки переведены.",
          "Длинный текст: Проверьте UI с языками, известными своей длиной (например, немецкий, который часто длиннее английского) и RTL-языками, чтобы убедиться, что текст не обрезается, элементы не накладываются друг на друга.",
          "RTL-интерфейс: Тщательно проверьте UI на арабском (или другом RTL-языке): направление текста, выравнивание элементов, отображение иконок направлений, положение скроллбаров.",
          "Интерполяция и Форматирование: Проверьте экраны, где используются динамические данные (имена, счетчики, даты, числа), убедитесь, что они форматируются правильно для текущей локали.",
          "Локализованные ошибки: Инициируйте различные ошибки (неправильный логин, отсутствие элемента), проверьте, что сообщения об ошибках приходят на выбранном языке."
        ]
      },
      "tools_title": "Инструменты:",
      "tools_points": [
        "Ручное тестирование: Основной метод. Тестирование на реальных устройствах с разными локалями.",
        "Автоматизированные тесты (Cypress/detox): Можно написать тесты, которые проверяют наличие определенных ключей перевода на странице или даже делают скриншоты UI для сравнения LTR/RTL макетов (Принцип 9: Система)."
      ],
      "criteria_title": "Критерии Успеха Тестирования:",
      "criteria_points": [
        "100% пользовательских строк переведены.",
        "Отсутствие обрезки или наложения текста в UI.",
        "Корректное и полное RTL-отображение для соответствующих языков.",
        "Правильное локализованное форматирование дат, чисел, валют."
      ]
    },
    "section11": {
      "title": "11. Примечания",
      "notes": [
        "План: Полная реализация поддержки 5 ключевых языков запланирована на Q3 2025 (см. Дорожную карту), после завершения этапа построения технологического фундамента и начала разработки MVP.",
        "Масштабирование: Система разработана так, чтобы добавление новых языков в будущем было эффективным (Принцип 9). Основные затраты — это сам перевод.",
        "Ограничения: Технические логи, сообщения сервера для отладки не переводятся. Локализация касается только пользовательского интерфейса и сообщений, предназначенных для конечного пользователя."
      ]
    }
  },
  "integrationsGuide": {
    "title": "Документація Інтеграцій BrainMessenger",
    "subtitle": "Построение Надежной Системы с Внешними Рычагами",
    "introduction": {
      "title": "1. Введение: Интеграции как Часть Фундамента Системы",
      "description": "Этот документ описывает, как BrainMessenger интегрируется с ключевыми внешними сервисами. Мы выбираем эти интеграции <strong>прагматично</strong> (Принцип 12), рассматривая их как <strong>рычаги</strong> (принцип Маргулана), которые позволяют нам не изобретать колесо, а использовать <strong>надежные и масштабируемые</strong> (Принцип 8, 9) сторонние решения для ускорения разработки и обеспечения <strong>качества</strong> (Принцип 3) нашего продукта. Эти интеграции являются неотъемлемой частью нашего <strong>технологического фундамента</strong> (Принцип 8).",
      "principlesTitle": "Принципы, которыми руководствуется выбор и настройка интеграций:",
      "principles": [
        "<strong>Система и Оптимизация (Принцип 9):</strong> Интеграции должны быть частью единой, хорошо продуманной системы, где каждый компонент выполняет свою роль эффективно.",
        "<strong>Прагматизм и Реализм (Принцип 12):</strong> Выбор сервисов с учетом текущих потребностей, бюджета (бесплатные/доступные тарифы на старте) и простоты интеграции.",
        "<strong>Долгосрочное Мышление (Принцип 8):</strong> Выбор сервисов, способных масштабироваться вместе с ростом проекта.",
        "<strong>Качество > Количество (Принцип 3):</strong> Фокус на надежности и производительности интеграций, даже если их список на старте небольшой.",
        "<strong>Создание Ценности (Принцип 2):</strong> Каждая интеграция должна добавлять реальную ценность для конечного пользователя (например, надежное хранение файлов, мгновенные уведомления)."
      ]
    },
    "overview": {
      "title": "2. Обзор Ключевых Интеграций: Наши Внешние Компоненты Системы",
      "table": [
        ["Сервис", "Назначение", "Роль в BrainMessenger", "Основные функции", "Связь с Принципами"],
        ["<strong>Neon</strong>", "Управляемый PostgreSQL БД", "Хранение всех <strong>структурированных данных</strong> (пользователи, чаты, сообщения, метаданные файлов). Фундамент данных.", "Хостинг PostgreSQL, масштабирование, доступ через строку подключения.", "P8 (Долгосрочное), P9 (Система), P12 (Прагматизм - бесплатный тариф)."],
        ["<strong>Cloudflare R2</strong>", "Облачное Хранилище (S3-совместимое)", "Хранение всех <strong>неструктурированных данных</strong> (файлы пользователей, аватарки, записи звонков, зашифрованные метаданные). Хранилище Активов.", "Надежное хранение объектов, CDN-доставка, отсутствие платы за исходящий трафик.", "P8 (Долгосрочное), P10 (Активы), P12 (Прагматизм - бесплатный тариф, нет платы за трафик), P3 (Качество - CDN)."],
        ["<strong>Firebase</strong>", "Push-уведомления", "Мгновенная доставка уведомлений пользователям на мобильные устройства.", "Отправка push-уведомлений (FCM).", "P2 (Ценность - информирование), P9 (Система - надежная доставка), P12 (Прагматизм - готовое решение)."],
        ["<strong>Stripe</strong>", "Платежная Система", "Обработка платежей за Premium-подписку. Доступ к платежам как к рычагу создания Ценности/Богатства.", "Прием платежей, управление подписками.", "P2 (Ценность - премиум), P10 (Богатство/Активы), P9 (Система - автоматизация платежей)."],
        ["<strong>Gmail API</strong>", "Сервис отправки email", "Отправка критически важных email (коды подтверждения для регистрации и 2FA).", "Отправка транзакционных email.", "P3 (Качество - надежная доставка email), P9 (Система - часть аутентификации), P5 (Здоровье - безопасность пользователя)."]
      ]
    },
    "neonIntegration": {
      "title": "3. Интеграция с Neon: Фундамент Структурированных Данных",
      "generalInfo": {
        "title": "3.1. Общая Информация",
        "description": "Neon предоставляет управляемый сервис PostgreSQL. Мы используем его как <strong>основное хранилище структурированных данных</strong>, таких как информация о пользователях, чатах, сообщениях и метаданных файлов.",
        "advantages": [
          "<strong>Прагматизм (P12):</strong> Бесплатный тариф на старте (30 ГБ) полностью покрывает начальные потребности.",
          "<strong>Система и Долгосрочное Мышление (P9, P8):</strong> Управляемый сервис снижает операционную нагрузку, автоматическое масштабирование и репликация доступны на платных планах, обеспечивая готовность к росту.",
          "<strong>Качество (P3):</strong> Надежность и производительность PostgreSQL как проверенной СУБД."
        ],
        "role": "Роль: Ядро, к которому обращается Backend для всех CRUD-операций над метаданными."
      },
      "configuration": {
        "title": "3.2. Конфигурация: Подключение к Системе Данных",
        "steps": [
          "1. <strong>Регистрация и Создание Проекта:</strong>",
          "Создайте аккаунт на `https://neon.tech`.",
          "Создайте новый проект (например, `brainmessenger-prod`) в консоли Neon.",
          "2. <strong>Настройка Базы Данных:</strong>",
          "Neon автоматически предоставляет инстанс PostgreSQL.",
          "<strong>Примените схему базы данных:</strong> Используйте Prisma Migrate для инициализации структуры таблиц (см. `database/schema.prisma` и Руководство по разработке).",
          "3. <strong>Переменные Окружения:</strong>",
          "Получите <strong>строку подключения</strong> (Connection Details) из консоли Neon (Settings → Connection Details).",
          "Добавьте в ваш `.env` файл:"
        ],
        "envExample": "```env\\n# Строка подключения к базе данных Neon\\nDATABASE_URL=postgresql://<user>:<password>@<neon-host>/<dbname>?sslmode=require\\n```",
        "note1": "*Примечание:* Используйте `sslmode=require` для безопасного соединения.",
        "backendCode": "4. <strong>Подключение Backend (NestJS + Prisma):</strong>\\nPrisma использует `DATABASE_URL` для подключения. Убедитесь, что Prisma Client сгенерирован (`npx prisma generate`).\\nИспользуйте `PrismaService` (из `nestjs-prisma`) для всех операций с БД.\\n```typescript\\n// backend/src/app.module.ts (или db.module.ts)\\nimport { Module } from '@nestjs/common';\\nimport { PrismaService } from 'nestjs-prisma'; // Убедитесь, что PrismaModule импортирован в app.module\\n\\n@Module({\\n  providers: [PrismaService], // PrismaService доступен для инъекции\\n  exports: [PrismaService],\\n})\\nexport class DbModule {}\\n```"
      },
      "interactionScenarios": {
        "title": "3.3. Методы и Сценарии Взаимодействия: API Данных",
        "description": "Все взаимодействия с Neon происходят через Prisma ORM в Backend, что обеспечивает <strong>типизацию, безопасность и системность</strong> (Принцип 3, 9).",
        "signup": {
          "title": "Сценарий: Регистрация пользователя:",
          "interaction": "<strong>Взаимодействие:</strong> Backend получает данные пользователя → Использует `PrismaService` для создания новой записи в таблице `users`.",
          "code": "<strong>Пример кода (Backend Service):</strong>\\n```typescript\\n// backend/src/auth/auth.service.ts\\nimport { Injectable } from '@nestjs/common';\\nimport { PrismaService } from 'nestjs-prisma';\\nimport { Prisma } from '@prisma/client'; // Импорт типов Prisma\\n\\n@Injectable()\\nexport class AuthService {\\n  constructor(private prisma: PrismaService) {}\\n\\n  async signUp(data: Prisma.UserCreateInput) {\\n    // Пример: пароль должен быть захэширован ДО сохранения\\n    const hashedPassword = await hashPassword(data.password); // Использование утилиты для хэширования\\n    return this.prisma.user.create({\\n      data: {\\n        email: data.email,\\n        name: data.name,\\n        password: hashedPassword, // Сохраняем захэшированный пароль\\n        // ... другие поля по схеме\\n      },\\n    });\\n  }\\n}\\n```",
          "result": "<strong>Результат:</strong> Данные пользователя надежно сохранены в Neon."
        },
        "getChats": {
          "title": "Сценарий: Получение списка чатов пользователя:",
          "interaction": "<strong>Взаимодействие:</strong> Frontend запрашивает чаты через GraphQL API → Backend использует `PrismaService` для выполнения запроса к таблице `chats` (возможно, с фильтрацией по `userId` и `include` для метаданных).",
          "code": "<strong>Пример кода (Backend Service):</strong>\\n```typescript\\n// backend/src/chat/chat.service.ts\\nimport { Injectable } from '@nestjs/common';\\nimport { PrismaService } from 'nestjs-prisma';\\n\\n@Injectable()\\nexport class ChatService {\\n  constructor(private prisma: PrismaService) {}\\n\\n  async getUserChats(userId: string) {\\n    // Используем индексы @@index([userId]) для оптимизации (Принцип 9, Оптимизация)\\n    return this.prisma.chat.findMany({\\n      where: {\\n        users: { // Предполагается связь Many-to-Many с таблицей UserChat\\n          some: {\\n            userId: userId,\\n          },\\n        },\\n      },\\n      select: { // Выбираем только необходимые поля (Принцип 9, Оптимизация)\\n        id: true,\\n        name: true,\\n        type: true,\\n        // ... другие нужные поля\\n      },\\n      orderBy: { // Сортировка по дате последнего сообщения для актуальности (Принцип 2, Ценность)\\n        lastMessageAt: 'desc',\\n      },\\n    });\\n  }\\n}\\n```"
        },
        "saveMessage": {
          "title": "Сценарий: Сохранение сообщения:",
          "interaction": "<strong>Взаимодействие:</strong> Пользователь отправляет сообщение → Frontend отправляет его через GraphQL API → Backend использует `PrismaService` для создания новой записи в таблице `messages`, связывая ее с `chatId` и `userId`.",
          "code": "<strong>Пример кода (Backend Service):</strong>\\n```typescript\\n// backend/src/message/message.service.ts\\nimport { Injectable } from '@nestjs/common';\\nimport { PrismaService } from 'nestjs-prisma';\\nimport { Prisma } from '@prisma/client';\\n\\n@Injectable()\\nexport class MessageService {\\n  constructor(private prisma: PrismaService) {}\\n\\n  async createMessage(data: Prisma.MessageCreateInput) {\\n    // Используем транзакцию, если нужно обновить дату последнего сообщения в чате\\n    return this.prisma.$transaction(async (tx) => {\\n      const message = await tx.message.create({ data });\\n      await tx.chat.update({\\n        where: { id: data.chatId },\\n        data: { lastMessageAt: message.createdAt }, // Обновляем время последнего сообщения\\n      });\\n      return message;\\n    });\\n  }\\n}\\n```"
        }
      },
      "errorHandling": {
        "title": "3.4. Обработка Ошибок Интеграции: Поддержание Качества Системы",
        "description": "Надежная система должна уметь обрабатывать ошибки внешних зависимостей (Принцип 3: Качество).",
        "connectionError": {
          "title": "Connection Error:",
          "cause": "Причина: Невозможно установить соединение с Neon. Неверная строка подключения (`DATABASE_URL`), проблемы с сетью, недоступность сервиса Neon.",
          "solution": "Решение: Проверить переменную окружения `DATABASE_URL`, статус сервиса Neon. Логировать ошибку на Backend (Sentry/Winston)."
        },
        "queryError": {
          "title": "Database Query Error:",
          "cause": "Причина: Ошибка выполнения запроса к БД (например, нарушение уникальности, неверный тип данных). Ошибка в логике Backend, несоответствие схемы БД.",
          "solution": "Решение: Отладить запрос в Backend, проверить логи Prisma. Логировать ошибку."
        },
        "rateLimitError": {
          "title": "Rate Limit Exceeded (на платных тарифах):",
          "cause": "Причина: Превышены лимиты на количество запросов или вычислительные ресурсы в Neon. Высокая нагрузка, неоптимизированные запросы, недостаточный тарифный план.",
          "solution": "Решение: Оптимизировать запросы (см. Руководство по оптимизации), рассмотреть переход на более высокий тарифный план Neon."
        }
      }
    },
    "r2Integration": {
      "title": "4. Интеграция с Cloudflare R2: Хранилище Цифровых Активов",
      "generalInfo": {
        "title": "4.1. Общая Информация",
        "description": "Cloudflare R2 — это сервис объектного хранилища, совместимый с S3 API. Мы используем его для хранения <strong>всех файлов пользователей</strong>, таких как изображения, видео, документы, а также зашифрованные данные.",
        "advantages": [
          "<strong>Прагматизм (P12), Создание Богатства/Активов (P10):</strong> <strong>Отсутствие платы за исходящий трафик</strong> — критически важное преимущество для мессенджера, где пользователи активно обмениваются файлами. Бесплатный тариф 10 ГБ на старте.",
          "<strong>Качество (P3):</strong> Высокая производительность и надежность благодаря глобальной сети Cloudflare.",
          "<strong>Долгосрочное Мышление (P8), Система (P9):</strong> S3-совместимый API позволяет легко использовать стандартные библиотеки и инструменты, обеспечивая гибкость в будущем."
        ],
        "role": "Роль: Децентрализованное хранилище для крупных бинарных объектов, снижающее нагрузку на основную базу данных."
      },
      "configuration": {
        "title": "4.2. Конфигурация: Подключение к Хранилищу Активов",
        "steps": [
          "1. <strong>Создание Бакета:</strong>",
          "Войдите в Cloudflare Dashboard → R2.",
          "Нажмите <strong>\"Create Bucket\"</strong>.",
          "Назовите бакет (например, `brainmessenger-files`). Название должно быть уникальным в рамках всех аккаунтов Cloudflare.",
          "<strong>Настройки:</strong> Включите шифрование в покое (Encryption at rest) — это часть нашей <strong>системы безопасности</strong> (Принцип 3, 5). Ограничьте публичный доступ к бакету, доступ будет осуществляться через подписанные URL (если требуется) или через Backend.",
          "2. <strong>Ключи Доступа:</strong>",
          "В Cloudflare Dashboard перейдите в R2 → Manage R2 API Tokens.",
          "Создайте новый API-токен. Предоставьте ему минимально необходимые разрешения (например, Read and Write to specific buckets).",
          "Скопируйте `Access Key ID` и `Secret Access Key`.",
          "3. <strong>Переменные Окружения:</strong>",
          "Добавьте в ваш `.env` файл:"
        ],
        "envExample": "```env\\n# Cloudflare R2 Credentials\\nR2_ENDPOINT=<Your R2 Endpoint> # Формат: https://<account-id>.r2.cloudflarestorage.com\\nR2_ACCESS_KEY=<Your Access Key ID>\\nR2_SECRET_KEY=<Your Secret Access Key>\\nR2_BUCKET=brainmessenger-files # Название вашего бакета\\n\\n# Ключ шифрования для конфиденциальных данных (важно для P3, P5, P10)\\nENCRYPTION_KEY=<Your 32-byte (256-bit) hex or base64 encryption key> # Сгенерируйте надежный ключ!\\n```",
        "note": "*Примечание:* <strong>Не коммитьте эти ключи в Git!</strong> (Принцип 3, 5, 6). Используйте `.env.example` без чувствительных данных. <strong>ENCRYPTION_KEY</strong> должен быть сгенерирован надежно и храниться в безопасности.",
        "backendCode": "4. <strong>Подключение Backend (`@aws-sdk/client-s3`):</strong>\\nR2 совместим с S3 API, поэтому можно использовать стандартный AWS SDK для S3.\\nУстановите SDK: `npm install @aws-sdk/client-s3`.\\nИнициализируйте S3 Client в вашем Backend-сервисе (например, `StorageService`).\\n```typescript\\n// backend/src/storage/storage.service.ts\\nimport { Injectable } from '@nestjs/common';\\nimport { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3';\\nimport { getSignedUrl } from '@aws-sdk/s3-request-presigner'; // Для подписанных URL\\nimport { createCipheriv, randomBytes, createDecipheriv } from 'crypto'; // Для шифрования\\n\\n@Injectable()\\nexport class StorageService {\\n  private r2: S3Client;\\n  private encryptionKey: Buffer; // Ключ для шифрования\\n\\n  constructor() {\\n    this.r2 = new S3Client({\\n      region: 'auto', // R2 не использует регионы в классическом понимании\\n      endpoint: process.env.R2_ENDPOINT,\\n      credentials: {\\n        accessKeyId: process.env.R2_ACCESS_KEY,\\n        secretAccessKey: process.env.R2_SECRET_KEY,\\n      },\\n    });\\n    // Важно: ENCRYPTION_KEY должен быть Buffer 32 байт для aes-256-cbc\\n    this.encryptionKey = Buffer.from(process.env.ENCRYPTION_KEY, 'hex'); // Или 'base64'\\n    if (this.encryptionKey.length !== 32) {\\n         // Логировать ошибку или выбросить исключение - ключ неверной длины\\n         console.error(\\\"Invalid ENCRYPTION_KEY length. Must be 32 bytes for aes-256-cbc.\\\");\\n         // process.exit(1); // Возможно, стоит остановить приложение\\n    }\\n  }\\n\\n  // Утилита для шифрования (часть системы безопасности - P3, P5)\\n  private encrypt(data: string): { encrypted: string, iv: string } {\\n    const iv = randomBytes(16); // Initialization Vector, 16 байт для aes-256-cbc\\n    const cipher = createCipheriv('aes-256-cbc', this.encryptionKey, iv);\\n    let encrypted = cipher.update(data, 'utf8', 'hex');\\n    encrypted += cipher.final('hex');\\n    return { encrypted, iv: iv.toString('hex') };\\n  }\\n\\n  // Утилита для дешифрования\\n  private decrypt(encrypted: string, iv: string): string {\\n      const decipher = createDecipheriv('aes-256-cbc', this.encryptionKey, Buffer.from(iv, 'hex'));\\n      let decrypted = decipher.update(encrypted, 'hex', 'utf8');\\n      decrypted += decipher.final('utf8');\\n      return decrypted;\\n  }\\n\\n  // ... методы для работы с R2 (загрузка, скачивание, удаление)\\n}\\n```"
      },
      "interactionScenarios": {
        "title": "4.3. Методы и Сценарии Взаимодействия: API Хранилища",
        "description": "Взаимодействие с R2 осуществляется через Backend, что позволяет контролировать доступ, обрабатывать файлы (например, оптимизация изображений перед загрузкой) и управлять метаданными в БД (Принцип 9: Система).",
        "uploadFile": {
          "title": "Сценарий: Загрузка файла пользователем:",
          "interaction": "<strong>Взаимодействие:</strong> Пользователь прикрепляет файл в чате → Frontend отправляет файл на Backend → Backend (`StorageService`) загружает файл в R2 → Backend сохраняет метаданные файла (URL, тип, размер) в Neon → Backend отправляет сообщение в чат с ссылкой на файл.",
          "code": "<strong>Пример кода (Backend Service):</strong>\\n```typescript\\n// backend/src/storage/storage.service.ts (продолжение)\\n// ... S3Client и encryptionKey инициализация ...\\n\\nasync uploadFile(fileBuffer: Buffer, fileName: string, mimeType: string): Promise<string> {\\n  const key = `uploads/${Date.now()}-${fileName}`; // Уникальный ключ файла\\n  const params = {\\n    Bucket: process.env.R2_BUCKET,\\n    Key: key,\\n    Body: fileBuffer,\\n    ContentType: mimeType, // Важно для отдачи файла\\n  };\\n  const command = new PutObjectCommand(params);\\n  await this.r2.send(command); // Асинхронная загрузка\\n\\n  // Возвращаем URL для сохранения в БД. R2 позволяет прямые ссылки, если настроен публичный домен.\\n  // ИЛИ генерируем подписанный URL для ограниченного доступа (более безопасно).\\n  // Пример прямой ссылки (требует настройки Public Access URL в CF Dashboard):\\n  // const publicUrl = `${process.env.R2_ENDPOINT.replace('.r2.cloudflarestorage.com', '.r2.dev')}/${process.env.R2_BUCKET}/${key}`;\\n  // Для своего домена (предпочтительно):\\n  const fileUrl = `https://r2.brainmessenger.com/${key}`; // Ваш настроенный домен Cloudflare Workers/Pages\\n\\n  return fileUrl;\\n}\\n\\n//backend/src/chat/chat.service.ts (интеграция uploadFile)\\n// ... constructor с StorageService ...\\nasync sendFileMessage(chatId: string, userId: string, file: Express.Multer.File): Promise<Message> {\\n   // Опционально: обработка изображения перед загрузкой (см. DocOptimizationIn)\\n   // const processedFileBuffer = await this.imageProcessingService.processImage(file.buffer, 800, 600); // Пример\\n   const fileUrl = await this.storageService.uploadFile(file.buffer, file.originalname, file.mimetype);\\n\\n   // Создаем сообщение в БД со ссылкой на файл\\n   return this.prisma.message.create({\\n     data: {\\n       chatId,\\n       userId,\\n       content: '[File]', // Или другое обозначение файла\\n       fileUrl: fileUrl, // Сохраняем ссылку на файл в БД\\n       // fileMetadata: { type: file.mimetype, size: file.size }, // Опционально: сохранение метаданных в JSON поле или отдельной таблице\\n     },\\n   });\\n}\\n```",
          "result": "<strong>Результат:</strong> Файл надежно хранится в R2, ссылка на него доступна в БД для отображения в чате."
        },
        "sensitiveData": {
          "title": "Сценарий: Хранение конфиденциальных данных (например, зашифрованные метаданные):",
          "interaction": "<strong>Взаимодействие:</strong> При регистрации или обновлении профиля Backend шифрует чувствительные данные (например, резервные email, секретные вопросы) и сохраняет их в R2 в отдельном бакете или папке.",
          "code": "<strong>Пример кода (Backend Service):</strong>\\n```typescript\\n// backend/src/storage/storage.service.ts (продолжение)\\n// ... методы encrypt/decrypt ...\\n\\nasync storeSensitiveData(userId: string, sensitiveInfo: any): Promise<string> {\\n   const encryptedData = {};\\n   for (const key in sensitiveInfo) {\\n       if (sensitiveInfo.hasOwnProperty(key)) {\\n           const { encrypted, iv } = this.encrypt(JSON.stringify(sensitiveInfo[key])); // Шифруем каждое поле или весь объект\\n           encryptedData[key] = { encrypted, iv };\\n       }\\n   }\\n\\n   const key = `sensitive/${userId}/metadata.json`;\\n   const params = {\\n       Bucket: process.env.R2_BUCKET, // Или отдельный бакет для чувствительных данных\\n       Key: key,\\n       Body: JSON.stringify(encryptedData),\\n       ContentType: 'application/json',\\n   };\\n   const command = new PutObjectCommand(params);\\n   await this.r2.send(command);\\n   return `https://r2.brainmessenger.com/${key}`; // Ссылка для внутреннего использования\\n}\\n\\n// backend/src/user/user.service.ts (интеграция storeSensitiveData)\\n// ... constructor с StorageService ...\\nasync createUserWithSensitiveData(userData: any, sensitiveData: any) {\\n    // Создаем пользователя в БД\\n    const user = await this.prisma.user.create({ data: userData });\\n    // Сохраняем зашифрованные данные в R2\\n    const sensitiveDataUrl = await this.storageService.storeSensitiveData(user.id, sensitiveData);\\n    // Сохраняем ссылку на зашифрованные данные в БД (опционально)\\n    await this.prisma.user.update({\\n        where: { id: user.id },\\n        data: { sensitiveDataUrl: sensitiveDataUrl } // Добавить поле sensitiveDataUrl в схему Prisma\\n    });\\n    return user;\\n}\\n```",
          "result": "<strong>Результат:</strong> Конфиденциальные данные надежно зашифрованы и хранятся отдельно от основной БД в R2. Доступ к ним возможен только через Backend с использованием ключа шифрования."
        },
        "getFile": {
          "title": "Сценарий: Получение файла (для отображения или скачивания):",
          "interaction": "<strong>Взаимодействие:</strong> Frontend получает URL файла из метаданных сообщения (из Neon) → Frontend (или Backend, если требуется аутентификация/подписанные URL) использует этот URL для скачивания файла напрямую из R2.",
          "code": "<strong>Реализация:</strong> Если бакет R2 настроен с Public Access URL (через Cloudflare Workers/Pages), Frontend может обращаться напрямую. Если доступ ограничен, Backend может генерировать временные подписанные URL через `@aws-sdk/s3-request-presigner`.\\n```typescript\\n// backend/src/storage/storage.service.ts (продолжение)\\n// ... S3Client инициализация ...\\n\\n// Метод для генерации подписанного URL (более безопасный подход для приватных файлов)\\nasync getSignedFileUrl(fileKey: string): Promise<string> {\\n    const command = new GetObjectCommand({\\n        Bucket: process.env.R2_BUCKET,\\n        Key: fileKey,\\n    });\\n    // Сгенерировать подписанный URL, действительный, например, 60 секунд\\n    const signedUrl = await getSignedUrl(this.r2, command, { expiresIn: 60 });\\n    return signedUrl;\\n}\\n```"
        }
      },
      "errorHandling": {
        "title": "4.4. Обработка Ошибок Интеграции: Хранилище Активов",
        "forbidden": {
          "title": "403 Forbidden:",
          "cause": "Причина: Ошибка доступа к бакету R2. Неверные ключи доступа (`R2_ACCESS_KEY`, `R2_SECRET_KEY`), неверные разрешения токена, попытка доступа к приватному файлу без аутентификации/подписанного URL.",
          "solution": "Решение: Проверить переменные окружения, разрешения токена R2. Убедиться, что логика доступа (публичный URL vs подписанный URL) реализована корректно. Логировать ошибку."
        },
        "notFound": {
          "title": "404 Not Found:",
          "cause": "Причина: Файл отсутствует в R2. Неверный ключ файла (`Key`), файл был удален.",
          "solution": "Решение: Проверить ключ файла, который был сохранен в Neon. Убедиться, что файл действительно был загружен. Логировать ошибку."
        },
        "tooManyRequests": {
          "title": "429 Too Many Requests:",
          "cause": "Причина: Превышен лимит запросов к R2 API. Высокая частота запросов загрузки/скачивания.",
          "solution": "Решение: Внедрить Rate Limiting на Backend (см. Руководство по оптимизации). Оптимизировать логику работы с файлами."
        },
        "encryptionError": {
          "title": "Encryption/Decryption Error:",
          "cause": "Причина: Ошибка шифрования/дешифрования. Неверный ключ шифрования (`ENCRYPTION_KEY`), поврежденный IV, поврежденные зашифрованные данные.",
          "solution": "Решение: Убедиться, что используется правильный ключ (`ENCRYPTION_KEY`), который совпадает с ключом, использованным при шифровании. Проверить целостность данных и IV. Логировать критическую ошибку."
        }
      }
    },
    "neonR2Interaction": {
      "title": "5. Взаимодействие Neon и Cloudflare R2: Оптимизация Хранения Данных (Принцип 9, 12)",
      "description": "Мы используем Neon и R2 совместно, чтобы создать оптимизированную систему хранения данных, где каждый сервис выполняет свою лучшую функцию (Принцип 9).",
      "scenario": [
        "<strong>Neon (PostgreSQL):</strong> Хранит <strong>структурированные метаданные</strong>, которые часто запрашиваются и по которым выполняются сложные запросы (пользователи, чаты, текстовые сообщения, ссылки на файлы).",
        "<strong>Cloudflare R2:</strong> Хранит <strong>неструктурированные бинарные данные</strong> большого размера (файлы), которые реже запрашиваются и не требуют сложной логики выборки по содержимому).",
        "<strong>Сценарий комплексного взаимодействия:</strong>",
        "1. Пользователь отправляет файл через чат (Frontend -> Backend).",
        "2. Backend (`StorageService`) <strong>загружает файл в Cloudflare R2</strong> (используя S3 API). Получает URL файла (или ключ).",
        "3. Backend (`ChatService`) <strong>сохраняет метаданные сообщения в Neon через Prisma</strong>, включая полученный URL/ключ файла.",
        "4. Когда другой пользователь открывает чат, Backend (`ChatService`) <strong>получает список сообщений из Neon через Prisma</strong>, включая URL/ключи файлов.",
        "5. Frontend отображает список сообщений и использует URL/ключи для <strong>скачивания файлов напрямую из R2</strong> (или через Backend, если требуется аутентификация)."
      ],
      "advantagesTitle": "Преимущества такого разделения:",
      "advantages": [
        "<strong>Оптимизация производительности БД:</strong> PostgreSQL не \"засоряется\" большими бинарными данными, что улучшает скорость текстовых запросов (Принцип 9).",
        "<strong>Снижение стоимости:</strong> R2 предлагает очень выгодные тарифы для хранения больших объемов данных без платы за исходящий трафик, что <strong>прагматично</strong> (Принцип 12) и способствует созданию <strong>актива</strong> (Принцип 10).",
        "<strong>Масштабируемость:</strong> Каждый сервис масштабируется независимо в соответствии со своим типом нагрузки (Neon для транзакций, R2 для объема/трафика файлов).",
        "<strong>Надежность:</strong> Разделение ответственности между сервисами повышает общую отказоустойчивость системы."
      ]
    },
    "otherIntegrations": {
      "title": "6. Другие Интеграции: Расширение Функционала Системы (Принцип 2, 12)",
      "description": "Эти интеграции добавляют <strong>ценность</strong> (Принцип 2) и используют <strong>прагматичные, готовые решения</strong> (Принцип 12).",
      "firebase": {
        "title": "6.1. Firebase (Push-уведомления)",
        "purpose": "Назначение: Мгновенная доставка уведомлений о новых сообщениях, звонках и системных событиях пользователям мобильных приложений.",
        "role": "Роль: <strong>Критически важный компонент системы уведомлений</strong> (Принцип 9) для поддержания вовлеченности пользователей и оперативного информирования (Принцип 2).",
        "configuration": "Конфигурация: Переменная окружения: `FIREBASE_CREDENTIALS_PATH` (путь к JSON-файлу учетных данных сервисного аккаунта Firebase). <strong>Храните этот файл безопасно!</strong>",
        "example": "Используется библиотека `firebase-admin` в Backend NestJS. Пример использования: Отправка уведомления при получении нового сообщения (см. Руководство по оптимизации для батчинга и тем)."
      },
      "stripe": {
        "title": "6.2. Stripe (Платежи)",
        "purpose": "Назначение: Обработка подписок на Premium-функционал BrainMessenger.",
        "role": "Роль: <strong>Финансовый рычаг</strong> для поддержки развития проекта (Принцип 10: Создание Богатства) и предоставления дополнительной <strong>ценности</strong> (Принцип 2) премиум-пользователям.",
        "configuration": "Конфигурация: Переменная окружения: `STRIPE_SECRET_KEY`.",
        "example": "Используется библиотека `stripe` в Backend NestJS. Пример использования: Создание сессии оплаты при попытке оформить подписку. Обработка вебхуков для подтверждения успешной оплаты."
      },
      "gmailApi": {
        "title": "6.3. Gmail API (Отправка Email)",
        "purpose": "Назначение: Отправка транзакционных email, таких как коды подтверждения для регистрации и двухфакторной аутентификации (2FA), уведомления о сбросе пароля.",
        "role": "Роль: <strong>Критически важный компонент системы аутентификации и безопасности</strong> (Принцип 9, 5).",
        "configuration": "Конфигурация: Требует настройки сервисного аккаунта Google Cloud и получения учетных данных (см. Техническую документацию, раздел 10.1). Переменные окружения для учетных данных сервисного аккаунта или API-ключей.",
        "example": "Пример использования: Вызов API для отправки письма с кодом подтверждения после ввода email при регистрации или включении 2FA (см. Спецификацию API, раздел 2.4)."
      }
    },
    "recommendations": {
      "title": "7. Рекомендации по Интеграциям: Поддержание Здоровья Системы (Принцип 3, 5, 9)",
      "intro": "Чтобы интеграции оставались <strong>надежными, безопасными и эффективными</strong> (Принцип 3, 9), следуйте этим рекомендациям, связанным с поддержанием \"здоровья\" системы (Принцип 5, применительно к технике):",
      "security": {
        "title": "Безопасность:",
        "points": [
          "<strong>Никогда не коммитьте ключи и секреты в Git.</strong> Используйте переменные окружения и системы управления секретами в продакшен-окружении (например, Kubernetes Secrets, HashiCorp Vault).",
          "Регулярно проводите <strong>ротацию API-токенов</strong> (R2, Firebase, Gmail, Stripe) для повышения безопасности.",
          "Используйте <strong>принцип минимальных привилегий</strong> при создании API-токенов: давайте им только те разрешения, которые действительно необходимы."
        ]
      },
      "scaling": {
        "title": "Масштабирование:",
        "points": [
          "<strong>Мониторьте использование ресурсов</strong> (место в Neon/R2, запросы к API Firebase/Stripe) через консоли соответствующих сервисов. Будьте готовы перейти на платный тариф при росте нагрузки (Принцип 8, 12).",
          "Используйте <strong>оптимизационные подходы</strong> (например, батчинг запросов к Firebase, индексирование в Neon, см. Руководство по оптимизации), чтобы отложить необходимость перехода на более дорогие тарифы."
        ]
      },
      "monitoring": {
        "title": "Мониторинг и Логирование:",
        "points": [
          "Настройте <strong>логирование ошибок интеграций</strong> в NestJS (Winston, Sentry).",
          "Используйте <strong>системы мониторинга</strong> (Prometheus/Grafana) для отслеживания метрик запросов к внешним сервисам (задержки, количество ошибок) — это часть <strong>Кайдзен</strong> (Принцип 9), позволяющая выявлять проблемы на ранней стадии."
        ]
      },
      "errorHandling": {
        "title": "Обработка Ошибок:",
        "points": [
          "Реализуйте <strong>грамотную обработку ошибок</strong> от внешних сервисов на Backend. Логируйте их подробно.",
          "Для критически важных операций (например, регистрация, платежи) предусмотрите механизмы <strong>повторных попыток (retries)</strong> или <strong>компенсирующих действий</strong> (например, отметка платежа как незавершенного) при временных сбоях внешних сервисов."
        ]
      },
      "documentation": {
        "title": "Документация:",
        "content": "Поддерживайте эту документацию в актуальном состоянии, отражая изменения в используемых сервисах или добавлении новых интеграций (Принцип 1: Обучение, Принцип 9: Система)."
      }
    }
  },
  "optimizationGuide": {
      "title": "Руководство по Оптимизации BrainMessenger (Принцип Кайдзен в Действии)",
      "subtitle": "Введение: Оптимизация как Непрерывный Процесс Улучшения",
      "introduction": {
        "title": "1. Введение: Оптимизация как Непрерывный Процесс Улучшения",
        "description": "Этот документ подробно описывает подходы, инструменты и техники, которые мы используем для оптимизации производительности BrainMessenger. Оптимизация — это не одноразовая задача, а <strong>непрерывный процесс улучшения</strong> (Принцип 1, 9: Кайдзен), который позволяет нам обеспечить <strong>высокое качество, надежность и масштабируемость</strong> (Принцип 3, 8) приложения.",
        "goalTitle": "Цель:",
        "goalContent": "Идентифицировать и устранять узкие места в производительности на всех уровнях системы (Frontend, Backend, База данных, Инфраструктура), чтобы BrainMessenger оставался <strong>быстрым, отзывчивым и эффективным</strong> (Принцип 2) даже при значительной нагрузке (цель — 1 миллион активных пользователей), поддерживая <strong>здоровье системы</strong> (Принцип 5, применительно к технике).",
        "audienceTitle": "Аудитория:",
        "audienceContent": "Backend, Frontend, Mobile, Desktop и DevOps разработчики, сфокусированные на производительности и масштабировании.",
        "principlesTitle": "Принципы, которыми руководствуется оптимизация:",
        "principles": [
          "<strong>Система и Оптимизация (Принцип 9: Кайдзен):</strong> Оптимизация является ключевым аспектом нашей системы разработки. Используется цикличный подход: Измерение → Анализ → Улучшение → Проверка.",
          "<strong>Качество > Количество (Принцип 3):</strong> Лучше иметь несколько критически важных оптимизаций, чем много мелких, не дающих значительного эффекта.",
          "<strong>Прагматизм и Реализм (Принцип 12):</strong> Оптимизируем то, что действительно влияет на производительность и пользовательский опыт, основываясь на реальных данных, а не на догадках.",
          "<strong>Постоянное Обучение (Принцип 1):</strong> Изучение новых техник и инструментов оптимизации, анализ результатов и уроков.",
          "<strong>Настойчивость (Принцип 13):</strong> Оптимизация может быть сложной. Требуется упорство для выявления и решения глубоких проблем производительности.",
          "<strong>Здоровье как Фундамент (Принцип 5):</strong> Оптимизация системы (например, снижение потребления памяти/CPU) напрямую влияет на \"здоровье\" серверов и устройств пользователей.",
          "<strong>Внешняя Экспертиза (Принцип 14):</strong> Использование стандартных инструментов (Prometheus, Grafana, V8 Profiler), изучение опыта других команд (Google, Next.js и т.д.)."
        ]
      },
      "generalPrinciple": {
        "title": "2. Общий Принцип Оптимизации (Цикл Кайдзен)",
        "intro": "Наш подход к оптимизации следует <strong>циклу Кайдзен (Принцип 9)</strong>:",
        "step1": {
          "title": "1. Измерение (Measure):",
          "content": "Соберите данные о производительности. Используйте инструменты мониторинга (Prometheus, Sentry), профилирования (V8 Profiler), анализа бандлов (Webpack Bundle Analyzer, `@next/bundle-analyzer`)."
        },
        "step2": {
          "title": "2. Анализ (Analyze):",
          "content": "Определите <strong>узкие места (bottlenecks)</strong> на основе собранных данных. Где система тратит больше всего времени или ресурсов?"
        },
        "step3": {
          "title": "3. Улучшение (Improve):",
          "content": "Примените конкретные техники оптимизации, описанные в этом руководстве, для устранения выявленных узких мест."
        },
        "step4": {
          "title": "4. Проверка (Verify):",
          "content": "Снова измерьте производительность после внесенных изменений. Убедитесь, что оптимизация дала ожидаемый эффект и не вызвала регрессий (не ухудшила другие аспекты)."
        },
        "step5": {
          "title": "5. Повторение:",
          "content": "Производительность может меняться с ростом нагрузки и функционала. Повторяйте цикл Кайдзен непрерывно."
        }
      },
      "imageProcessing": {
        "title": "3. Оптимизация Обработки Изображений: Эффективность и Скорость (Принцип 9, 2)",
        "intro": "Обработка изображений может быть ресурсоемкой. <strong>Оптимизация этого процесса напрямую влияет на скорость загрузки контента и отзывчивость приложения</strong> (Принцип 2: Ценность).",
        "libraryTitle": "Библиотека:",
        "libraryContent": "`sharp` (на базе `libvips`). Выбран как <strong>прагматичное</strong> (Принцип 12) и <strong>высокопроизводительное</strong> (Принцип 9) решение для Node.js.",
        "applicationAreasTitle": "Области применения:",
        "applicationAreasContent": "Изменение размера, сжатие, конвертация формата для аватаров, изображений в чатах.",
        "keyTechniqueTitle": "Ключевая техника:",
        "keyTechniqueContent": "<strong>Асинхронная обработка</strong> в фоновом режиме через Kafka.",
        "implementationStepsTitle": "Шаги по внедрению (Backend):",
        "step1": {
          "title": "1. Установите `sharp`:",
          "content": "Убедитесь, что `libvips` установлен в вашей операционной системе или Docker-образе.",
          "code": "```bash\\nnpm install sharp\\n```"
        },
        "step2": {
          "title": "2. Создайте сервис обработки изображений:",
          "content": "Инкапсулируйте логику в отдельном сервисе (часть <strong>системы</strong> - Принцип 9).",
          "code": "```typescript\\n// backend/src/image-processing/image-processing.service.ts\\nimport { Injectable } from '@nestjs/common';\\nimport sharp from 'sharp';\\n\\n@Injectable()\\nexport class ImageProcessingService {\\n  // Метод для изменения размера, сжатия и конвертации в WebP\\n  async processImage(buffer: Buffer, width: number, height?: number): Promise<Buffer> {\\n    // resize({ width, height, withoutEnlargement: true }) - избегаем увеличения, если исходник меньше\\n    // webp({ quality: 80 }) - сжатие в формат WebP (хорошее сжатие при сохранении качества)\\n    // withMetadata({ orientation: true }) - сохраняем ориентацию из EXIF, остальное удаляем (экономия размера - Принцип 9)\\n    return sharp(buffer)\\n      .resize(width, height, { withoutEnlargement: true })\\n      .webp({ quality: 80 })\\n      .withMetadata({ orientation: true })\\n      .toBuffer();\\n  }\\n\\n  // Метод для простого изменения размера\\n  async resizeImage(buffer: Buffer, width: number, height?: number): Promise<Buffer> {\\n       return sharp(buffer)\\n           .resize(width, height, { withoutEnlargement: true })\\n           .toBuffer();\\n  }\\n\\n   // Метод для конвертации в определенный формат\\n   async convertToFormat(buffer: Buffer, format: keyof sharp.Format): Promise<Buffer> {\\n       return sharp(buffer).toFormat(format).toBuffer();\\n   }\\n}\\n```"
        },
        "step3": {
          "title": "3. Интеграция с загрузкой файлов (Backend Controller/Service):",
          "content": "",
          "code": "```typescript\\n// backend/src/upload/upload.controller.ts (пример обработки загрузки аватара)\\nimport { Controller, Post, UploadedFile, UseInterceptors, Body, Inject } from '@nestjs/common';\\nimport { FileInterceptor } from '@nestjs/platform-express';\\nimport { ImageProcessingService } from '../image-processing/image-processing.service';\\nimport { StorageService } from '../storage/storage.service';\\nimport { UserService } from '../user/user.service';\\n\\n@Controller('upload')\\nexport class UploadController {\\n  constructor(\\n    private imageProcessingService: ImageProcessingService,\\n    private storageService: StorageService,\\n    private userService: UserService,\\n    // ... инъекция Kafka продюсера для асинхронной обработки\\n  ) {}\\n\\n  @Post('avatar')\\n  @UseInterceptors(FileInterceptor('file')) // 'file' - имя поля формы\\n  async uploadAvatar(@UploadedFile() file: Express.Multer.File, @Body('userId') userId: string) {\\n    // Оптимизация: Обработка изображения перед загрузкой в R2\\n    const processedImageBuffer = await this.imageProcessingService.processImage(file.buffer, 300, 300); // Изменить размер и сжать\\n    const fileName = `avatars/${userId}-${Date.now()}.webp`; // Уникальное имя файла в папке avatars\\n    const mimeType = 'image/webp'; // Соответствует формату WebP\\n\\n    // Загрузка обработанного файла в Cloudflare R2\\n    const avatarUrl = await this.storageService.uploadFile(processedImageBuffer, fileName, mimeType);\\n\\n    // Обновление ссылки на аватар в профиле пользователя в Neon\\n    await this.userService.updateUserAvatar(userId, avatarUrl);\\n\\n    // Возвращаем URL аватара клиенту\\n    return { avatarUrl };\\n  }\\n\\n  @Post('chat-image')\\n  @UseInterceptors(FileInterceptor('file'))\\n  async uploadChatImage(@UploadedFile() file: Express.Multer.File, @Body('chatId') chatId: string, @Body('userId') userId: string) {\\n      // Отправка задачи на обработку изображения в Kafka для асинхронной обработки (Принцип 9)\\n      const taskPayload = { fileBuffer: file.buffer.toString('base64'), fileName: file.originalname, mimeType: file.mimetype, chatId, userId };\\n      // Предполагается, что у вас есть Kafka продюсер сервис\\n      // await this.kafkaProducerService.sendMessage('image-processing-topic', JSON.stringify(taskPayload));\\n\\n      // Немедленный ответ клиенту, что файл принят в обработку\\n      return { status: 'processing', originalFileName: file.originalname };\\n\\n      // ИЛИ, если синхронная обработка приемлема для небольших файлов:\\n      /*\\n      const processedImageBuffer = await this.imageProcessingService.processImage(file.buffer, 800); // Изменить размер\\n      const fileName = `chat-images/${chatId}-${Date.now()}.webp`;\\n      const mimeType = 'image/webp';\\n      const imageUrl = await this.storageService.uploadFile(processedImageBuffer, fileName, mimeType);\\n\\n      // Создание сообщения типа 'image' в чате\\n      // await this.chatService.sendImageMessage(chatId, userId, imageUrl);\\n\\n      return { imageUrl };\\n      */\\n  }\\n}\\n```"
        },
        "step4": {
          "title": "4. Асинхронность через Kafka (для тяжелых задач):",
          "content": "Для обработки изображений в чатах (которые могут быть большими) используйте <strong>Kafka</strong> (см. раздел 8) для <strong>асинхронной обработки</strong>. Backend быстро принимает файл от клиента и ставит задачу в очередь Kafka. Отдельный воркер (consumer Kafka) забирает задачу, обрабатывает изображение с помощью `sharp`, загружает в R2 и только после этого создает сообщение в чате через API. Это <strong>снижает время ответа API</strong> (Принцип 9) и улучшает пользовательский опыт."
        }
      },
      "dbOptimization": {
        "title": "4. Оптимизация Базы Данных (Neon/PostgreSQL): Ускорение Доступа к Данным (Принцип 9, 8)",
        "intro": "База данных часто становится узким местом. Оптимизация запросов и структуры БД критически важна для <strong>долгосрочной производительности</strong> (Принцип 8) и <strong>эффективности системы</strong> (Принцип 9).",
        "platformTitle": "Платформа:",
        "platformContent": "Neon (управляемый PostgreSQL).",
        "toolTitle": "Инструмент:",
        "toolContent": "Prisma ORM.",
        "analysisToolTitle": "Инструмент анализа:",
        "analysisToolContent": "`EXPLAIN ANALYZE` в SQL-клиенте Neon или `prisma.queryRaw` с `EXPLAIN ANALYZE`.",
        "monitoringToolTitle": "Инструмент мониторинга:",
        "monitoringToolContent": "Prometheus + `postgres_exporter` (см. раздел 14).",
        "indexing": {
          "title": "4.1. Индексация: Ускорение Поиска и Фильтрации",
          "intro": "Индексы позволяют базе данных быстрее находить нужные строки.",
          "whenTitle": "Когда использовать:",
          "whenContent": "На полях, которые часто используются в `WHERE`, `JOIN`, `ORDER BY`.",
          "applicationAreasTitle": "Области применения в BrainMessenger:",
          "applicationAreasContent": "`userId`, `chatId`, `createdAt` (в таблице `Message`), `email` (в таблице `User`), поля для поиска.",
          "prismaTitle": "Реализация (Prisma):",
          "prismaContent": "Добавляйте `@index` в `schema.prisma`.",
          "prismaCode": "```prisma\\n// schema.prisma\\nmodel Message {\\n  id        String   @id @default(cuid())\\n  content   String\\n  createdAt DateTime @default(now()) @map(\\\"created_at\\\") // Пример @map для snake_case в БД\\n  chatId    String @map(\\\"chat_id\\\")\\n  userId    String @map(\\\"user_id\\\")\\n  chat      Chat     @relation(fields: [chatId], references: [id])\\n  user      User     @relation(fields: [userId], references: [id])\\n\\n  // Комбинированный индекс для быстрых запросов сообщений в чате по времени\\n  @@index([chatId, createdAt])\\n  // Индекс для быстрого получения сообщений по пользователю (например, для статистики)\\n  @@index([userId])\\n  // Индекс для поиска по содержимому (если требуется полнотекстовый поиск - рассмотреть tsearch)\\n  // @@index([content]) // Только для простых фильтров LIKE\\n}\\n\\nmodel User {\\n    id    String @id @default(cuid())\\n    email String @unique // Уникальный индекс для быстрого поиска по email (логин, регистрация)\\n    name  String\\n    // ... другие поля\\n}\\n\\nmodel Chat {\\n   id          String @id @default(cuid())\\n   lastMessageAt DateTime? @map(\\\"last_message_at\\\") // Для сортировки чатов (нужен индекс)\\n   // ... другие поля\\n   @@index([lastMessageAt]) // Индекс для сортировки списка чатов\\n}\\n```",
          "applicationTitle": "Применение:",
          "applicationContent": "После изменения `schema.prisma` выполните миграцию (`npx prisma migrate dev`)."
        },
        "queryOptimization": {
          "title": "4.2. Оптимизация Запросов (Prisma): Пишем Эффективный Код Взаимодействия с БД",
          "intro": "",
          "selectFieldsTitle": "Выбирайте только нужные поля (`select`):",
          "selectFieldsContent": "Не запрашивайте `SELECT *`. Указывайте поля, которые вам действительно нужны. Это уменьшает объем данных, передаваемых по сети и обрабатываемых БД.",
          "selectFieldsCode": "```typescript\\n// Плохо\\nconst user = await prisma.user.findUnique({ where: { id: userId } }); // Выберет все поля\\n\\n// Хорошо (если нужен только email и name)\\nconst user = await prisma.user.findUnique({\\n  where: { id: userId },\\n  select: {\\n    email: true,\\n    name: true,\\n  },\\n});\\n```",
          "nPlus1Title": "Избегайте N+1 проблем (`include`):",
          "nPlus1Content": "Если вам нужны связанные данные (например, автор сообщения при получении списка сообщений), используйте `include` или `select` со вложенными полями вместо выполнения отдельного запроса для каждого элемента.",
          "nPlus1Code": "```typescript\\n// Плохо (N+1 проблема - отдельный запрос за каждым пользователем)\\nconst messages = await prisma.message.findMany({ where: { chatId: chatId } });\\nfor (const message of messages) {\\n  const sender = await prisma.user.findUnique({ where: { id: message.userId } });\\n  // ... использовать sender\\n}\\n\\n// Хорошо (используем include для получения автора сообщения одним запросом)\\nconst messagesWithSender = await prisma.message.findMany({\\n  where: { chatId: chatId },\\n  include: {\\n    user: { // Включаем данные пользователя, связанного с сообщением через поле 'user' в модели Message\\n      select: { id: true, name: true, avatarUrl: true } // Выбираем только нужные поля пользователя\\n    },\\n  },\\n  orderBy: { createdAt: 'asc' }, // Пример: сообщения в хронологическом порядке\\n  take: 50, // Пример: пагинация\\n});\\n```",
          "paginationTitle": "Пагинация (`skip`, `take`, `cursor`):",
          "paginationContent": "Для получения больших списков (сообщения в чате, список чатов) используйте пагинацию, чтобы не загружать все данные сразу. `cursor`-пагинация предпочтительнее для бесконечной прокрутки.",
          "paginationCode": "```typescript\\n// Пример пагинации с take и skip\\nconst messages = await prisma.message.findMany({\\n    where: { chatId: chatId },\\n    orderBy: { createdAt: 'asc' },\\n    skip: (page - 1) * pageSize, // Пропустить N сообщений\\n    take: pageSize, // Взять M сообщений\\n});\\n\\n// Пример Cursor-based пагинации (для \\\"показать еще\\\")\\nconst messages = await prisma.message.findMany({\\n    where: { chatId: chatId },\\n    orderBy: { createdAt: 'asc' },\\n    cursor: { id: lastMessageId }, // Начать после последнего сообщения\\n    skip: 1, // Пропустить само последнее сообщение\\n    take: pageSize,\\n});\\n```"
        },
        "prismaAccelerate": {
          "title": "4.3. Prisma Accelerate: Глобальный Кэш и Пул Соединений",
          "intro": "Prisma Accelerate предоставляет глобальную сеть серверов (Edge locations), которые кэшируют результаты запросов и управляют пулом соединений к вашей БД Neon.",
          "whenTitle": "Когда использовать:",
          "whenContent": "Для снижения задержки запросов (latency) для пользователей по всему миру и оптимизации использования пула соединений БД.",
          "implementationTitle": "Реализация:",
          "implementationContent": "Настраивается в консоли Prisma. Ваша `DATABASE_URL` заменяется на URL Prisma Accelerate."
        },
        "materializedViews": {
          "title": "4.4. Материализованные Представления: Кэширование Сложных Агрегаций",
          "intro": "Материализованные представления — это по сути кэшированные результаты сложных запросов или агрегаций (например, количество сообщений в чате, последние активные пользователи в группе). Они хранятся на диске и могут быть быстро прочитаны.",
          "whenTitle": "Когда использовать:",
          "whenContent": "Для запросов, которые выполняются часто, но требуют сложных вычислений (JOINs, GROUP BY, агрегатные функции) над большими таблицами, и данные в которых не должны быть абсолютно актуальными каждую миллисекунду.",
          "applicationAreasTitle": "Области применения:",
          "applicationAreasContent": "Статистика чатов (общее количество сообщений, участников), списки \"топ\" пользователей (например, по количеству отправленных сообщений).",
          "implementationTitle": "Реализация (SQL, через Prisma `queryRaw` или SQL-клиент Neon):",
          "implementationContent": "```sql\\n-- Создать материализованное представление для подсчета сообщений в каждом чате\\nCREATE MATERIALIZED VIEW chat_message_counts AS\\nSELECT\\n    \\\"chatId\\\",\\n    COUNT(*) as \\\"messageCount\\\"\\nFROM \\\"Message\\\"\\nGROUP BY \\\"chatId\\\";\\n\\n-- Создать индекс на представлении для быстрого поиска по chatId (необязательно, но часто полезно)\\nCREATE INDEX idx_chat_message_counts_chat_id ON chat_message_counts (\\\"chatId\\\");\\n```",
          "updateTitle": "Обновление:",
          "updateContent": "Материализованные представления нужно <strong>периодически обновлять</strong>, чтобы отразить изменения в базовых таблицах. Это делается командой `REFRESH MATERIALIZED VIEW <view_name>;`. Частота обновления зависит от того, насколько актуальными должны быть данные (например, раз в час, раз в день).",
          "updateCode": "```sql\\n-- Обновить представление (может блокировать чтение во время выполнения)\\nREFRESH MATERIALIZED VIEW chat_message_counts;\\n\\n-- Обновить представление без блокировки чтения (для больших представлений)\\nREFRESH MATERIALIZED VIEW CONCURRENTLY chat_message_counts; -- Требует уникального индекса\\n```",
          "usageTitle": "Использование в Prisma:",
          "usageContent": "Запрашивайте как обычную таблицу.",
          "usageCode": "```typescript\\nconst chatStats = await prisma.chatMessageCounts.findMany({\\n  select: { chatId: true, messageCount: true },\\n  where: { chatId: 'some-chat-id' },\\n});\\n```"
        },
        "partitioning": {
          "title": "4.5. Партиционирование Таблиц: Разделение Больших Объемов Данных",
          "intro": "Партиционирование физически разделяет очень большие таблицы (например, `Message`) на более мелкие части (партиции) на основе значения в определенном столбце (например, `createdAt` или `chatId`).",
          "whenTitle": "Когда использовать:",
          "whenContent": "Когда таблица становится настолько большой (миллиарды строк), что индексы уже не справляются, и запросы начинают замедляться из-за необходимости сканировать слишком много данных.",
          "applicationAreasTitle": "Области применения:",
          "applicationAreasContent": "Таблица `Message` — идеальный кандидат для партиционирования по времени создания (`createdAt`) или по ID чата (`chatId`).",
          "implementationTitle": "Реализация (SQL, через Prisma `queryRaw` или SQL-клиент Neon):",
          "implementationContent": "PostgreSQL поддерживает нативное партиционирование.",
          "implementationCode": "```sql\\n-- Создать главную партиционированную таблицу по диапазону дат\\nCREATE TABLE messages (\\n    id TEXT NOT NULL,\\n    content TEXT NOT NULL,\\n    created_at TIMESTAMP WITH TIME ZONE NOT NULL,\\n    chat_id TEXT NOT NULL,\\n    user_id TEXT NOT NULL,\\n    PRIMARY KEY (id, created_at) -- Ключ партиционирования должен быть частью первичного ключа\\n) PARTITION BY RANGE (created_at); -- Партиционируем по диапазону поля created_at\\n\\n-- Создать партиции (например, по месяцам)\\nCREATE TABLE messages_2025_03 PARTITION OF messages\\n    FOR VALUES FROM ('2025-03-01 00:00:00+00') TO ('2025-04-01 00:00:00+00');\\n\\nCREATE TABLE messages_2025_04 PARTITION OF messages\\n    FOR VALUES FROM ('2025-04-01 00:00:00+00') TO ('2025-05-01 00:00:00+00');\\n\\n-- ... создавать новые партиции по мере необходимости (автоматически или вручную)\\n\\n-- Создать индексы для партиционированной таблицы (применяются ко всем партициям)\\nCREATE INDEX ON messages (\\\"chat_id\\\", \\\"created_at\\\");\\nCREATE INDEX ON messages (\\\"user_id\\\");\\n```",
          "advantagesTitle": "Преимущества:",
          "advantagesContent": "Запросы, включающие фильтр по ключу партиционирования (например, `WHERE created_at BETWEEN ...`), будут сканировать только нужные партиции, что значительно ускоряет их выполнение. Управление старыми данными (удаление) становится проще (можно просто удалить старые партиции).",
          "prismaRelationTitle": "Связь с Prisma:",
          "prismaRelationContent": "Prisma работает с партиционированной таблицей как с обычной."
        }
      },
      "graphqlOptimization": {
        "title": "5. Оптимизация GraphQL API (NestJS + Prisma): Эффективная Передача Данных",
        "intro": "GraphQL сам по себе является инструментом <strong>оптимизации</strong> (Принцип 9) по сравнению с REST (клиент запрашивает только нужные данные). Однако и его можно оптимизировать.",
        "analysisToolTitle": "Инструмент анализа:",
        "analysisToolContent": "`graphql-query-complexity` для защиты от сложных запросов.",
        "dataloader": {
          "title": "5.1. DataLoader: Решение Проблемы N+1 в GraphQL",
          "intro": "DataLoader — это утилита, которая помогает решить проблему N+1 запросов при работе с графами данных. Если у вас есть список объектов, и для каждого объекта нужно подтянуть связанный с ним объект (например, список сообщений и для каждого сообщения его автора), DataLoader соберет все ID связанных объектов и сделает один пакетный запрос к БД.",
          "whenTitle": "Когда использовать:",
          "whenContent": "В резолверах GraphQL, когда вам нужно получить связанные объекты для списка родительских объектов.",
          "applicationAreasTitle": "Области применения:",
          "applicationAreasContent": "Получение данных автора для каждого сообщения в чате, получение списка участников для каждого чата в списке чатов пользователя.",
          "implementationTitle": "Реализация:",
          "implementationContent": "Создайте отдельные DataLoader для каждого типа объекта, который нужно подтягивать. Интегрируйте их в контекст GraphQL запроса.",
          "implementationCode": "```typescript\\n// backend/src/graphql/loaders/user.loader.ts\\nimport { Injectable, Scope } from '@nestjs/common';\\nimport DataLoader from 'dataloader';\\nimport { PrismaService } from 'nestjs-prisma';\\nimport { User } from '@prisma/client'; // Импорт модели Prisma\\n\\n// Scope.REQUEST - важно, чтобы DataLoader был уникален для каждого запроса GraphQL\\n@Injectable({ scope: Scope.REQUEST })\\nexport class UserLoader {\\n  private loader: DataLoader<string, User>;\\n\\n  constructor(private prisma: PrismaService) {\\n    // Создаем новый DataLoader. Функция batchLoadFn принимает массив ключей (user IDs)\\n    this.loader = new DataLoader<string, User>(\\n      async (ids: readonly string[]) => {\\n        // Выполняем ОДИН запрос к БД, чтобы получить ВСЕх пользователей по их ID\\n        const users = await this.prisma.user.findMany({\\n          where: {\\n            id: { in: Array.from(ids) }, // Array.from(ids) для совместимости с Prisma\\n          },\\n        });\\n\\n        // Важно: Вернуть массив результатов, упорядоченный по исходному массиву ids\\n        const userMap = new Map(users.map(user => [user.id, user]));\\n        return ids.map(id => userMap.get(id)); // Возвращаем пользователей в том же порядке, что и запросили\\n      },\\n      { cache: true } // Включаем кэширование внутри запроса GraphQL\\n    );\\n  }\\n\\n  // Метод для загрузки одного пользователя по ID\\n  load(id: string): Promise<User> {\\n    return this.loader.load(id);\\n  }\\n\\n  // Метод для загрузки списка пользователей по ID\\n  loadMany(ids: string[]): Promise<(Error | User)[]> {\\n      return this.loader.loadMany(ids);\\n  }\\n}\\n```\\nИнтегрируйте лоадеры в контекст GraphQL (`backend/src/graphql/graphql.module.ts` или `app.module.ts`):\\n```typescript\\n// backend/src/graphql/graphql.module.ts\\nimport { Module } from '@nestjs/common';\\nimport { GraphQLModule } from '@nestjs/graphql';\\nimport { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';\\nimport { UserLoader } from './loaders/user.loader'; // Импорт лоадера\\n// ... другие импорты резолверов и модулей\\n\\n@Module({\\n  imports: [\\n    GraphQLModule.forRoot<ApolloDriverConfig>({\\n      driver: ApolloDriver,\\n      // ... другие настройки GraphQL (schema path, context, etc.)\\n      context: ({ req, connection }) => {\\n        // Создаем контекст для каждого запроса\\n        const context = { req }; // Добавляем объект запроса\\n         if (connection) {\\n           // Для WebSocket (подписки)\\n           // context.loaders = new Loaders(); // Если лоадеры создаются здесь\\n         } else {\\n           // Для HTTP запросов (queries/mutations)\\n           // Создаем лоадеры и добавляем их в контекст\\n           context.loaders = {\\n              userLoader: new UserLoader(/* зависимости */), // Нужно инжектить PrismaService\\n              // ... другие лоадеры\\n           };\\n           // Пример инъекции зависимостей в лоадер (может потребовать FactoryProvider)\\n           // context.loaders = {\\n           //     userLoader: req.loaders.userLoader, // Если используете Request-scoped провайдеры NestJS\\n           // };\\n         }\\n        return context;\\n      },\\n      // plugins: [complexityPlugin], // Плагин для анализа сложности запросов\\n    }),\\n    // ... импорт других модулей\\n  ],\\n   providers: [UserLoader], // Добавляем лоадер как провайдер (для Request scope)\\n})\\nexport class GraphqlModule {}\\n```",
          "usageTitle": "Используйте лоадеры в резолверах:",
          "usageContent": "",
          "usageCode": "```typescript\\n// backend/src/message/message.resolver.ts\\nimport { Resolver, ResolveField, Parent, Context } from '@nestjs/graphql';\\nimport { Message } from '@prisma/client'; // Импорт модели Prisma\\nimport { UserLoader } from '../graphql/loaders/user.loader'; // Импорт лоадера\\n\\n@Resolver('Message') // Указываем GraphQL тип, к которому относится резолвер\\nexport class MessageResolver {\\n  @ResolveField('user') // Определяем резолвер для поля 'user' в типе Message\\n  async resolveUser(@Parent() message: Message, @Context() context: any) {\\n    // Используем userLoader из контекста для загрузки пользователя по message.userId\\n    // DataLoader автоматически соберет все message.userId в текущем запросе и загрузит их батчем\\n    return context.loaders.userLoader.load(message.userId);\\n  }\\n}\\n```"
        },
        "queryComplexityAnalysis": {
          "title": "5.2. Анализ Сложности Запросов: Защита от \"Тяжелых\" Запросов",
          "intro": "GraphQL позволяет клиенту запрашивать данные произвольной вложенности, что может привести к очень \"тяжелым\" запросам, сильно нагружающим сервер и БД.",
          "toolTitle": "Инструмент:",
          "toolContent": "`graphql-query-complexity`.",
          "whenTitle": "Когда использовать:",
          "whenContent": "Всегда включайте защиту от сложности в продакшене.",
          "principleTitle": "Принцип работы:",
          "principleContent": "Плагин анализирует запрос до его выполнения и вычисляет его \"сложность\" (например, как сумму \"стоимости\" каждого поля). Если сложность превышает заданный порог, запрос отклоняется.",
          "implementationTitle": "Реализация:",
          "implementationContent": "Настройте плагин в NestJS GraphQLModule (см. Руководство по разработке)."
        },
        "persistedQueries": {
          "title": "5.3. Persisted Queries: Кэширование Запросов на Уровне Сети",
          "intro": "Persisted Queries позволяют клиенту отправлять на сервер не полный текст GraphQL запроса, а только его хэш. Сервер по этому хэшу находит полный запрос (если он ему знаком) и выполняет его.",
          "whyTitle": "Почему:",
          "whyContent": "Уменьшает объем данных, передаваемых по сети, что ускоряет запросы, особенно на мобильных устройствах. Улучшает эффективность кэширования на CDN.",
          "whenTitle": "Когда использовать:",
          "whenContent": "Для часто повторяющихся запросов из клиента.",
          "implementationTitle": "Реализация:",
          "implementationContent": "Требует поддержки как на стороне клиента (Apollo Client поддерживает), так и на стороне сервера (Apollo Server поддерживает). На сервере нужно хранить соответствие хэшей и запросов (например, в Redis)."
        }
      },
      "backendLogicOptimization": {
        "title": "6. Оптимизация Backend Логики (NestJS): Эффективность Кода",
        "intro": "",
        "toolsTitle": "Инструменты:",
        "toolsContent": "Профилирование Node.js (V8 Profiler), обнаружение утечек памяти (`heapdump`).",
        "whenTitle": "Когда использовать:",
        "whenContent": "Для выявления \"горячих\" участков кода, потребляющих много CPU или памяти, и диагностики проблем с памятью.",
        "processTitle": "Процесс:",
        "processContent": "Используйте инструменты профилирования для <strong>измерения</strong> (Шаг 1 Кайдзен). Анализируйте результаты (Шаг 2). Вносите изменения в код (Шаг 3). Повторите (Шаг 4).",
        "recommendationsTitle": "Рекомендации:",
        "recommendationsContent": "Избегайте синхронных операций, блокирующих основной поток Node.js. Используйте асинхронные API. Оптимизируйте циклы, работу с большими массивами/объектами."
      },
      "caching": {
        "title": "7. Кэширование (Redis): Снижение Нагрузки на БД и Ускорение (Принцип 9)",
        "intro": "Кэширование позволяет хранить часто запрашиваемые данные в быстрой памяти (Redis), чтобы не обращаться к более медленной БД (Neon) при каждом запросе. Это ключевой <strong>рычаг</strong> для повышения <strong>эффективности системы</strong> (Принцип 9).",
        "libraryTitle": "Библиотека:",
        "libraryContent": "`ioredis`, `@nestjs/cache-manager`, `cache-manager-redis-store`.",
        "patternTitle": "Pаттерн:",
        "patternContent": "Cache-Aside (чтение из кэша, если нет — чтение из БД и запись в кэш).",
        "applicationAreasTitle": "Области применения:",
        "applicationAreasContent": "Часто запрашиваемые, относительно редко изменяющиеся данные (профили пользователей, настройки приложения, результаты сложных запросов/агрегаций, материализованных представлений).",
        "implementationTitle": "Реализация:",
        "implementationContent": "Настройте Redis в NestJS и используйте его в сервисах.",
        "invalidationTitle": "Ключевой аспект:",
        "invalidationContent": "<strong>Инвалидация кэша</strong>. При изменении данных в БД, удаляйте соответствующие ключи из Redis, чтобы клиенты не получали устаревшие данные."
      },
      "asyncProcessing": {
        "title": "8. Асинхронная Обработка (Kafka): Надежность и Отзывчивость (Принцип 9, 2)",
        "intro": "Используйте <strong>Kafka</strong> для выполнения задач, которые не требуют немедленного ответа пользователю (отправка email, обработка изображений, нотификации, аналитика).",
        "libraryTitle": "Библиотека:",
        "libraryContent": "`kafkajs`.",
        "whyTitle": "Почему:",
        "whyContent": "Kafka — <strong>надежная распределенная система очередей</strong>, гарантирующая доставку сообщений и позволяющая масштабировать обработку задач независимо от основного API (воркеры-консьюмеры).",
        "applicationAreasTitle": "Области применения:",
        "applicationAreasContent": [
          "Обработка изображений/видео после загрузки.",
          "Отправка больших объемов push-уведомлений.",
          "Генерация отчетов или статистики.",
          "Архивирование старых сообщений/файлов."
        ],
        "patternTitle": "Паттерн:",
        "patternContent": "<strong>Producer-Consumer</strong>. Backend-API ставит задачи в топик Kafka (Producer). Отдельные сервисы/воркеры (Consumer) читают задачи из топика и выполняют их в фоновом режиме.",
        "partitioningTitle": "Партиционирование в Kafka:",
        "partitioningContent": "Используйте ключи сообщений (например, `userId`, `chatId`), чтобы сообщения, относящиеся к одному пользователю/чату, попадали в одну партицию. Это гарантирует порядок обработки внутри партиции, что может быть важно для некоторых задач.",
        "monitoringTitle": "Мониторинг:",
        "monitoringContent": "Используйте <strong>Kafdrop</strong> для визуального мониторинга топиков, сообщений и состояния консьюмер-групп."
      },
      "pushNotificationsOptimization": {
        "title": "9. Оптимизация Push-уведомлений (Firebase FCM): Эффективная Доставка Информации (Принцип 2)",
        "intro": "Push-уведомления — важный канал связи с пользователем (Принцип 2: Ценность). Оптимизация их доставки важна для пользовательского опыта.",
        "platformTitle": "Платформа:",
        "platformContent": "Firebase Cloud Messaging (FCM).",
        "techniquesTitle": "Техники:",
        "techniquesContent": [
          "<strong>Батчинг:</strong> Отправляйте несколько уведомлений одним вызовом API FCM (`sendMulticast`) для снижения сетевых накладных расходов.",
          "<strong>Темы (Topics):</strong> Используйте темы для массовых рассылок (например, уведомление о новом сообщении в канале), чтобы FCM управлял списком подписчиков.",
          "<strong>Data Messages:</strong> Используйте Data Messages для полного контроля над отображением уведомления на клиенте и возможности прикреплять кастомные данные."
        ]
      },
      "clientApiDbInteraction": {
        "title": "10. Оптимизация Взаимодействия Клиент-API-БД: Сокращение Пути Данных (Принцип 9)",
        "intro": "",
        "clientLevelTitle": "На Уровне Клиента:",
        "clientLevelContent": "Используйте библиотеки для управления состоянием и кэширования данных, полученных по сети (`@apollo/client`, `react-query`/`@tanstack/react-query`). Это позволяет избежать повторных запросов за одними и теми же данными и быстро показывать кэшированные данные.",
        "networkLevelTitle": "На Уровне Сети:",
        "networkLevelContent": "Включите современные протоколы (HTTP/2, HTTP/3) и сжатие (Gzip/Brotli) на вашем API Gateway или Backend сервере для уменьшения объема передаваемых данных и снижения задержки.",
        "backendLevelTitle": "На Уровне Backend:",
        "backendLevelContent": "Оптимизируйте взаимодействие с БД (раздел 4) и внешними сервисами (раздел 7)."
      },
      "authenticationOptimization": {
        "title": "11. Оптимизация Аутентификации: Быстрота и Безопасность",
        "intro": "",
        "statelessJwtTitle": "Stateless (JWT):",
        "statelessJwtContent": "Использование JWT снижает нагрузку на сервер, так как ему не нужно хранить состояние сессий пользователей.",
        "rateLimitingTitle": "Rate Limiting (`@nestjs/throttler`):",
        "rateLimitingContent": "Защита эндпоинтов аутентификации от Brute Force атак, что также снижает нагрузку.",
        "secureHeadersTitle": "Безопасные Заголовки (`helmet`):",
        "secureHeadersContent": "Добавление HTTP-заголовков для защиты от XSS, CSRF и других атак."
      },
      "chatWebSocketOptimization": {
        "title": "12. Оптимизация Чатов (WebSocket): Низкая Задержка и Масштабирование",
        "intro": "WebSocket используется для обмена сообщениями в реальном времени. <strong>Оптимизация WebSocket-соединений критична для отзывчивости чатов</strong> (Принцип 2).",
        "libraryTitle": "Библиотека:",
        "libraryContent": "NestJS Gateways (`@nestjs/websockets`), Socket.IO (если нужна кросс-браузерная совместимость и fallback).",
        "techniquesTitle": "Техники:",
        "techniquesContent": [
          "<strong>Бинарные Форматы:</strong> Передача сообщений в бинарном формате (например, MessagePack) вместо текстового JSON может уменьшить объем данных.",
          "<strong>Батчинг Сообщений:</strong> Буферизируйте сообщения на клиенте и сервере и отправляйте их пачками (например, каждые 50 мс), а не по одному. Снижает количество пакетов.",
          "<strong>Управление Присутствием:</strong> Используйте Redis для быстрого отслеживания статуса онлайн/офлайн пользователей. Heartbeats (пинг-понг) для поддержания соединения и обнаружения отключений.",
          "<strong>Вертикальное/Горизонтальное Масштабирование:</strong> NestJS Gateways могут работать в кластерном режиме. Используйте Redis или другой Pub/Sub механизм (например, Kafka) для обмена сообщениями между инстансами Backend, чтобы сообщения доставлялись всем подписчикам, независимо от того, к какому инстансу Backend они подключены."
        ]
      },
      "animationsOptimization": {
        "title": "13. Оптимизация Анимаций: Плавность и Производительность (Принцип 3, 5)",
        "intro": "Производительные анимации делают интерфейс <strong>качественным</strong> (Принцип 3) и снижают нагрузку на устройство (Принцип 5: Здоров'я).",
        "mobileDesktopTitle": "Mobile-Desktop (React Native):",
        "mobileDesktopContent": "Используйте `react-native-reanimated` для анимаций, которые выполняются на нативном потоке, не блокируя поток JavaScript.",
        "webTitle": "Web (Next.js):",
        "webContent": "Используйте `framer-motion` для декларативного создания плавных анимаций.",
        "docDesignTitle": "DocDesign:",
        "docDesignContent": "В DocDesign описаны принципы и параметры анимаций, включая возможность их отключения пользователем (Принцип 12: Прагматизм)."
      },
      "monitoring": {
        "title": "14. Моніторинг з Prometheus та Grafana: Вимірювання як Основа Кайдзен (Принцип 9)",
        "intro": "Система моніторингу — це ваші <strong>глаза</strong> и <strong>измерительные инструменты</strong> (Шаг 1 Кайдзен).",
        "toolsTitle": "Инструменты:",
        "toolsContent": "Prometheus (сбор метрик), Grafana (визуализация), Alertmanager (уведомления об аномалиях).",
        "whenTitle": "Когда использовать:",
        "whenContent": "Всегда. Настройте мониторинг на всех уровнях: Backend (задержки API, ошибки), БД (время запросов, нагрузка), Redis (попадания в кэш, использование памяти), Kafka (количество сообщений в топиках, лаг консьюмеров), Инфраструктура (CPU, RAM, сеть).",
        "implementationTitle": "Реализация:",
        "implementationContent": "См. подробные шаги по настройке в Руководстве по разработке (раздел 14).",
        "principleTitle": "Принцип:",
        "principleContent": "Используйте метрики для <strong>выявления узких мест</strong> (Шаг 2 Кайдзен) и оценки <strong>эффективности</strong> (Принцип 9) ваших оптимизаций. Настройте <strong>алерты</strong> для проактивного обнаружения проблем."
      },
      "ciCdOptimization": {
        "title": "15. Оптимізація CI/CD: Ускорение Цикла Разработки (Принцип 9)",
        "intro": "Эффективный CI/CD пайплайн ускоряет доставку кода, что является частью <strong>оптимизации всего процесса разработки</strong> (Принцип 9).",
        "toolsTitle": "Инструменты:",
        "toolsContent": "Turborepo (кэширование, параллелизация), GitHub Actions (автоматизация).",
        "techniquesTitle": "Техники:",
        "techniquesContent": [
          "<strong>Кэширование с Turborepo:</strong> Кэшируйте результаты сборки и тестов между запусками в CI и локально.",
          "<strong>Параллельное выполнение:</strong> Запускайте задачи (lint, build, test) для разных пакетов или частей тестов параллельно.",
          "<strong>Оптимизация Docker-образов:</strong> Используйте многоступенчатую сборку и `.dockerignore` для уменьшения размера образов и ускорения сборки/деплоя."
        ]
      },
      "frontendOptimization": {
        "title": "16. Оптимізація Фронтенда: Быстрота и Отзывчивость для Пользователя (Принцип 2, 3)",
        "intro": "Фронтенд должен быть <strong>быстрым и отзывчивым</strong>, чтобы пользователь ощутил <strong>ценность</strong> (Принцип 2) продукта.",
        "webTechniquesTitle": "Техники (Web - Next.js):",
        "webTechniquesContent": [
          "<strong>Code Splitting / Dynamic Imports:</strong> Загружайте код только тогда, когда он нужен (`next/dynamic`).",
          "<strong>SSR/SSG:</strong> Используйте серверный рендеринг или генерацию статики для ускорения первой отрисовки и SEO (`getStaticProps`, `getServerSideProps`).",
          "<strong>Оптимизация Изображений:</strong> Используйте `next/image` или `<picture>` и современные форматы (WebP).",
          "<strong>Анализ Бандла:</strong> Используйте `@next/bundle-analyzer` для выявления самых тяжелых модулей."
        ],
        "reactNativeTechniquesTitle": "Техники (React Native):",
        "reactNativeTechniquesContent": [
          "<strong>Ленивая Загрузка:</strong> Используйте `React.lazy` и `Suspense` для экранов и компонентов, которые не нужны при старте.",
          "<strong>Производительные Списки:</strong> Используйте `FlatList` или `SectionList` с правильной настройкой (`getItemLayout`, `windowSize`) для больших списков сообщений или чатов.",
          "<strong>Оптимизация Изображений:</strong> Используйте `react-native-fast-image`.",
          "<strong>Профилирование:</strong> Используйте Performance Monitor в Debugger Menu React Native для выявления узких мест UI."
        ],
        "generalTechniquesTitle": "Общие техники:",
        "generalTechniquesContent": [
          "Удаление неиспользуемого кода (Tree Shaking), замена тяжелых библиотек на легкие аналоги (например, `dayjs` вместо `moment`), сжатие бандлов (Gzip/Brotli)."
        ]
      },
      "dbScaling": {
        "title": "17. Масштабирование Базы Данных (Репликация и Шардинг): Подготовка к Росту (Принцип 8)",
        "intro": "Эти техники становятся актуальными при значительном росте объема данных и нагрузки. Они являются частью <strong>долгосрочной стратегии масштабирования</strong> (Принцип 8).",
        "replicationTitle": "Репликация (Master-Slave):",
        "replicationContent": "Создание копий БД только для чтения (read replicas). Позволяет распределить нагрузку на чтение.",
        "shardingTitle": "Шардинг:",
        "shardingContent": "Разделение данных большой таблицы на части (шарды) по определенному ключу (`chatId`, `userId`), распределяя их по разным серверам. Позволяет масштабировать как чтение, так и запись. Реализуется логически (в приложении) или с помощью расширений (Citus для PostgreSQL).",
        "whenToApplyTitle": "Когда применять:",
        "whenToApplyContent": "Основываясь на <strong>измерениях</strong> нагрузки и производительности БД (Принцип 9), а не заранее."
      },
      "notes": {
        "title": "18. Примечания: Непрерывный Кайдзен в Оптимизации",
        "prioritizationTitle": "Приоритезация:",
        "prioritizationContent": "Начинайте оптимизацию с тех мест, которые приносят наибольший эффект на текущем этапе проекта (Принцип 12). Для MVP это может быть скорость загрузки Frontend, производительность основных API-запросов.",
        "automationTitle": "Автоматизация:",
        "automationContent": "Максимально автоматизируйте процессы измерения и проверки оптимизаций (CI/CD, алерты в мониторинге) — это часть <strong>Системы</strong> (Принцип 9).",
        "documentationNotesTitle": "Документирование:",
        "documentationNotesContent": "Фиксируйте проведенные оптимизации, их эффект и уроки в этой документации или в задачах/коммитах (Принцип 1: Обучение, Принцип 9: Кайдзен).",
        "cultureTitle": "Культура:",
        "cultureContent": "Создайте культуру, где каждый разработчик несет ответственность за производительность своего кода и активно участвует в поиске и устранении узких мест (Принцип 6)."
      }
    },
    "apiSpec": {
      "title": "Специфікація API BrainMessenger (Інтерфейс Системи)",
      "subtitle": "Інтерфейс Системи",
      "generalInfo": {
        "title": "1. Загальна Інформація: API як Точка Взаємодії з Системою",
        "description": "Цей документ описує GraphQL API BrainMessenger — <strong>основний інтерфейс</strong> (Принцип 9), через який клієнтські додатки (Web, Mobile, Desktop) взаємодіють з серверною частиною системи та отримують доступ до даних і функціональності. GraphQL обраний за його <strong>ефективність і гнучкість</strong> (Принцип 9, 2), дозволяючи клієнтам запитувати лише ті дані, які їм необхідні.",
        "projectNameTitle": "Назва проекту:",
        "projectNameContent": "BrainMessenger",
        "apiPurposeTitle": "Мета:",
        "apiPurposeContent": "Надати чіткий і повний опис доступних запитів (Queries) і мутацій (Mutations), їх вхідних і вихідних даних, а також правил автентифікації та форматів помилок. Це забезпечує <strong>системність</strong> (Принцип 9) взаємодії між Frontend і Backend та підвищує <strong>якість</strong> (Принцип 3) розробки.",
        "baseUrlTitle": "Базовий URL:",
        "baseUrlContent": "`https://api.brainmessenger.com/graphql` (адреса API Gateway, який перенаправляє запити на Backend Service).",
        "requestFormatTitle": "Формат запитів:",
        "requestFormatContent": "GraphQL-запити (POST-запити з `Content-Type: application/json` та тілом у форматі GraphQL).",
        "authenticationTitle": "Автентифікація:",
        "authenticationContent": "JWT-токени в заголовку `Authorization: Bearer <token>`. Токен отримується після успішного логіна. Це частина нашої <strong>системи безпеки</strong> (Принцип 3, 5).",
        "relatedDocsTitle": "Зв'язок з іншими документами:",
        "relatedDocsContent": [
          "DocTech.md: Загальна архітектура системи, включаючи Backend і API Gateway.",
          "DocDevIn.md: Деталі реалізації Backend на NestJS і GraphQL.",
          "DocInt.md: Опис інтеграцій, які Backend використовує (Neon, R2, Firebase та ін.).",
          "DocOptimizationIn.md: Підходи до оптимізації продуктивності API."
        ]
      },
      "graphqlSchema": {
        "title": "2. Схема GraphQL: Структура Доступних Даних та Операцій",
        "description": "Повна схема GraphQL доступна за адресою API через інструменти інтроспекції (наприклад, GraphQL Playground, Apollo Studio). Нижче наведено основні типи та операції.",
        "dataTypes": {
          "title": "2.1. Типи Даних (Schemas): Опис Структури Інформації",
          "user": {
            "title": "User:",
            "code": "type User {\n  id: ID!\n  email: String!\n  name: String!\n  avatarUrl: String # URL аватара користувача (зберігається в R2)\n  createdAt: DateTime!\n  updatedAt: DateTime!\n  # ... інші поля (наприклад, статус онлайн/офлайн)\n}"
          },
          "chat": {
            "title": "Chat:",
            "code": "type Chat {\n  id: ID!\n  name: String! # Назва чату (для груп/каналів)\n  type: String! # Тип чату (\"personal\", \"group\", \"channel\")\n  users: [User!] # Список учасників чату\n  messages(pagination: PaginationInput): [Message!] # Повідомлення в чаті (з пагінацією)\n  lastMessageAt: DateTime # Час останнього повідомлення (для сортування списку чатів)\n  createdAt: DateTime!\n  updatedAt: DateTime!\n  # ... інші поля (наприклад, фото групи/каналу, опис)\n}"
          },
          "message": {
            "title": "Message:",
            "code": "type Message {\n  id: ID!\n  content: String! # Текст повідомлення (для текстових повідомлень)\n  fileUrl: String # URL файлу, якщо повідомлення є файлом (зберігається в R2)\n  fileMetadata: JSON # Метадані файлу (тип, розмір, ім'я) (зберігається в Neon/R2)\n  sender: User! # Відправник повідомлення\n  chat: Chat! # Чат, якому належить повідомлення\n  createdAt: DateTime! # Час відправлення повідомлення\n  updatedAt: DateTime!\n  # ... інші поля (наприклад, статус прочтення, реакції)\n}"
          },
          "paginationInput": {
            "title": "PaginationInput:",
            "code": "input PaginationInput {\n  take: Int # Максимальна кількість елементів\n  skip: Int # Пропустити елементів (для offset-based пагінації)\n  cursor: String # Курсор (ID) для cursor-based пагінації\n}"
          },
          "authPayload": {
            "title": "AuthPayload:",
            "code": "type AuthPayload {\n  token: String! # JWT токен доступу\n  user: User! # Дані автентифікованого користувача\n}"
          },
          "dateTimeJson": {
            "title": "DateTime, JSON:",
            "content": "Стандартні скалярні типи або кастомні скаляри, визначені на Backend."
          }
        },
        "operations": {
          "title": "2.2. Операції (Queries та Mutations): Доступ до Функціоналу Системи",
          "authentication": {
            "title": "2.2.1. Автентифікація (Authentication)",
            "registerUser": {
              "title": "`mutation registerUser(input: RegisterInput!): AuthPayload!`",
              "description": "Реєструє нового користувача в системі.",
              "input": "`RegisterInput`: `{ email: String!, password: String!, name: String! }` (password min 8 chars, digit, special char - див. валідацію).",
              "authRequired": "Потрібна автентифікація: Ні.",
              "scenario": "Сценарій: Користувач заповнює форму реєстрації.",
              "errors": "Помилки: `400 Bad Request` (невірний формат даних/валідація), `409 Conflict` (email вже використовується)."
            },
            "loginUser": {
              "title": "`mutation loginUser(input: LoginInput!): AuthPayload!`",
              "description": "Автентифікує користувача за email та паролем.",
              "input": "`LoginInput`: `{ email: String!, password: String! }`.",
              "authRequired": "Потрібна автентифікація: Ні.",
              "scenario": "Сценарій: Користувач вводить облікові дані для входу.",
              "errors": "Помилки: `401 Unauthorized` (невірний email або пароль)."
            },
            "logoutUser": {
              "title": "`mutation logoutUser: Boolean!`",
              "description": "Інвалідує поточний JWT токен на сервері (якщо реалізовано зберігання токенів або їх чорних списків).",
              "authRequired": "Потрібна автентифікація: Так (використовується поточний токен).",
              "scenario": "Сценарій: Користувач натискає \"Вийти\".",
              "returns": "Повертає: `true` при успішному виході.",
              "errors": "Помилки: `401 Unauthorized` (токен недійсний)."
            }
          },
          "user": {
            "title": "2.2.2. Користувач (User)",
            "getUser": {
              "title": "`query getUser(id: ID!): User`",
              "description": "Отримує дані користувача за його унікальним ID.",
              "authRequired": "Потрібна автентифікація: Так (для доступу до будь-яких даних користувача, крім, можливо, публічного профілю).",
              "scenario": "Сценарій: Перегляд профілю користувача.",
              "errors": "Помилки: `404 Not Found` (користувача з таким ID не знайдено)."
            },
            "getCurrentUser": {
              "title": "`query getCurrentUser: User!`",
              "description": "Отримує дані поточного автентифікованого користувача.",
              "authRequired": "Потрібна автентифікація: Так.",
              "scenario": "Сценарій: Завантаження профілю поточного користувача при старті додатку.",
              "errors": "Помилки: `401 Unauthorized`."
            },
            "updateUser": {
              "title": "`mutation updateUser(id: ID!, input: UserInput!): User!`",
              "description": "Оновлює дані профілю користувача.",
              "input": "`UserInput`: `{ name: String, email: String, password: String, avatarUrl: String }`. Поля опціональні.",
              "authRequired": "Потрібна автентифікація: Так (і користувач повинен бути власником профілю або мати права адміністратора).",
              "scenario": "Сценарій: Користувач редагує свій профіль.",
              "errors": "Помилки: `400 Bad Request` (невірний формат даних), `401 Unauthorized`, `403 Forbidden` (немає прав на редагування цього користувача), `404 Not Found`."
            },
            "deleteUser": {
              "title": "`mutation deleteUser(id: ID!): Boolean!`",
              "description": "Видаляє обліковий запис користувача.",
              "authRequired": "Потрібна автентифікація: Так (і користувач повинен бути власником облікового запису).",
              "scenario": "Сценарій: Користувач вирішує видалити свій обліковий запис.",
              "returns": "Повертає: `true` при успішному видаленні.",
              "errors": "Помилки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            }
          },
          "chats": {
            "title": "2.2.3. Чати (Chats)",
            "getChats": {
              "title": "`query getChats: [Chat!]!`",
              "description": "Отримує список усіх чатів, в яких бере участь поточний користувач.",
              "authRequired": "Потрібна автентифікація: Так.",
              "scenario": "Сценарій: Завантаження списку чатів на головному екрані.",
              "errors": "Помилки: `401 Unauthorized`."
            },
            "getChat": {
              "title": "`query getChat(id: ID!): Chat`",
              "description": "Отримує дані конкретного чату за ID.",
              "authRequired": "Потрібна автентифікація: Так (і користувач повинен бути учасником цього чату).",
              "scenario": "Сценарій: Відкриття конкретного чату.",
              "errors": "Помилки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            },
            "createChat": {
              "title": "`mutation createChat(input: CreateChatInput!): Chat!`",
              "description": "Створює новий чат.",
              "input": "`CreateChatInput`: `{ type: String!, name: String, userIds: [ID!]! }`. `type` може бути \"personal\", \"group\", \"channel\". `name` обов'язковий для \"group\" і \"channel\". `userIds` включає ID творця та інших учасників (для \"personal\" і \"group\").",
              "authRequired": "Потрібна автентифікація: Так.",
              "scenario": "Сценарій: Користувач створює новий чат або групу.",
              "errors": "Помилки: `400 Bad Request` (невірний тип, відсутні userIds тощо), `401 Unauthorized`, `403 Forbidden` (немає прав на створення такого типу чату)."
            },
            "getMessages": {
              "title": "`query getMessages(chatId: ID!, pagination: PaginationInput): [Message!]!`",
              "description": "Отримує список повідомлень для заданого чату. Підтримує пагінацію.",
              "authRequired": "Потрібна автентифікація: Так (і користувач повинен бути учасником чату).",
              "scenario": "Сценарій: Відкриття чату, підвантаження старих повідомлень при прокручуванні.",
              "errors": "Помилки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            },
            "sendMessage": {
              "title": "`mutation sendMessage(chatId: ID!, content: String!, fileUrl: String, fileMetadata: JSON): Message!`",
              "description": "Відправляє нове повідомлення в чат. Може містити текст або посилання на файл.",
              "input": "`chatId`: ID чату. `content`: Текст повідомлення. `fileUrl`: URL файлу в R2 (опціонально). `fileMetadata`: Метадані файлу (опціонально).",
              "authRequired": "Потрібна автентифікація: Так (і користувач повинен бути учасником чату).",
              "scenario": "Сценарій: Користувач відправляє текстове повідомлення або файл.",
              "errors": "Помилки: `400 Bad Request`, `401 Unauthorized`, `403 Forbidden` (немає прав писати в цей чат), `404 Not Found` (чат не знайдено)."
            },
            "deleteMessage": {
              "title": "`mutation deleteMessage(messageId: ID!): Boolean!`",
              "description": "Видаляє повідомлення.",
              "authRequired": "Потрібна автентифікація: Так (і користувач повинен бути відправником повідомлення або мати права адміністратора чату).",
              "scenario": "Сценарій: Користувач видаляє своє повідомлення.",
              "returns": "Повертає: `true` при успішному видаленні.",
              "errors": "Помилки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            }
          },
          "externalIntegrations": {
            "title": "2.2.4. Зовнішні Інтеграції (через API Backend)",
            "sendVerificationCode": {
              "title": "`mutation sendVerificationCode(email: String!): Boolean!`",
              "description": "Запускає процес відправлення коду підтвердження на вказаний email (використовуючи Gmail API). Використовується при реєстрації або скиданні пароля.",
              "authRequired": "Потрібна автентифікація: Ні.",
              "scenario": "Сценарій: Користувач вводить email на екрані реєстрації/відновлення пароля.",
              "returns": "Повертає: `true` при успішній постановці задачі на відправлення.",
              "errors": "Помилки: `400 Bad Request` (невірний формат email), `429 Too Many Requests` (захист від спаму)."
            },
            "verifyEmailCode": {
              "title": "`mutation verifyEmailCode(email: String!, code: String!): Boolean!`",
              "description": "Перевіряє код підтвердження, отриманий по email.",
              "authRequired": "Потрібна автентифікація: Ні.",
              "scenario": "Сценарій: Користувач вводить код з email.",
              "returns": "Повертає: `true` при успішній перевірці.",
              "errors": "Помилки: `400 Bad Request` (невірний код або email), `404 Not Found` (для даного email немає активного коду)."
            },
            "enableTwoFactorAuth": {
              "title": "`mutation enableTwoFactorAuth(userId: ID!): Boolean!`",
              "description": "Вмикає/вимикає двофакторну автентифікацію для користувача. Потребує попередньої верифікації email. Код для 2FA відправляється на email (Gmail API) при кожному логіні після ввімкнення.",
              "authRequired": "Потрібна автентифікація: Так (користувач повинен керувати своїм обліковим записом).",
              "scenario": "Сценарій: Користувач налаштовує безпеку облікового запису.",
              "errors": "Помилки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`, `400 Bad Request` (email не верифіковано)."
            },
            "disableTwoFactorAuth": {
              "title": "`mutation disableTwoFactorAuth(userId: ID!): Boolean!`",
              "description": "Вмикає/вимикає двофакторну автентифікацію для користувача. Потребує попередньої верифікації email. Код для 2FA відправляється на email (Gmail API) при кожному логіні після ввімкнення.",
              "authRequired": "Потрібна автентифікація: Так (користувач повинен керувати своїм обліковим записом).",
              "scenario": "Сценарій: Користувач налаштовує безпеку облікового запису.",
              "errors": "Помилки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`, `400 Bad Request` (email не верифіковано)."
            },
            "sendTwoFactorCode": {
              "title": "`mutation sendTwoFactorCode(userId: ID!): Boolean!`",
              "description": "Відправляє код двофакторної автентифікації на email користувача.",
              "authRequired": "Потрібна автентифікація: Часткова (наприклад, після введення пароля, але до введення 2FA коду). Логіка залежить від флоу автентифікації.",
              "scenario": "Сценарій: Користувач входить в обліковий запис з увімкненою 2FA.",
              "errors": "Помилки: `404 Not Found` (користувача не знайдено або 2FA не ввімкнено), `429 Too Many Requests`."
            },
            "createPaymentSession": {
              "title": "`mutation createPaymentSession(input: PaymentInput!): PaymentSessionPayload!`",
              "description": "Створює сесію оплати через Stripe для оформлення Premium підписки.",
              "input": "`PaymentInput`: `{ planId: ID!, returnUrl: String! }` (ID обраного тарифного плану, URL для редиректу після оплати).",
              "authRequired": "Потрібна автентифікація: Так.",
              "scenario": "Сценарій: Користувач натискає \"Підписатися\" на Premium екрані.",
              "errors": "Помилки: `400 Bad Request` (невірний planId), `401 Unauthorized`."
            }
          }
        }
      },
      "errorHandling": {
        "title": "3. Обробка Помилок API: Ясна Зворотній Зв'язок (Принцип 3, 14)",
        "description": "API повертає стандартизовані помилки для <strong>ясної зворотного зв'язку</strong> (Принцип 14) з клієнтом та підтримання <strong>якості</strong> (Принцип 3).",
        "errorFormatTitle": "Формат помилок (відповідно до специфікації GraphQL):",
        "errorFormatCode": "{\n  \"data\": null, // Зазвичай null при помилках верхнього рівня\n  \"errors\": [\n    {\n      \"message\": \"Опис помилки (може бути локалізовано - див. DocLocIn)\",\n      \"locations\": [...], // Розташування помилки в запиті\n      \"path\": [...],      // Шлях до поля, що викликало помилку\n      \"extensions\": {\n        \"code\": \"КОД_ПОМИЛКИ\", // Стандартизований код помилки (наприклад, \"UNAUTHENTICATED\", \"FORBIDDEN\", \"BAD_USER_INPUT\", \"NOT_FOUND\")\n        \"http\": { // Якщо застосовно, HTTP статус код\n          \"status\": 401,\n          \"headers\": {}\n        },\n         \"details\": {} // Додаткові деталі про помилку (опціонально)\n      }\n    }\n    // ... можуть бути інші помилки\n  ]\n}",
        "keyErrorCodesTitle": "Ключові коди помилок (extensions.code):",
        "keyErrorCodesList": [
          "`UNAUTHENTICATED`: Потрібна автентифікація, але токен відсутній або недійсний (`HTTP 401`).",
          "`FORBIDDEN`: Автентифікація пройдена, але у користувача немає прав на виконання операції (`HTTP 403`).",
          "`BAD_USER_INPUT`: Помилка валідації вхідних даних (`HTTP 400`). Деталі можуть бути в `extensions.details`.",
          "`NOT_FOUND`: Запитуваний ресурс не знайдено (`HTTP 404`).",
          "`CONFLICT`: Конфлікт даних (наприклад, спроба зареєструвати email, який вже існує) (`HTTP 409`).",
          "`INTERNAL_SERVER_ERROR`: Неочікувана помилка на сервері (`HTTP 500`).",
          "`RATE_LIMITED`: Перевищено ліміт запитів (`HTTP 429`)."
        ],
        "localizationErrorsTitle": "Локалізація помилок:",
        "localizationErrorsContent": "Повідомлення про помилки (`message`) можуть бути локалізовані на стороні Backend на основі заголовка `Accept-Language` або переваг користувача (див. DocLocIn)."
      },
      "notes": {
        "title": "4. Примітки",
        "dataTypes": {
          "title": "Типи даних:",
          "list": [
            "`ID`: Унікальний ідентифікатор ресурсу (зазвичай рядок).",
            "`String`: Текстовий рядок.",
            "`Int`, `Float`: Числа.",
            "`Boolean`: Логічне значення (`true`/`false`).",
            "`DateTime`: Дата і час у форматі ISO 8601 (наприклад, \"2025-03-14T10:30:00Z\").",
            "`JSON`: Кастомний скаляр для передачі довільних JSON-об'єктів (наприклад, для `fileMetadata`).",
            "`!` в кінці типу означає, що поле <strong>не може бути null</strong>."
          ]
        },
        "pagination": {
          "title": "Пагінація:",
          "content": "Для списків, які можуть бути довгими (`messages`), використовуйте пагінацію для ефективної завантаження даних (Принцип 9)."
        },
        "validation": {
          "title": "Валідація:",
          "content": "Backend виконує строгу валідацію всіх вхідних даних (через DTO і `class-validator`), повертаючи помилки `BAD_USER_INPUT` при їх некоректності. Це частина <strong>системи забезпечення якості</strong> (Принцип 3)."
        },
        "security": {
          "title": "Безпека:",
          "content": "Всі запити, що працюють з чутливими даними або змінюють стан системи (крім реєстрації/логіна), потребують автентифікації."
        },
        "testingTools": {
          "title": "Інструменти тестування API:",
          "content": "Використовуйте GraphQL Playground (часто доступний за адресою `/graphql` в dev-режимі Backend), Postman або Apollo Studio для відправлення запитів та тестування API."
        }
      }
    },
    "technicalDocs": {
      "title": "BrainMessenger Technical Documentation (System and Foundation)",
      "subtitle": "General Information: Architecture of a Digital Asset",
      "generalInfo": {
        "title": "1. General Information: Architecture of a Digital Asset",
        "description": "BrainMessenger is a modern messenger built as a <strong>reliable, scalable, and secure system</strong> (Principle 9), which serves as a <strong>key digital ASSET</strong> (Principle 10). This document provides a high-level overview of the project's <strong>technical foundation</strong> (Principle 8), describing the main components, technologies, and their interaction.",
        "projectNameTitle": "Project Name:",
        "projectNameContent": "BrainMessenger",
        "purposeTitle": "Purpose:",
        "purposeContent": "To provide a general understanding of BrainMessenger's structure, the technology stack used, and the principles underlying its construction, for all team members and stakeholders.",
        "principlesTitle": "Principles reflected in the technical structure:",
        "principlesList": [
          "<strong>System and Optimization (Principle 9):</strong> The project is designed as a set of interconnected, optimized components.",
          "<strong>Long-Term Thinking (Principle 8):</strong> Selection of technologies and architecture considering future scaling and development needs.",
          "<strong>Quality > Quantity (Principle 3):</strong> Use of proven, reliable solutions and focus on code and infrastructure quality.",
          "<strong>Pragmatism and Realism (Principle 12):</strong> Use of ready-made services (Neon, R2, Firebase) where justified, instead of building everything from scratch.",
          "<strong>Value Creation (Principle 2):</strong> The technical structure aims to provide key messenger functions (communication, files, calls) at a high level."
        ]
      },
      "techStack": {
        "title": "2. Technology Stack: Tools for Building the System",
        "description": "We use a modern and flexible set of technologies, allowing us to effectively build and scale BrainMessenger.",
        "frontend": {
          "title": "Frontend (Client Applications):",
          "list": [
            "<strong>React Native (Android, Windows Desktop):</strong> A single codebase for mobile and desktop applications. Chosen for cross-platform compatibility and a large set of ready-made libraries.",
            "<strong>Next.js (Web):</strong> React-framework for web application with SSR/SSG support for performance and SEO.",
            "<strong>TypeScript:</strong> Strict typing for all Frontend code. Increases reliability and simplifies refactoring."
          ]
        },
        "backend": {
          "title": "Backend (Server Logic):",
          "list": [
            "<strong>Node.js:</strong> High-performance JavaScript/TypeScript runtime environment.",
            "<strong>NestJS:</strong> Modular framework for Node.js. Provides a structured architecture (modules, services, controllers/resolvers) and TypeScript support.",
            "<strong>GraphQL:</strong> API protocol. Allows clients to request exactly the data they need, reducing redundancy."
          ]
        },
        "databaseCaching": {
          "title": "Database and Caching:",
          "list": [
            "<strong>PostgreSQL (via Neon):</strong> Reliable relational DBMS. Used as the main storage for structured data (users, chats, messages, metadata). Neon provides a managed service with scaling and replication features.",
            "<strong>Prisma ORM:</strong> Tool for interacting with PostgreSQL from NestJS. Provides typing and query security.",
            "<strong>Redis:</strong> In-memory data store. Used for caching, Rate Limiting, managing WebSocket connection state (user presence)."
          ]
        },
        "fileStorage": {
          "title": "File Storage:",
          "list": [
            "<strong>Cloudflare R2:</strong> Object storage, compatible with S3 API. Used for storing user files (photos, videos, documents, avatars, call recordings), encrypted data. Chosen for low cost and no egress fees."
          ]
        },
        "asyncProcessing": {
          "title": "Asynchronous Processing:",
          "list": [
            "<strong>Kafka:</strong> Distributed message queue system. Used for reliable asynchronous task processing (e.g., image processing, sending notifications) outside the main API thread."
          ]
        },
        "infrastructureDeployment": {
          "title": "Infrastructure and Deployment:",
          "list": [
            "<strong>Docker:</strong> Application containerization. Provides isolation and portability.",
            "<strong>Kubernetes:</strong> Container orchestration. Manages deployment, scaling, and self-healing of services in a cluster.",
            "<strong>Terraform:</strong> Infrastructure as Code (IaC). Automates the creation and management of cloud resources."
          ]
        },
        "testingMonitoringLogging": {
          "title": "Testing, Monitoring, Logging:",
          "list": [
            "<strong>Jest, Cypress, Detox:</strong> Tools for unit, integration, and E2E testing.",
            "<strong>Prometheus, Grafana:</strong> Monitoring system. Collection and visualization of performance metrics and system status.",
            "<strong>Winston, Sentry:</strong> Logging and error tracking system."
          ]
        }
      },
      "architecture": {
        "title": "3. Project Architecture: Interconnection of System Components",
        "description": "BrainMessenger's architecture follows the principles of <strong>modularity and separation of concerns</strong> (Principle 9).",
        "clientApplications": {
          "title": "Client Applications (Frontend):",
          "list": [
            "Web (Next.js), Mobile & Desktop (React Native).",
            "Contain the user interface and user interaction logic.",
            "Interact with the Backend exclusively via <strong>GraphQL API</strong>.",
            "Can directly download files from Cloudflare R2 (if public access) or via Backend (if authentication or URL signing is required)."
          ]
        },
        "apiGateway": {
          "title": "API Gateway (In the future):",
          "content": "Single entry point for all client requests. Can perform authentication, Rate Limiting, routing to the necessary Backend services. At startup, the Backend itself acts as the Gateway."
        },
        "backendService": {
          "title": "Backend Service (NestJS):",
          "list": [
            "Main server component.",
            "Contains <strong>BrainMessenger's business logic</strong> (user management, chats, messages, calls, payments).",
            "Provides <strong>GraphQL API</strong> for client applications.",
            "Interacts with the <strong>Database (Neon/PostgreSQL via Prisma)</strong> for reading/writing structured data.",
            "Interacts with <strong>File Storage (Cloudflare R2)</strong> for uploading/retrieving files (via AWS SDK).",
            "Interacts with <strong>Cache (Redis)</strong> for fast operations.",
            "Queues tasks in <strong>Queue (Kafka)</strong> for asynchronous processing.",
            "Uses external services (Firebase, Stripe, Gmail API)."
          ]
        },
        "database": {
          "title": "Database (Neon/PostgreSQL):",
          "content": "Stores structured data. Scales independently."
        },
        "fileStorage": {
          "title": "File Storage (Cloudflare R2):",
          "content": "Stores unstructured binary data. Scales by volume."
        },
        "caching": {
          "title": "Caching (Redis):",
          "content": "Fast access to temporary data."
        },
        "messageQueue": {
          "title": "Message Queue (Kafka):",
          "content": "Buffering and reliable message delivery between services for asynchronous processing."
        },
        "workers": {
          "title": "Workers (Kafka Consumers):",
          "list": [
            "Separate services that read tasks from Kafka and perform heavy or long operations (image processing, sending large mailings).",
            "Scale independently."
          ]
        },
        "externalServices": {
          "title": "External Services (Firebase, Stripe, Gmail API):",
          "list": [
            "Provide specialized functionality (notifications, payments, email).",
            "Used by the Backend service."
          ]
        },
        "mermaidDiagram": {
          "title": "Architecture Diagram:",
          "code": "graph TD\n    A[Frontend Web (Next.js)] -->|GraphQL API| B(API Gateway / Backend);\n    A -->|Direct File Access (Opt.)| E(Cloudflare R2);\n    F[Frontend Mobile/Desktop (React Native)] -->|GraphQL API| B;\n    F -->|Direct File Access (Opt.)| E;\n    B -->|Prisma Queries/Mutations| C(Neon/PostgreSQL);\n    B -->|AWS SDK (S3 API)| E;\n    B -->|ioredis| D(Redis Cache);\n    B -->|kafkajs Producer| G(Kafka Queue);\n    B -->|Firebase Admin SDK| H(Firebase FCM);\n    B -->|Stripe SDK| I(Stripe);\n    B -->|Google APIs Client| J(Gmail API);\n    G -->|kafkajs Consumer| K(Kafka Workers);\n    K -->|sharp| K; % Image processing\n    K -->|AWS SDK (S3 API)| E;\n    K -->|GraphQL API / Other Service Calls| B; % Report completion, send chat message\n    C -->|Replication (for scaling)| C;\n    C -->|Partitioning/Sharding (for scaling)| C;\n    E -->|CDN| A; % File delivery to Frontend\n    Prometheus(Prometheus) -->|Scrape Metrics| B;\n    Prometheus -->|Scrape Metrics| C;\n    Prometheus -->|Scrape Metrics| D;\n    Prometheus -->|Scrape Metrics| G;\n    Grafana(Grafana) -->|Visualize Metrics| Prometheus;\n    Sentry(Sentry) -->|Error Reports| B;\n    Sentry -->|Error Reports| A;"
        }
      },
      "api": {
        "title": "4. API: Інтерфейс Взаємодії",
        "description": "API BrainMessenger реалізовано на GraphQL з використанням NestJS.",
        "endpointTitle": "Endpoint:",
        "endpointContent": "`/graphql`",
        "structureTitle": "Структура:",
        "structureContent": "Визначається GraphQL Схемою (типи User, Chat, Message тощо) та набором Queries (для отримання даних) і Mutations (для зміни даних).",
        "authenticationTitle": "Автентифікація:",
        "authenticationContent": "JWT-токени в заголовку `Authorization: Bearer <token>`.",
        "externalApiIntegrationsTitle": "Зовнішні API Інтеграції:",
        "externalApiIntegrationsContent": "Взаємодія із зовнішніми сервісами (Gmail, Stripe) здійснюється через Backend, який надає відповідні Mutations в GraphQL API (див. Специфікацію API).",
        "keyFunctionalAreas": {
          "title": "Ключові функціональні області API:",
          "list": [
            "Автентифікація (реєстрація, логін, логаут, 2FA).",
            "Управління користувачами (отримання/оновлення/видалення профілю).",
            "Управління чатами (створення, отримання списку, отримання даних чату).",
            "Робота з повідомленнями (надсилання текстових повідомлень, надсилання файлів, отримання історії).",
            "Управління контактами.",
            "Налаштування додатку (тема, сповіщення, мова).",
            "Управління Premium-підпискою.",
            "Управління файлами (завантаження в R2 через Backend).",
            "(У майбутньому) Дзвінки та відеодзвінки (управління сесіями дзвінків)."
          ]
        },
        "detailedSpecTitle": "Детальна специфікація API описана в:",
        "detailedSpecContent": "DocSpec.md"
      },
      "database": {
        "title": "5. База Даних (Neon/PostgreSQL): Сховище Основних Даних",
        "description": "",
        "technologyTitle": "Технологія:",
        "technologyContent": "PostgreSQL 15.x.",
        "hostingTitle": "Хостинг:",
        "hostingContent": "Neon.",
        "roleTitle": "Роль:",
        "roleContent": "Реляційна база даних для всіх структурованих даних.",
        "keyTables": {
          "title": "Ключові таблиці (визначені в backend/prisma/schema.prisma):",
          "list": [
            "User: Інформація про користувачів (id, email, password_hash, name, avatarUrl, createdAt, updatedAt, is2FaEnabled).",
            "Chat: Інформація про чати (id, type, name, createdAt, updatedAt, lastMessageAt).",
            "UserChat: Зв'язуюча таблиця для Many-to-Many зв'язку між User та Chat (userId, chatId, joinedAt, lastReadMessageId).",
            "Message: Повідомлення в чатах (id, chatId, senderId, content, fileUrl, fileMetadata (JSON), createdAt, updatedAt).",
            "Contact: Список контактів користувача (id, userId, contactId).",
            "Transaction: Історія платежів (для Premium) (id, userId, amount, currency, status, provider, createdAt).",
            "Code: Тимчасові коди (для email верифікації, 2FA) (id, userId/email, code, type, expiresAt)."
          ]
        },
        "interactionTitle": "Взаємодія:",
        "interactionContent": "Тільки Backend через Prisma ORM.",
        "optimizationScalingTitle": "Оптимізація та Масштабування:",
        "optimizationScalingContent": "Використовуються індекси, оптимізація запитів Prisma, матеріалізовані представлення, партиціонування, реплікація (див. DocOptimizationIn)."
      },
      "fileStorage": {
        "title": "6. Сховище Файлів (Cloudflare R2): Сховище Медіа та Бінарних Активів",
        "description": "",
        "technologyTitle": "Технологія:",
        "technologyContent": "Об'єктне сховище, S3-сумісний API.",
        "hostingTitle": "Хостинг:",
        "hostingContent": "Cloudflare R2.",
        "roleTitle": "Роль:",
        "roleContent": "Зберігання всіх неструктурованих даних (файли користувачів, аватарки, записи дзвінків).",
        "interactionTitle": "Взаємодія:",
        "interactionContent": "Backend завантажує файли, Backend або Frontend отримує файли (безпосередньо або через підписані URL).",
        "structureTitle": "Структура:",
        "structureContent": "Файли організовані за папками/ключами (наприклад, `avatars/`, `chat-images/`, `sensitive-data/`).",
        "securityTitle": "Безпека:",
        "securityContent": "Шифрування в спокої, обмежений доступ, шифрування чутливих даних на рівні додатку перед завантаженням (див. DocInt, DocSecurity)."
      },
      "projectStructure": {
        "title": "7. Проектна Структура (Монорепозиторій): Організація Коду",
        "description": "Проект організований як монорепозиторій з використанням Turborepo.",
        "purposeTitle": "Мета:",
        "purposeContent": "Спростити управління кількома додатками/пакетами (backend, web, mobile-desktop, core) та перевикористання коду.",
        "packages": {
          "title": "Пакети:",
          "list": [
            "core: Спільний код.",
            "backend: Серверна логіка.",
            "web: Веб-додаток.",
            "mobile-desktop: Мобільний/десктопний додаток (React Native).",
            "Інфраструктура: Файли конфігурації для розгортання (infrastructure/).",
            "Документація: Проектна документація (docs/)."
          ]
        },
        "detailedDescriptionTitle": "Детальний опис структури монорепозиторію див. у:",
        "detailedDescriptionContent": "DocDevIn.md (розділ 2)."
      },
      "security": {
        "title": "8. Безпека: Фундаментальний Аспект Системи",
        "description": "Безпека вбудована на всіх рівнях (див. докладніше в Посібнику з безпеки BrainMessenger).",
        "authenticationTitle": "Автентифікація:",
        "authenticationContent": "JWT, 2FA через email.",
        "authorizationTitle": "Авторизація:",
        "authorizationContent": "Перевірка прав доступу до ресурсів на Backend.",
        "encryptionTitle": "Шифрування:",
        "encryptionContent": "TLS/SSL для передачі даних, шифрування паролів (bcrypt/argon2), шифрування чутливих даних на рівні додатку перед зберіганням в R2.",
        "validationTitle": "Валідація:",
        "validationContent": "Сувора валідація вхідних даних на Backend.",
        "attackProtectionTitle": "Захист від Атак:",
        "attackProtectionContent": "Rate Limiting, безпечні HTTP-заголовки.",
        "principleTitle": "Принцип:",
        "principleContent": "Безпека — це постійний процес навчання (Принцип 1) та вдосконалення (Принцип 9), заснований на відповідальності (Принцип 6)."
      },
      "deployment": {
        "title": "9. Розгортання: Доставка Системи Користувачам",
        "description": "Процес розгортання автоматизований.",
        "containerizationTitle": "Контейнеризація:",
        "containerizationContent": "Docker-образи для Backend, Kafka Consumers.",
        "orchestrationTitle": "Оркестрація:",
        "orchestrationContent": "Kubernetes керує контейнерами в хмарі.",
        "iacTitle": "Інфраструктура як Код:",
        "iacContent": "Terraform (IaC). Автоматизує створення та управління хмарними ресурсами."
      },
      "monitoringLogging": {
        "title": "10. Моніторинг та Логування: Видимість Стану Системи",
        "description": "",
        "monitoringTitle": "Моніторинг:",
        "monitoringList": [
          "Збір та візуалізація метрик продуктивності та здоров'я системи (CPU, RAM, затримки API/БД, помилки).",
          "Інструменти: Prometheus, Grafana. Дозволяє виявляти проблеми на ранній стадії (Принцип 9: Кайдзен)."
        ],
        "loggingTitle": "Логування:",
        "loggingList": [
          "Збір структурованих логів від усіх компонентів (Backend, воркери).",
          "Інструменти: Winston (для Node.js), Sentry (для відстеження помилок)."
        ],
        "detailedDescriptionTitle": "Детальний опис див. у:",
        "detailedDescriptionList": [
          "Посібнику з оптимізації BrainMessenger (розділ 14)",
          "Посібнику з моніторингу"
        ]
      },
      "externalApiIntegrations": {
        "title": "11. Зовнішні API Інтеграції: Використання Зовнішніх Важелів",
        "description": "Backend взаємодіє з кількома зовнішніми сервісами через їх API.",
        "gmailApiTitle": "Gmail API:",
        "gmailApiContent": "Надсилання транзакційних email (підтвердження, 2FA).",
        "stripeTitle": "Stripe:",
        "stripeContent": "Обробка платежів та підписок.",
        "firebaseFCMTitle": "Firebase FCM:",
        "firebaseFCMContent": "Надсилання push-сповіщень на мобільні пристрої.",
        "principleTitle": "Принцип:",
        "principleContent": "Використання цих сервісів — прагматичний (Принцип 12) спосіб швидко додати функціонал, використовуючи готові, надійні (Принцип 3) рішення.",
        "detailedDescriptionTitle": "Детальний опис інтеграцій див. у:",
        "detailedDescriptionContent": "DocInt.md"
      },
      "notes": {
        "title": "12. Примітки",
        "description": "Ця документація надає високорівневий огляд технічної системи BrainMessenger. Для більш детального розуміння окремих частин звертайтеся до пов'язаних документів:",
        "apiSpecLinkTitle": "Специфікація API:",
        "apiSpecLinkContent": "DocSpec.md",
        "devGuideLinkTitle": "Посібник з розробки:",
        "devGuideLinkContent": "DocDevIn.md",
        "optimizationGuideLinkTitle": "Посібник з оптимізації:",
        "optimizationGuideLinkContent": "DocOptimizationIn.md",
        "integrationsDocsLinkTitle": "Документація інтеграцій:",
        "integrationsDocsLinkContent": "DocInt.md",
        "designDocsLinkTitle": "Документація дизайну:",
        "designDocsLinkContent": "DocDesign.md",
        "userGuideLinkTitle": "Посібник користувача:",
        "userGuideLinkContent": "DocUser.md",
        "longTermInvestmentTitle": "Розробка та підтримка цієї технічної системи — це довгострокова інвестиція (Принцип 8) та безперервний процес навчання та вдосконалення (Принцип 1, 9)."
      }
    },
    "uiDocs": {
    "generalInfo": {
      "title": "Загальна Інформація: UI як Обличчя Системи",
      "projectNameTitle": "Назва проекту:",
      "projectName": "BrainMessenger",
      "description": "Цей документ описує користувацький інтерфейс (UI) BrainMessenger. UI — це **обличчя нашої системи** (Принцип 9), через яке користувачі взаємодіють з програмою та сприймають її **цінність** (Принцип 2). Ми прагнемо створити UI, який буде **інтуїтивно зрозумілим, ефективним та доступним**, відображаючи принципи **якості > кількості** (Принцип 3) та **спрощення складного**.",
      "purposeTitle": "Мета:",
      "purpose": "Надати чіткий опис основних екранів, принципів навігації, використовуваних елементів UI, функціональних вимог до інтерфейсу та типових користувацьких сценаріїв. Це допомагає забезпечити **єдність** (Принцип 7) та **якість** (Принцип 3) користувацького досвіду на всіх платформах.",
      "principlesTitle": "Принципи, відображені в UI:",
      "principlesList": {
        "p2": "**Створення Цінності** (Принцип 2): UI сфокусований на наданні ключових функцій (спілкування, файли, дзвінки) максимально зручним способом.",
        "p3": "**Якість > Кількість** (Принцип 3): Перевага надається чистому дизайну з чіткою ієрархією елементів, а не перевантаженому інтерфейсу.",
        "p9": "**Система та Оптимізація** (Принцип 9): UI побудований на модульній системі компонентів і слідує чітким правилам вирівнювання та сітки (див. DocDesign). Навігація та робочі процеси оптимізовані.",
        "p8": "**Довгострокове Мислення** (Принцип 8): Дизайн враховує можливість додавання нового функціоналу в майбутньому, не порушуючи загальну структуру.",
        "p5": "**Здоров'я як Фундамент** (Принцип 5): Приділяється увага доступності (WCAG), використанню темної теми, налаштуванням анімацій для зниження навантаження на користувача.",
        "p12": "**Прагматизм та Реалізм** (Принцип 12): Дизайн враховує технічні обмеження та можливості кросплатформної розробки."
      }
    },
    "mainScreens": {
      "title": "Основні Екрани: Шлях Користувача по Системі",
      "welcomeScreen": {
        "title": "Welcome Screen",
        "purpose": "Представити BrainMessenger, його основні переваги та **цінність** (Принцип 2). Онбординг нових користувачів.",
        "elements": "Заголовок, короткий опис, слайдер з інформацією (переваги, функції, оновлення), кнопки \"Sign Up\" (Реєстрація) та \"Log In\" (Вхід).",
        "connection": "Використовує градієнт та шрифти з DocDesign для привернення уваги. Наявність слайдера з описом функціоналу — частина стратегії **створення цінності** (Принцип 2)."
      },
      "authScreens": {
        "title": "Екрани Автентифікації (Реєстрація / Вхід / Підтвердження коду / Скидання пароля)",
        "purpose": "Надати безпечний та зрозумілий процес доступу до системи.",
        "elements": "Поля вводу (Email, Пароль, Ім'я, Код), кнопки дії, посилання (\"Забули пароль?\").",
        "requirements": "Сувора валідація вводу (див. Функціональні вимоги), чіткі повідомлення про помилки. Пов'язано з **безпекою** (Принцип 5) та **якістю** (Принцип 3)."
      },
      "mainChatList": {
        "title": "Головний Екран (Список Чатів)",
        "purpose": "Забезпечити швидкий доступ до всіх поточних діалогів користувача.",
        "elements": "Список чатів (особисті, групові, канали) з короткою інформацією (назва, аватар, останнє повідомлення, час, лічильник непрочитаних), рядок пошуку, кнопка створення нового чату (\"+\"), доступ до головного меню (\"бургер\" або аватар).",
        "organization": "Чати сортуються за часом останнього повідомлення для **ефективності** (Принцип 9).",
        "actions": "Відкриття чату (кліком), архівування/видалення (свайпом або контекстним меню)."
      },
      "chatScreen": {
        "title": "Екран Чату",
        "purpose": "Забезпечити зручний обмін повідомленнями та файлами.",
        "elements": "Шапка чату (назва, аватар, кнопки дзвінка/відеодзвінка/інформації), область повідомлень, поле вводу повідомлення, кнопки прикріплення файлу/відправки/голосового повідомлення.",
        "messages": "Відображення текстових повідомлень, зображень, файлів. Індикатори статусу (відправлено, доставлено, прочитано).",
        "chatSettings": "Доступні через шапку чату (зміна теми, шрифту - див. розділ 13)."
      },
      "contactScreen": {
        "title": "Екран Контактів",
        "purpose": "Управління списком контактів та пошук нових користувачів.",
        "elements": "Список контактів, рядок пошуку, кнопка додавання нового контакту."
      },
      "profileSettings": {
        "title": "Налаштування Профілю",
        "purpose": "Дозволити користувачеві управляти своєю особистою інформацією та налаштуваннями облікового запису.",
        "elements": "Поля для редагування імені, email, пароля, завантаження аватара, опції безпеки (2FA), кнопка видалення облікового запису. Пов'язано з **відповідальністю** (Принцип 6) користувача за свої дані."
      },
      "appSettings": {
        "title": "Налаштування Програми",
        "purpose": "Налаштувати загальну поведінку програми під уподобання користувача.",
        "elements": "Розділи налаштувань (Повідомлення, Зовнішній вигляд/Тема, Мова, Батарея та Анімації, Сховище даних). Надання вибору підвищує **цінність** (Принцип 2)."
      },
      "premiumScreen": {
        "title": "Екран Premium",
        "purpose": "Пояснити переваги Premium-підписки та надати можливість її оформлення.",
        "elements": "Опис функцій Premium (наприклад, глітч-ефект, нейронні зв'язки в UI - див. DocDesign), інформація про тарифи, кнопка \"Підписатися\", посилання на історію платежів. Пов'язано зі **створенням цінності** (Принцип 2) та **монетизацією Активу** (Принцип 10)."
      },
      "callsScreen": {
        "title": "Екрани Дзвінків (Історія / Екран дзвінка / Конференція)",
        "purpose": "Забезпечити функціональність аудіо- та відеозв'язку.",
        "elements": "Список минулих дзвінків, інтерфейс активного дзвінка (відеопотік, кнопки Mute/Unmute, відео вкл/викл, завершити дзвінок, переключити камеру), інтерфейс конференції."
      },
      "filesMediaScreen": {
        "title": "Екран Файлів та Медіа",
        "purpose": "Надати зручний доступ до всіх файлів, якими користувач обмінювався в чатах.",
        "elements": "Список файлів (з попереднім переглядом для медіа), фільтрація за типом (фото, відео, документи), пошук. Організовано **системно** (Принцип 9)."
      },
      "archiveChatScreen": {
        "title": "Екран Архіву Чатів",
        "purpose": "Приховати менш актуальні чати з основного списку, зберігаючи до них доступ.",
        "elements": "Список архівних чатів, можливість відновлення. Частина **системи організації** (Принцип 9)."
      },
      "languageSettings": {
        "title": "Налаштування Мови",
        "purpose": "Дозволити користувачеві вибрати мову інтерфейсу.",
        "elements": "Список доступних мов. Зміна мови відбувається **миттєво** або після швидкого перезапуску, що підвищує **цінність** (Принцип 2) та **доступність** (Принцип 5) програми. Підтримується RTL (справа наліво) для деяких мов (див. DocLocIn)."
      },
      "batteryAnimationSettings": {
        "title": "Налаштування Батареї та Анімації",
        "purpose": "Дозволити користувачеві контролювати споживання ресурсів пристроєм.",
        "elements": "Перемикач для повного вимкнення анімацій, можливо, регулювання окремих ефектів. Це **прагматичне** (Принцип 12) рішення, що враховує **здоров'я** пристрою (Принцип 5)."
      },
      "chatCustomizationSettings": {
        "title": "Налаштування Чату (Кастомізація)",
        "purpose": "Дозволити користувачеві персоналізувати зовнішній вигляд окремих чатів.",
        "elements": "Опції вибору кольору фону чату, вибору шрифту для повідомлень. Це додає **цінність** (Принцип 2) за рахунок кастомізації."
      }
    },
    "navigationPrinciples": {
      "title": "Принципи Навігації: Зрозумілий Шлях по Системі",
      "description": "Навігація спроектована так, щоб бути **інтуїтивно зрозумілою** (Принцип 2) та слідувати **системним правилам** (Принцип 9).",
      "list": {
        "item1": "**Послідовність:** Екрани автентифікації та реєстрації проходять послідовно.",
        "item2": "**Головне Меню:** Забезпечує доступ до основних розділів програми (Чати, Контакти, Дзвінки, Налаштування, Архів).",
        "item3": "**Всередині Чату:** Доступ до інформації про чат/користувача та налаштувань чату зазвичай через шапку.",
        "item4": "**Повернення:** Чіткий спосіб повернутися на попередній екран (кнопка \"Назад\").",
        "item5": "**Welcome Screen:** Слайдер для покрокового ознайомлення з функціями."
      }
    },
    "uiStructure": {
      "title": "Структура Інтерфейсу: Побудова на Системі Компонентів (Принцип 9)",
      "description": "UI побудований на **модульній системі компонентів**, що забезпечує **єдність, швидкість розробки та підтримку** (Принцип 9).",
      "uiElements": {
        "title": "Елементи UI:",
        "list": {
          "item1": "**Текстові блоки (Text):** Використовуються для відображення тексту. Слідують типографічній шкалі з DocDesign.",
          "item2": "**Кнопки (Button):** Інтерактивні елементи для виконання дій. Мають чіткі стани (нормальний, натиснутий, вимкнений - див. DocDesign для стилів).",
          "item3": "**Поля вводу (Input):** Для вводу тексту, паролів, чисел. Включають плейсхолдери, мітки, індикатори помилок.",
          "item4": "**Іконки (Icon):** Використовуються для навігації, дій (відправити, дзвонити) та декоративних цілей. Єдиний набір та стиль (див. DocDesign). Можуть мати анімації.",
          "item5": "**Зображення (Image):** Відображення аватарів, зображень у чатах. Використовується оптимізоване завантаження.",
          "item6": "**Слайдер (Carousel):** Використовується на Welcome Screen.",
          "item7": "**Перемикачі (Toggle):** Для налаштувань типу вкл/викл."
        }
      },
      "alignmentGrid": {
        "title": "Вирівнювання та Сітка:",
        "description": "UI будується на основі **системи сітки 8px** (див. DocDesign).",
        "list": {
          "item1": "**Вертикальний потік:** Елементи на екранах розташовуються зверху вниз з чіткими вертикальними відступами.",
          "item2": "**Горизонтальне вирівнювання:** Елементи вирівнюються по лівому або правому краю контейнерів (з урахуванням RTL).",
          "item3": "**Відступи (Padding/Margin):** Використовуються значення зі шкали, кратні 8px, для створення гармонійного простору."
        }
      },
      "adaptiveDesign": "**Адаптивний Дизайн:** UI адаптується під різні розміри екрана та орієнтацію пристрою для забезпечення **цінності** (Принцип 2) на будь-якому пристрої."
    },
    "functionalRequirements": {
      "title": "Функціональні Вимоги до UI: Деталізація Взаємодії",
      "passwordInput": "**Ввід Пароля:** Повинен бути маскованим (`*` або `•`). Повинна бути опція показати/приховати пароль. Мінімальна довжина 8 символів, вимога наявності цифри та спецсимволу — валідація на клієнті та сервері.",
      "emailInput": "**Ввід Email:** Перевірка формату (`user@domain.com`).",
      "codeInput": "**Ввід Коду Підтвердження:** Поле вводу для 8-значного коду. Автоматичне перемикання на наступне поле при вводу цифри (зручність - Принцип 2). Перевірка коректності коду при відправленні на сервер.",
      "search": "**Пошук:** Фільтрація списків (чатів, контактів) у міру вводу запиту (чутливість - Принцип 9).",
      "profileManagement": "**Управління Профілем:** Поля для редагування, кнопка збереження, валідація нового email/пароля.",
      "subscription": "**Оформлення Підписки:** Перенаправлення на сторінку оплати Stripe (див. DocInt).",
      "slideSwitching": "**Перемикання Слайдів:** Слайдер на Welcome Screen повинен плавно перемикатися свайпом або кліком на стрілки/індикатори.",
      "languageChange": "**Зміна Мови:** Вибір мови зі списку. UI повинен оновитися миттєво або після запиту на перезапуск (див. DocLocIn).",
      "animationSettings": "**Налаштування Анімацій:** Перемикач повинен вмикати/вимикати основні анімації.",
      "chatCustomization": "**Кастомізація Чату:** Зміна кольорів/шрифтів повинна застосовуватися до конкретного чату.",
      "errorHandling": {
        "title": "Обробка помилок в UI:",
        "validation": "**Валідація вводу:** При некоректному вводу (наприклад, невірний формат email, занадто короткий пароль) під полем вводу з'являється **ясне візуальне повідомлення** з описом проблеми (Принцип 3, 14). Кнопка дії може бути вимкнена до виправлення.",
        "apiErrors": "**Помилки мережі/API:** При помилках взаємодії з Backend (наприклад, \"Невірний логін/пароль\", \"Користувач не знайдений\", \"Помилка мережі\") у верхній частині екрану з'являється **неблокуюче повідомлення (Snackbar/Toast)** з описом помилки, отриманої з API (див. DocSpec, локалізація - див. DocLocIn)."
      }
    },
    "userScenarios": {
      "title": "Користувацькі Сценарії: Приклади Взаємодії з Системою",
      "description": "Типові шляхи користувачів, що демонструють роботу системи з точки зору кінцевого користувача.",
      "registrationScenario": {
        "title": "Реєстрація нового користувача:",
        "steps": [
          "Користувач відкриває програму → Натискає \"Sign Up\" → Вводить пароль (валідація) → Натискає \"Next\" → Вводить ім'я → Натискає \"Next\" → Вводить email (валідація) → Натискає \"Sign Up\" → Отримує email з кодом → Повертається до програми → Вводить код → Натискає \"Confirm\" → Успішний вхід на Головний екран."
        ]
      },
      "loginScenario": {
        "title": "Вхід існуючого користувача:",
        "steps": [
          "Користувач відкриває програму → Натискає \"Log In\" → Вводить email та пароль → Натискає \"Log In\" → (Якщо 2FA включена: Отримує email з кодом → Вводить код → Натискає \"Confirm\") → Успішний вхід на Головний екран. При помилці логіна/пароля - повідомлення."
        ]
      },
      "sendMessage": {
        "title": "Відправлення текстового повідомлення:",
        "steps": [
          "Користувач на Головному екрані → Відкриває чат (клік) → Вводить текст у поле вводу → Натискає \"Відправити\" → Повідомлення з'являється у чаті."
        ]
      },
      "sendFile": {
        "title": "Відправлення файлу:",
        "steps": [
          "У відкритому чаті → Користувач натискає \"скріпку\" → Вибирає тип файлу (фото) → Вибирає файл з галереї → (Можливо, попередній перегляд) → Натискає \"Відправити\" → У чаті з'являється індикатор завантаження/файл з попереднім переглядом."
        ]
      },
      "searchChat": {
        "title": "Пошук чату:",
        "steps": [
          "На Головному екрані → Користувач вводить запит у рядок пошуку → Список чатів фільтрується в реальному часі."
        ]
      },
      "changeTheme": {
        "title": "Зміна теми оформлення:",
        "steps": [
          "На Головному екрані → Користувач відкриває Головне меню → Переходить до \"Налаштування\" → \"Зовнішній вигляд\" → Вибирає \"Dark\" → UI миттєво перемикається на темну тему."
        ]
      }
    },
    "notes": {
      "title": "Примітки: Фокус на Користувацькому Досвіді",
      "testing": "**Тестування:** Важливо тестувати UI на реальних пристроях з різними розмірами екрана, роздільною здатністю та налаштуваннями доступності (розмір шрифту, інверсія кольорів) для забезпечення **якості** (Принцип 3) та **доступності** (Принцип 5).",
      "feedback": "**Зворотній Зв'язок:** UI буде розвиватися на основі **зворотного зв'язку** (Принцип 14) від користувачів та аналізу їхньої поведінки.",
      "consistency": "**Послідовність:** UI на всіх платформах (Web, Mobile, Desktop) повинен бути максимально **послідовним** (Принцип 7), щоб користувач, освоївши одну версію, міг легко використовувати інші.",
      "animations": "**Анімації:** Анімації використовуються для покращення сприйняття, але можуть бути вимкнені. Вони повинні бути **оптимізованими** (Принцип 9) і не викликати дискомфорту.",
      "customization": "**Кастомізація:** Надання опцій кастомізації (тема, шрифт) підвищує **цінність** (Принцип 2) програми для користувача."
    }
  }
}
