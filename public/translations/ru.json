{
  "header": {
      "features": "Функции",
      "news": "Новости",
      "faq": "Часто задаваемые вопросы",
      "faqLink": "FAQ",
      "docs": "Документация",
      "updates": "Обновления",
      "selectLanguage": "Выбрать язык",
      "changeLanguageTooltip": "Изменить язык",
      "lightMode": "Светлая тема",
      "darkMode": "Темная тема",
      "openMenu": "Открыть меню",
      "closeMenu": "Закрыть меню",
      "settings": "Настройки",
      "signOut": "Выйти",
      "deleteAccount": "Удалить аккаунт",
      "deleteAccountConfirmTitle": "Подтвердите удаление аккаунта",
      "deleteAccountConfirmMessage": "Вы уверены, что хотите удалить свой аккаунт? Это действие нельзя отменить.",
      "cancel": "Отмена",
      "confirmDelete": "Подтвердить удаление",
      "signIn": "Войти"
    },
    "hero": {
      "title": "Добро пожаловать в BrainMessenger",
      "subtitle": "Ваша умная платформа для общения",
      "getStarted": "Начать",
      "learnMore": "Узнать больше",
      "connectSmarterTitle": "Общайтесь умнее с BrainMessenger",
      "connectSmarterSubtitle": "Оцените новое поколение мессенджеров с расширенными функциями, непревзойденной безопасностью и бесперебойной связью на всех ваших устройствах.",
      "downloadButton": "Скачать",
      "downloadAndroid": "Скачать для Android"
    },
    "features": {
      "featuresTitle": "Ключевые особенности",
      "featuresSubtitle": "Узнайте, что делает нас уникальными",
      "secureMessaging": "Безопасные сообщения",
      "secureMessagingDesc": "Сквозное шифрование для вашей конфиденциальности",
      "smartAssistant": "Умный помощник",
      "smartAssistantDesc": "Помощь на основе ИИ всегда под рукой",
      "crossPlatform": "Кроссплатформенность",
      "crossPlatformDesc": "Используйте на любом устройстве, где угодно",
      "groupChats": "Групповые чаты",
      "groupChatsDesc": "Общайтесь с несколькими людьми одновременно",
      "privacyFirst": "Приватность превыше всего",
      "privacyFirstDesc": "Ваши данные всегда ваши"
    },
    "news": {
      "latestNews": "Последние новости",
      "readMore": "Подробнее",
      "previousButton": "Предыдущая новость",
      "nextButton": "Следующая новость",
      "pauseAutoplay": "Приостановить автовоспроизведение",
      "playAutoplay": "Воспроизвести автоматически"
    },
    "roadmap": {
      "title": {
        "section": "Дорожная карта",
        "projectLaunch": "Запуск проекта",
        "enhancedSecurity": "Улучшенная безопасность",
        "advancedCollaboration": "Расширенное сотрудничество",
        "mobileEnhancement": "Улучшение мобильных приложений",
        "aiIntegration": "Интеграция ИИ",
        "globalExpansion": "Глобальное расширение",
        "enterpriseSolutions": "Корпоративные решения",
        "futureInnovation": "Будущие инновации"
      },
      "subtitle": {
        "section": "Наше видение будущего"
      },
      "status": {
        "completed": "Завершено",
        "inProgress": "В процессе",
        "upcoming": "Предстоящее"
      },
      "description": {
        "projectLaunch": "Первоначальный запуск BrainMessenger с основными функциями.",
        "enhancedSecurity": "Укрепление протоколов и функций безопасности.",
        "advancedCollaboration": "Внедрение расширенных инструментов для совместной работы.",
        "mobileEnhancement": "Улучшение опыта использования мобильного приложения.",
        "aiIntegration": "Интеграция функций на основе ИИ для более умного общения.",
        "globalExpansion": "Расширение охвата BrainMessenger по всему миру.",
        "enterpriseSolutions": "Разработка решений для корпоративных клиентов.",
        "futureInnovation": "Изучение и внедрение будущих технологий."
      },
      "features": {
        "secureMessagingInfrastructure": "Инфраструктура безопасного обмена сообщениями",
        "crossPlatformCompatibility": "Кроссплатформенная совместимость",
        "basicUserInterface": "Базовый пользовательский интерфейс",
        "endToEndEncryption": "Сквозное шифрование",
        "twoFactorAuthentication": "Двухфакторная аутентификация",
        "fileSharingCapabilities": "Возможности обмена файлами",
        "teamWorkspaces": "Рабочие пространства для команд",
        "realTimeCollaboration": "Совместная работа в реальном времени",
        "advancedFileSharing": "Расширенный обмен файлами",
        "nativeMobileApps": "Нативные мобильные приложения",
        "offlineFunctionality": "Офлайн-функциональность",
        "pushNotifications": "Push-уведомления",
        "smartMessageCategorization": "Умная категоризация сообщений",
        "automatedResponses": "Автоматические ответы",
        "contentAnalysis": "Анализ контента",
        "multiLanguageSupport": "Поддержка нескольких языков",
        "regionalDataCenters": "Региональные центры обработки данных",
        "culturalAdaptations": "Культурные адаптации",
        "advancedAdminControls": "Расширенные административные элементы управления",
        "customIntegrations": "Пользовательские интеграции",
        "enterpriseSupport": "Корпоративная поддержка",
        "emergingTechnologies": "Новые технологии",
        "communityDrivenFeatures": "Функции, ориентированные на сообщество",
        "platformExpansion": "Расширение платформы"
      },
      "date": {
        "jan2024": "Январь 2024",
        "mar2024": "Март 2024",
        "jun2024": "Июнь 2024",
        "sep2024": "Сентябрь 2024",
        "nov2024": "Ноябрь 2024",
        "jan2025": "Январь 2025",
        "mar2025": "Март 2025",
        "jun2025": "Июнь 2025",
        "beyond2025": "После 2025"
      }
    },
    "faq": {
      "title": "Часто задаваемые вопросы",
      "subtitle": "Найдите ответы на распространенные вопросы о BrainMessenger",
      "searchAlt": "Иконка поиска",
      "searchPlaceholder": "Искать вопросы...",
      "allQuestions": "Все вопросы",
      "noResults": "Вопросов по вашему запросу не найдено.",
      "categories": {
        "general": "Общие",
        "technical": "Технические",
        "security": "Безопасность",
        "pricing": "Цены",
        "generalProject": "Общие вопросы о проекте",
        "technicalQuestions": "Технические вопросы",
        "developmentProcesses": "Процессы разработки",
        "statusRoadmapFuture": "Статус, дорожная карта и будущее",
        "challengesOpportunitiesLimitations": "Вызовы, возможности и ограничения",
        "learnMoreContribute": "Узнать больше и внести вклад"
      },
      "questionsData": {
        "generalProject": {
          "q1": {
            "question": "В чем основная идея BrainMessenger? Что делает его особенным?",
            "answer": "BrainMessenger — это не просто очередной мессенджер. Наша главная идея — создать ЦИФРОВОЙ АКТИВ (Принцип 10), который упрощает сложное взаимодействие (принцип Маргулана Сейсембаева) и служит надежным инструментом для эффективной коммуникации. Мы сосредоточены на качестве (Принцип 3), безопасности (Принцип 5) и надежности (Принцип 3), а не просто на наборе функций. Мы строим СИСТЕМУ (Принцип 9), которая отражает наши принципы и постоянно улучшается."
          },
          "q2": {
            "question": "Какие ключевые принципы лежат в основе разработки BrainMessenger?",
            "answer": "Проект основан на наборе из 15 ключевых принципов (см. Мои ключевые принципы), вдохновленных Маргуланом Сейсембаевым и лучшими практиками IT-индустрии. Наиболее важные, влияющие на код и процессы: Непрерывное обучение (Принцип 1), Создание ценности (Принцип 2), Качество > Количество (Принцип 3), Система и оптимизация (Кайдзен, Принцип 9), Долгосрочное мышление (Принцип 8), Прагматизм и реализм (Принцип 12), Настойчивость (Принцип 13), Склонность к действию (Принцип 15). Мы стремимся, чтобы эти принципы пронизывали все аспекты проекта."
          },
          "q3": {
            "question": "Кто стоит за проектом? Это открытое сообщество или команда?",
            "answer": "В настоящее время проект находится на ранней стадии и активно разрабатывается одним человеком (вами), который является движущей силой и несет ответственность (Принцип 6) за его создание. В будущем планируется привлечение контрибьюторов и, возможно, формирование команды. Проект открыт для вкладов (см. CONTRIBUTING.md)."
          }
        },
        "technicalQuestions": {
          "q1": {
            "question": "Почему был выбран именно этот технологический стек (TypeScript, NestJS, React/RN, PostgreSQL/Neon, GraphQL, Kafka, Redis, Cloudflare R2 и др.)?",
            "answer": "Выбор стека основан на прагматизме (Принцип 12), долгосрочном мышлении (Принцип 8) и стремлении к качеству (Принцип 3) и масштабируемости (НФТ-14, НФТ-15).\n*   TypeScript: Повышает надежность и поддерживаемость кода за счет строгой типизации.\n*   NestJS: Предоставляет мощную модульную архитектуру для бэкенда, упрощая построение масштабируемых приложений.\n*   React/React Native/Next.js: Позволяют создавать UI для разных платформ из единой кодовой базы (кроссплатформенность) и обеспечивают хорошую производительность.\n*   PostgreSQL (Neon): Надежная, проверенная реляционная база данных с обширными возможностями масштабирования и оптимизации. Neon как управляемый сервис снижает операционные накладные расходы (Прагматизм).\n*   Prisma: Выбрана как надежный ORM, обеспечивающий типобезопасность и встроенную защиту от SQL-инъекций (Качество, Безопасность).\n*   GraphQL: Позволяет клиентам запрашивать только те данные, которые им действительно нужны, одним запросом, оптимизируя сетевое взаимодействие (особенно для мобильных клиентов) и уменьшая избыточность данных по сравнению с REST. GraphQL также упрощает получение связанных данных (решая проблемы N+1 с DataLoader).\n*   Kafka: Выбрана для надежной асинхронной обработки задач, что критически важно для масштабируемости и отказоустойчивости.\n*   Redis: Высокопроизводительное хранилище в памяти для кэширования, Rate Limiting и управления состоянием в реальном времени.\n*   Cloudflare R2: Объектное хранилище с очень выгодными условиями (без платы за исходящий трафик), идеально подходящее для хранения пользовательских файлов (Прагматизм, АКТИВ).\n\nЭтот стек позволяет заложить прочный технический фундамент (Принцип 8) для будущего развития."
          },
          "q2": {
            "question": "Почему на старте используется монолитная архитектура, а не сразу микросервисы?",
            "answer": "Использование монолитной архитектуры на старте (MVP) — это прагматичное и реалистичное решение (Принцип 12). Оно позволяет быстро разрабатывать и итерировать базовую функциональность, минимизируя сложность на раннем этапе, когда команда небольшая. Запуск MVP важнее, чем построение излишне сложной архитектуры. После завершения MVP и роста проекта планируется поэтапный переход к микросервисам (см. План миграции на микросервисы)."
          },
          "q3": {
            "question": "Какие подходы используются для обеспечения безопасности?",
            "answer": "Безопасность является фундаментальным аспектом (Принцип 5) и приоритетом (см. Руководство по безопасности).\n*   Шифрование данных при передаче (TLS 1.2+) и хранении (AES для конфиденциальных данных, шифрование в R2).\n*   Надежное хеширование паролей (bcrypt/argon2).\n*   Использование Prisma для предотвращения SQL-инъекций.\n*   Валидация всех входных данных на бэкенде.\n*   Двухфакторная аутентификация (2FA) по электронной почте.\n*   Rate Limiting для защиты от брутфорс и DDoS-атак.\n*   Регулярное сканирование на уязвимости.\n*   Хранение секретов в безопасных местах (Kubernetes Secrets)."
          },
          "q4": {
            "question": "Как реализована функциональность реального времени (обмен сообщениями)?",
            "answer": "Функциональность реального времени (обмен сообщениями) реализована с использованием WebSockets. Бэкенд (NestJS Gateway) управляет WebSocket-соединениями, и клиенты подписываются на события чата. Доставка сообщений происходит через WebSocket. Для масштабирования WebSockets в микросервисной архитектуре будет использоваться Redis Pub/Sub или Kafka."
          },
          "q5": {
            "question": "Почему используется GraphQL вместо REST API?",
            "answer": "GraphQL позволяет клиентам запрашивать только те данные, которые им действительно нужны, одним запросом. Это оптимизирует сетевое взаимодействие (особенно для мобильных клиентов) и уменьшает избыточность данных по сравнению с REST. GraphQL также упрощает получение связанных данных (решая проблемы N+1 с DataLoader)."
          },
          "q6": {
            "question": "Как осуществляется управление большими объемами данных и файлов?",
            "answer": "*   Структурированные данные (сообщения, пользователи, чаты): Хранятся в PostgreSQL (Neon). Для быстрого получения используются индексы и оптимизация запросов (Prisma). По мере роста планируется партиционирование таблиц и репликация базы данных.\n*   Неструктурированные данные (файлы, изображения): Хранятся в Cloudflare R2. Для оптимизации изображений перед загрузкой используется асинхронная обработка (Kafka). R2 выбран за масштабируемость и выгодные тарифы на трафик."
          }
        },
        "developmentProcesses": {
          "q1": {
            "question": "Каков подход к управлению проектом и задачами?",
            "answer": "Управление проектом осуществляется с использованием системы планирования (см. Моя система планирования 2025-2026) в Notion. Глобальные цели декомпозируются на этапы (Roadmap), используется еженедельное планирование и трекер задач. Важным элементом является Час Кайдзен (Принцип 9) для ежедневной рефлексии, анализа узких мест и поиска путей улучшения."
          },
          "q2": {
            "question": "Как обеспечивается качество кода?",
            "answer": "Качество кода обеспечивается системными подходами (Принцип 3, 9):\n*   Использование TypeScript со строгой типизацией.\n*   Соблюдение стандартов кодирования (ESLint, Prettier).\n*   Code review всех изменений.\n*   Автоматизированное тестирование на разных уровнях (Unit, Integration, E2E).\n*   Непрерывная интеграция (CI) для автоматической проверки кода и тестов при каждом коммите/PR."
          },
          "q3": {
            "question": "Какая стратегия тестирования используется?",
            "answer": "Используется многоуровневая стратегия тестирования (см. Руководство по тестированию), сочетающая ручное и автоматизированное тестирование: Unit, Integration, API, E2E, Load, Security, Regression. Тесты интегрированы в CI/CD. Фокус делается на проверке ключевых требований (ФТ, НФТ)."
          },
          "q4": {
            "question": "Как обрабатываются ошибки?",
            "answer": "Ошибки обрабатываются централизованно и единообразно на бэкенде (NestJS Exception Filters) и преобразуются в стандартный формат API-ответа с кодами (extensions.code). На фронтенде ошибки обрабатываются на основе этих кодов, отображая пользователю понятное сообщение и предлагая действие. Все ошибки тщательно логируются (Winston → ELK) и отправляются в Sentry для отслеживания и анализа (см. Спецификация ошибок, Руководство по мониторингу)."
          },
          "q5": {
            "question": "Как разворачивается проект?",
            "answer": "Развертывание автоматизировано через CI/CD пайплайн (GitHub Actions). Docker используется для контейнеризации, а Kubernetes — для оркестрации в облаке. Инфраструктура описывается как код (Terraform). Процесс включает автоматическую сборку, тестирование, публикацию образов и Rolling Updates в Kubernetes для развертывания без простоев (см. Руководство по развертыванию)."
          },
          "q6": {
            "question": "Как осуществляется мониторинг системы в продакшене?",
            "answer": "Система мониторинга — это глаза и уши проекта (Принцип 9, 5). Используются:\n*   Prometheus для сбора метрик производительности и ресурсов.\n*   Grafana для визуализации метрик и дашбордов.\n*   Sentry для отслеживания ошибок приложения (Frontend и Backend).\n*   ELK Stack (или Kibana с Winston) для централизованного логирования и анализа.\n*   Alertmanager для настройки автоматических оповещений о проблемах.\nЭти инструменты позволяют проактивно выявлять проблемы и проводить оптимизацию (см. Руководство по мониторингу)."
          }
        },
        "statusRoadmapFuture": {
          "q1": {
            "question": "Каков текущий статус проекта?",
            "answer": "Проект находится в стадии активной разработки Минимально Жизнеспособного Продукта (MVP). Заложен основной технологический фундамент, реализованы ключевые элементы UI и базовая безопасность. Идет работа над основной функциональностью обмена сообщениями, обработки файлов и создания групп/каналов. (См. Руководство по требованиям к проекту BrainMessenger (MVP))."
          },
          "q2": {
            "question": "Каковы следующие шаги после завершения MVP?",
            "answer": "После завершения MVP следующие шаги включают добавление расширенных функций (аудио/видеозвонки, Premium, расширенная безопасность, полный набор анимаций и локализация), дальнейшую оптимизацию производительности и подготовку к масштабированию. Детальный план представлен в Дорожной карте BrainMessenger (см. Дорожная карта)."
          },
          "q3": {
            "question": "Планируется ли переход на микросервисную архитектуру?",
            "answer": "Да, переход на микросервисы является частью долгосрочной стратегии развития (Принцип 8). Он планируется поэтапно, начиная с 1 квартала 2026 года, с использованием подхода Strangler Pattern. Это позволит масштабировать компоненты независимо, увеличивая отказоустойчивость и гибкость (см. План миграции на микросервисы)."
          }
        },
        "challengesOpportunitiesLimitations": {
          "q1": {
            "question": "Каковы основные технические проблемы (подводные камни) в проекте?",
            "answer": "*   Реализация надежной функциональности реального времени (WebSockets): Управление тысячами одновременных подключений, надежная доставка сообщений, управление статусами онлайн/офлайн.\n*   Масштабирование базы данных при больших объемах данных: Управление ростом таблицы сообщений (партиционирование), оптимизация сложных запросов.\n*   Обработка и доставка файлов: Эффективная загрузка, оптимизация изображений, безопасная загрузка из Cloudflare R2.\n*   Переход на микросервисы: Увеличение операционной сложности, настройка межсервисного взаимодействия (Kafka, GraphQL Federation), миграция данных.\n*   Поддержание высокого качества и производительности: Постоянная оптимизация на всех уровнях (бэкенд, фронтенд, инфраструктура) по мере роста нагрузки и функциональности."
          },
          "q2": {
            "question": "Какие возможности и преимущества дает архитектура и стек проекта?",
            "answer": "*   Высокая масштабируемость: Выбранные технологии (NestJS, Kubernetes, Kafka, Redis, Neon, R2) позволяют горизонтально масштабировать приложение для поддержки большого количества пользователей.\n*   Надежность и отказоустойчивость: Использование надежных сервисов, асинхронной обработки (Kafka), мониторинга и, в будущем, микросервисов повышает устойчивость системы к сбоям.\n*   Высокая производительность: GraphQL, кэширование, оптимизация запросов, асинхронная обработка способствуют быстрой работе приложения.\n*   Кроссплатформенность: React Native и Next.js позволяют создавать приложения для всех основных платформ из единой кодовой базы (для UI).\n*   Качество кода и поддерживаемость: TypeScript, NestJS, Prisma, стандарты кодирования, тестирование упрощают разработку и уменьшают количество дефектов.\n*   Экономичность (на старте): Использование бесплатных/доступных тарифов (Neon, R2) и проверенных решений с открытым исходным кодом.\n*   Богатая экосистема: Использование популярных технологий с большим сообществом и множеством готовых библиотек."
          },
          "q3": {
            "question": "Каковы ограничения проекта на текущем этапе (MVP)?"
            ,
            "answer": "*   Ограниченный набор функций по сравнению с видением (нет звонков, Premium, расширенной безопасности).\n*   Ограниченные возможности многоязычности и доступности (планируется расширение).\n*   Архитектура в настоящее время монолитна, что накладывает ограничения на независимое масштабирование отдельных частей.\n*   Возможны ограничения производительности при нагрузке, значительно превышающей целевую для MVP (~1000 одновременных пользователей), до внедрения глубоких оптимизаций и микросервисов."
          }
        }
      }
    },
  "docs": {
    "general": {
      "title": "BrainMessenger - Ваш Цифровой Актив для Эффективной Коммуникации",
      "subtitle": "Введение: Построение Системы Ценности",
      "introduction": {
        "title": "Введение: Построение Системы Ценности",
        "content": "Добро пожаловать в репозиторий BrainMessenger. Это не просто очередной мессенджер. Это целенаправленный проект, призванный создать <strong>надежную, масштабируемую и безопасную СИСТЕМУ</strong> (Принцип 9), которая станет <strong>ключевым цифровым АКТИВОМ</strong> (Принцип 10) для каждого пользователя. Наша главная цель — <strong>упрощать сложность</strong> (принцип Маргулана Сейсембаева), предоставляя интуитивно понятные и мощные инструменты для эффективного общения и взаимодействия в современном цифровом мире.<br/><br/>BrainMessenger строится на <strong>прочном фундаменте</strong> (Принцип 8) глубоких принципов, осознанного планирования и <strong>непрерывного обучения</strong> (Принцип 1). Каждая строка кода, каждое принятое решение – это <strong>долгосрочная инвестиция</strong> (Принцип 8) в <strong>качество</strong> (Принцип 3) и <strong>ценность</strong> (Принцип 2) нашего продукта."
      },
      "visionAndMission": {
        "title": "Видение и Миссия: Наш Долгосрочный Взгляд",
        "visionTitle": "Наше Видение:",
        "visionContent": "Создать ведущий цифровой актив для коммуникации, который поможет миллионам пользователей по всему миру эффективно обмениваться информацией, строить сообщества и достигать своих целей.",
        "missionTitle": "Наша Миссия:",
        "missionContent": "Упрощать сложное взаимодействие, предоставляя надежный, безопасный и удобный мессенджер, построенный на принципах качества, прозрачности и непрерывного улучшения."
      },
      "keyPrinciples": {
        "title": "Ключевые Принципы: Фундамент Нашей Системы",
        "intro": "Наши действия и решения руководствуются набором ключевых принципов, которые служат <strong>фундаментом</strong> (Принцип 8) всего проекта BrainMessenger. Это не просто слова, а <strong>личные алгоритмы и стандарты (Кайдзен, Принцип 9)</strong>, выработанные через опыт и рефлексию (Принцип 1):",
        "principles": [
          "<strong>Непрерывное Обучение и Рост (Принцип 1):</strong> Процесс создания BrainMessenger – это полигон для глубокого обучения в технологиях, архитектуре и психологии пользователя. Мы учимся на каждом шагу, превращая ошибки в уроки.",
          "<strong>Создание Ценности (Принцип 2):</strong> Выгода пользователя лежит в основе всего. Мы строим то, что по-настоящему решает проблемы и делает жизнь лучше.",
          "<strong>Качество превыше Количества (Принцип 3):</strong> Мы стремимся делать хорошо, а не просто быстро. Надежность, продуманность и внимание к деталям – наши приоритеты.",
          "<strong>Осознанность и Присутствие (Принцип 4):</strong> Быть внимательным к процессу, пользователям и команде.",
          "<strong>Здоровье как Фундамент (Принцип 5):</strong> Физическое и ментальное благополучие команды (и будущих пользователей) – основа продуктивности и устойчивости.",
          "<strong>Ответственность и Проактивность (Принцип 6):</strong> Мы берем на себя ответственность за результат и действуем на опережение.",
          "<strong>Целостность (Принцип 7):</strong> Наши слова соответствуют нашим действиям.",
          "<strong>Долгосрочное Мышление (Принцип 8):</strong> Мы инвестируем время и силы с прицелом на будущее.",
          "<strong>Система и Оптимизация (Принцип 9):</strong> Мы строим процессы и архитектуру как систему, постоянно ищем способы повышения эффективности (Кайдзен).",
          "<strong>Создание Актива > Зарабатывание Денег (Принцип 10):</strong> Фокус на создании АКТИВА (BrainMessenger), который приносит ценность и работает в долгосрочной перспективе.",
          "<strong>Гибкость и Адаптивность (Принцип 11):</strong> Готовность менять тактику и инструменты, сохраняя видение.",
          "<strong>Прагматизм и Реализм (Принцип 12):</strong> Принятие решений на основе реальных данных и возможностей.",
          "<strong>Настойчивость (Принцип 13):</strong> Не сдаваться перед трудностями, извлекая уроки из неудач.",
          "<strong>Использование Внешней Экспертизы и Обратной Связи (Принцип 14):</strong> Мы учимся у других, прислушиваемся к конструктивной критике.",
          "<strong>Склонность к Действию (Принцип 15):</strong> На ранних этапах важнее начать делать и получать обратную связь, чем бесконечно планировать."
        ],
        "outro": "Эти принципы, вдохновленные философией Маргулана Сейсембаева и практиками ведущих IT-компаний, формируют нашу культуру и подход к разработке."
      },
      "aboutMVP": {
        "title": "О Проекте BrainMessenger (Фокус на MVP)",
        "intro": "Наш текущий фокус – на разработке <strong>Минимально Жизнеспособного Продукта (MVP)</strong>. MVP – это первый, <strong>прагматичный</strong> (Принцип 12) шаг к реализации нашего видения. Мы строим <strong>прочный технический фундамент</strong> (Принцип 8), который позволит нам быстро и эффективно развивать продукт в будущем.",
        "featuresTitle": "MVP включает базовые, но <strong>высококачественные и надежные</strong> (Принцип 3) функции, предоставляющие ключевую <strong>ценность</strong> (Принцип 2):",
        "features": [
          "<strong>Базовая Переписка:</strong> Отправка и получение текстовых сообщений в личных чатах и группах/каналах.",
          "<strong>Обмен Файлами:</strong> Загрузка и скачивание файлов (с оптимизацией изображений).",
          "<strong>Каналы и Группы:</strong> Базовое создание групп/каналов, присоединение к публичным каналам и чтение контента.",
          "<strong>Базовое Управление Аккаунтом:</strong> Регистрация, вход/выход, редактирование профиля (имя, аватар), базовые настройки безопасности.",
          "<strong>Основные Настройки UI:</strong> Выбор темы (Светлая/Темная), базовые настройки уведомлений и языка.",
          "<strong>Базовая Безопасность:</strong> Шифрование данных (TLS, хеширование паролей, базовые меры против SQLi/XSS/DDoS), подтверждение почты при регистрации.",
          "<strong>Адаптивный UI:</strong> Интерфейс, адаптированный для мобильных (Android, iOS) и веб-платформ.",
          "<strong>Базовая Мультиязычность:</strong> Поддержка нескольких языков интерфейса (английский, русский и другие согласно DocLocIn.md)."
        ],
        "outro": "Функциональность за пределами MVP (аудио/видеозвонки, расширенные функции безопасности/приватности, премиум-подписка, полный набор анимаций, интеграции с ИИ) планируется на последующие этапы Roadmap."
      },
      "howWeBuild": {
        "title": "Как Мы Строим: История Создания и Процесс Кайдзен",
        "intro": "Процесс создания BrainMessenger – это живая история, основанная на наших принципах. Мы строим его <strong>системно</strong> (Принцип 9), шаг за шагом, документируя каждый этап и непрерывно ища возможности для <strong>улучшения (Кайдзен)</strong>.",
        "steps": [
          "<strong>Осознанное Планирование (Принцип 4):</strong> Проект начался с четкого определения глобальных целей и их декомпозиции на достижимые этапы (Roadmap).",
          "<strong>Выбор Фундамента (Принцип 8, 12):</strong> Мы тщательно отобрали технологический стек – надежные и <strong>прагматичные</strong> инструменты (TypeScript, NestJS, React/RN, PostgreSQL/Neon, Cloudflare R2, Kafka, Redis), которые формируют <strong>прочный технический фундамент</strong>.",
          "<strong>Построение Ядра MVP:</strong> Реализация началась с базовых, критически важных частей системы (Аутентификация, Базовый UI, Инфраструктура, Работа с файлами). Мы применяем <strong>Склонность к Действию</strong> (Принцип 15), фокусируясь на создании работающих компонентов, пусть пока и минимальных.",
          "<strong>Непрерывное Обучение и Применение Знаний (Принцип 1):</strong> Каждая новая задача, особенно связанная с изучением или интеграцией технологий (как видно в <a href=\"https://www.notion.so/2025-2026-1576e78881b7435e9c3c2cf174e61b91?pvs=4\" target=\"_blank\" rel=\"noopener noreferrer\">Video Tracker</a> и задачах), рассматривается как возможность для роста. Мы документируем этот процесс через видео и рефлексию (Кайдзен-Час).",
          "<strong>Системный Подход к Качеству (Принцип 3, 9):</strong> Мы интегрируем тестирование на ранних этапах цикла разработки (Unit-тесты), настраиваем CI/CD пайплайны для автоматических проверок, используем инструменты мониторинга (Prometheus, Grafana, Sentry) и логирования (Winston, ELK) для постоянного контроля за <strong>здоровьем системы</strong> (Принцип 5) в реальном времени.",
          "<strong>Документация как Часть Системы Знаний:</strong> Весь процесс разработки, архитектурные решения, стандарты и требования тщательно документируются. Это не просто формальность, а часть создания <strong>системы знаний</strong>, которая ускоряет онбординг, упрощает поддержку и позволяет принимать обоснованные решения в будущем."
        ],
        "outro": "Мы строим BrainMessenger как живой, развивающийся организм, постоянно адаптирующийся и улучшающийся на основе наших принципов и обратной связи от процесса разработки и будущих пользователей."
      },
      "technologyStack": {
        "title": "Технологический Стек: Наши Инструменты для Создания Актива",
        "intro": "Мы выбрали стек, который является <strong>прагматичным</strong> (Принцип 12), <strong>надежным</strong> (Принцип 3) и <strong>масштабируемым</strong> (Принцип 8) для создания нашего <strong>цифрового АКТИВА</strong>.",
        "stack": [
          "<strong>Язык:</strong> <a href=\"https://www.typescriptlang.org/\" target=\"_blank\" rel=\"noopener noreferrer\">TypeScript</a> - Статическая типизация для повышения качества и надежности кода.",
          "<strong>Бэкенд:</strong> <a href=\"https://nodejs.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Node.js</a>, <a href=\"https://nestjs.com/\" target=\"_blank\" rel=\"noopener noreferrer\">NestJS</a> - Эффективный и структурированный фреймворк для серверной логики и GraphQL API.",
          "<strong>Фронтенд:</strong> <a href=\"https://react.dev/\" target=\"_blank\" rel=\"noopener noreferrer\">React</a>, <a href=\"https://nextjs.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Next.js</a> (Веб), <a href=\"https://reactnative.dev/\" target=\"_blank\" rel=\"noopener noreferrer\">React Native</a> (Мобильные/Десктоп) - Кроссплатформенная разработка UI с фокусом на производительность.",
          "<strong>API:</strong> <a href=\"https://graphql.org/\" target=\"_blank\" rel=\"noopener noreferrer\">GraphQL</a> - Гибкое взаимодействие между клиентом и сервером.",
          "<strong>Реальное время:</strong> WebSockets - Мгновенная доставка сообщений.",
          "<strong>База данных:</strong> <a href=\"https://www.postgresql.org/\" target=\"_blank\" rel=\"noopener noreferrer\">PostgreSQL</a> (через <a href=\"https://neon.tech/\" target=\"_blank\" rel=\"noopener noreferrer\">Neon</a>) - Надежная и масштабируемая база данных. Neon как управляемый сервис снижает операционные издержки (Прагматизм).",
          "<strong>ORM:</strong> <a href=\"https://www.prisma.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Prisma</a> - Типобезопасное и надежное взаимодействие с БД, защита от SQL-инъекций (Качество, Безопасность).",
          "<strong>Кэширование:</strong> <a href=\"https://redis.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Redis</a> - Высокопроизводительное кэширование и управление состоянием.",
          "<strong>Очереди:</strong> <a href=\"https://kafka.apache.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Kafka</a> - Надежная асинхронная обработка задач.",
          "<strong>Файловое хранилище:</strong> <a href=\"https://www.cloudflare.com/developer/r2/\" target=\"_blank\" rel=\"noopener noreferrer\">Cloudflare R2</a> - Объектное хранилище с выгодными ценами и без платы за исходящий трафик (Прагматизм, АКТИВ).",
          "<strong>Уведомления:</strong> <a href=\"https://firebase.google.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Firebase</a> - Управляемый сервис для Push-уведомлений.",
          "<strong>Почта/2FA:</strong> <a href=\"https://developers.google.com/gmail/api\" target=\"_blank\" rel=\"noopener noreferrer\">Gmail API</a> - Надежная доставка транзакционных писем (коды подтверждения, 2FA).",
          "<strong>Платежи:</strong> <a href=\"https://stripe.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Stripe</a>, Cryptomus (За пределами MVP) - Монетизация АКТИВА, Прагматизм.",
          "<strong>Тестирование:</strong> Jest, Cypress, Detox, k6, OWASP ZAP/Burp Suite (план) - Комплексный подход к обеспечению качества.",
          "<strong>Развертывание:</strong> <a href=\"https://vercel.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Vercel</a> (Веб), Docker, <a href=\"https://kubernetes.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Kubernetes</a> - Автоматизированное и масштабируемое развертывание.",
          "<strong>Мониторинг:</strong> Prometheus, Grafana, Sentry (план) - Видимость системы и анализ Кайдзен."
        ]
      },
      "architecture": {
        "title": "Архитектура: Эволюция Системы",
        "intro": "В настоящее время BrainMessenger реализован как <strong>монолитное приложение на базе NestJS</strong>. Это <strong>прагматичное</strong> (Принцип 12) решение для MVP, позволяющее быстро запустить продукт и проверить основные гипотезы.",
        "future": "В будущем, по мере роста проекта и увеличения нагрузки, мы планируем поэтапный переход к <strong>микросервисной архитектуре</strong> с использованием <strong>Strangler Pattern</strong>. Это <strong>долгосрочная стратегия</strong> (Принцип 8), которая позволит независимо масштабировать и развивать отдельные компоненты (чаты, звонки, ИИ, платежи), повышая общую <strong>надежность и гибкость</strong> системы (Принцип 3, 11).",
        "interaction": "Взаимодействие между компонентами будет осуществляться через <strong>GraphQL API</strong> (синхронно) и <strong>Kafka</strong> (асинхронно), используя <strong>Apollo Federation</strong> (в будущем) для построения единой схемы API из множества микросервисов."
      },
      "projectStatus": {
        "title": "Статус Проекта: Текущий Этап (MVP)",
        "content": "В настоящее время проект находится в активной стадии разработки <strong>MVP</strong> (согласно <a href=\"https://www.notion.so/MVP-11a2a21315e54eb3b3c90171b4c7493d?pvs=4\" target=\"_blank\" rel=\"noopener noreferrer\">Инструкции по требованиям MVP</a>). Мы сосредоточены на завершении основной функциональности обмена сообщениями, обработки файлов, создания групп/каналов и базовых настроек, одновременно укрепляя <strong>технический фундамент</strong> (Принцип 8) и внедряя процессы <strong>непрерывного обучения</strong> и <strong>Кайдзен</strong> в нашу повседневную работу.",
        "progress": "Прогресс документируется через задачи, код в репозитории и видеозаписи, которые демонстрируют наш путь и <strong>процесс создания</strong> (Принцип 1)."
      },
      "gettingStarted": {
        "title": "Начало Работы (Для Разработчиков)",
        "intro": "Хотите присоединиться к нам в создании этого цифрового АКТИВА? Вот как начать:",
        "steps": [
          "Клонируйте репозиторий:<br/>```bash<br/>git clone <URL of your repository><br/>cd BrainMessenger<br/>```",
          "Установите зависимости:<br/>```bash<br/>npm install # Turborepo установит зависимости для всех пакетов<br/>```",
          "Настройте переменные окружения: Скопируйте `.env.example` в `.env` и заполните необходимые данные для интеграций (Neon, R2, Firebase и т.д.). <strong>Не коммитьте ваш файл `.env`!</strong><br/>```bash<br/>cp .env.example .env<br/># Заполните .env<br/>```",
          "Настройте базу данных: Запустите локальный PostgreSQL или используйте инстанс Neon, затем примените миграции Prisma.<br/>```bash<br/>cd backend<br/>npx prisma migrate dev --name initial_setup # Или npx prisma migrate deploy для продакшна<br/>cd ..<br/>```",
          "Запустите сервисы в режиме разработки:<br/>```bash<br/>turbo run dev # Это запустит бэкенд и фронтенд серверы разработки<br/># Или перейдите в конкретные пакеты и запустите их скрипты разработки:<br/># cd backend && npm run start:dev<br/># cd packages/web && npm run dev<br/># cd packages/mobile-desktop && npm run android / npm run windows<br/>```"
        ],
        "outro": "Более подробные инструкции по локальной настройке и разработке можно найти в <a href=\"link_to_development_guide_doc\" target=\"_blank\" rel=\"noopener noreferrer\">Руководстве по Разработке</a>."
      },
      "documentationSystem": {
        "title": "Документация: Наша Система Знаний",
        "intro": "Этот README предоставляет общий обзор. Вся подробная информация о проекте содержится в нашей <strong>комплексной системе документации</strong>. Изучение этих документов является частью процесса <strong>обучения</strong> (Принцип 1) и понимания <strong>системы</strong> (Принцип 9):",
        "links": [
          "<a href=\"docs/AllRequirements/Docs/Planning/DocReq.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Документация по Требованиям</strong></a>: Что мы строим (функциональные и нефункциональные требования).",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocDevIn.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Руководство по Разработке</strong></a>: Как мы пишем код (структура, стандарты, инструменты, процесс CI/CD).",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocTech.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Техническая Документация</strong></a>: Высокоуровневый обзор архитектуры и стека.",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocSpec.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Спецификация API</strong></a>: Как компоненты взаимодействуют (описание GraphQL API).",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocInt.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Документация по Интеграциям</strong></a>: Как мы используем внешние сервисы (Neon, R2, Firebase, Stripe и т.д.) в качестве <strong>рычагов</strong>.",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocSecurity.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Руководство по Безопасности</strong></a>: Как мы защищаем АКТИВ и данные (принципы, методы, инструменты, процесс).",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocPer.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Руководство по Производительности</strong></a>: Как мы делаем систему быстрой (метрики, техники, инструменты оптимизации).",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocMonLog.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Руководство по Мониторингу и Логированию</strong></a>: Как мы видим состояние системы (метрики, логи, алерты).",
          "<a href=\"docs/AllRequirements/Docs/Design/Design/DocUI.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Документация UI</strong></a>: Как выглядит приложение и почему (макеты, компоненты, принципы дизайна).",
          "<a href=\"docs/AllRequirements/Docs/Sound/DocSound.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Аудио Руководство</strong></a>: Как аудио используется для улучшения UX.",
          "<a href=\"docs/AllRequirements/Docs/Support/DocSupport.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Руководство по Поддержке и Обслуживанию</strong></a>: Как мы поддерживаем систему и пользователей после релиза.",
          "<a href=\"docs/AllRequirements/Docs/Testing/DocSpecError.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Спецификация Ошибок</strong></a>: Как мы обрабатываем и сообщаем об ошибках.",
          "<a href=\"docs/AllRequirements/Docs/Testing/DocTesting.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Руководство по Тестированию</strong></a>: Как мы проверяем качество и надежность.",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocMigrationMicro.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>План Миграции на Микросервисы</strong></a>: Наша долгосрочная стратегия архитектурной эволюции.",
          "<a href=\"docs/AllRequirements/Docs/Planning/DocReq.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Инструкция по Требованиям MVP</strong></a>: Детальный анализ требований MVP и статуса реализации."
        ]
      },
      "contribution": {
        "title": "Вклад",
        "content": "Мы приветствуем вклад в создание этого цифрового АКТИВА! Если у вас есть идеи, предложения или вы хотите помочь с кодом, пожалуйста, ознакомьтесь с <a href=\"CONTRIBUTING.md\" target=\"_blank\" rel=\"noopener noreferrer\">Руководством по Вкладу</a> (если доступно)."
      }
    },
    "design": {
      "title": "Документация Дизайна BrainMessenger",
      "subtitle": "Система Качества и Ценности",
      "section1": {
        "title": "1. Введение: Дизайн как Фундамент Ценности",
        "name": "Система Дизайна BrainMessenger",
        "description": "Эта дизайн-система определяет визуальные и функциональные стандарты для интерфейса BrainMessenger. Наша цель — создать интерфейс, который не просто выглядит хорошо, но и является <strong>интуитивно понятным, эффективным и доступным</strong> (Принцип 2: Создание Ценности), опираясь на принципы <strong>качества > количества</strong> (Принцип 3) и <strong>прагматизма</strong> (Принцип 12) в выборе решений.",
        "goal": "Обеспечить <strong>единообразие, надежность и позитивный пользовательский опыт</strong> на всех платформах (Windows, Android, веб), делая BrainMessenger <strong>полезным АКТИВОМ</strong> (Принцип 10) для пользователей.",
        "principles_title": "Принципы, которыми руководствуется дизайн:",
        "principles": [
          "<strong>Создание Ценности (Принцип 2):</strong> Дизайн должен быть функциональным и решать задачи пользователя максимально удобно и эффективно.",
          "<strong>Качество > Количество (Принцип 3):</strong> Фокус на отточенности ключевых элементов, а не на множестве непродуманных деталей. Дизайн должен быть <strong>надежным</strong> и <strong>продуманным</strong>.",
          "<strong>Прагматизм и Реализм (Принцип 12):</strong> Выбор дизайнерских решений, реализуемых с учетом технических ограничений (например, оптимизация анимаций).",
          "<strong>Целостность (Принцип 7):</strong> Визуальная и функциональная целостность на всех платформах.",
          "<strong>Здоровье как Фундамент (Принцип 5):</strong> Внимание к доступности (WCAG), чтобы дизайн не создавал излишней нагрузки (зрительной, когнитивной) на пользователя."
        ]
      },
      "section2": {
        "title": "2. Цветовая палитра: Визуальный язык BrainMessenger",
        "intro": "Цвета разделены для Light и Dark режимов, поддерживая переключение темы (функция \"Night Mode\"). Все цвета заданы в HEX.",
        "light_mode_title": "2.1. Light Mode",
        "light_mode_table": [
          ["Категория", "Цвет (HEX)", "Назначение"],
          ["<strong>Primary Gradient</strong>", "`#A7F43A` → `#00C853`", "Основной градиент для акцентных элементов (кнопки \"Get Started\", иконки)"],
          ["<strong>Accent</strong>", "`#FF6347`", "Акцентные элементы (ошибки, важные сообщения)"],
          ["<strong>Secondary</strong>", "`#00BFFF`", "Второстепенные кнопки, ссылки, интерактивные элементы"],
          ["<strong>Success</strong>", "`#96C93D`", "Подтверждение, успешные действия"],
          ["<strong>Background</strong>", "`#FFFFFF`", "Основной фон"],
          ["<strong>Surface</strong>", "`#F0F0F0`", "Карточки, панели, фоны сообщений"],
          ["<strong>Text Primary</strong>", "`#333333`", "Основной текст"],
          ["<strong>Text Secondary</strong>", "`#4D4D4D`", "Вторичный текст, подсказки, метаданные"],
          ["<strong>Disabled</strong>", "`#B0B0B0`", "Неактивные элементы"],
          ["<strong>Border</strong>", "`#E8E8D9`", "Границы, разделители"]
        ],
        "dark_mode_title": "2.2. Dark Mode",
        "dark_mode_table": [
          ["Категория", "Цвет (HEX)", "Назначение"],
          ["<strong>Primary Gradient</strong>", "`#F2F047` → `#1ED94F`", "Основной градиент для акцентных элементов"],
          ["<strong>Accent</strong>", "`#FF6347`", "Акцентные элементы (ошибки)"],
          ["<strong>Secondary</strong>", "`#00BFFF`", "Второстепенные кнопки, ссылки"],
          ["<strong>Success</strong>", "`#96C93D`", "Подтверждение, успешные действия"],
          ["<strong>Background</strong>", "`#1A1A1A`", "Основной фон"],
          ["<strong>Surface</strong>", "`#333333`", "Карточки, панели, фоны сообщений"],
          ["<strong>Text Primary</strong>", "`#FFFFFF`", "Основной текст"],
          ["<strong>Text Secondary</strong>", "`#D9E8D9`", "Вторичный текст, подсказки"],
          ["<strong>Disabled</strong>", "`#4D4D4D`", "Неактивные элементы"],
          ["<strong>Border</strong>", "`#B0B0B0`", "Границы, разделители"]
        ],
        "premium_colors_title": "2.3. Цвета Премиум-Функций (Визуальное выделение Ценности)",
        "premium_colors": [
          "<strong>Premium Accent:</strong> `#FFD600` (Золотой)",
          "<strong>Premium Secondary:</strong> `#2196F3` (Синий)",
          "Используются для визуального выделения премиум-функций (например, в анимациях нейронных связей, специальных элементах UI), подчеркивая их <strong>дополнительную ценность</strong> (Принцип 2, 10)."
        ],
        "color_application_title": "2.4. Применение Цветов (Примеры)",
        "color_application": [
          {
            "title": "Welcome Screen (из скриншота):",
            "items": [
              "Фон: `#1A1A1A` (Dark Mode).",
              "Кнопка \"Get Started\": Градиент `#F2F047` → `#1ED94F`.",
              "Иконка чата: `#F2F047` (обводка) с белым символом внутри.",
              "Текст: `#FFFFFF` (Welcome to Brain Messenger), `#D9E8D9` (подсказка)."
            ]
          },
          {
            "title": "Переключение темы:",
            "items": [
              "Реализовано через глобальный флаг `themeMode` (`Light`/`Dark`).",
              "Пример в React Native:\n```jsx\nimport { useColorScheme } from 'react-native';\nconst themeMode = useColorScheme() === 'dark' ? 'Dark' : 'Light';\nconst backgroundColor = themeMode === 'Dark' ? '#1A1A1A' : '#FFFFFF'; // Пример выбора фона\n```"
            ]
          }
        ],
        "usage_recommendations_title": "2.5. Рекомендации по Использованию Цветов",
        "usage_recommendations": [
          "<strong>Градиенты:</strong> Используйте `#A7F43A` → `#00C853` или `#F2F047` → `#1ED94F` (в зависимости от темы) для ключевых действий и акцентных элементов, привлекающих внимание к <strong>ценности</strong> (Принцип 2).",
          "<strong>Темная тема:</strong> Используйте `#1A1A1A` или `#212121` как основной фон для снижения нагрузки на глаза (связь с Принципом 5: Здоровье).",
          "<strong>Контраст:</strong> Всегда проверяйте контрастность текста и элементов для обеспечения <strong>доступности</strong> (WCAG 2.1 AA) и соответствия Принципу 7 (Целостность). Используйте инструменты вроде WebAIM Contrast Checker."
        ]
      },
      "section3": {
        "title": "3. Типографика: Читаемость как Основа Эффективности",
        "intro": "Выбор шрифта и его применение основаны на обеспечении максимальной читаемости и доступности, что критически важно для эффективного усвоения информации и снижения когнитивной нагрузки (связь с Принципом 5: Здоровье и Принципом 2: Ценность).",
        "primary_font_title": "3.1. Основной шрифт",
        "primary_font": [
          "<strong>Семейство:</strong> Roboto (Google Fonts)",
          "<strong>Запасной:</strong> Sans-serif",
          "<strong>Причина:</strong> Высокая читаемость на разных размерах экрана, широкая поддержка символов (мультиязычность), открытая лицензия и доступность."
        ],
        "sizes_styles_title": "3.2. Размеры и стили (Шкала для Иерархии)",
        "sizes_styles_table": [
          ["Уровень", "Размер", "Начертание", "Использование"],
          ["H1 (Заголовок)", "24px", "Bold", "Основные заголовки экранов (например, \"Чаты\")"],
          ["H2 (Подзаголовок)", "18px", "Medium", "Второстепенные заголовки, названия групп"],
          ["Body", "16px", "Regular", "Основной текст сообщений, список чатов"],
          ["Caption", "14px", "Regular", "Подписи под фото, время сообщений, мелкий текст"],
          ["Button", "16px", "Medium", "Текст кнопок действий"]
        ],
        "notes_title": "Примечания:",
        "notes": [
          "<strong>Высота строки (Line Height):</strong> Минимум 1.5 для основного текста для улучшения читаемости.",
          "<strong>Кастомизация (Принцип 2):</strong> Пользователь может выбрать альтернативный шрифт в настройках (например, Open Sans) для адаптации под свои предпочтения.",
          "<strong>Доступность:</strong> Соблюдение контраста и минимального размера шрифта для соответствия WCAG."
        ]
      },
      "section4": {
        "title": "4. Анимации: Оптимизация и Смысл (Принцип 12: Прагматизм)",
        "intro": "Анимации в BrainMessenger используются для улучшения пользовательского опыта, предоставления визуальной обратной связи и придания интерфейсу живости. Однако они должны быть <strong>прагматичными, оптимизированными</strong> (<2 ГБ RAM), и <strong>не создавать излишней нагрузки</strong> (связь с Принципом 5: Здоровье).",
        "principles_title": "4.1. Принципы Анимаций",
        "principles": [
          "<strong>Смысл:</strong> Каждая анимация должна иметь четкую цель – объяснить переход, привлечь внимание к важному, подтвердить действие.",
          "<strong>Плавность:</strong> Использование `ease-in-out` или `ease-out` для натурального движения.",
          "<strong>Оптимизация:</strong> Анимации не должны замедлять интерфейс или потреблять много ресурсов. Длительность подобрана для баланса между плавностью и скоростью.",
          "<strong>Доступность:</strong> Избегание слишком быстрых или мигающих анимаций, которые могут вызвать дискомфорт или приступы у чувствительных пользователей."
        ],
        "list_title": "4.2. Список Анимаций (Примеры)",
        "list_table": [
          ["Название", "Описание", "Триггер", "Параметры", "Связь с Принципами", "Цвета (Light/Dark)"],
          ["Переключение слайдов", "Сдвиг слайдов (Welcome Screen)", "Свайп/клик по стрелке", "0.3 сек, slide left/right", "P2 (Онбординг)", "#96C93D / #96C93D"],
          ["Открытие чата", "Чат появляется снизу вверх", "Клик по чату в списке", "0.3 сек, ease-in-out", "P2 (Навигация)", "#00BFFF / #00BFFF"],
          ["Нажатие кнопки", "Визуальный фидбек при клике (уменьшение)", "Клик по кнопке", "0.2 сек, scale", "P2 (Фидбек)", "Градиент #F2F047→#1ED94F"],
          ["Отправка сообщения", "Сообщение появляется с плавным появлением", "Клик \"Отправить\"", "0.3 сек, fade-in", "P2 (Фидбек)", "#96C93D / #96C93D"],
          ["Переход между экранами", "Сдвиг экрана вправо/влево (базовая навигация)", "Навигация", "0.3 сек, slide", "P2 (Навигация)", "#B0B0B0 / #4D4D4D"],
          ["Анимация иконок (Morph)", "Преобразование иконки (например, mute → unmute)", "Клик (переключение состояния)", "0.4 сек, morph", "P2 (Состояние)", "#FF6347 / #FF6347"],
          ["Волны при нажатии (Ripple)", "Радиальные волны от точки нажатия (фидбек)", "Клик по кнопке/элементу", "0.3 сек, ripple", "P2 (Фидбек)", "#F2F047 / #F2F047"],
          ["Глитч-эффект (Premium)", "Искажение текста для премиум (визуализация)", "Активация подписки", "0.2 сек, glitch", "P2, P10 (Выделение)", "#FF6347 / #FF6347"],
          ["Нейронные связи (Premium)", "Пульсирующие линии (визуализация Актива)", "Премиум-экран", "0.5 сек, pulse", "P2, P10 (Выделение)", "#96C93D / #96C93D"]
        ],
        "implementation_examples_title": "4.3. Примеры Реализации (Фрагменты кода)",
        "css_ripple_title": "CSS для Ripple-эффекта:",
        "css_ripple_code": ".ripple {\n  background: linear-gradient(45deg, #F2F047, #1ED94F); /* Или другие цвета/градиент */\n  border-radius: 50%;\n  animation: ripple 0.3s ease-out;\n}\n@keyframes ripple {\n  to { transform: scale(2); opacity: 0; }\n}",
        "rn_icon_title": "React Native для анімованої іконки:",
        "rn_icon_code": "import Animated from 'react-native-reanimated'; // Пример библиотеки\nimport Icon from 'react-native-vector-icons/MaterialIcons'; // Пример библиотеки\n\nconst color = themeMode === 'Dark' ? '#FFFFFF' : '#333333';\n// Создание анімованого компонента Icon\nconst AnimatedIcon = Animated.createAnimatedComponent(Icon);\n\n// Пример использования с анимацией scale (припускаючи, что 'scale' - это Animated.Value)\n<AnimatedIcon name=\"volume-up\" color={color} style={{ transform: [{ scale: scale }] }} />"
      },
      "section5": {
        "title": "5. Выравнивание и Сетка: Структура и Порядок (Принцип 9: Система)",
        "intro": "Использование последовательной системы выравнивания и модульной сетки — это основа для создания <strong>системного, легко поддерживаемого и визуально гармоничного</strong> интерфейса (Принцип 9: Система).",
        "base_grid": "<strong>Базовая Сетка:</strong> 8px (базовый шаг для определения размеров элементов, отступов, интервалов). Все значения должны быть кратны 8 (или 4 для очень мелких элементов).",
        "alignment_title": "<strong>Выравнивание:</strong>",
        "alignment": [
          "Используется принцип <strong>визуальной иерархии</strong>: более важные элементы располагаются выше или визуально доминируют.",
          "<strong>Вертикальный поток:</strong> Контент на экранах организуется сверху вниз: Заголовок → Поле ввода → Кнопка действия.",
          "<strong>Горизонтальное выравнивание:</strong> Элементы в контейнерах выравниваются по левому краю (для LTR) или правому краю (для RTL), если нет необходимости в центрировании (например, заголовки в шапке).",
          "<strong>Отступы (Padding/Margin):</strong> Используются значения из шкалы, кратной 8px (8, 16, 24, 32, 40, 48 px и т.д.) для создания четких интервалов между элементами и группами элементов."
        ],
        "adaptability_title": "<strong>Адаптивность и Отзывчивость:</strong>",
        "adaptability": [
          "Дизайн адаптируется под различные размеры экрана для обеспечения <strong>ценности</strong> (Принцип 2) на любом устройстве.",
          "<strong>Мобильные устройства:</strong> 320px–767px (Обычно одноколоночный макет).",
          "<strong>Планшеты:</strong> 768px–1023px (Возможно, двухколоночный макет, боковые панели).",
          "<strong>Десктоп:</strong> 1024px+ (Широкий макет, многоколоночный дизайн, боковые панели)."
        ]
      },
      "section6": {
        "title": "6. Принципы Доступности (WCAG 2.1 AA): Дизайн для Всех (Принцип 5: Здоровье, Принцип 7: Целостность)",
        "intro": "<strong>Доступность — это не опция, а фундаментальное требование</strong> (схоже с Принципом 5: Здоровье как Фундамент) для создания <strong>целостного</strong> (Принцип 7) и <strong>ценного</strong> (Принцип 2) продукта, которым могут пользоваться все, независимо от их способностей или используемых технологий. Мы стремимся соответствовать уровню WCAG 2.1 AA.",
        "principles": [
          "<strong>Контрастность Цветов:</strong> Текстовые элементы должны иметь минимальный контраст 4.5:1 (для обычного текста) и 3:1 (для крупного текста или иконок) по отношению к фону. Это проверяется для обеих тем (Light/Dark).",
          "<strong>Навигация с Клавиатуры:</strong> Все интерактивные элементы (кнопки, ссылки, поля ввода) должны быть доступны для навигации с помощью клавиатуры (Tab, Shift+Tab) и активации (Enter, Space).",
          "<strong>Поддержка Экранных Читалок (Screen Readers):</strong> Использование семантической разметки (HTML) и ARIA-атрибутов для предоставления контекста и информации пользователям экранных читалок (например, описания для иконок, состояния элементов).",
          "<strong>Визуальный Индикатор Фокуса:</strong> Для пользователей клавиатуры должен быть четкий и видимый индикатор текущего сфокусированного элемента (например, синяя обводка `#007BFF`).",
          "<strong>Обработка Ошибок:</strong> Сообщения об ошибках должны быть четкими, понятными и легко определяемыми пользователями, включая пользователей экранных читалок.",
          "<strong>Поддержка RTL (Справа Налево):</strong> Дизайн адаптируется для языков с направлением письма справа налево (например, арабский), включая зеркальное отображение макета, иконок и текста (см. DocLocIn.md)."
        ]
      },
      "section7": {
        "title": "7. Примечания и Рекомендации",
        "notes": [
          "<strong>Кастомизация Пользователем:</strong> Помните, что некоторые аспекты дизайна (цвета чатов, шрифты) пользователь может изменять в настройках. Дизайн системы должен учитывать эту гибкость.",
          "<strong>Тестирование на Реальных Устройствах:</strong> Все компоненты дизайна необходимо тестировать на разнообразных устройствах, с различными разрешениями экрана и в разных условиях освещения, чтобы убедиться в их эффективности и доступности.",
          "<strong>Живая Документация:</strong> Эта дизайн-система — живой документ. Она будет дополняться новыми компонентами, шаблонами и рекомендациями по мере развития продукта, отражая принципы <strong>непрерывного совершенствования</strong> (Принцип 1) и <strong>системного подхода</strong> (Принцип 9).",
          "<strong>Дизайн как часть Процесса Кайдзен:</strong> Дизайн-решения анализируются и улучшаются на основе обратной связи и реального использования, интегрируясь в общий процесс Кайдзен (Принцип 9, 14)."
        ]
      }
    },
    "localizationGuide": {
      "title": "Руководство по Локализации BrainMessenger",
      "subtitle": "Доступность и Масштабирование",
      "section1": {
        "title": "1. Введение: Расширение Ценности через Доступность",
        "name": "BrainMessenger Design System",
        "description": "Это руководство описывает процесс локализации BrainMessenger — ключевой шаг для обеспечения доступности и ценности (Принцип 2) продукта для широкой аудитории по всему миру. Мы рассматриваем локализацию не просто как перевод строк, а как систематический процесс (Принцип 9) адаптации интерфейса и контента, который позволит нам масштабировать наше влияние (Принцип 2, 8).",
        "goal": "Сделать BrainMessenger понятным и удобным для пользователей из разных культур, начиная с базового набора языков и создавая надежную систему (Принцип 9) для легкого добавления новых в будущем.",
        "current_status": "Базовая поддержка английского языка (MVP). Идет планирование и подготовка к добавлению новых языков в рамках текущих этапов разработки (см. Дорожную карту).",
        "principles_title": "Принципы, которыми руководствуется локализация:",
        "principles": [
          "Создание Ценности (Принцип 2): Локализация напрямую повышает ценность продукта для неанглоязычных пользователей.",
          "Система и Оптимизация (Принцип 9): Процесс локализации строится как четкая, повторяемая система для эффективности.",
          "Прагматизм и Реализм (Принцип 12): Выбор начального набора языков основывается на потенциальном охвате и ресурсах.",
          "Внешняя Экспертиза и Обратная Связь (Принцип 14): Привлечение профессиональных переводчиков и сбор обратной связи от пользователей на разных языках."
        ]
      },
      "section2": {
        "title": "2. Цели Локализации",
        "goals": [
          "Обеспечить поддержку минимум 5 ключевых языков (Английский, Испанский, Французский, Русский, Арабский) для старта MVP — (Требование NFR-11, соответствующее Принципу 12: Прагматизм).",
          "Реализовать адаптацию пользовательского интерфейса для языков с направлением письма справа налево (RTL), таких как арабский (Принцип 2: Доступность).",
          "Поддерживать единообразие терминологии и стиля во всех переводах, используя централизованные инструменты (Принцип 9: Система).",
          "Создать эффективный и простой процесс добавления новых языков по мере роста базы пользователей и поступления запросов (Принцип 9: Масштабирование, Принцип 12: Прагматизм, Принцип 14: Обратная связь)."
        ]
      },
      "section3": {
        "title": "3. Инструменты и Технологии: Надежный Фундамент (Принцип 8, 9)",
        "intro": "Выбор инструментов основан на прагматизме (Принцип 12), надежности и поддержке системного подхода (Принцип 9).",
        "tools_table": [
          ["Инструмент", "Назначение", "Установка/Конфигурация"],
          ["i18next", "Основная библиотека для управления переводами в Frontend (React Native). Поддерживает интерполяцию, контексты.", "npm install i18next react-i18next"],
          ["react-intl", "Библиотека для локализованного форматирования дат, чисел, валют в Frontend.", "npm install react-intl"],
          ["Transifex", "Профессиональная платформа для управления переводами, привлечения переводчиков и обеспечения качества перевода.", "Регистрация на transifex.com"],
          ["rtlcss", "Утилита для автоматической трансформации CSS-стилей для поддержки RTL-языков.", "npm install -g rtlcss (глобально) или npm install rtlcss --save-dev"],
          ["JSON файлы", "Формат хранения переводов.", "Стандартный."]
        ]
      },
      "section4": {
        "title": "4. Структура Файлов Переводов: Порядок в Системе (Принцип 9)",
        "intro": "Переводы организованы в четкой файловой структуре для удобства управления (Принцип 9: Система).",
        "location_title": "4.1. Расположение",
        "location_content": "Файлы переводов хранятся в директории locales внутри frontend/src:\n\nfrontend/\n├── src/\n│ ├── locales/\n│ │ ├── en.json # Английский (базовый)\n│ │ ├── es.json # Испанский\n│ │ ├── fr.json # Французский\n│ │ ├── ru.json # Русский\n│ │ ├── ar.json # Арабский (пример RTL)\n│ └── index.ts # Конфигурация i18next",
        "format_title": "4.2. Формат JSON: Контекст и Гибкость",
        "format_content": "Ключи: Используется camelCase. Ключи должны быть описательными и отражать контекст использования строки (например, sendButton вместо просто send).\n\nЗначения: Содержат переводимый текст. Поддерживается интерполяция для вставки динамических данных (например, имена пользователей).",
        "format_example": "Пример en.json:\n\n```json\n{\n  \"welcomeTitle\": \"Welcome to BrainMessenger!\",\n  \"sendButton\": \"Send\",\n  \"errors\": {\n    \"unauthorized\": \"Please log in again to continue.\",\n    \"notFound\": \"The requested item could not be found.\"\n  },\n  \"chat\": {\n    \"newMessageNotification\": \"New message from {{name}}\",\n    \"unreadCount\": \"{{count}} unread messages\"\n  },\n  \"settings\": {\n    \"language\": \"Language\",\n    \"theme\": \"Theme\"\n  }\n}\n```",
        "rtl_flag_title": "4.3. RTL-флаг: Адаптация Интерфейса",
        "rtl_flag_content": "Для языков с направлением справа налево в начало соответствующего JSON-файла добавляется метаданные для индикации:",
        "rtl_flag_example": "```json\n{\n  \"rtl\": true,\n  \"welcomeTitle\": \"مرحبًا بك في BrainMessenger!\"\n  // ... остальные переводы\n}\n```\n\nЭтот флаг используется Frontend-приложением для соответствующей адаптации стилей и макета."
      },
      "section5": {
        "title": "5. Настройка Локализации: Интеграция в Систему (Принцип 9)",
        "intro": "Локализация интегрируется как в Frontend (для отображения переведенного UI), так и в Backend (для возврата локализованных ошибок или уведомлений).",
        "frontend_title": "5.1. Frontend (React Native): Использование i18next",
        "frontend_init_title": "Инициализация i18next:",
        "frontend_init_code": "В главном файле приложения или файла конфигурации (frontend/src/index.ts или подобном):\n\n```jsx\nimport i18n from 'i18next'\nimport { initReactI18next } from 'react-i18next'\n\n// Импорт всех файлов локалей\nimport en from './locales/en.json'\nimport es from './locales/es.json'\nimport fr from './locales/fr.json'\nimport ru from './locales/ru.json'\nimport ar from './locales/ar.json'\n\n// Определение ресурсов\nconst resources = {\n  en: { translation: en },\n  es: { translation: es },\n  fr: { translation: fr },\n  ru: { translation: ru },\n  ar: { translation: ar },\n};\n\ni18n\n  .use(initReactI18next) // Подключение react-i18next\n  .init({\n    resources,\n    lng: 'en', // Язык по умолчанию при первом запуске (может определяться по системным настройкам или выбору пользователя)\n    fallbackLng: 'en', // Резервный язык, если текущий перевод отсутствует\n    interpolation: {\n      escapeValue: false // Позволяет использовать HTML теги в переводах (осторожно!)\n    }\n  });\n\nexport default i18n;\n```",
        "frontend_usage_title": "Использование перевода в компонентах:",
        "frontend_usage_code": "Используйте хук useTranslation для доступа к функции t и объекту i18n.\n\n```jsx\nimport { useTranslation } from 'react-i18next';\nimport { Text, Button, View } from 'react-native';\n\nconst WelcomeScreen = () => {\n  const { t, i18n } = useTranslation(); // Получаем функцию t и объект i18n\n\n  return (\n    <View>\n      {/* Использование простого перевода */}\n      <Text>{t('welcomeTitle')}</Text>\n      \n      {/* Использование перевода с интерполяцией */}\n      {/* Предполагается, что где-то есть состояние unreadCount */}\n      <Text>{t('chat.unreadCount', { count: 5 })}</Text> \n\n      {/* Использование перевода для текста кнопки */}\n      <Button title={t('sendButton')} onPress={sendMessage} />\n      \n      {/* Пример смены языка */}\n      <Button title={t('settings.language')} onPress={() => i18n.changeLanguage('ar')} />\n    </View>\n  );\n};\n```",
        "frontend_change_title": "Смена языка:",
        "frontend_change_content": "Язык меняется вызовом i18n.changeLanguage('код_языка'). Обычно это делается в настройках пользователя.",
        "backend_title": "5.2. Backend (NestJS): Локализация Ошибок и Уведомлений",
        "backend_intro": "Backend может возвращать локализованные сообщения об ошибках или уведомления, опираясь на язык, переданный Frontend (например, в заголовке Accept-Language или настройках пользователя).",
        "backend_code": "Использование локализованных сообщений при выбрасывании ошибок:\n\n```typescript\nimport { HttpException, HttpStatus } from '@nestjs/common';\nimport { t } from 'i18next'; // Предполагается, что i18next инициализирован и в Backend\n\n// В сервисе или контроллере\nif (!user) {\n  // Определяем язык пользователя (например, из request.headers['accept-language'])\n  const userLang = determineUserLanguage(request); \n  throw new HttpException(t('errors.unauthorized', { lng: userLang }), HttpStatus.UNAUTHORIZED);\n}\n```",
        "backend_note": "Локаль пользователя определяется из заголовка Accept-Language (стандартный подход) или сохраняется в профиле пользователя в базе данных после его выбора в настройках приложения.",
        "rtl_adaptation_title": "5.3. RTL-адаптация (Справа Налево): Зеркальное Отображение Системы",
        "rtl_adaptation_intro": "Для языков с RTL (арабский, иврит и др.) необходимо зеркально отобразить макет и некоторые элементы интерфейса.",
        "rtl_css_title": "Стили (CSS/CSS-in-JS):",
        "rtl_css_code": "Используйте rtlcss в процессе сборки или условные стили в коде. rtlcss автоматически преобразует свойства вроде margin-left, padding-right, text-align: left и т.п. в их RTL-эквиваленты (margin-right, padding-left, text-align: right).\n\n```css\n/* Исходный CSS для LTR */\n.message-bubble {\n  margin-left: 10px;\n  text-align: left;\n}\n/* После обработки rtlcss для RTL */\n.message-bubble {\n  margin-right: 10px;\n  text-align: right;\n}\n```",
        "rtl_rn_title": "React Native:",
        "rtl_rn_code": "React-Native имеет встроенную поддержку RTL через I18nManager.\n\n```jsx\nimport { I18nManager } from 'react-native';\nimport i18n from './index'; // Ваш файл инициализации i18next\n\n// В главном файле приложения, перед рендером\nconst isRTL = i18n.language === 'ar' || i18n.language === 'he'; // Проверяем, является ли текущий язык RTL\n\n// ForceRTL может потребовать перезагрузки приложения для полной силы\nif (isRTL !== I18nManager.isRTL) {\n  I18nManager.forceRTL(isRTL);\n  // Optional: Restart the app to apply RTL layout fully\n  // RNRestart.Restart(); \n}\n\n// Некоторые стили могут требовать ручной адаптации, если auto-conversion недостаточно\nconst containerStyle = {\n  flexDirection: isRTL ? 'row-reverse' : 'row',\n  textAlign: isRTL ? 'right' : 'left',\n};\n```",
        "rtl_icons_title": "Иконки:",
        "rtl_icons_content": "Некоторые иконки (например, стрелки \"назад\", \"далее\") должны быть зеркально отображены для RTL. Это можно делать условно в коде или использовать RTL-ready наборы иконок."
      },
      "section6": {
        "title": "6. Процесс Добавления Нового Языка: Масштабируемая Система (Принцип 9)",
        "intro": "Процесс добавления нового языка построен как четкая, повторяемая последовательность действий для обеспечения эффективности (Принцип 9).",
        "file_title": "Создание базового файла перевода:",
        "file_content": "Скопируйте актуальный en.json (или другой наиболее полный файл) в frontend/src/locales/<code>.json, где <code> — двухбуквенный код нового языка (например, de.json для немецкого).\nДобавьте rtl: true в начало файла, если новый язык RTL.",
        "transifex_title": "Загрузка на платформу переводов (Transifex):",
        "transifex_content": "Загрузите новый файл <code>.json в проект BrainMessenger на Transifex. Система автоматически определит, какие строки нуждаются в переводе.",
        "process_title": "Организация процесса перевода:",
        "process_content": "Назначьте переводчиков (профессионалов или проверенных участников сообщества, Принцип 14) для нового языка в Transifex.\nОтвечайте на их вопросы по контексту строк.\nКонтролируйте прогресс перевода в Transifex.",
        "export_title": "Экспорт и Интеграция перевода:",
        "export_content": "После завершения перевода экспортируйте готовый файл <code>.json из Transifex.\nПоместите его обратно в директорию frontend/src/locales/.\nИмпортируйте новый ресурс в файле инициализации i18next (frontend/src/index.ts) и добавьте его в объект resources.",
        "ui_title": "Добавление опции выбора языка в UI:",
        "ui_content": "Добавьте новый язык в список доступных языков в разделе \"Настройки\" > \"Язык\".",
        "testing_title": "Тестирование:",
        "testing_intro": "Критически важный шаг (Принцип 3: Качество). Переключите язык в настройках приложения.",
        "testing_scenarios": [
          "Корректность перевода всех строк в UI.",
          "Отсутствие обрезки текста (некоторые языки длиннее английского).",
          "Корректное отображение UI для RTL-языков (зеркальность, выравнивание).",
          "Интерполяция и Форматирование: Проверьте экраны, где используются динамические данные (имена, счетчики, даты, числа), убедитесь, что они форматируются правильно для текущей локали.",
          "Локализованные ошибки: Инициируйте различные ошибки (неправильный логин, отсутствие элемента), проверьте, что сообщения об ошибках приходят на выбранном языке."
        ]
      },
      "section7": {
        "title": "7. Поддерживаемые Языки (Начальный Список и План)",
        "intro": "Начальный список языков, выбранный по прагматическим соображениям (Принцип 12) и потенциальному охвату.",
        "languages_table": [
          ["Код", "Язык", "Направление", "Статус", "План (Q 2025)"],
          ["en", "Английский", "LTR", "Реализован (Базовый)", "-"],
          ["es", "Испанский", "LTR", "В плане (Q3)", "Q3"],
          ["fr", "Французский", "LTR", "В плане (Q3)", "Q3"],
          ["ru", "Русский", "LTR", "В плане (Q3)", "Q3"],
          ["ar", "Арабский", "RTL", "В плане (Q3, требуется RTL)", "Q3"]
        ],
        "expansion_note": "Расширение списка: Новые языки будут добавляться на основе обратной связи (Принцип 14) и анализа потенциальной ценности (Принцип 2) для роста аудитории (например, если >10% запросов о поддержке нового языка)."
      },
      "section8": {
        "title": "8. Рекомендации: Лучшие Практики Локализации",
        "dev_title": "8.1. Для Разработчиков (Пишем Код, Готовый к Миру)",
        "dev_points": [
          "Не хардкодьте строки! Все строки, которые видит пользователь, должны быть вынесены в файлы локализации и использоваться через функцию t('ключ') (Принцип 9: Система).",
          "Используйте интерполяцию для строк с переменными данными (t('chat.newMessageNotification', { name: user.name })), а не конкатенацию строк в коде.",
          "Учитывайте плюрализацию (формы единственного/множественного числа) при работе со счетчиками ({{count}} unread messages). i18next и react-intl поддерживают это.",
          "Используйте react-intl для всех операций с датами, числами, валютами, чтобы их формат был корректным для каждой локали (Принцип 3: Качество, Принцип 2: Ценность).",
          "Тестируйте UI с длинными переводами (например, немецкий, который часто длиннее английского) и RTL-языками, чтобы убедиться, что макет не ломается и текст не обрезается (Принцип 3: Качество)."
        ],
        "design_title": "8.2. Для Дизайнеров (Рисуем Макеты, Гибкие к Языкам)",
        "design_points": [
          "Учитывайте, что текст на других языках может быть на 30% (и более) длиннее английского. Оставляйте достаточно пространства в компонентах.",
          "Проектируйте макеты с учетом зеркального отображения для RTL. Иконки направлений, расположение текста и элементов должны меняться (Принцип 2: Доступность)."
        ],
        "translator_title": "8.3. Для Переводчиков (Создаем Понятный Контент)",
        "translator_points": [
          "Сохраняйте контекст. Одно и то же английское слово может переводиться по-разному в зависимости от того, где оно используется (например, \"Send\" для сообщения или для заявки). Платформы вроде Transifex помогают добавлять контекстные комментарии.",
          "Придерживайтесь последовательной терминологии, используйте глоссарий, если он есть.",
          "Сохраняйте тон приложения (дружелюбный, но профессиональный, особенно в системных сообщениях и ошибках).",
          "Используйте возможности интерполяции и плюрализации в файлах перевода."
        ]
      },
      "section9": {
        "title": "9. Форматирование (Даты, Числа, Валюты): Детали, Создающие Качество (Принцип 3)",
        "intro": "Корректное отображение локализованных данных критически важно для качества (Принцип 3) и удобства (Принцип 2).",
        "dates_title": "Даты и Время:",
        "dates_code": "```jsx\nimport { FormattedDate, FormattedTime } from 'react-intl';\n\n// Отобразит дату в формате, соответствующем текущей локали\n<FormattedDate value={new Date()} /> // Например, \"3/14/2025\" (en-US) или \"14.3.2025\" (de-DE)\n<FormattedDate value={new Date()} weekday=\"long\" year=\"numeric\" month=\"long\" day=\"numeric\" /> // \"Friday, March 14, 2025\"\n\n// Отобразит время\n<FormattedTime value={new Date()} /> // Например, \"3:00:00 PM\" (en-US) или \"15:00:00\" (de-DE)\n```",
        "numbers_title": "Числа и Валюты:",
        "numbers_code": "```jsx\nimport { FormattedNumber, FormattedCurrency } from 'react-intl';\n\n// Отобразит число с локальным разделителем тысяч и десятичным знаком\n<FormattedNumber value={1234.56} /> // \"1,234.56\" (en-US) или \"1.234,56\" (de-DE)\n\n// Отобразит число как процент\n<FormattedNumber value={0.75} style=\"percent\" /> // \"75%\"\n\n// Отобразит число как валюту (требует кода валюты)\n<FormattedCurrency value={123.45} currency=\"USD\" /> // \"$123.45\" (en-US)\n```\n\nДля работы с react-intl необходимо обернуть ваше приложение в IntlProvider и загрузить соответствующие данные локали (react-intl/locale-data)."
      },
      "section10": {
        "title": "10. Тестирование Локализации: Гарантия Качества (Принцип 3, 9)",
        "intro": "Тестирование — неотъемлемая часть системы обеспечения качества (Принцип 3, 9).",
        "scenarios_title": "Сценарии Тестирования:",
        "scenarios_points": [
          "Переключение языка: Убедитесь, что смена языка в настройках мгновенно (или после перезапуска, если требуется I18nManager) применяет новый перевод и RTL-макет.",
          "Отображение всех строк: Проверьте основные экраны и диалоги, чтобы убедиться, что все видимые пользователю строки переведены.",
          "Длинный текст: Проверьте UI с языками, известными своей длиной (например, немецкий, русский), чтобы убедиться, что текст не обрезается, элементы не накладываются друг на друга.",
          "RTL-интерфейс: Тщательно проверьте UI на арабском (или другом RTL-языке): направление текста, выравнивание элементов, отображение иконок направлений, положение скроллбаров.",
          "Интерполяция и Форматирование: Проверьте экраны, где используются динамические данные (имена, счетчики, даты, числа), убедитесь, что они форматируются правильно для текущей локали.",
          "Локализованные ошибки: Инициируйте различные ошибки (неправильный логин, отсутствие элемента), проверьте, что сообщения об ошибках приходят на выбранном языке."
        ],
        "tools_title": "Инструменты:",
        "tools_points": [
          "Ручное тестирование: Основной метод. Тестирование на реальных устройствах с разными локалями.",
          "Автоматизированные тесты (Cypress/detox): Можно написать тесты, которые проверяют наличие определенных ключей перевода на странице или даже делают скриншоты UI для сравнения LTR/RTL макетов (Принцип 9: Система)."
        ],
        "criteria_title": "Критерии Успеха Тестирования:",
        "criteria_points": [
          "100% пользовательских строк переведены.",
          "Отсутствие обрезки или наложения текста в UI.",
          "Корректное и полное RTL-отображение для соответствующих языков.",
          "Правильное локализованное форматирование дат, чисел, валют."
        ]
      },
      "section11": {
        "title": "11. Примечания",
        "notes": [
          "План: Полная реализация поддержки 5 ключевых языков запланирована на Q3 2025 (см. Дорожную карту), после завершения этапа построения технологического фундамента и начала разработки MVP.",
          "Масштабирование: Система разработана так, чтобы добавление новых языков в будущем было эффективным (Принцип 9). Основные затраты — это сам перевод.",
          "Ограничения: Технические логи, сообщения сервера для отладки не переводятся. Локализация касается только пользовательского интерфейса и сообщений, предназначенных для конечного пользователя."
        ]
      }
    },
    "userGuide": {
      "title": "Руководство пользователя BrainMessenger",
      "subtitle": "Ваш центр для эффективного общения и роста",
      "introduction": {
        "title": "1. Введение: Добро пожаловать в Вашу систему взаимодействия",
        "p1": "<strong>Добро пожаловать в BrainMessenger!</strong>",
        "p2": "BrainMessenger — это не просто мессенджер, а <strong>ваша персональная система</strong> для безопасного, удобного и <strong>эффективного общения и взаимодействия</strong> (Принцип 2: Создание ценности, Принцип 9: Система). Мы создали этот <strong>цифровой АКТИВ</strong> (Принцип 10), чтобы <strong>упростить сложность</strong> (Маргулан), предоставив вам надежный инструмент для связи с другими и организации вашего общения.",
        "p3": "Это руководство — ваш компас в мире BrainMessenger. Оно структурировано так, чтобы вы могли быстро освоить ключевые функции и использовать приложение максимально <strong>эффективно</strong> (Принцип 9).",
        "p4": "<strong>Для кого:</strong> BrainMessenger разработан для широкой аудитории и доступен на всех основных платформах: iOS (версия 13+), Android (версия 9+), а также полноценная веб-версия для современных браузеров (Chrome, Firefox, Safari, Edge). Мы стремимся к максимальной <strong>доступности</strong> (Принцип 5) для каждого.",
        "p5": "<strong>Как начать:</strong> Самый <strong>прагматичный</strong> (Принцип 12) способ — установить приложение из соответствующего магазина приложений или открыть веб-сайт `https://brainmessenger.com`."
      },
      "gettingStarted": {
        "title": "2. Начало работы: Первые шаги в системе BrainMessenger",
        "p1": "Ваш процесс регистрации и входа разработан как <strong>простая и безопасная система</strong> (Принцип 9, 5).",
        "registration": {
          "title": "2.1. Регистрация: Создание вашего профиля в системе",
          "steps": [
            "1. Откройте приложение или перейдите на веб-сайт.",
            "2. Нажмите кнопку <strong>\"Начать\"</strong> (Зарегистрироваться) на экране приветствия.",
            "3. Следуйте пошаговым инструкциям:",
            "<strong>Введите Email:</strong> Ваш активный адрес электронной почты (например, `user@example.com`). Он будет использоваться для уведомлений, входа и восстановления доступа. Убедитесь, что формат email верный.",
            "<strong>Создайте Пароль:</strong> Придумайте <strong>надежный пароль</strong> (минимум 8 символов, включая хотя бы одну цифру и один специальный символ, например, `MyStrongP@ss!1`). Безопасность вашей учетной записи является частью нашей <strong>основы</strong> (Принцип 5, 8).",
            "<strong>Введите Имя:</strong> Ваше отображаемое имя в BrainMessenger.",
            "<strong>Подтвердите Email:</strong> Мы отправим 8-значный код подтверждения на указанный email (см. API Specification, DocInt). Проверьте свою почту (включая папку «Спам»). Введите код в приложении.",
            "4. Нажимайте кнопку подтверждения на каждом шаге."
          ],
          "result": "*Результат:* Ваша учетная запись успешно создана. Вы становитесь частью <strong>системы BrainMessenger</strong>."
        },
        "login": {
          "title": "2.2. Вход: Доступ к вашей сети взаимодействия",
          "steps": [
            "1. На экране приветствия выберите <strong>\"Войти\"</strong> (Sign In).",
            "2. Введите ваш зарегистрированный email и пароль.",
            "3. Нажмите <strong>\"Войти\"</strong> (Sign In)."
          ],
          "note": "*Примечание:* Если у вас включена двухфакторная аутентификация (2FA) для дополнительной безопасности (см. раздел 3.5), вам потребуется ввести дополнительный код, полученный по электронной почте после ввода пароля."
        },
        "logout": {
          "title": "2.3. Выход: Завершение текущей сессии",
          "steps": [
            "1. Откройте главное меню (обычно значок «бургер» или ваш аватар в верхнем углу).",
            "2. Перейдите в раздел <strong>\"Настройки\"</strong>.",
            "3. Прокрутите вниз и выберите <strong>\"Выйти\"</strong>.",
            "4. Подтвердите действие, если потребуется."
          ]
        }
      },
      "mainFunctions": {
        "title": "3. Основные функции: Инструменты для эффективного общения (Принцип 2)",
        "p1": "BrainMessenger предоставляет набор <strong>инструментов</strong> (Принцип 10) для различных видов общения, сфокусированных на предоставлении вам <strong>ценности</strong> (Принцип 2).",
        "chatsAndMessages": {
          "title": "3.1. Чаты и сообщения: Ваше личное пространство системы коммуникации",
          "sections": [
            "<strong>Просмотр чатов:</strong> На главном экране отображается <strong>систематически организованный</strong> (Принцип 9) список всех ваших чатов (личные, групповые, каналы). Чаты с новыми сообщениями всегда находятся сверху.",
            "<strong>Создание нового чата:</strong>",
            "1. Нажмите на значок <strong>\"+\"</strong> (обычно в правом верхнем углу).",
            "2. Выберите <strong>\"Новый чат\"</strong> или «Новая группа», «Новый канал».",
            "3. Выберите контакты или добавьте участников, укажите имя (для групп/каналов).",
            "4. Нажмите <strong>\"Создать\"</strong>.",
            "<strong>Отправка сообщения:</strong>",
            "1. Откройте нужный чат.",
            "2. Введите текст в поле ввода сообщения внизу.",
            "3. Нажмите на значок <strong>\"Отправить\"</strong>.",
            "<strong>Отправка файлов:</strong>",
            "1. В поле ввода сообщения нажмите на значок скрепки.",
            "2. Выберите файл (фото, видео, документ). Максимальный размер файла для загрузки — 100 МБ.",
            "3. Нажмите <strong>\"Отправить\"</strong>. Файлы безопасно хранятся в Cloudflare R2 (см. DocInt).",
            "<strong>Поиск чатов и сообщений:</strong> Используйте строку поиска в верхней части главного экрана. Поиск быстрый и <strong>эффективный</strong> (Принцип 9).",
            "<strong>Архивация чатов:</strong> Чтобы убрать чат из основного списка без удаления, смахните его влево (на мобильном) или используйте контекстное меню и выберите <strong>\"Архивировать\"</strong>. Доступ к архиву осуществляется через главное меню. Часть вашей системы <strong>организации рабочего пространства</strong> (Принцип 9)."
          ]
        },
        "calls": {
          "title": "3.2. Звонки и видеозвонки: Прямое взаимодействие",
          "sections": [
            "<strong>Начать звонок:</strong> В открытом чате нажмите на значок телефона (аудио) или камеры (видео).",
            "<strong>Конференции:</strong> Создайте групповой чат и используйте функцию «Начать звонок».",
            "<strong>История звонков:</strong> Просмотр списка всех прошедших звонков в разделе <strong>\"Звонки\"</strong> главного меню.",
            "<strong>Настройки качества:</strong> Во время звонка вы можете выбрать качество видео/аудио (низкое, среднее, высокое) для <strong>прагматичного</strong> (Принцип 12) использования интернет-трафика."
          ]
        },
        "filesAndMedia": {
          "title": "3.3. Файлы и медиа: Централизованный доступ к обмену",
          "sections": [
            "<strong>Просмотр файлов из чата:</strong> В открытом чате перейдите в информацию о чате (нажмите на имя/аватар в заголовке) и выберите раздел <strong>\"Медиа\"</strong>. Здесь собраны все файлы, которыми вы обменивались в этом чате. Вы можете фильтровать их по типу."
          ]
        },
        "contacts": {
          "title": "3.4. Контакты: Управление вашей сетью подключений",
          "sections": [
            "<strong>Список контактов:</strong> Доступен в разделе <strong>\"Контакты\"</strong> главного меню.",
            "<strong>Поиск и добавление:</strong> Ищите существующих пользователей или добавляйте новых по email/номеру телефона."
          ]
        },
        "settings": {
          "title": "3.5. Настройки: Адаптация системы под себя (Принцип 2)",
          "p1": "Раздел «Настройки» позволяет персонализировать BrainMessenger, делая его более <strong>ценным и удобным</strong> именно для вас.",
          "sections": [
            "<strong>Профиль:</strong> Изменение имени, фото, email, пароля. Настройка параметров безопасности (например, включение <strong>двухфакторной аутентификации (2FA)</strong> для дополнительной защиты аккаунта). Связано с <strong>ответственностью</strong> (Принцип 6) за безопасность ваших данных.",
            "<strong>Уведомления:</strong> Настройка типов уведомлений, звуков, вибрации.",
            "<strong>Внешний вид (Тема):</strong> Выбор <strong>«Светлой»</strong> или <strong>«Темной»</strong> темы. Темная тема может снизить нагрузку на глаза (связано с Принципом 5: Здоровье).",
            "<strong>Язык:</strong> Выбор языка интерфейса из списка доступных. Изменения применяются быстро. Поддерживаются языки с письмом справа налево (RTL), что делает приложение <strong>доступным</strong> (Принцип 2, 5) для разных регионов (см. DocLocIn).",
            "<strong>Настройки батареи и анимации:</strong> Включение или отключение анимаций интерфейса. Это <strong>прагматичное</strong> (Принцип 12) решение для экономии заряда батареи и ресурсов устройства (Принцип 5).",
            "<strong>Настройки чата (Кастомизация):</strong> В каждом чате вы можете изменить его визуальное оформление (цвета фона, шрифты), что добавляет <strong>ценности</strong> (Принцип 2) за счет персонализации."
          ]
        },
        "premiumSubscription": {
          "title": "3.6. Премиум-подписка: Дополнительные функции и поддержка развития актива (Принцип 2, 10)",
          "p1": "Премиум-подписка предоставляет доступ к расширенным функциям, повышающим <strong>ценность</strong> (Принцип 2) вашего опыта, и является способом поддержки <strong>долгосрочного развития</strong> (Принцип 8) BrainMessenger как <strong>цифрового Актива</strong> (Принцип 10).",
          "sections": [
            "<strong>Преимущества:</strong> Ознакомьтесь с эксклюзивными функциями Премиум в разделе <strong>\"Настройки\" → \"Премиум\"</strong>.",
            "<strong>Покупка:</strong> Выберите тарифный план и оформите подписку через защищенную платежную систему (Stripe, см. DocInt).",
            "<strong>История платежей:</strong> Просмотр информации о ваших транзакциях."
          ]
        }
      },
      "faq": {
        "title": "4. Часто задаваемые вопросы (FAQ): Быстрые ответы из системы знаний",
        "p1": "Этот раздел содержит ответы на типичные вопросы, основанные на нашем <strong>накопленном опыте</strong> (Принцип 1, 14).",
        "q1": {
          "question": "В: Что делать, если я не получил код подтверждения при регистрации?",
          "answer": "О: Проверьте папку «Спам» в вашей электронной почте. Если кода нет, вернитесь на экран ввода кода и нажмите <strong>«Отправить код повторно»</strong>."
        },
        "q2": {
          "question": "В: Как восстановить пароль?",
          "answer": "О: На экране входа нажмите <strong>«Забыли пароль?»</strong> и следуйте инструкциям, отправленным на ваш email."
        },
        "q3": {
          "question": "В: Как удалить мой аккаунт и данные?",
          "answer": "О: Вы можете инициировать удаление аккаунта в <strong>\"Настройки\" → \"Профиль\"</strong>, выбрав <strong>\"Удалить аккаунт\"</strong>. Ваши данные будут надежно удалены в соответствии с политикой конфиденциальности (см. DocSecurity)."
        },
        "q4": {
          "question": "В: Поддерживает ли BrainMessenger сквозное шифрование?",
          "answer": "О: Да, безопасность и <strong>целостность</strong> (Принцип 7) ваших данных — наш приоритет. Все личные чаты используют сквозное шифрование."
        }
      },
      "tips": {
        "title": "5. Полезные советы: Оптимизация вашего опыта (Принцип 9)",
        "p1": "Несколько советов для более <strong>эффективного</strong> (Принцип 9) использования BrainMessenger:",
        "sections": [
          "<strong>Используйте онбординг:</strong> Первый экран со слайдером содержит полезную информацию о приложении.",
          "<strong>Оптимизируйте производительность на вашем устройстве:</strong> Если приложение работает медленно или потребляет много батареи, попробуйте отключить анимации в <strong>\"Настройки\" → \"Батарея и анимации\"</strong>. Это <strong>прагматичный</strong> шаг для сохранения <strong>здоровья</strong> вашего устройства (Принцип 5).",
          "<strong>Поддерживайте порядок в чатах:</strong> Используйте функцию архивации, чтобы скрыть менее актуальные диалоги.",
          "<strong>Изучите настройки:</strong> Исследуйте все опции в «Настройках», чтобы полностью адаптировать приложение под себя."
        ]
      },
      "support": {
        "title": "6. Поддержка: Мы готовы помочь (Принцип 2, 14)",
        "p1": "Если у вас возникли вопросы или проблемы, пожалуйста, свяжитесь с нами. Ваш <strong>отзыв</strong> помогает нам <strong>улучшать систему</strong> (Принцип 9).",
        "sections": [
          "<strong>Через приложение:</strong> Откройте главное меню, выберите <strong>\"Поддержка\"</strong> → <strong>\"Связаться с нами\"</strong>.",
          "<strong>По электронной почте:</strong> Вы также можете написать нам напрямую по адресу `support@brainmessenger.com`."
        ],
        "p2": "Мы стремимся быстро отвечать на запросы и предоставлять вам самую полезную <strong>помощь</strong> (Маргулан)."
      }
    },
    "devGuide": {
      "title": "Руководство по разработке BrainMessenger",
      "subtitle": "Применение принципов в коде",
      "introduction": {
        "title": "1. Введение: Процесс разработки как система улучшения",
        "description": "Этот документ — ваш путеводитель по процессу разработки BrainMessenger. Мы строим этот проект не хаотично, а как <strong>целостную систему</strong> (Принцип 9), где каждый член команды (или вы сами) действует в соответствии с <strong>четкими стандартами и принципами</strong>, стремясь к <strong>непрерывному улучшению</strong> (Принцип 1, 9). Этот процесс напрямую влияет на <strong>качество</strong> (Принцип 3) конечного продукта и его превращение в <strong>ценный АКТИВ</strong> (Принцип 10).",
        "goal": "Обеспечить <strong>единый, эффективный и масштабируемый</strong> процесс разработки, упростить онбординг для новых участников и поддерживать высокий уровень <strong>качества кода и архитектуры</strong> на каждом этапе, включая глубокое обучение и применение технологий (как показано в видео трекере).",
        "audience": "Все, кто пишет код или управляет процессом разработки BrainMessenger (Frontend, Backend, Mobile, Desktop, DevOps разработчики).",
        "principles_title": "Принципы, которыми руководствуется процесс разработки:",
        "principles": [
          "<strong>Система и Оптимизация (Принцип 9):</strong> Структура репозитория, стандарты кодирования, CI/CD, использование инструментов — все нацелено на создание эффективной и предсказуемой системы. <strong>Кайдзен</strong> применяется к самому процессу разработки.",
          "<strong>Качество > Количество (Принцип 3):</strong> Приоритет отдается написанию чистого, тестируемого и поддерживаемого кода, даже если это требует больше времени на начальном этапе.",
          "<strong>Непрерывное Обучение (Принцип 1):</strong> Процесс разработки включает изучение новых технологий, их прагматичное применение и рефлексию над полученным опытом (как задокументировано в видео трекере и часах Кайдзен).",
          "<strong>Прагматизм и Реализм (Принцип 12):</strong> Выбор инструментов и подходов, подходящих для текущей стадии проекта, без излишнего усложнения.",
          "<strong>Долгосрочное Мышление (Принцип 8):</strong> Архитектурные решения принимаются с учетом будущей масштабируемости и поддерживаемости. Код пишется так, чтобы его можно было легко развивать.",
          "<strong>Ответственность и Проактивность (Принцип 6):</strong> Каждый разработчик несет ответственность за качество своего кода, тестов и активно участвует в улучшении процесса."
        ]
      },
      "repoStructure": {
        "title": "2. Структура репозитория: Монорепозиторий как система организации кода",
        "description": "Проект организован как <strong>монорепозиторий</strong>, используя <strong>Turborepo</strong> для управления пакетами. Это осознанный выбор, призванный повысить <strong>эффективность</strong> (Принцип 9) за счет повторного использования кода и <strong>оптимизации</strong> (Принцип 9) процессов сборки и тестирования.",
        "core_title": "<code>core</code>:",
        "core_content": "Содержит код, являющийся <strong>ядром системы</strong> (Принцип 9) и пригодный для использования на любой платформе (API-клиент, общие утилиты, бизнес-логика, не привязанная к UI/серверу). Повторное использование повышает <strong>эффективность</strong> (Принцип 9) и <strong>согласованность</strong> (Принцип 7).",
        "mobile_desktop_title": "<code>mobile-desktop</code>:",
        "mobile_desktop_content": "Содержит код для <strong>клиентского Актива</strong> (Принцип 10) на мобильных и настольных платформах.",
        "web_title": "<code>web</code>:",
        "web_content": "Содержит код для <strong>клиентского Актива</strong> на веб-платформе.",
        "backend_title": "<code>backend</code>:",
        "backend_content": "Содержит код для <strong>серверной части системы</strong>, обрабатывающей запросы, взаимодействующей с базой данных и внешними сервисами. Это критически важный <strong>рычаг</strong> (Маргулан) для всего приложения.",
        "infrastructure_title": "<code>infrastructure</code>:",
        "infrastructure_content": "Содержит конфигурации для <strong>развертывания системы</strong> (Принцип 9) на облачных ресурсах.",
        "docs_title": "<code>docs</code>:",
        "docs_content": "Содержит <strong>документацию — часть системы знаний</strong> (Принцип 1), необходимую для эффективной работы и онбординга.",
        "turbo_title": "<code>turbo.json</code>:",
        "turbo_content": "Определяет, как Turborepo управляет задачами (сборка, тестирование, линтинг) по всему монорепозиторию, используя <strong>кеширование и параллельное выполнение</strong> для <strong>оптимизации</strong> (Принцип 9) времени разработки."
      },
      "techStack": {
        "title": "3. Стек технологий: Инструменты для построения фундамента (Принцип 8)",
        "intro": "Выбор стека основан на <strong>прагматизме, надежности и потенциале для долгосрочного развития</strong> (Принцип 8, 12). Мы используем <strong>проверенные технологии</strong>, которые позволяют быстро строить, закладывая при этом <strong>прочный фундамент</strong> (Принцип 8).",
        "table": [
          ["Компонент", "Технология", "Версия", "Назначение", "Связь с принципами"],
          ["Frontend: Mobile", "React Native", "0.72+", "Создание UI для Android из единой кодовой базы.", "П9 (Система), П12 (Прагматизм), П2 (Ценность - кросс-платформа)."],
          ["Frontend: Desktop", "React Native for Windows (RNW)", "0.72+", "Создание UI для Windows из единой кодовой базы.", "П9 (Система), П12 (Прагматизм), П2 (Ценность - кросс-платформа)."],
          ["Frontend: Web", "Next.js, Tailwind CSS", "14.x", "Веб-приложение с SSR/SSG для SEO и производительности, стилизация на основе утилит.", "П2 (Ценность), П9 (Система - фреймворк), П12 (Прагматизм)."],
          ["Frontend: General", "TypeScript", "5.x", "Строгая статическая типизация для повышения <strong>качества и надежности</strong> кода.", "П3 (Качество), П9 (Система - предсказуемость)."],
          ["Backend", "Node.js, NestJS", "22.x, 10.x", "Серверная логика, GraphQL API, высокая производительность Node.js, модульность NestJS.", "П9 (Система - модульность), П8 (Долгосрочность - масштабируемость Node.js)."],
          ["ORM", "Prisma", "5.x", "Удобная и безопасная работа с базой данных (PostgreSQL).", "П3 (Качество - безопасность запросов), П9 (Система - абстракция БД)."],
          ["База данных", "PostgreSQL (Neon)", "15.x", "Основное хранилище структурированных данных. Надежная реляционная СУБД.", "П8 (Долгосрочность), П9 (Система), П12 (Прагматизм)."],
          ["Файловое хранилище", "Cloudflare R2 (S3-совместимое)", "-", "Хранение медиафайлов и бинарных данных. Экономичное и масштабируемое.", "П10 (Активы), П12 (Прагматизм), П8 (Долгосрочность)."],
          ["Кеширование", "Redis", "7.x", "Кеширование данных, ограничение частоты запросов (Rate Limiting), управление присутствием WebSocket.", "П9 (Система - эффективность), П3 (Качество - снижение нагрузки), П5 (Здоровье - отзывчивость)."],
          ["Асинхронность", "Kafka", "3.x", "Надежная асинхронная обработка фоновых задач (обработка изображений).", "П9 (Система - разделение ответственности), П3 (Качество - надежность)."],
          ["Оркестрация", "Kubernetes", "1.24+", "Управление контейнерами, автоматическое масштабирование, самовосстановление.", "П8 (Долгосрочность), П9 (Система - управление сложностью), П3 (Качество - отказоустойчивость)."],
          ["Инфраструктура", "Terraform", "1.5+", "Автоматизация создания и управления инфраструктурой (IaC).", "П9 (Система - автоматизация), П3 (Качество - предсказуемость инфраструктуры)."],
          ["Тестирование", "Jest, Cypress, Detox", "-", "Модульные, интеграционные, E2E тесты для обеспечения <strong>качества</strong>.", "П3 (Качество), П9 (Система - автоматическая верификация)."],
          ["Профилирование", "V8 Profiler, Chrome DevTools", "-", "Инструменты для <strong>измерения и оптимизации производительности</strong>.", "П1 (Обучение), П9 (Система - Кайдзен), П13 (Настойчивость)."],
          ["Мониторинг Kafka", "Kafdrop", "-", "Визуальный мониторинг очередей Kafka.", "П9 (Система), П5 (Здоровье - систем, видимость проблем)."]
        ]
      },
      "codingStandards": {
        "title": "4. Стандарты кодирования: Дисциплина как основа качества (Принцип 3, 9)",
        "intro": "Соблюдение стандартов кодирования — это проявление <strong>дисциплины</strong> и часть <strong>системы обеспечения качества</strong>. Это делает код предсказуемым, легко читаемым и поддерживаемым другими разработчиками (или вами самими в будущем).",
        "generalPrinciples": {
          "title": "4.1. Общие принципы",
          "principles": [
            "<strong>DRY (Don’t Repeat Yourself):</strong> Избегайте дублирования кода. Используйте общие функции, компоненты, хуки в пакете <code>core</code>.",
            "<strong>KISS (Keep It Simple, Stupid):</strong> Стремитесь к простым решениям. Не усложняйте без необходимости. <strong>Упрощение сложного</strong> (Маргулан) применимо и к коду.",
            "<strong>Именование:</strong> Используйте английский для всех идентификаторов (переменных, функций, классов), комментариев. Будьте последовательны.",
            "<strong>Комментарии:</strong> Обязательны для:",
            "Сложной бизнес-логики (например, обработка платежей, управление WebSocket-соединениями).",
            "Интеграций с внешними сервисами (где могут быть неочевидные детали API).",
            "Критических участков кода (аутентификация, шифрование, операции с множествами).",
            "Неочевидных решений или обходных путей (с объяснением)."
          ]
        },
        "namingConventions": {
          "title": "4.2. Соглашения по именованию",
          "conventions": [
            "<strong>Переменные и функции:</strong> <code>camelCase</code> (например, <code>getUserProfile</code>, <code>chatMessage</code>).",
            "<strong>Классы и модули:</strong> <code>PascalCase</code> (например, <code>UserService</code>, <code>ChatModule</code>).",
            "<strong>Константы:</strong> <code>UPPER_SNAKE_CASE</code> (например, <code>MAX_FILE_SIZE</code>, <code>DEFAULT_TIMEOUT</code>).",
            "<strong>Файлы и папки:</strong> <code>kebab-case</code> (например, <code>user-service.ts</code>, <code>chat-screen.tsx</code>, <code>image-processing</code>).",
            "<strong>API Endpoints (в контексте GraphQL):</strong> Резолверы и их поля именуются в соответствии с доменной моделью, часто следуя REST-подобной логике (например, query <code>getUser</code>, mutation <code>sendMessage</code>)."
          ]
        },
        "formattingLinting": {
          "title": "4.3. Форматирование и линтинг: Автоматизация поддержания порядка",
          "intro": "Используйте автоматические инструменты для обеспечения единообразного форматирования и соблюдения базовых правил кодирования. Это часть <strong>автоматизированной системы качества</strong> (Принцип 9).",
          "prettier_title": "<strong>Форматирование:</strong> <strong>Prettier</strong> — автоматический форматер кода.",
          "prettier_content": "Настройте <code>.prettierrc</code> в корне проекта. Рекомендуемые настройки: 2 пробела для отступов, отсутствие точек с запятой в конце строк, одинарные кавычки для строк.",
          "prettier_code": "```json\n{\n  \"tabWidth\": 2,\n  \"semi\": false,\n  \"singleQuote\": true,\n  \"trailingComma\": \"es5\"\n}\n```",
          "eslint_title": "<strong>Линтинг:</strong> <strong>ESLint</strong> — статический анализатор кода для выявления проблем.",
          "eslint_content": "Используйте конфигурацию, такую как Airbnb или Standard, адаптированную для TypeScript, React/React Native, NestJS. Настройте правила в <code>.eslintrc.js</code>.\nИнтегрируйте ESLint в ваш редактор кода для обратной связи в реальном времени."
        },
        "codeStructure": {
          "title": "4.4. Структура кода: Модульность и четкие границы",
          "intro": "Код организован модульно внутри каждого пакета, следуя принципам <strong>систематизации</strong> (Принцип 9) и разделения ответственности.",
          "corePackage": {
            "title": "Core (<code>packages/core</code>):",
            "points": [
              "<code>api/</code>: Код для взаимодействия с GraphQL API BrainMessenger (Apollo Client).",
              "<code>hooks/</code>: Переиспользуемые хуки для React/React Native.",
              "<code>utils/</code>: Чистые утилитарные функции, независимые от конкретной платформы."
            ]
          },
          "mobileDesktopPackage": {
            "title": "Mobile-Desktop (<code>packages/mobile-desktop</code>):",
            "points": [
              "<code>components/</code>: Небольшие, переиспользуемые UI-компоненты (<code>Button</code>, <code>MessageBubble</code>).",
              "<code>screens/</code>: Компоненты, представляющие целые экраны (<code>ChatScreen</code>, <code>SettingsScreen</code>).",
              "<code>theme/</code>: Файлы с цветовыми схемами и типографией, определенные в DocDesign.",
              "<code>platform/</code>: Код, специфичный для Android или Windows (например, работа с нативными модулями)."
            ]
          },
          "webPackage": {
            "title": "Web (<code>packages/web</code>):",
            "points": [
              "<code>pages/</code>: Компоненты страниц Next.js.",
              "<code>components/</code>: UI-компоненты для веба (могут переиспользовать логику из <code>core/hooks</code> или <code>core/utils</code>).",
              "<code>styles/</code>: Файлы стилей (Tailwind CSS)."
            ]
          },
          "backendPackage": {
            "title": "Backend (<code>backend</code>):",
            "points": [
              "Структура NestJS: Модули (<code>auth</code>, <code>user</code>, <code>chat</code>, <code>message</code>), сервисы (<code>AuthService</code>, <code>UserService</code>), контроллеры (для REST, если есть) или резолверы (для GraphQL), DTO (объекты передачи данных), Entities (определяются Prisma).",
              "<code>src/</code>: Исходный код.",
              "<code>test/</code>: Тесты."
            ]
          }
        }
      },
      "libraries": {
        "title": "5. Используемые библиотеки: Выбор правильных инструментов (Принцип 12)",
        "intro": "Мы выбираем библиотеки, которые решают проблемы <strong>прагматично</strong> (Принцип 12), обеспечивают <strong>качество</strong> (Принцип 3) и хорошо интегрируются в нашу <strong>систему</strong> (Принцип 9).",
        "common": {
          "title": "5.1. Общие (Core)",
          "libs": [
            "<code>@apollo/client</code> (и связанные): GraphQL-клиент для выполнения запросов к Backend API. Используется в <code>core</code> и импортируется в <code>mobile-desktop</code> и <code>web</code>. Обеспечивает <strong>эффективность</strong> (Принцип 9) за счет управления кешем."
          ]
        },
        "mobileDesktop": {
          "title": "5.2. Мобильные-Десктопные (React Native)",
          "libs": [
            "<code>react-native-reanimated</code>, <code>moti</code>, <code>lottie-react-native</code>: Библиотеки для создания <strong>плавных и производительных анимаций</strong> (см. DocDesign). Относятся к Принципу 3 (Качество UI) и Принципу 5 (Здоровье - снижение нагрузки).",
            "<code>@react-navigation/native</code> (и связанные): Навигация между экранами приложения. <strong>Систематическое</strong> (Принцип 9) управление переходами.",
            "<code>react-native-sound</code>: Базовая библиотека для воспроизведения звуков (сообщения, звонки). См. Sound Documentation."
          ]
        },
        "web": {
          "title": "5.3. Веб (Next.js)",
          "libs": [
            "<code>next</code>, <code>react</code>, <code>react-dom</code>: Фундамент веб-приложения. Next.js предоставляет <strong>систему</strong> (Принцип 9) для SSR, SSG, маршрутизации и <strong>оптимизации</strong> (см. DocOptimizationIn).",
            "<code>tailwindcss</code>: CSS-фреймворк с упором на утилиты для быстрой и <strong>прагматичной</strong> (Принцип 12) стилизации.",
            "<code>framer-motion</code>: Библиотека для <strong>качественных</strong> (Принцип 3) анимаций на вебе."
          ]
        },
        "backend": {
          "title": "5.4. Backend (NestJS)",
          "libs": [
            "<code>@nestjs/*</code>: Основные пакеты NestJS (core, common, platform-express/fastify, graphql, typeorm/prisma, jwt, passport, websockets и т.д.). Предоставляют <strong>модульную, масштабируемую систему</strong> (Принцип 9).",
            "<code>@nestjs/prisma</code>: Интеграция NestJS и Prisma.",
            "<code>graphql</code>, <code>@nestjs/graphql</code>, <code>apollo-server-express</code>: Реализация GraphQL API.",
            "<code>@prisma/client</code>: Prisma ORM клиент для взаимодействия с Neon (PostgreSQL).",
            "<code>@aws-sdk/client-s3</code>, <code>@aws-sdk/s3-request-presigner</code>: Работа с Cloudflare R2 (S3-совместимым).",
            "<code>ioredis</code>: Redis-клиент для кеширования и других задач.",
            "<code>kafkajs</code>: Kafka-клиент для асинхронных задач.",
            "<code>firebase-admin</code>: Firebase SDK (Push-уведомления).",
            "<code>stripe</code>: Stripe SDK (Платежи).",
            "<code>googleapis</code>: Google APIs SDK (Gmail API).",
            "<code>bcrypt</code> или <code>argon2</code>: Библиотека для <strong>безопасного</strong> (Принцип 3, 5) хеширования паролей."
          ]
        },
        "crossPackage": {
          "title": "5.5. Общие (Cross-Package)",
          "libs": [
            "<code>typescript</code>: Язык разработки.",
            "<code>winston</code> или <code>pino</code>: Библиотека для <strong>структурированного логирования</strong> (Принцип 9).",
            "<code>@sentry/node</code>, <code>@sentry/react</code>, <code>@sentry/react-native</code>: Клиенты Sentry для <strong>отслеживания ошибок в продакшене</strong> (часть системы <strong>качества</strong> и <strong>Кайдзен</strong>).",
            "<code>core-js</code>, <code>regenerator-runtime</code>: Полифилы для поддержки современных функций JavaScript в старых средах (например, новые методы Set в ES2024).",
            "<code>zod</code> или <code>class-validator</code>/<code>class-transformer</code>: Библиотеки для <strong>валидации данных</strong>, обеспечивающие <strong>качество</strong> (Принцип 3) на входе в систему."
          ]
        },
        "setMethods": {
          "title": "5.6. Работа с Set в ES2024+: Пример применения новых знаний (Принцип 1)",
          "intro": "<strong>Непрерывное обучение</strong> (Принцип 1) и применение <strong>прагматичных</strong> (Принцип 12) языковых инструментов — часть нашей философии. Новые методы объекта <code>Set</code> в ECMAScript 2024 (поддерживаются в Node.js 22+, современных браузерах) предоставляют <strong>более чистый, читаемый и часто более эффективный</strong> (Принцип 9) способ работы с уникальными наборами данных по сравнению с ручными циклами или преобразованиями в массивы.",
          "areas": {
            "title": "Области применения в BrainMessenger:",
            "points": [
              "Управление списками пользователей в групповых чатах (добавление/удаление участников).",
              "Отслеживание уникальных активных сессий или WebSocket-соединений.",
              "Управление правами доступа (проверка, входит ли набор разрешений в доступные).",
              "Синхронизация списков (например, контактов, чатов) между клиентом и сервером, выявление добавленных/удаленных элементов."
            ]
          },
          "keys": {
            "title": "Ключевые методы (из ES2024):",
            "points": [
              "<code>union(iterable)</code>: Возвращает новый <code>Set</code> со всеми уникальными элементами из текущего <code>Set</code> и переданного итерируемого объекта.",
              "<code>intersection(iterable)</code>: Возвращает новый <code>Set</code> с элементами, присутствующими в <strong>обоих</strong> множествах.",
              "<code>difference(iterable)</code>: Возвращает новый <code>Set</code> с элементами, присутствующими в текущем <code>Set</code>, но <strong>не</strong> в переданном итерируемом объекте.",
              "<code>symmetricDifference(iterable)</code>: Возвращает новый <code>Set</code> с элементами, которые находятся в <strong>одном</strong>, но не в <strong>обоих</strong> множествах.",
              "<code>isSubsetOf(iterable)</code>: Проверяет, являются ли все элементы текущего <code>Set</code> подмножеством переданного итерируемого объекта (<code>true</code> или <code>false</code>).",
              "<code>isSupersetOf(iterable)</code>: Проверяет, содержит ли текущий <code>Set</code> все элементы переданного итерируемого объекта (<code>true</code> или <code>false</code>).",
              "<code>isDisjointFrom(iterable)</code>: Проверяет, не имеют ли текущий <code>Set</code> и переданный итерируемый объект общих элементов (<code>true</code> или <code>false</code>)."
            ]
          },
          "examples": {
            "title": "Примеры использования в коде (TypeScript):",
            "code": "```typescript\n// backend/src/chat/chat.service.ts (пример управления участниками группы)\nasync updateGroupMembers(groupId: string, currentMemberIds: Set<string>, newMemberIds: Set<string>) {\n  // Principle 9: Optimization and clarity\n  const addedMembers = newMemberIds.difference(currentMemberIds);\n  const removedMembers = currentMemberIds.difference(newMemberIds);\n  const unchangedMembers = currentMemberIds.intersection(newMemberIds); // For verification\n\n  console.log('Added:', addedMembers);\n  console.log('Removed:', removedMembers);\n\n  // Perform add/remove operations in the database via Prisma\n  if (addedMembers.size > 0) {\n    await this.prisma.userChat.createMany({\n      data: Array.from(addedMembers).map(userId => ({ groupId, userId })),\n    });\n  }\n  if (removedMembers.size > 0) {\n    await this.prisma.userChat.deleteMany({\n      where: {\n        groupId: groupId,\n        userId: { in: Array.from(removedMembers) },\n      },\n    });\n  }\n\n  // Permissions check: Ensure the current user has permission to modify group membership\n  const requiredPermission = new Set(['manage_members']);\n  const userPermissions = new Set(await this.getUserPermissions(userId, groupId)); // Get user permissions\n  const hasPermission = requiredPermission.isSubsetOf(userPermissions); // Check using new method\n  if (!hasPermission) {\n      throw new ForbiddenException(\"Insufficient permissions to modify group membership.\");\n  }\n}\n\n// frontend/src/hooks/useChats.ts (example of chat list synchronization)\nfunction useSyncChats(localChats: Set<string>, serverChats: string[]) {\n    // Principle 9: Synchronization efficiency\n    const serverChatsSet = new Set(serverChats);\n    const newChats = serverChatsSet.difference(localChats);\n    const removedChats = localChats.difference(serverChatsSet);\n\n    console.log('New chats:', newChats);\n    console.log('Removed chats:', removedChats);\n\n    // Update local state/UI based on newChats and removedChats\n    // ...\n}\n",
            "recommendations": [
              "Применяйте их для операций с уникальными наборами данных. Они специально для этого предназначены и часто более производительны, чем аналогичные операции с массивами, особенно для больших объемов данных.",
              "Учитывайте совместимость: Новые методы доступны в Node.js 22+ и современных браузерах. Если вам нужно поддерживать старые среды, используйте полифилы (core-js/proposals/set-methods-v2).",
              "Типизация TypeScript: Всегда указывайте тип элементов в Set (например, Set<string>, Set<number>) для лучшей проверки типов и автодополнения."
            ]
          }
        }
      },
      "devProcess": {
        "title": "6. Процесс разработки: Наша система рабочего процесса (Принцип 9)",
        "intro": "Четкий процесс разработки обеспечивает систематизацию, качество и предсказуемость (Принцип 9).",
        "envSetup": {
          "title": "6.1. Настройка окружения: Подготовка к работе",
          "intro": "Клонировать репозиторий:",
          "cloneRepo": {
            "title": "Клонировать репозиторий:",
            "code": "```bash\ngit clone <https://github.com/xAI/BrainMessenger.git> # Пример\ncd BrainMessenger\n```"
          },
          "installDeps": {
            "title": "Установить зависимости:",
            "code": "```bash\nnpm install\n```"
          },
          "envVars": {
            "title": "Настроить переменные окружения:",
            "code": "```bash\ncp .env.example .env\n# Заполнить .env данными для Neon, R2, Redis, Kafka, API Gateways, Stripe, Firebase, Gmail API\n```",
            "note": "Важно иметь работающие локальные или тестовые экземпляры БД, Redis, Kafka или использовать их облачные версии для разработки."
          },
          "prismaClient": {
            "title": "Сгенерировать Prisma Client:",
            "code": "```bash\ncd backend\nnpx prisma generate\ncd ..\n```"
          },
          "localDb": {
            "title": "Настроить локальную БД (если не используется облачная):",
            "code": "```bash\ncd backend\nnpx prisma migrate dev --name initial_setup\ncd ..\n```"
          }
        },
        "localRun": {
          "title": "6.2. Локальный запуск: Активация системы для разработки",
          "intro": "Используйте команды <code>turbo run</code> или команды конкретных пакетов.",
          "runAll": {
            "title": "Запустить все сервисы (Backend, Web) для разработки:",
            "code": "```bash\nturbo run dev # Запустит dev-серверы для всех пакетов с задачей 'dev' в turbo.json\n```"
          },
          "runBackend": {
            "title": "Отдельный запуск Backend:",
            "code": "```bash\ncd backend\nnpm run start:dev # или npm run start:debug для отладки\n```"
          },
          "runMobileDesktop": {
            "title": "Отдельный запуск Mobile-Desktop (React Native):",
            "code": "```bash\ncd packages/mobile-desktop\nnpm run android # для запуска на Android эмуляторе/устройстве\nnpm run windows # для запуска на Windows\n```"
          },
          "runWeb": {
            "title": "Отдельный запуск Web (Next.js):",
            "code": "```bash\ncd packages/web\nnpm run dev\n```"
          }
        },
        "commitsBranches": {
          "title": "6.3. Коммиты и ветки: Структура эволюции кода (Принцип 9)",
          "intro": "Мы используем четкую стратегию ветвления и стандарты коммитов для поддержания порядка (Принцип 9) и ясной истории изменений (Принцип 7).",
          "mainBranches": {
            "title": "Основная ветка разработки:",
            "points": [
              "<code>develop</code>. Здесь интегрируются все новые функции и исправления.",
              "Стабильная ветка: <code>main</code>. Только проверенный код из <code>develop</code> (через PR релизов)."
            ]
          },
          "workBranches": {
            "title": "Рабочие ветки:",
            "points": [
              "<code>feature/<feature_name></code>: Для разработки новой функциональности (например, <code>feature/graphql-auth</code>).",
              "<code>fix/<fix_name></code>: Для исправления ошибок (например, <code>fix/chat-message-scroll</code>).",
              "<code>refactor/<name></code>: Для рефакторинга кода."
            ]
          },
          "commitFormat": {
            "title": "Формат коммитов:",
            "example": "Используйте Conventional Commits. Это упрощает генерацию changelog и понимание назначения каждого коммита.\n\nПример:\n\n<code>feat(backend/auth): add JWT authentication</code> (новая функция в модуле аутентификации бэкенда)\n\n<code>fix(mobile/chat): resolve message display bug on scroll</code> (исправление ошибки отображения сообщений в мобильном чате при прокрутке)\n\n<code>docs(roadmap): update Q3 2025 plan</code> (обновление документации)\n\n<code>chore(deps): update prisma to 5.x</code> (рутинная задача, обновление зависимостей)",
            "structure": "Структура: <code>type(scope): description</code>\n\n<code>type</code>: <code>feat</code>, <code>fix</code>, <code>docs</code>, <code>chore</code>, <code>style</code>, <code>refactor</code>, <code>test</code>, <code>ci</code>, <code>perf</code>, <code>build</code>\n\n<code>scope</code>: Необязательно, указывает пакет или область (<code>backend</code>, <code>web</code>, <code>mobile-desktop</code>, <code>core</code>, <code>auth</code>, <code>chat</code>, <code>ui</code>, <code>infra</code> и т.д.)."
          }
        },
        "prCodeReview": {
          "title": "6.4. Pull Request (PR) и Code Review: Коллективное обеспечение качества (Принцип 3, 14)",
          "intro": "Каждый Pull Request — это возможность получить обратную связь (Принцип 14), улучшить код и обеспечить качество (Принцип 3) перед интеграцией в основную ветку.",
          "prDescription": {
            "title": "Описание PR:",
            "points": [
              "Четко опишите, какую проблему решает PR или какую функцию он добавляет.",
              "Укажите ссылку на соответствующую задачу Jira (например, [BM-123]) или другое место отслеживания задач.",
              "Опишите основные изменения и любые потенциальные риски или вопросы."
            ]
          },
          "prRequirements": {
            "title": "Требования к PR:",
            "points": [
              "Код должен соответствовать стандартам кодирования (линтер, форматер).",
              "Все тесты должны проходить (<code>npm test</code>). Настройте проверки в GitHub Actions.",
              "Должен быть как минимум 1 одобрение от другого разработчика (или от вас самих, если работаете в одиночку, но стремитесь к идеальному code review).",
              "Нетривиальные изменения могут потребовать ревью от более опытного разработчика или архитектора."
            ]
          }
        },
        "testing": {
          "title": "6.5. Тестирование: Проверка надежности системы (Принцип 3)",
          "intro": "Тестирование является неотъемлемой частью процесса обеспечения качества (Принцип 3). Мы используем многоуровневый подход.",
          "runAllTests": {
            "title": "Запустить все тесты:",
            "code": "```bash\nnpm run test # Запустит тесты для всех пакетов (модульные, интеграционные)\n```"
          },
          "testTypes": {
            "title": "Виды тестов:",
            "points": [
              "Модульные тесты: Тестирование отдельных функций или классов в изоляции (Jest). Фокус: Корректность работы небольших частей кода.",
              "Интеграционные тесты: Тестирование взаимодействия между несколькими компонентами (например, сервис -> БД, API -> сервис) (Jest). Фокус: Корректность связей между частями системы.",
              "E2E тесты (Сквозные тесты): Тестирование пользовательских сценариев в приложении (Cypress для Web, Detox для React Native). Фокус: Общая работоспособность системы с точки зрения пользователя."
            ]
          },
          "ciCdTests": {
            "title": "Настроить автоматический запуск тестов в CI/CD (GitHub Actions) при каждом PR и пуше в ветку develop.",
            "content": "Настроить автоматический запуск тестов в CI/CD (GitHub Actions) при каждом PR и пуше в ветку develop."
          }
        }
      },
      "devRecommendations": {
        "title": "7. Рекомендации по разработке: Лучшие практики для создания Актива",
        "intro": "Применяйте эти рекомендации для создания качественного, поддерживаемого кода, который станет фундаментом вашего цифрового Актива (Принцип 3, 10).",
        "corePackage": {
          "title": "7.1. Пакет Core: Повторное использование для эффективности",
          "points": [
            "API-клиент (<code>@apollo/client</code>): Используйте его для всех GraphQL-запросов с Frontend. Настройте кеширование (InMemoryCache) и обработку ошибок. Это уменьшает дублирование кода и обеспечивает унифицированный способ взаимодействия с API.",
            "Общие хуки/утилиты: Извлекайте сюда логику, которая повторяется на разных платформах (форматирование данных, валидация, обработка токенов)."
          ]
        },
        "mobileDesktop": {
          "title": "7.2. Мобильные-Десктопные (React Native)",
          "points": [
            "Функциональные компоненты: Используйте React Hooks и функциональные компоненты. Разделяйте компоненты на «умные» (с логикой) и «глупые» (только UI).",
            "Стилизация: Используйте StyleSheet.create для производительности или библиотеки типа styled-components / NativeBase для согласованности.",
            "Нативная оптимизация: Изучите специфику RNW и RN (например, работа с нативными модулями для повышения производительности критических участков, анимации на нативном потоке с Reanimated)."
          ]
        },
        "web": {
          "title": "7.3. Веб (Next.js)",
          "points": [
            "Маршрутизация и выборка данных: Используйте возможности Next.js (File-system routing, getStaticProps, getServerSideProps, getStaticPaths) для оптимизации загрузки страниц (SSR/SSG) и SEO (Принцип 2).",
            "Стилизация: Tailwind CSS ускоряет разработку UI. Следуйте принципам из DocDesign.",
            "Оптимизация изображений: Используйте next/image для автоматической оптимизации изображений."
          ]
        },
        "backend": {
          "title": "7.4. Backend (NestJS)",
          "points": [
            "GraphQL API: Следуйте принципам GraphQL (запрашивайте только то, что нужно). Используйте DataLoader для решения проблемы N+1 (см. DocOptimizationIn).",
            "Prisma: Используйте ORM для всех взаимодействий с БД. Это обеспечивает безопасность (защита от SQL-инъекций - Принцип 3, 5) и типизацию.",
            "Сервисы: Выделяйте основную бизнес-логику в сервисы. Контроллеры/резолверы должны быть тонкими (только обработка запросов и вызов сервисов).",
            "Интеграции: Взаимодействие с внешними сервисами (R2, Firebase, Stripe, Gmail API) должно быть инкапсулировано в отдельные сервисы (например, StorageService, NotificationService). Это делает код более модульным и тестируемым (Принцип 9).",
            "Обработка ошибок: Используйте фильтры исключений NestJS для централизованной обработки ошибок и возврата стандартизированных API-ответов (см. DocSpec). Подробно логируйте ошибки (Winston, Sentry)."
          ]
        },
        "security": {
          "title": "7.5. Безопасность: Защита вашего Актива (Принцип 3, 5, 10)",
          "intro": "Безопасность — это не фича, а фундаментальный аспект качества (Принцип 3), напрямую связанный со здоровьем системы (Принцип 5) и защитой цифрового актива (Принцип 10: ваш продукт и данные пользователей).",
          "points": [
            "Аутентификация: Используйте JWT для stateless-аутентификации с коротким сроком жизни access-токенов и refresh-токенами. Надежно храните JWT-секрет.",
            "Хеширование паролей: Никогда не храните пароли в открытом виде. Используйте сильные алгоритмы хеширования (bcrypt, argon2).",
            "Валидация входных данных: Строго валидируйте все входящие данные на Backend (например, используя class-validator и DTO).",
            "Защита от атак: Реализуйте Rate Limiting (<code>@nestjs/throottler</code>) для защиты от brute-force атак или DDoS на уровне API. Используйте helmet для установки безопасных HTTP-заголовков.",
            "Шифрование конфиденциальных данных: Шифруйте данные перед сохранением в R2 (см. DocInt). Ключ шифрования храните отдельно от данных.",
            "2FA: Реализуйте двухфакторную аутентификацию как опцию для пользователей."
          ]
        }
      },
      "optimization": {
        "title": "8. Оптимизация проекта: Непрерывное улучшение (Принцип 9, 1)",
        "content": "Оптимизация — это итеративный процесс (Принцип 9: Кайдзен), основанный на измерениях и обучении (Принцип 1). См. подробное руководство по оптимизации BrainMessenger."
      },
      "deployProcess": {
        "title": "9. Процесс развертывания: Доставка системы пользователям (Принцип 9)",
        "intro": "Процесс развертывания должен быть автоматизированным, надежным и предсказуемым (Принцип 9, 3).",
        "points": [
          "Контейнеризация (Docker): Создавайте Docker-образы для Backend и других сервисов. Используйте многоступенчатые сборки для оптимизации размера образов (см. CI/CD Optimization Guide).",
          "Оркестрация (Kubernetes): Развертывайте контейнеры в Kubernetes. Используйте манифесты в папке <code>infrastructure/k8s</code>. K8s обеспечивает автоматическое масштабирование, самовосстановление и управление нагрузкой.",
          "Инфраструктура как код (Terraform): Управляйте облачными ресурсами (кластер K8s, сети) с помощью Terraform (<code>infrastructure/main.tf</code>). Это делает инфраструктуру версионируемой и воспроизводимой.",
          "CI/CD (GitHub Actions): Настройте автоматические пайплайны для сборки, тестирования и развертывания (см. CI/CD Optimization Guide)."
        ],
        "process": "Процесс: Код пушится в <code>develop</code> → CI/CD запускает тесты и сборки → После успешных тестов и ревью, PR мержится в <code>develop</code> → (опционально) автоматическое развертывание dev/staging окружения → Release PR из <code>develop</code> в <code>main</code> → Продакшн развертывание."
      },
      "devCommands": {
        "title": "10. Полезные команды разработчика: Инструментарий системы",
        "table": [
          ["Команда", "Описание", "Расположение"],
          ["<code>npm install</code>", "Устанавливает зависимости для всех пакетов (Turborepo).", "Корень"],
          ["<code>turbo run <task></code>", "Запускает задачу (build, test, lint, dev) для всех пакетов или по фильтру.", "Корень"],
          ["<code>npm run lint</code>", "Запускает линтеры для всех пакетов.", "Корень"],
          ["<code>npm run format</code>", "Форматирует код для всех пакетов (Prettier).", "Корень"],
          ["<code>npm run build</code>", "Собирает production версии всех пакетов.", "Корень"],
          ["<code>npm run test</code>", "Запускает тесты для всех пакетов.", "Корень"],
          ["<code>cd backend && npx prisma migrate dev --name <name></code>", "Создает и применяет новую миграцию БД.", "Корень/backend"],
          ["<code>cd backend && npx prisma studio</code>", "Запускает графический интерфейс для просмотра БД.", "Корень/backend"],
          ["<code>cd backend && npm run start:dev</code>", "Запускает бэкенд в режиме разработки.", "Корень/backend"],
          ["<code>cd packages/web && npm run dev</code>", "Запускает веб-приложение в режиме разработки.", "Корень/packages/web"],
          ["<code>cd packages/mobile-desktop && npm run android</code>", "Запускает мобильное приложение на Android.", "Корень/packages/mobile-desktop"],
          ["<code>cd packages/mobile-desktop && npm run windows</code>", "Запускает десктопное приложение на Windows.", "Корень/packages/mobile-desktop"],
          ["<code>cd infrastructure && terraform plan</code>", "Показывает план изменений инфраструктуры.", "Корень/infrastructure"],
          ["<code>cd infrastructure && terraform apply</code>", "Применяет изменения инфраструктуры.", "Корень/infrastructure"]
        ]
      },
      "notes": {
        "title": "11. Примечания: Непрерывное обучение и Кайдзен",
        "points": [
          "Онбординг: Новые разработчики должны начать с изучения этой документации, а также Технической документации (общий обзор), Документации по дизайну (визуальные стандарты) и Руководства по оптимизации (как писать производительный код).",
          "Живой документ: Эта документация — живой документ. Она будет обновляться по мере развития проекта, изучения новых технологий и улучшения процессов. Ваши предложения по улучшению приветствуются! (Принцип 1, 14).",
          "Совместимость с ECMAScript 2024: Убедитесь, что вы используете Node.js 22+ (для бэкенда) и актуальные версии браузеров/React Native (для фронтенда) для полной поддержки новых методов Set. При необходимости используйте полифилы.",
          "Вопросы и обратная связь: Если что-то непонятно, или вы видите возможность улучшить процесс — задавайте вопросы в командном чате (#dev-team в Slack или другом инструменте) и предлагайте изменения. Это часть Силы Взаимодействия и Сотрудничества (Маргулан), которая делает систему сильнее."
        ]
      }
    },
    "integrationsGuide": {
      "title": "Документация Интеграций BrainMessenger",
      "subtitle": "Построение Надежной Системы с Внешними Рычагами",
      "introduction": {
        "title": "1. Введение: Интеграции как Часть Фундамента Системы",
        "description": "Этот документ описывает, как BrainMessenger интегрируется с ключевыми внешними сервисами. Мы выбираем эти интеграции <strong>прагматично</strong> (Принцип 12), рассматривая их как <strong>рычаги</strong> (принцип Маргулана), которые позволяют нам не изобретать колесо, а использовать <strong>надежные и масштабируемые</strong> (Принцип 8, 9) сторонние решения для ускорения разработки и обеспечения <strong>качества</strong> (Принцип 3) нашего продукта. Эти интеграции являются неотъемлемой частью нашего <strong>технологического фундамента</strong> (Принцип 8).",
        "principlesTitle": "Принципы, которыми руководствуется выбор и настройка интеграций:",
        "principles": [
          "<strong>Система и Оптимизация (Принцип 9):</strong> Интеграции должны быть частью единой, хорошо продуманной системы, где каждый компонент выполняет свою роль эффективно.",
          "<strong>Прагматизм и Реализм (Принцип 12):</strong> Выбор сервисов с учетом текущих потребностей, бюджета (бесплатные/доступные тарифы на старте) и простоты интеграции.",
          "<strong>Долгосрочное Мышление (Принцип 8):</strong> Выбор сервисов, способных масштабироваться вместе с ростом проекта.",
          "<strong>Качество > Количество (Принцип 3):</strong> Фокус на надежности и производительности интеграций, даже если их список на старте небольшой.",
          "<strong>Создание Ценности (Принцип 2):</strong> Каждая интеграция должна добавлять реальную ценность для конечного пользователя (например, надежное хранение файлов, мгновенные уведомления)."
        ]
      },
      "overview": {
        "title": "2. Обзор Ключевых Интеграций: Наши Внешние Компоненты Системы",
        "table": [
          ["Сервис", "Назначение", "Роль в BrainMessenger", "Основные функции", "Связь с Принципами"],
          ["<strong>Neon</strong>", "Управляемый PostgreSQL БД", "Хранение всех <strong>структурированных данных</strong> (пользователи, чаты, сообщения, метаданные файлов). Фундамент данных.", "Хостинг PostgreSQL, масштабирование, доступ через строку подключения.", "P8 (Долгосрочное), P9 (Система), P12 (Прагматизм - бесплатный тариф)."],
          ["<strong>Cloudflare R2</strong>", "Облачное Хранилище (S3-совместимое)", "Хранение всех <strong>неструктурированных данных</strong> (файлы пользователей, аватарки, записи звонков, зашифрованные метаданные). Хранилище Активов.", "Надежное хранение объектов, CDN-доставка, отсутствие платы за исходящий трафик.", "P8 (Долгосрочное), P10 (Активы), P12 (Прагматизм - бесплатный тариф, нет платы за трафик), P3 (Качество - CDN)."],
          ["<strong>Firebase</strong>", "Push-уведомления", "Мгновенная доставка уведомлений пользователям на мобильные устройства.", "Отправка push-уведомлений (FCM).", "P2 (Ценность - информирование), P9 (Система - надежная доставка), P12 (Прагматизм - готовое решение)."],
          ["<strong>Stripe</strong>", "Платежная Система", "Обработка платежей за Premium-подписку. Доступ к платежам как к рычагу создания Ценности/Богатства.", "Прием платежей, управление подписками.", "P2 (Ценность - премиум), P10 (Богатство/Активы), P9 (Система - автоматизация платежей)."],
          ["<strong>Gmail API</strong>", "Сервис отправки email", "Отправка критически важных email (коды подтверждения для регистрации и 2FA).", "Отправка транзакционных email.", "P3 (Качество - надежная доставка email), P9 (Система - часть аутентификации), P5 (Здоровье - безопасность пользователя)."]
        ]
      },
      "neonIntegration": {
        "title": "3. Интеграция с Neon: Фундамент Структурированных Данных",
        "generalInfo": {
          "title": "3.1. Общая Информация",
          "description": "Neon предоставляет управляемый сервис PostgreSQL. Мы используем его как <strong>основное хранилище структурированных данных</strong>, таких как информация о пользователях, чатах, сообщениях и метаданных файлов.",
          "advantages": [
            "<strong>Прагматизм (P12):</strong> Бесплатный тариф на старте (30 ГБ) полностью покрывает начальные потребности.",
            "<strong>Система и Долгосрочное Мышление (P9, P8):</strong> Управляемый сервис снижает операционную нагрузку, автоматическое масштабирование и репликация доступны на платных планах, обеспечивая готовность к росту.",
            "<strong>Качество (P3):</strong> Надежность и производительность PostgreSQL как проверенной СУБД."
          ],
          "role": "Роль: Ядро, к которому обращается Backend для всех CRUD-операций над метаданными."
        },
        "configuration": {
          "title": "3.2. Конфигурация: Подключение к Системе Данных",
          "steps": [
            "1. <strong>Регистрация и Создание Проекта:</strong>",
            "Создайте аккаунт на `https://neon.tech`.",
            "Создайте новый проект (например, `brainmessenger-prod`) в консоли Neon.",
            "2. <strong>Настройка Базы Данных:</strong>",
            "Neon автоматически предоставляет инстанс PostgreSQL.",
            "<strong>Примените схему базы данных:</strong> Используйте Prisma Migrate для инициализации структуры таблиц (см. `database/schema.prisma` и Руководство по разработке).",
            "3. <strong>Переменные Окружения:</strong>",
            "Получите <strong>строку подключения</strong> (Connection Details) из консоли Neon (Settings → Connection Details).",
            "Добавьте в ваш `.env` файл:"
          ],
          "envExample": "```env\n# Строка подключения к базе данных Neon\nDATABASE_URL=postgresql://<user>:<password>@<neon-host>/<dbname>?sslmode=require\n```",
          "note1": "*Примечание:* Используйте `sslmode=require` для безопасного соединения.",
          "backendCode": "4. <strong>Подключение Backend (NestJS + Prisma):</strong>\nPrisma использует `DATABASE_URL` для подключения. Убедитесь, что Prisma Client сгенерирован (`npx prisma generate`).\nИспользуйте `PrismaService` (из `nestjs-prisma`) для всех операций с БД.\n```typescript\n// backend/src/app.module.ts (или db.module.ts)\nimport { Module } from '@nestjs/common';\nimport { PrismaService } from 'nestjs-prisma'; // Убедитесь, что PrismaModule импортирован в app.module\n\n@Module({\n  providers: [PrismaService], // PrismaService доступен для инъекции\n  exports: [PrismaService],\n})\nexport class DbModule {}\n```"
        },
        "interactionScenarios": {
          "title": "3.3. Методы и Сценарии Взаимодействия: API Данных",
          "description": "Все взаимодействия с Neon происходят через Prisma ORM в Backend, что обеспечивает <strong>типизацию, безопасность и системность</strong> (Принцип 3, 9).",
          "signup": {
            "title": "Сценарий: Регистрация пользователя:",
            "interaction": "<strong>Взаимодействие:</strong> Backend получает данные пользователя → Использует `PrismaService` для создания новой записи в таблице `users`.",
            "code": "<strong>Пример кода (Backend Service):</strong>\n```typescript\n// backend/src/auth/auth.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { PrismaService } from 'nestjs-prisma';\nimport { Prisma } from '@prisma/client'; // Импорт типов Prisma\n\n@Injectable()\nexport class AuthService {\n  constructor(private prisma: PrismaService) {}\n\n  async signUp(data: Prisma.UserCreateInput) {\n    // Пример: пароль должен быть захэширован ДО сохранения\n    const hashedPassword = await hashPassword(data.password); // Использование утилиты для хэширования\n    return this.prisma.user.create({\n      data: {\n        email: data.email,\n        name: data.name,\n        password: hashedPassword, // Сохраняем захэшированный пароль\n        // ... другие поля по схеме\n      },\n    });\n  }\n}\n```",
            "result": "<strong>Результат:</strong> Данные пользователя надежно сохранены в Neon."
          },
          "getChats": {
            "title": "Сценарий: Получение списка чатов пользователя:",
            "interaction": "<strong>Взаимодействие:</strong> Frontend запрашивает чаты через GraphQL API → Backend использует `PrismaService` для выполнения запроса к таблице `chats` (возможно, с фильтрацией по `userId` и `include` для метаданных).",
            "code": "<strong>Пример кода (Backend Service):</strong>\n```typescript\n// backend/src/chat/chat.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { PrismaService } from 'nestjs-prisma';\n\n@Injectable()\nexport class ChatService {\n  constructor(private prisma: PrismaService) {}\n\n  async getUserChats(userId: string) {\n    // Используем индексы @@index([userId]) для оптимизации (Принцип 9, Оптимизация)\n    return this.prisma.chat.findMany({\n      where: {\n        users: { // Предполагается связь Many-to-Many с таблицей UserChat\n          some: {\n            userId: userId,\n          },\n        },\n      },\n      select: { // Выбираем только необходимые поля (Принцип 9, Оптимизация)\n        id: true,\n        name: true,\n        type: true,\n        // ... другие нужные поля\n      },\n      orderBy: { // Сортировка по дате последнего сообщения для актуальности (Принцип 2, Ценность)\n        lastMessageAt: 'desc',\n      },\n    });\n  }\n}\n```"
          },
          "saveMessage": {
            "title": "Сценарий: Сохранение сообщения:",
            "interaction": "<strong>Взаимодействие:</strong> Пользователь отправляет сообщение → Frontend отправляет его через GraphQL API → Backend использует `PrismaService` для создания новой записи в таблице `messages`, связывая ее с `chatId` и `userId`.",
            "code": "<strong>Пример кода (Backend Service):</strong>\n```typescript\n// backend/src/message/message.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { PrismaService } from 'nestjs-prisma';\nimport { Prisma } from '@prisma/client';\n\n@Injectable()\nexport class MessageService {\n  constructor(private prisma: PrismaService) {}\n\n  async createMessage(data: Prisma.MessageCreateInput) {\n    // Используем транзакцию, если нужно обновить дату последнего сообщения в чате\n    return this.prisma.$transaction(async (tx) => {\n      const message = await tx.message.create({ data });\n      await tx.chat.update({\n        where: { id: data.chatId },\n        data: { lastMessageAt: message.createdAt }, // Обновляем время последнего сообщения\n      });\n      return message;\n    });\n  }\n}\n```"
          }
        },
        "errorHandling": {
          "title": "3.4. Обработка Ошибок Интеграции: Поддержание Качества Системы",
          "description": "Надежная система должна уметь обрабатывать ошибки внешних зависимостей (Принцип 3: Качество).",
          "connectionError": {
            "title": "Connection Error:",
            "cause": "Причина: Невозможно установить соединение с Neon. Неверная строка подключения (`DATABASE_URL`), проблемы с сетью, недоступность сервиса Neon.",
            "solution": "Решение: Проверить переменную окружения `DATABASE_URL`, статус сервиса Neon. Логировать ошибку на Backend (Sentry/Winston)."
          },
          "queryError": {
            "title": "Database Query Error:",
            "cause": "Причина: Ошибка выполнения запроса к БД (например, нарушение уникальности, неверный тип данных). Ошибка в логике Backend, несоответствие схемы БД.",
            "solution": "Решение: Отладить запрос в Backend, проверить логи Prisma. Логировать ошибку."
          },
          "rateLimitError": {
            "title": "Rate Limit Exceeded (на платных тарифах):",
            "cause": "Причина: Превышены лимиты на количество запросов или вычислительные ресурсы в Neon. Высокая нагрузка, неоптимизированные запросы, недостаточный тарифный план.",
            "solution": "Решение: Оптимизировать запросы (см. Руководство по оптимизации), рассмотреть переход на более высокий тарифный план Neon."
          }
        }
      },
      "r2Integration": {
        "title": "4. Интеграция с Cloudflare R2: Хранилище Цифровых Активов",
        "generalInfo": {
          "title": "4.1. Общая Информация",
          "description": "Cloudflare R2 — это сервис объектного хранилища, совместимый с S3 API. Мы используем его для хранения <strong>всех файлов пользователей</strong>, таких как изображения, видео, документы, а также зашифрованные данные.",
          "advantages": [
            "<strong>Прагматизм (P12), Создание Богатства/Активов (P10):</strong> <strong>Отсутствие платы за исходящий трафик</strong> — критически важное преимущество для мессенджера, где пользователи активно обмениваются файлами. Бесплатный тариф 10 ГБ на старте.",
            "<strong>Качество (P3):</strong> Высокая производительность и надежность благодаря глобальной сети Cloudflare.",
            "<strong>Долгосрочное Мышление (P8), Система (P9):</strong> S3-совместимый API позволяет легко использовать стандартные библиотеки и инструменты, обеспечивая гибкость в будущем."
          ],
          "role": "Роль: Децентрализованное хранилище для крупных бинарных объектов, снижающее нагрузку на основную базу данных."
        },
        "configuration": {
          "title": "4.2. Конфигурация: Подключение к Хранилищу Активов",
          "steps": [
            "1. <strong>Создание Бакета:</strong>",
            "Войдите в Cloudflare Dashboard → R2.",
            "Нажмите <strong>\"Create Bucket\"</strong>.",
            "Назовите бакет (например, `brainmessenger-files`). Название должно быть уникальным в рамках всех аккаунтов Cloudflare.",
            "<strong>Настройки:</strong> Включите шифрование в покое (Encryption at rest) — это часть нашей <strong>системы безопасности</strong> (Принцип 3, 5). Ограничьте публичный доступ к бакету, доступ будет осуществляться через подписанные URL (если требуется) или через Backend.",
            "2. <strong>Ключи Доступа:</strong>",
            "В Cloudflare Dashboard перейдите в R2 → Manage R2 API Tokens.",
            "Создайте новый API-токен. Предоставьте ему минимально необходимые разрешения (например, Read and Write to specific buckets).",
            "Скопируйте `Access Key ID` и `Secret Access Key`.",
            "3. <strong>Переменные Окружения:</strong>",
            "Добавьте в ваш `.env` файл:"
          ],
          "envExample": "```env\n# Cloudflare R2 Credentials\nR2_ENDPOINT=<Your R2 Endpoint> # Формат: https://<account-id>.r2.cloudflarestorage.com\nR2_ACCESS_KEY=<Your Access Key ID>\nR2_SECRET_KEY=<Your Secret Access Key>\nR2_BUCKET=brainmessenger-files # Название вашего бакета\n\n# Ключ шифрования для конфиденциальных данных (важно для P3, P5, P10)\nENCRYPTION_KEY=<Your 32-byte (256-bit) hex or base64 encryption key> # Сгенерируйте надежный ключ!\n```",
          "note": "*Примечание:* <strong>Не коммитьте эти ключи в Git!</strong> (Принцип 3, 5, 6). Используйте `.env.example` без чувствительных данных. <strong>ENCRYPTION_KEY</strong> должен быть сгенерирован надежно и храниться в безопасности.",
          "backendCode": "4. <strong>Подключение Backend (`@aws-sdk/client-s3`):</strong>\nR2 совместим с S3 API, поэтому можно использовать стандартный AWS SDK для S3.\nУстановите SDK: `npm install @aws-sdk/client-s3`.\nИнициализируйте S3 Client в вашем Backend-сервисе (например, `StorageService`).\n```typescript\n// backend/src/storage/storage.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3';\nimport { getSignedUrl } from '@aws-sdk/s3-request-presigner'; // Для подписанных URL\nimport { createCipheriv, randomBytes, createDecipheriv } from 'crypto'; // Для шифрования\n\n@Injectable()\nexport class StorageService {\n  private r2: S3Client;\n  private encryptionKey: Buffer; // Ключ для шифрования\n\n  constructor() {\n    this.r2 = new S3Client({\n      region: 'auto', // R2 не использует регионы в классическом понимании\n      endpoint: process.env.R2_ENDPOINT,\n      credentials: {\n        accessKeyId: process.env.R2_ACCESS_KEY,\n        secretAccessKey: process.env.R2_SECRET_KEY,\n      },\n    });\n    // Важно: ENCRYPTION_KEY должен быть Buffer 32 байт для aes-256-cbc\n    this.encryptionKey = Buffer.from(process.env.ENCRYPTION_KEY, 'hex'); // Или 'base64'\n    if (this.encryptionKey.length !== 32) {\n         // Логировать ошибку или выбросить исключение - ключ неверной длины\n         console.error(\"Invalid ENCRYPTION_KEY length. Must be 32 bytes for aes-256-cbc.\");\n         // process.exit(1); // Возможно, стоит остановить приложение\n    }\n  }\n\n  // Утилита для шифрования (часть системы безопасности - P3, P5)\n  private encrypt(data: string): { encrypted: string, iv: string } {\n    const iv = randomBytes(16); // Initialization Vector, 16 байт для aes-256-cbc\n    const cipher = createCipheriv('aes-256-cbc', this.encryptionKey, iv);\n    let encrypted = cipher.update(data, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    return { encrypted, iv: iv.toString('hex') };\n  }\n\n  // Утилита для дешифрования\n  private decrypt(encrypted: string, iv: string): string {\n      const decipher = createDecipheriv('aes-256-cbc', this.encryptionKey, Buffer.from(iv, 'hex'));\n      let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n      decrypted += decipher.final('utf8');\n      return decrypted;\n  }\n\n  // ... методы для работы с R2 (загрузка, скачивание, удаление)\n}\n```"
        },
        "interactionScenarios": {
          "title": "4.3. Методы и Сценарии Взаимодействия: API Хранилища",
          "description": "Взаимодействие с R2 осуществляется через Backend, что позволяет контролировать доступ, обрабатывать файлы (например, оптимизация изображений перед загрузкой) и управлять метаданными в БД (Принцип 9: Система).",
          "uploadFile": {
            "title": "Сценарий: Загрузка файла пользователем:",
            "interaction": "<strong>Взаимодействие:</strong> Пользователь прикрепляет файл в чате → Frontend отправляет файл на Backend → Backend (`StorageService`) загружает файл в R2 → Backend сохраняет метаданные файла (URL, тип, размер) в Neon → Backend отправляет сообщение в чат с ссылкой на файл.",
            "code": "<strong>Пример кода (Backend Service):</strong>\n```typescript\n// backend/src/storage/storage.service.ts (продолжение)\n// ... S3Client и encryptionKey инициализация ...\n\nasync uploadFile(fileBuffer: Buffer, fileName: string, mimeType: string): Promise<string> {\n  const key = `uploads/${Date.now()}-${fileName}`; // Уникальный ключ файла\n  const params = {\n    Bucket: process.env.R2_BUCKET,\n    Key: key,\n    Body: fileBuffer,\n    ContentType: mimeType, // Важно для отдачи файла\n  };\n  const command = new PutObjectCommand(params);\n  await this.r2.send(command); // Асинхронная загрузка\n\n  // Возвращаем URL для сохранения в БД. R2 позволяет прямые ссылки, если настроен публичный домен.\n  // ИЛИ генерируем подписанный URL для ограниченного доступа (более безопасно).\n  // Пример прямой ссылки (требует настройки Public Access URL в CF Dashboard):\n  // const publicUrl = `${process.env.R2_ENDPOINT.replace('.r2.cloudflarestorage.com', '.r2.dev')}/${process.env.R2_BUCKET}/${key}`;\n  // Для своего домена (предпочтительно):\n  const fileUrl = `https://r2.brainmessenger.com/${key}`; // Ваш настроенный домен Cloudflare Workers/Pages\n\n  return fileUrl;\n}\n\n//backend/src/chat/chat.service.ts (интеграция uploadFile)\n// ... constructor с StorageService ...\nasync sendFileMessage(chatId: string, userId: string, file: Express.Multer.File): Promise<Message> {\n   // Опционально: обработка изображения перед загрузкой (см. DocOptimizationIn)\n   // const processedFileBuffer = await this.imageProcessingService.processImage(file.buffer, 800, 600); // Пример\n   const fileUrl = await this.storageService.uploadFile(file.buffer, file.originalname, file.mimetype);\n\n   // Создаем сообщение в БД со ссылкой на файл\n   return this.prisma.message.create({\n     data: {\n       chatId,\n       userId,\n       content: '[File]', // Или другое обозначение файла\n       fileUrl: fileUrl, // Сохраняем ссылку на файл в БД\n       // fileMetadata: { type: file.mimetype, size: file.size }, // Опционально: сохранение метаданных в JSON поле или отдельной таблице\n     },\n   });\n}\n```",
            "result": "<strong>Результат:</strong> Файл надежно хранится в R2, ссылка на него доступна в БД для отображения в чате."
          },
          "sensitiveData": {
            "title": "Сценарий: Хранение конфиденциальных данных (например, зашифрованные метаданные):",
            "interaction": "<strong>Взаимодействие:</strong> При регистрации или обновлении профиля Backend шифрует чувствительные данные (например, резервные email, секретные вопросы) и сохраняет их в R2 в отдельном бакете или папке.",
            "code": "<strong>Пример кода (Backend Service):</strong>\n```typescript\n// backend/src/storage/storage.service.ts (продолжение)\n// ... методы encrypt/decrypt ...\n\nasync storeSensitiveData(userId: string, sensitiveInfo: any): Promise<string> {\n   const encryptedData = {};\n   for (const key in sensitiveInfo) {\n       if (sensitiveInfo.hasOwnProperty(key)) {\n           const { encrypted, iv } = this.encrypt(JSON.stringify(sensitiveInfo[key])); // Шифруем каждое поле или весь объект\n           encryptedData[key] = { encrypted, iv };\n       }\n   }\n\n   const key = `sensitive/${userId}/metadata.json`;\n   const params = {\n       Bucket: process.env.R2_BUCKET, // Или отдельный бакет для чувствительных данных\n       Key: key,\n       Body: JSON.stringify(encryptedData),\n       ContentType: 'application/json',\n   };\n   const command = new PutObjectCommand(params);\n   await this.r2.send(command);\n   return `https://r2.brainmessenger.com/${key}`; // Ссылка для внутреннего использования\n}\n\n// backend/src/user/user.service.ts (интеграция storeSensitiveData)\n// ... constructor с StorageService ...\nasync createUserWithSensitiveData(userData: any, sensitiveData: any) {\n    // Создаем пользователя в БД\n    const user = await this.prisma.user.create({ data: userData });\n    // Сохраняем зашифрованные данные в R2\n    const sensitiveDataUrl = await this.storageService.storeSensitiveData(user.id, sensitiveData);\n    // Сохраняем ссылку на зашифрованные данные в БД (опционально)\n    await this.prisma.user.update({\n        where: { id: user.id },\n        data: { sensitiveDataUrl: sensitiveDataUrl } // Добавить поле sensitiveDataUrl в схему Prisma\n    });\n    return user;\n}\n```",
            "result": "<strong>Результат:</strong> Конфиденциальные данные надежно зашифрованы и хранятся отдельно от основной БД в R2. Доступ к ним возможен только через Backend с использованием ключа шифрования."
          },
          "getFile": {
            "title": "Сценарий: Получение файла (для отображения или скачивания):",
            "interaction": "<strong>Взаимодействие:</strong> Frontend получает URL файла из метаданных сообщения (из Neon) → Frontend (или Backend, если требуется аутентификация/подписанные URL) использует этот URL для скачивания файла напрямую из R2.",
            "code": "<strong>Реализация:</strong> Если бакет R2 настроен с Public Access URL (через Cloudflare Workers/Pages), Frontend может обращаться напрямую. Если доступ ограничен, Backend может генерировать временные подписанные URL через `@aws-sdk/s3-request-presigner`.\n```typescript\n// backend/src/storage/storage.service.ts (продолжение)\n// ... S3Client инициализация ...\n\n// Метод для генерации подписанного URL (более безопасный подход для приватных файлов)\nasync getSignedFileUrl(fileKey: string): Promise<string> {\n    const command = new GetObjectCommand({\n        Bucket: process.env.R2_BUCKET,\n        Key: fileKey,\n    });\n    // Сгенерировать подписанный URL, действительный, например, 60 секунд\n    const signedUrl = await getSignedUrl(this.r2, command, { expiresIn: 60 });\n    return signedUrl;\n}\n```"
          }
        },
        "errorHandling": {
          "title": "4.4. Обработка Ошибок Интеграции: Хранилище Активов",
          "forbidden": {
            "title": "403 Forbidden:",
            "cause": "Причина: Ошибка доступа к бакету R2. Неверные ключи доступа (`R2_ACCESS_KEY`, `R2_SECRET_KEY`), неверные разрешения токена, попытка доступа к приватному файлу без аутентификации/подписанного URL.",
            "solution": "Решение: Проверить переменные окружения, разрешения токена R2. Убедиться, что логика доступа (публичный URL vs подписанный URL) реализована корректно. Логировать ошибку."
          },
          "notFound": {
            "title": "404 Not Found:",
            "cause": "Причина: Файл отсутствует в R2. Неверный ключ файла (`Key`), файл был удален.",
            "solution": "Решение: Проверить ключ файла, который был сохранен в Neon. Убедиться, что файл действительно был загружен. Логировать ошибку."
          },
          "tooManyRequests": {
            "title": "429 Too Many Requests:",
            "cause": "Причина: Превышен лимит запросов к R2 API. Высокая частота запросов загрузки/скачивания.",
            "solution": "Решение: Внедрить Rate Limiting на Backend (см. Руководство по оптимизации). Оптимизировать логику работы с файлами."
          },
          "encryptionError": {
            "title": "Encryption/Decryption Error:",
            "cause": "Причина: Ошибка шифрования/дешифрования. Неверный ключ шифрования (`ENCRYPTION_KEY`), поврежденный IV, поврежденные зашифрованные данные.",
            "solution": "Решение: Убедиться, что используется правильный ключ (`ENCRYPTION_KEY`), который совпадает с ключом, использованным при шифровании. Проверить целостность данных и IV. Логировать критическую ошибку."
          }
        }
      },
      "neonR2Interaction": {
        "title": "5. Взаимодействие Neon и Cloudflare R2: Оптимизация Хранения Данных (Принцип 9, 12)",
        "description": "Мы используем Neon и R2 совместно, чтобы создать оптимизированную систему хранения данных, где каждый сервис выполняет свою лучшую функцию (Принцип 9).",
        "scenario": [
          "<strong>Neon (PostgreSQL):</strong> Хранит <strong>структурированные метаданные</strong>, которые часто запрашиваются и по которым выполняются сложные запросы (пользователи, чаты, текстовые сообщения, ссылки на файлы).",
          "<strong>Cloudflare R2:</strong> Хранит <strong>неструктурированные бинарные данные</strong> большого размера (файлы), которые реже запрашиваются и не требуют сложной логики выборки по содержимому).",
          "<strong>Сценарий комплексного взаимодействия:</strong>",
          "1. Пользователь отправляет файл через чат (Frontend -> Backend).",
          "2. Backend (`StorageService`) <strong>загружает файл в Cloudflare R2</strong> (используя S3 API). Получает URL файла (или ключ).",
          "3. Backend (`ChatService`) <strong>сохраняет метаданные сообщения в Neon через Prisma</strong>, включая полученный URL/ключ файла.",
          "4. Когда другой пользователь открывает чат, Backend (`ChatService`) <strong>получает список сообщений из Neon через Prisma</strong>, включая URL/ключи файлов.",
          "5. Frontend отображает список сообщений и использует URL/ключи для <strong>скачивания файлов напрямую из R2</strong> (или через Backend, если требуется аутентификация)."
        ],
        "advantagesTitle": "Преимущества такого разделения:",
        "advantages": [
          "<strong>Оптимизация производительности БД:</strong> PostgreSQL не \"засоряется\" большими бинарными данными, что улучшает скорость текстовых запросов (Принцип 9).",
          "<strong>Снижение стоимости:</strong> R2 предлагает очень выгодные тарифы для хранения больших объемов данных без платы за исходящий трафик, что <strong>прагматично</strong> (Принцип 12) и способствует созданию <strong>актива</strong> (Принцип 10).",
          "<strong>Масштабируемость:</strong> Каждый сервис масштабируется независимо в соответствии со своим типом нагрузки (Neon для транзакций, R2 для объема/трафика файлов).",
          "<strong>Надежность:</strong> Разделение ответственности между сервисами повышает общую отказоустойчивость системы."
        ]
      },
      "otherIntegrations": {
        "title": "6. Другие Интеграции: Расширение Функционала Системы (Принцип 2, 12)",
        "description": "Эти интеграции добавляют <strong>ценность</strong> (Принцип 2) и используют <strong>прагматичные, готовые решения</strong> (Принцип 12).",
        "firebase": {
          "title": "6.1. Firebase (Push-уведомления)",
          "purpose": "Назначение: Мгновенная доставка уведомлений о новых сообщениях, звонках и системных событиях пользователям мобильных приложений.",
          "role": "Роль: <strong>Критически важный компонент системы уведомлений</strong> (Принцип 9) для поддержания вовлеченности пользователей и оперативного информирования (Принцип 2).",
          "configuration": "Конфигурация: Переменная окружения: `FIREBASE_CREDENTIALS_PATH` (путь к JSON-файлу учетных данных сервисного аккаунта Firebase). <strong>Храните этот файл безопасно!</strong>",
          "example": "Используется библиотека `firebase-admin` в Backend NestJS. Пример использования: Отправка уведомления при получении нового сообщения (см. Руководство по оптимизации для батчинга и тем)."
        },
        "stripe": {
          "title": "6.2. Stripe (Платежи)",
          "purpose": "Назначение: Обработка подписок на Premium-функционал BrainMessenger.",
          "role": "Роль: <strong>Финансовый рычаг</strong> для поддержки развития проекта (Принцип 10: Создание Богатства) и предоставления дополнительной <strong>ценности</strong> (Принцип 2) премиум-пользователям.",
          "configuration": "Конфигурация: Переменная окружения: `STRIPE_SECRET_KEY`.",
          "example": "Используется библиотека `stripe` в Backend NestJS. Пример использования: Создание сессии оплаты при попытке оформить подписку. Обработка вебхуков для подтверждения успешной оплаты."
        },
        "gmailApi": {
          "title": "6.3. Gmail API (Отправка Email)",
          "purpose": "Назначение: Отправка транзакционных email, таких как коды подтверждения для регистрации и двухфакторной аутентификации (2FA), уведомления о сбросе пароля.",
          "role": "Роль: <strong>Критически важный компонент системы аутентификации и безопасности</strong> (Принцип 9, 5).",
          "configuration": "Конфигурация: Требует настройки сервисного аккаунта Google Cloud и получения учетных данных (см. Техническую документацию, раздел 10.1). Переменные окружения для учетных данных сервисного аккаунта или API-ключей.",
          "example": "Пример использования: Вызов API для отправки письма с кодом подтверждения после ввода email при регистрации или включении 2FA (см. Спецификацию API, раздел 2.4)."
        }
      },
      "recommendations": {
        "title": "7. Рекомендации по Интеграциям: Поддержание Здоровья Системы (Принцип 3, 5, 9)",
        "intro": "Чтобы интеграции оставались <strong>надежными, безопасными и эффективными</strong> (Принцип 3, 9), следуйте этим рекомендациям, связанным с поддержанием \"здоровья\" системы (Принцип 5, применительно к технике):",
        "security": {
          "title": "Безопасность:",
          "points": [
            "<strong>Никогда не коммитьте ключи и секреты в Git.</strong> Используйте переменные окружения и системы управления секретами в продакшен-окружении (например, Kubernetes Secrets, HashiCorp Vault).",
            "Регулярно проводите <strong>ротацию API-токенов</strong> (R2, Firebase, Gmail, Stripe) для повышения безопасности.",
            "Используйте <strong>принцип минимальных привилегий</strong> при создании API-токенов: давайте им только те разрешения, которые действительно необходимы."
          ]
        },
        "scaling": {
          "title": "Масштабирование:",
          "points": [
            "<strong>Мониторьте использование ресурсов</strong> (место в Neon/R2, запросы к API Firebase/Stripe) через консоли соответствующих сервисов. Будьте готовы перейти на платный тариф при росте нагрузки (Принцип 8, 12).",
            "Используйте <strong>оптимизационные подходы</strong> (например, батчинг запросов к Firebase, индексирование в Neon, см. Руководство по оптимизации), чтобы отложить необходимость перехода на более дорогие тарифы."
          ]
        },
        "monitoring": {
          "title": "Мониторинг и Логирование:",
          "points": [
            "Настройте <strong>логирование ошибок интеграций</strong> в NestJS (Winston, Sentry).",
            "Используйте <strong>системы мониторинга</strong> (Prometheus/Grafana) для отслеживания метрик запросов к внешним сервисам (задержки, количество ошибок) — это часть <strong>Кайдзен</strong> (Принцип 9), позволяющая выявлять проблемы на ранней стадии."
          ]
        },
        "errorHandling": {
          "title": "Обработка Ошибок:",
          "points": [
            "Реализуйте <strong>грамотную обработку ошибок</strong> от внешних сервисов на Backend. Логируйте их подробно.",
            "Для критически важных операций (например, регистрация, платежи) предусмотрите механизмы <strong>повторных попыток (retries)</strong> или <strong>компенсирующих действий</strong> (например, отметка платежа как незавершенного) при временных сбоях внешних сервисов."
          ]
        },
        "documentation": {
          "title": "Документация:",
          "content": "Поддерживайте эту документацию в актуальном состоянии, отражая изменения в используемых сервисах или добавлении новых интеграций (Принцип 1: Обучение, Принцип 9: Система)."
        }
      }
    },
    "optimizationGuide": {
      "title": "Руководство по Оптимизации BrainMessenger (Принцип Кайдзен в Действии)",
      "subtitle": "Введение: Оптимизация как Непрерывный Процесс Улучшения",
      "introduction": {
        "title": "1. Введение: Оптимизация как Непрерывный Процесс Улучшения",
        "description": "Этот документ подробно описывает подходы, инструменты и техники, которые мы используем для оптимизации производительности BrainMessenger. Оптимизация — это не одноразовая задача, а <strong>непрерывный процесс улучшения</strong> (Принцип 1, 9: Кайдзен), который позволяет нам обеспечить <strong>высокое качество, надежность и масштабируемость</strong> (Принцип 3, 8) приложения.",
        "goalTitle": "Цель:",
        "goalContent": "Идентифицировать и устранять узкие места в производительности на всех уровнях системы (Frontend, Backend, База данных, Инфраструктура), чтобы BrainMessenger оставался <strong>быстрым, отзывчивым и эффективным</strong> (Принцип 2) даже при значительной нагрузке (цель — 1 миллион активных пользователей), поддерживая <strong>здоровье системы</strong> (Принцип 5, применительно к технике).",
        "audienceTitle": "Аудитория:",
        "audienceContent": "Backend, Frontend, Mobile, Desktop и DevOps разработчики, сфокусированные на производительности и масштабировании.",
        "principlesTitle": "Принципы, которыми руководствуется оптимизация:",
        "principles": [
          "<strong>Система и Оптимизация (Принцип 9: Кайдзен):</strong> Оптимизация является ключевым аспектом нашей системы разработки. Используется цикличный подход: Измерение → Анализ → Улучшение → Проверка.",
          "<strong>Качество > Количество (Принцип 3):</strong> Лучше иметь несколько критически важных оптимизаций, чем много мелких, не дающих значительного эффекта.",
          "<strong>Прагматизм и Реализм (Принцип 12):</strong> Оптимизируем то, что действительно влияет на производительность и пользовательский опыт, основываясь на реальных данных, а не на догадках.",
          "<strong>Постоянное Обучение (Принцип 1):</strong> Изучение новых техник и инструментов оптимизации, анализ результатов и уроков.",
          "<strong>Настойчивость (Принцип 13):</strong> Оптимизация может быть сложной. Требуется упорство для выявления и решения глубоких проблем производительности.",
          "<strong>Здоровье как Фундамент (Принцип 5):</strong> Оптимизация системы (например, снижение потребления памяти/CPU) напрямую влияет на \"здоровье\" серверов и устройств пользователей.",
          "<strong>Внешняя Экспертиза (Принцип 14):</strong> Использование стандартных инструментов (Prometheus, Grafana, V8 Profiler), изучение опыта других команд (Google, Next.js и т.д.)."
        ]
      },
      "generalPrinciple": {
        "title": "2. Общий Принцип Оптимизации (Цикл Кайдзен)",
        "intro": "Наш подход к оптимизации следует <strong>циклу Кайдзен (Принцип 9)</strong>:",
        "step1": {
          "title": "1. Измерение (Measure):",
          "content": "Соберите данные о производительности. Используйте инструменты мониторинга (Prometheus, Sentry), профилирования (V8 Profiler), анализа бандлов (Webpack Bundle Analyzer, `@next/bundle-analyzer`)."
        },
        "step2": {
          "title": "2. Анализ (Analyze):",
          "content": "Определите <strong>узкие места (bottlenecks)</strong> на основе собранных данных. Где система тратит больше всего времени или ресурсов?"
        },
        "step3": {
          "title": "3. Улучшение (Improve):",
          "content": "Примените конкретные техники оптимизации, описанные в этом руководстве, для устранения выявленных узких мест."
        },
        "step4": {
          "title": "4. Проверка (Verify):",
          "content": "Снова измерьте производительность после внесенных изменений. Убедитесь, что оптимизация дала ожидаемый эффект и не вызвала регрессий (не ухудшила другие аспекты)."
        },
        "step5": {
          "title": "5. Повторение:",
          "content": "Производительность может меняться с ростом нагрузки и функционала. Повторяйте цикл Кайдзен непрерывно."
        }
      },
      "imageProcessing": {
        "title": "3. Оптимизация Обработки Изображений: Эффективность и Скорость (Принцип 9, 2)",
        "intro": "Обработка изображений может быть ресурсоемкой. <strong>Оптимизация этого процесса напрямую влияет на скорость загрузки контента и отзывчивость приложения</strong> (Принцип 2: Ценность).",
        "libraryTitle": "Библиотека:",
        "libraryContent": "`sharp` (на базе `libvips`). Выбран как <strong>прагматичное</strong> (Принцип 12) и <strong>высокопроизводительное</strong> (Принцип 9) решение для Node.js.",
        "applicationAreasTitle": "Области применения:",
        "applicationAreasContent": "Изменение размера, сжатие, конвертация формата для аватаров, изображений в чатах.",
        "keyTechniqueTitle": "Ключевая техника:",
        "keyTechniqueContent": "<strong>Асинхронная обработка</strong> в фоновом режиме через Kafka.",
        "implementationStepsTitle": "Шаги по внедрению (Backend):",
        "step1": {
          "title": "1. Установите `sharp`:",
          "content": "Убедитесь, что `libvips` установлен в вашей операционной системе или Docker-образе.",
          "code": "```bash\\nnpm install sharp\\n```"
        },
        "step2": {
          "title": "2. Создайте сервис обработки изображений:",
          "content": "Инкапсулируйте логику в отдельном сервисе (часть <strong>системы</strong> - Принцип 9).",
          "code": "```typescript\\n// backend/src/image-processing/image-processing.service.ts\\nimport { Injectable } from '@nestjs/common';\\nimport sharp from 'sharp';\\n\\n@Injectable()\\nexport class ImageProcessingService {\\n  // Метод для изменения размера, сжатия и конвертации в WebP\\n  async processImage(buffer: Buffer, width: number, height?: number): Promise<Buffer> {\\n    // resize({ width, height, withoutEnlargement: true }) - избегаем увеличения, если исходник меньше\\n    // webp({ quality: 80 }) - сжатие в формат WebP (хорошее сжатие при сохранении качества)\\n    // withMetadata({ orientation: true }) - сохраняем ориентацию из EXIF, остальное удаляем (экономия размера - Принцип 9)\\n    return sharp(buffer)\\n      .resize(width, height, { withoutEnlargement: true })\\n      .webp({ quality: 80 })\\n      .withMetadata({ orientation: true })\\n      .toBuffer();\\n  }\\n\\n  // Метод для простого изменения размера\\n  async resizeImage(buffer: Buffer, width: number, height?: number): Promise<Buffer> {\\n       return sharp(buffer)\\n           .resize(width, height, { withoutEnlargement: true })\\n           .toBuffer();\\n  }\\n\\n   // Метод для конвертации в определенный формат\\n   async convertToFormat(buffer: Buffer, format: keyof sharp.Format): Promise<Buffer> {\\n       return sharp(buffer).toFormat(format).toBuffer();\\n   }\\n}\\n```"
        },
        "step3": {
          "title": "3. Интеграция с загрузкой файлов (Backend Controller/Service):",
          "content": "",
          "code": "```typescript\\n// backend/src/upload/upload.controller.ts (пример обработки загрузки аватара)\\nimport { Controller, Post, UploadedFile, UseInterceptors, Body, Inject } from '@nestjs/common';\\nimport { FileInterceptor } from '@nestjs/platform-express';\\nimport { ImageProcessingService } from '../image-processing/image-processing.service';\\nimport { StorageService } from '../storage/storage.service';\\nimport { UserService } from '../user/user.service';\\n\\n@Controller('upload')\\nexport class UploadController {\\n  constructor(\\n    private imageProcessingService: ImageProcessingService,\\n    private storageService: StorageService,\\n    private userService: UserService,\\n    // ... инъекция Kafka продюсера для асинхронной обработки\\n  ) {}\\n\\n  @Post('avatar')\\n  @UseInterceptors(FileInterceptor('file')) // 'file' - имя поля формы\\n  async uploadAvatar(@UploadedFile() file: Express.Multer.File, @Body('userId') userId: string) {\\n    // Оптимизация: Обработка изображения перед загрузкой в R2\\n    const processedImageBuffer = await this.imageProcessingService.processImage(file.buffer, 300, 300); // Изменить размер и сжать\\n    const fileName = `avatars/${userId}-${Date.now()}.webp`; // Уникальное имя файла в папке avatars\\n    const mimeType = 'image/webp'; // Соответствует формату WebP\\n\\n    // Загрузка обработанного файла в Cloudflare R2\\n    const avatarUrl = await this.storageService.uploadFile(processedImageBuffer, fileName, mimeType);\\n\\n    // Обновление ссылки на аватар в профиле пользователя в Neon\\n    await this.userService.updateUserAvatar(userId, avatarUrl);\\n\\n    // Возвращаем URL аватара клиенту\\n    return { avatarUrl };\\n  }\\n\\n  @Post('chat-image')\\n  @UseInterceptors(FileInterceptor('file'))\\n  async uploadChatImage(@UploadedFile() file: Express.Multer.File, @Body('chatId') chatId: string, @Body('userId') userId: string) {\\n      // Отправка задачи на обработку изображения в Kafka для асинхронной обработки (Принцип 9)\\n      const taskPayload = { fileBuffer: file.buffer.toString('base64'), fileName: file.originalname, mimeType: file.mimetype, chatId, userId };\\n      // Предполагается, что у вас есть Kafka продюсер сервис\\n      // await this.kafkaProducerService.sendMessage('image-processing-topic', JSON.stringify(taskPayload));\\n\\n      // Немедленный ответ клиенту, что файл принят в обработку\\n      return { status: 'processing', originalFileName: file.originalname };\\n\\n      // ИЛИ, если синхронная обработка приемлема для небольших файлов:\\n      /*\\n      const processedImageBuffer = await this.imageProcessingService.processImage(file.buffer, 800); // Изменить размер\\n      const fileName = `chat-images/${chatId}-${Date.now()}.webp`;\\n      const mimeType = 'image/webp';\\n      const imageUrl = await this.storageService.uploadFile(processedImageBuffer, fileName, mimeType);\\n\\n      // Создание сообщения типа 'image' в чате\\n      // await this.chatService.sendImageMessage(chatId, userId, imageUrl);\\n\\n      return { imageUrl };\\n      */\\n  }\\n}\\n```"
        },
        "step4": {
          "title": "4. Асинхронность через Kafka (для тяжелых задач):",
          "content": "Для обработки изображений в чатах (которые могут быть большими) используйте <strong>Kafka</strong> (см. раздел 8) для <strong>асинхронной обработки</strong>. Backend быстро принимает файл от клиента и ставит задачу в очередь Kafka. Отдельный воркер (consumer Kafka) забирает задачу, обрабатывает изображение с помощью `sharp`, загружает в R2 и только после этого создает сообщение в чате через API. Это <strong>снижает время ответа API</strong> (Принцип 9) и улучшает пользовательский опыт."
        }
      },
      "dbOptimization": {
        "title": "4. Оптимизация Базы Данных (Neon/PostgreSQL): Ускорение Доступа к Данным (Принцип 9, 8)",
        "intro": "База данных часто становится узким местом. Оптимизация запросов и структуры БД критически важна для <strong>долгосрочной производительности</strong> (Принцип 8) и <strong>эффективности системы</strong> (Принцип 9).",
        "platformTitle": "Платформа:",
        "platformContent": "Neon (управляемый PostgreSQL).",
        "toolTitle": "Инструмент:",
        "toolContent": "Prisma ORM.",
        "analysisToolTitle": "Инструмент анализа:",
        "analysisToolContent": "`EXPLAIN ANALYZE` в SQL-клиенте Neon или `prisma.queryRaw` с `EXPLAIN ANALYZE`.",
        "monitoringToolTitle": "Инструмент мониторинга:",
        "monitoringToolContent": "Prometheus + `postgres_exporter` (см. раздел 14).",
        "indexing": {
          "title": "4.1. Индексация: Ускорение Поиска и Фильтрации",
          "intro": "Индексы позволяют базе данных быстрее находить нужные строки.",
          "whenTitle": "Когда использовать:",
          "whenContent": "На полях, которые часто используются в `WHERE`, `JOIN`, `ORDER BY`.",
          "applicationAreasTitle": "Области применения в BrainMessenger:",
          "applicationAreasContent": "`userId`, `chatId`, `createdAt` (в таблице `Message`), `email` (в таблице `User`), поля для поиска.",
          "prismaTitle": "Реализация (Prisma):",
          "prismaContent": "Добавляйте `@index` в `schema.prisma`.",
          "prismaCode": "```prisma\\n// schema.prisma\\nmodel Message {\\n  id        String   @id @default(cuid())\\n  content   String\\n  createdAt DateTime @default(now()) @map(\\\"created_at\\\") // Пример @map для snake_case в БД\\n  chatId    String @map(\\\"chat_id\\\")\\n  userId    String @map(\\\"user_id\\\")\\n  chat      Chat     @relation(fields: [chatId], references: [id])\\n  user      User     @relation(fields: [userId], references: [id])\\n\\n  // Комбинированный индекс для быстрых запросов сообщений в чате по времени\\n  @@index([chatId, createdAt])\\n  // Индекс для быстрого получения сообщений по пользователю (например, для статистики)\\n  @@index([userId])\\n  // Индекс для поиска по содержимому (если требуется полнотекстовый поиск - рассмотреть tsearch)\\n  // @@index([content]) // Только для простых фильтров LIKE\\n}\\n\\nmodel User {\\n    id    String @id @default(cuid())\\n    email String @unique // Уникальный индекс для быстрого поиска по email (логин, регистрация)\\n    name  String\\n    // ... другие поля\\n}\\n\\nmodel Chat {\\n   id          String @id @default(cuid())\\n   lastMessageAt DateTime? @map(\\\"last_message_at\\\") // Для сортировки чатов (нужен индекс)\\n   // ... другие поля\\n   @@index([lastMessageAt]) // Индекс для сортировки списка чатов\\n}\\n```",
          "applicationTitle": "Применение:",
          "applicationContent": "После изменения `schema.prisma` выполните миграцию (`npx prisma migrate dev`)."
        },
        "queryOptimization": {
          "title": "4.2. Оптимизация Запросов (Prisma): Пишем Эффективный Код Взаимодействия с БД",
          "intro": "",
          "selectFieldsTitle": "Выбирайте только нужные поля (`select`):",
          "selectFieldsContent": "Не запрашивайте `SELECT *`. Указывайте поля, которые вам действительно нужны. Это уменьшает объем данных, передаваемых по сети и обрабатываемых БД.",
          "selectFieldsCode": "```typescript\\n// Плохо\\nconst user = await prisma.user.findUnique({ where: { id: userId } }); // Выберет все поля\\n\\n// Хорошо (если нужен только email и name)\\nconst user = await prisma.user.findUnique({\\n  where: { id: userId },\\n  select: {\\n    email: true,\\n    name: true,\\n  },\\n});\\n```",
          "nPlus1Title": "Избегайте N+1 проблем (`include`):",
          "nPlus1Content": "Если вам нужны связанные данные (например, автор сообщения при получении списка сообщений), используйте `include` или `select` со вложенными полями вместо выполнения отдельного запроса для каждого элемента.",
          "nPlus1Code": "```typescript\\n// Плохо (N+1 проблема - отдельный запрос за каждым пользователем)\\nconst messages = await prisma.message.findMany({ where: { chatId: chatId } });\\nfor (const message of messages) {\\n  const sender = await prisma.user.findUnique({ where: { id: message.userId } });\\n  // ... использовать sender\\n}\\n\\n// Хорошо (используем include для получения автора сообщения одним запросом)\\nconst messagesWithSender = await prisma.message.findMany({\\n  where: { chatId: chatId },\\n  include: {\\n    user: { // Включаем данные пользователя, связанного с сообщением через поле 'user' в модели Message\\n      select: { id: true, name: true, avatarUrl: true } // Выбираем только нужные поля пользователя\\n    },\\n  },\\n  orderBy: { createdAt: 'asc' }, // Пример: сообщения в хронологическом порядке\\n  take: 50, // Пример: пагинация\\n});\\n```",
          "paginationTitle": "Пагинация (`skip`, `take`, `cursor`):",
          "paginationContent": "Для получения больших списков (сообщения в чате, список чатов) используйте пагинацию, чтобы не загружать все данные сразу. `cursor`-пагинация предпочтительнее для бесконечной прокрутки.",
          "paginationCode": "```typescript\\n// Пример пагинации с take и skip\\nconst messages = await prisma.message.findMany({\\n    where: { chatId: chatId },\\n    orderBy: { createdAt: 'asc' },\\n    skip: (page - 1) * pageSize, // Пропустить N сообщений\\n    take: pageSize, // Взять M сообщений\\n});\\n\\n// Пример Cursor-based пагинации (для \\\"показать еще\\\")\\nconst messages = await prisma.message.findMany({\\n    where: { chatId: chatId },\\n    orderBy: { createdAt: 'asc' },\\n    cursor: { id: lastMessageId }, // Начать после последнего сообщения\\n    skip: 1, // Пропустить само последнее сообщение\\n    take: pageSize,\\n});\\n```"
        },
        "prismaAccelerate": {
          "title": "4.3. Prisma Accelerate: Глобальный Кэш и Пул Соединений",
          "intro": "Prisma Accelerate предоставляет глобальную сеть серверов (Edge locations), которые кэшируют результаты запросов и управляют пулом соединений к вашей БД Neon.",
          "whenTitle": "Когда использовать:",
          "whenContent": "Для снижения задержки запросов (latency) для пользователей по всему миру и оптимизации использования пула соединений БД.",
          "implementationTitle": "Реализация:",
          "implementationContent": "Настраивается в консоли Prisma. Ваша `DATABASE_URL` заменяется на URL Prisma Accelerate."
        },
        "materializedViews": {
          "title": "4.4. Материализованные Представления: Кэширование Сложных Агрегаций",
          "intro": "Материализованные представления — это по сути кэшированные результаты сложных запросов или агрегаций (например, количество сообщений в чате, последние активные пользователи в группе). Они хранятся на диске и могут быть быстро прочитаны.",
          "whenTitle": "Когда использовать:",
          "whenContent": "Для запросов, которые выполняются часто, но требуют сложных вычислений (JOINs, GROUP BY, агрегатные функции) над большими таблицами, и данные в которых не должны быть абсолютно актуальными каждую миллисекунду.",
          "applicationAreasTitle": "Области применения:",
          "applicationAreasContent": "Статистика чатов (общее количество сообщений, участников), списки \"топ\" пользователей (например, по количеству отправленных сообщений).",
          "implementationTitle": "Реализация (SQL, через Prisma `queryRaw` или SQL-клиент Neon):",
          "implementationContent": "```sql\\n-- Создать материализованное представление для подсчета сообщений в каждом чате\\nCREATE MATERIALIZED VIEW chat_message_counts AS\\nSELECT\\n    \\\"chatId\\\",\\n    COUNT(*) as \\\"messageCount\\\"\\nFROM \\\"Message\\\"\\nGROUP BY \\\"chatId\\\";\\n\\n-- Создать индекс на представлении для быстрого поиска по chatId (необязательно, но часто полезно)\\nCREATE INDEX idx_chat_message_counts_chat_id ON chat_message_counts (\\\"chatId\\\");\\n```",
          "updateTitle": "Обновление:",
          "updateContent": "Материализованные представления нужно <strong>периодически обновлять</strong>, чтобы отразить изменения в базовых таблицах. Это делается командой `REFRESH MATERIALIZED VIEW <view_name>;`. Частота обновления зависит от того, насколько актуальными должны быть данные (например, раз в час, раз в день).",
          "updateCode": "```sql\\n-- Обновить представление (может блокировать чтение во время выполнения)\\nREFRESH MATERIALIZED VIEW chat_message_counts;\\n\\n-- Обновить представление без блокировки чтения (для больших представлений)\\nREFRESH MATERIALIZED VIEW CONCURRENTLY chat_message_counts; -- Требует уникального индекса\\n```",
          "usageTitle": "Использование в Prisma:",
          "usageContent": "Запрашивайте как обычную таблицу.",
          "usageCode": "```typescript\\nconst chatStats = await prisma.chatMessageCounts.findMany({\\n  select: { chatId: true, messageCount: true },\\n  where: { chatId: 'some-chat-id' },\\n});\\n```"
        },
        "partitioning": {
          "title": "4.5. Партиционирование Таблиц: Разделение Больших Объемов Данных",
          "intro": "Партиционирование физически разделяет очень большие таблицы (например, `Message`) на более мелкие части (партиции) на основе значения в определенном столбце (например, `createdAt` или `chatId`).",
          "whenTitle": "Когда использовать:",
          "whenContent": "Когда таблица становится настолько большой (миллиарды строк), что индексы уже не справляются, и запросы начинают замедляться из-за необходимости сканировать слишком много данных.",
          "applicationAreasTitle": "Области применения:",
          "applicationAreasContent": "Таблица `Message` — идеальный кандидат для партиционирования по времени создания (`createdAt`) или по ID чата (`chatId`).",
          "implementationTitle": "Реализация (SQL, через Prisma `queryRaw` или SQL-клиент Neon):",
          "implementationContent": "PostgreSQL поддерживает нативное партиционирование.",
          "implementationCode": "```sql\\n-- Создать главную партиционированную таблицу по диапазону дат\\nCREATE TABLE messages (\\n    id TEXT NOT NULL,\\n    content TEXT NOT NULL,\\n    created_at TIMESTAMP WITH TIME ZONE NOT NULL,\\n    chat_id TEXT NOT NULL,\\n    user_id TEXT NOT NULL,\\n    PRIMARY KEY (id, created_at) -- Ключ партиционирования должен быть частью первичного ключа\\n) PARTITION BY RANGE (created_at); -- Партиционируем по диапазону поля created_at\\n\\n-- Создать партиции (например, по месяцам)\\nCREATE TABLE messages_2025_03 PARTITION OF messages\\n    FOR VALUES FROM ('2025-03-01 00:00:00+00') TO ('2025-04-01 00:00:00+00');\\n\\nCREATE TABLE messages_2025_04 PARTITION OF messages\\n    FOR VALUES FROM ('2025-04-01 00:00:00+00') TO ('2025-05-01 00:00:00+00');\\n\\n-- ... создавать новые партиции по мере необходимости (автоматически или вручную)\\n\\n-- Создать индексы для партиционированной таблицы (применяются ко всем партициям)\\nCREATE INDEX ON messages (\\\"chat_id\\\", \\\"created_at\\\");\\nCREATE INDEX ON messages (\\\"user_id\\\");\\n```",
          "advantagesTitle": "Преимущества:",
          "advantagesContent": "Запросы, включающие фильтр по ключу партиционирования (например, `WHERE created_at BETWEEN ...`), будут сканировать только нужные партиции, что значительно ускоряет их выполнение. Управление старыми данными (удаление) становится проще (можно просто удалить старые партиции).",
          "prismaRelationTitle": "Связь с Prisma:",
          "prismaRelationContent": "Prisma работает с партиционированной таблицей как с обычной."
        }
      },
      "graphqlOptimization": {
        "title": "5. Оптимизация GraphQL API (NestJS + Prisma): Эффективная Передача Данных",
        "intro": "GraphQL сам по себе является инструментом <strong>оптимизации</strong> (Принцип 9) по сравнению с REST (клиент запрашивает только нужные данные). Однако и его можно оптимизировать.",
        "analysisToolTitle": "Инструмент анализа:",
        "analysisToolContent": "`graphql-query-complexity` для защиты от сложных запросов.",
        "dataloader": {
          "title": "5.1. DataLoader: Решение Проблемы N+1 в GraphQL",
          "intro": "DataLoader — это утилита, которая помогает решить проблему N+1 запросов при работе с графами данных. Если у вас есть список объектов, и для каждого объекта нужно подтянуть связанный с ним объект (например, список сообщений и для каждого сообщения его автора), DataLoader соберет все ID связанных объектов и сделает один пакетный запрос к БД.",
          "whenTitle": "Когда использовать:",
          "whenContent": "В резолверах GraphQL, когда вам нужно получить связанные объекты для списка родительских объектов.",
          "applicationAreasTitle": "Области применения:",
          "applicationAreasContent": "Получение данных автора для каждого сообщения в чате, получение списка участников для каждого чата в списке чатов пользователя.",
          "implementationTitle": "Реализация:",
          "implementationContent": "Создайте отдельные DataLoader для каждого типа объекта, который нужно подтягивать. Интегрируйте их в контекст GraphQL запроса.",
          "implementationCode": "```typescript\\n// backend/src/graphql/loaders/user.loader.ts\\nimport { Injectable, Scope } from '@nestjs/common';\\nimport DataLoader from 'dataloader';\\nimport { PrismaService } from 'nestjs-prisma';\\nimport { User } from '@prisma/client'; // Импорт модели Prisma\\n\\n// Scope.REQUEST - важно, чтобы DataLoader был уникален для каждого запроса GraphQL\\n@Injectable({ scope: Scope.REQUEST })\\nexport class UserLoader {\\n  private loader: DataLoader<string, User>;\\n\\n  constructor(private prisma: PrismaService) {\\n    // Создаем новый DataLoader. Функция batchLoadFn принимает массив ключей (user IDs)\\n    this.loader = new DataLoader<string, User>(\\n      async (ids: readonly string[]) => {\\n        // Выполняем ОДИН запрос к БД, чтобы получить ВСЕх пользователей по их ID\\n        const users = await this.prisma.user.findMany({\\n          where: {\\n            id: { in: Array.from(ids) }, // Array.from(ids) для совместимости с Prisma\\n          },\\n        });\\n\\n        // Важно: Вернуть массив результатов, упорядоченный по исходному массиву ids\\n        const userMap = new Map(users.map(user => [user.id, user]));\\n        return ids.map(id => userMap.get(id)); // Возвращаем пользователей в том же порядке, что и запросили\\n      },\\n      { cache: true } // Включаем кэширование внутри запроса GraphQL\\n    );\\n  }\\n\\n  // Метод для загрузки одного пользователя по ID\\n  load(id: string): Promise<User> {\\n    return this.loader.load(id);\\n  }\\n\\n  // Метод для загрузки списка пользователей по ID\\n  loadMany(ids: string[]): Promise<(Error | User)[]> {\\n      return this.loader.loadMany(ids);\\n  }\\n}\\n```\\nИнтегрируйте лоадеры в контекст GraphQL (`backend/src/graphql/graphql.module.ts` или `app.module.ts`):\\n```typescript\\n// backend/src/graphql/graphql.module.ts\\nimport { Module } from '@nestjs/common';\\nimport { GraphQLModule } from '@nestjs/graphql';\\nimport { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';\\nimport { UserLoader } from './loaders/user.loader'; // Импорт лоадера\\n// ... другие импорты резолверов и модулей\\n\\n@Module({\\n  imports: [\\n    GraphQLModule.forRoot<ApolloDriverConfig>({\\n      driver: ApolloDriver,\\n      // ... другие настройки GraphQL (schema path, context, etc.)\\n      context: ({ req, connection }) => {\\n        // Создаем контекст для каждого запроса\\n        const context = { req }; // Добавляем объект запроса\\n         if (connection) {\\n           // Для WebSocket (подписки)\\n           // context.loaders = new Loaders(); // Если лоадеры создаются здесь\\n         } else {\\n           // Для HTTP запросов (queries/mutations)\\n           // Создаем лоадеры и добавляем их в контекст\\n           context.loaders = {\\n              userLoader: new UserLoader(/* зависимости */), // Нужно инжектить PrismaService\\n              // ... другие лоадеры\\n           };\\n           // Пример инъекции зависимостей в лоадер (может потребовать FactoryProvider)\\n           // context.loaders = {\\n           //     userLoader: req.loaders.userLoader, // Если используете Request-scoped провайдеры NestJS\\n           // };\\n         }\\n        return context;\\n      },\\n      // plugins: [complexityPlugin], // Плагин для анализа сложности запросов\\n    }),\\n    // ... импорт других модулей\\n  ],\\n   providers: [UserLoader], // Добавляем лоадер как провайдер (для Request scope)\\n})\\nexport class GraphqlModule {}\\n```",
          "usageTitle": "Используйте лоадеры в резолверах:",
          "usageContent": "",
          "usageCode": "```typescript\\n// backend/src/message/message.resolver.ts\\nimport { Resolver, ResolveField, Parent, Context } from '@nestjs/graphql';\\nimport { Message } from '@prisma/client'; // Импорт модели Prisma\\nimport { UserLoader } from '../graphql/loaders/user.loader'; // Импорт лоадера\\n\\n@Resolver('Message') // Указываем GraphQL тип, к которому относится резолвер\\nexport class MessageResolver {\\n  @ResolveField('user') // Определяем резолвер для поля 'user' в типе Message\\n  async resolveUser(@Parent() message: Message, @Context() context: any) {\\n    // Используем userLoader из контекста для загрузки пользователя по message.userId\\n    // DataLoader автоматически соберет все message.userId в текущем запросе и загрузит их батчем\\n    return context.loaders.userLoader.load(message.userId);\\n  }\\n}\\n```"
        },
        "queryComplexityAnalysis": {
          "title": "5.2. Анализ Сложности Запросов: Защита от \"Тяжелых\" Запросов",
          "intro": "GraphQL позволяет клиенту запрашивать данные произвольной вложенности, что может привести к очень \"тяжелым\" запросам, сильно нагружающим сервер и БД.",
          "toolTitle": "Инструмент:",
          "toolContent": "`graphql-query-complexity`.",
          "whenTitle": "Когда использовать:",
          "whenContent": "Всегда включайте защиту от сложности в продакшене.",
          "principleTitle": "Принцип работы:",
          "principleContent": "Плагин анализирует запрос до его выполнения и вычисляет его \"сложность\" (например, как сумму \"стоимости\" каждого поля). Если сложность превышает заданный порог, запрос отклоняется.",
          "implementationTitle": "Реализация:",
          "implementationContent": "Настройте плагин в NestJS GraphQLModule (см. Руководство по разработке)."
        },
        "persistedQueries": {
          "title": "5.3. Persisted Queries: Кэширование Запросов на Уровне Сети",
          "intro": "Persisted Queries позволяют клиенту отправлять на сервер не полный текст GraphQL запроса, а только его хэш. Сервер по этому хэшу находит полный запрос (если он ему знаком) и выполняет его.",
          "whyTitle": "Почему:",
          "whyContent": "Уменьшает объем данных, передаваемых по сети, что ускоряет запросы, особенно на мобильных устройствах. Улучшает эффективность кэширования на CDN.",
          "whenTitle": "Когда использовать:",
          "whenContent": "Для часто повторяющихся запросов из клиента.",
          "implementationTitle": "Реализация:",
          "implementationContent": "Требует поддержки как на стороне клиента (Apollo Client поддерживает), так и на стороне сервера (Apollo Server поддерживает). На сервере нужно хранить соответствие хэшей и запросов (например, в Redis)."
        }
      },
      "backendLogicOptimization": {
        "title": "6. Оптимизация Backend Логики (NestJS): Эффективность Кода",
        "intro": "",
        "toolsTitle": "Инструменты:",
        "toolsContent": "Профилирование Node.js (V8 Profiler), обнаружение утечек памяти (`heapdump`).",
        "whenTitle": "Когда использовать:",
        "whenContent": "Для выявления \"горячих\" участков кода, потребляющих много CPU или памяти, и диагностики проблем с памятью.",
        "processTitle": "Процесс:",
        "processContent": "Используйте инструменты профилирования для <strong>измерения</strong> (Шаг 1 Кайдзен). Анализируйте результаты (Шаг 2). Вносите изменения в код (Шаг 3). Повторите (Шаг 4).",
        "recommendationsTitle": "Рекомендации:",
        "recommendationsContent": "Избегайте синхронных операций, блокирующих основной поток Node.js. Используйте асинхронные API. Оптимизируйте циклы, работу с большими массивами/объектами."
      },
      "caching": {
        "title": "7. Кэширование (Redis): Снижение Нагрузки на БД и Ускорение (Принцип 9)",
        "intro": "Кэширование позволяет хранить часто запрашиваемые данные в быстрой памяти (Redis), чтобы не обращаться к более медленной БД (Neon) при каждом запросе. Это ключевой <strong>рычаг</strong> для повышения <strong>эффективности системы</strong> (Принцип 9).",
        "libraryTitle": "Библиотека:",
        "libraryContent": "`ioredis`, `@nestjs/cache-manager`, `cache-manager-redis-store`.",
        "patternTitle": "Pаттерн:",
        "patternContent": "Cache-Aside (чтение из кэша, если нет — чтение из БД и запись в кэш).",
        "applicationAreasTitle": "Области применения:",
        "applicationAreasContent": "Часто запрашиваемые, относительно редко изменяющиеся данные (профили пользователей, настройки приложения, результаты сложных запросов/агрегаций, материализованных представлений).",
        "implementationTitle": "Реализация:",
        "implementationContent": "Настройте Redis в NestJS и используйте его в сервисах.",
        "invalidationTitle": "Ключевой аспект:",
        "invalidationContent": "<strong>Инвалидация кэша</strong>. При изменении данных в БД, удаляйте соответствующие ключи из Redis, чтобы клиенты не получали устаревшие данные."
      },
      "asyncProcessing": {
        "title": "8. Асинхронная Обработка (Kafka): Надежность и Отзывчивость (Принцип 9, 2)",
        "intro": "Используйте <strong>Kafka</strong> для выполнения задач, которые не требуют немедленного ответа пользователю (отправка email, обработка изображений, нотификации, аналитика).",
        "libraryTitle": "Библиотека:",
        "libraryContent": "`kafkajs`.",
        "whyTitle": "Почему:",
        "whyContent": "Kafka — <strong>надежная распределенная система очередей</strong>, гарантирующая доставку сообщений и позволяющая масштабировать обработку задач независимо от основного API (воркеры-консьюмеры).",
        "applicationAreasTitle": "Области применения:",
        "applicationAreasContent": [
          "Обработка изображений/видео после загрузки.",
          "Отправка больших объемов push-уведомлений.",
          "Генерация отчетов или статистики.",
          "Архивирование старых сообщений/файлов."
        ],
        "patternTitle": "Паттерн:",
        "patternContent": "<strong>Producer-Consumer</strong>. Backend-API ставит задачи в топик Kafka (Producer). Отдельные сервисы/воркеры (Consumer) читают задачи из топика и выполняют их в фоновом режиме.",
        "partitioningTitle": "Партиционирование в Kafka:",
        "partitioningContent": "Используйте ключи сообщений (например, `userId`, `chatId`), чтобы сообщения, относящиеся к одному пользователю/чату, попадали в одну партицию. Это гарантирует порядок обработки внутри партиции, что может быть важно для некоторых задач.",
        "monitoringTitle": "Мониторинг:",
        "monitoringContent": "Используйте <strong>Kafdrop</strong> для визуального мониторинга топиков, сообщений и состояния консьюмер-групп."
      },
      "pushNotificationsOptimization": {
        "title": "9. Оптимизация Push-уведомлений (Firebase FCM): Эффективная Доставка Информации (Принцип 2)",
        "intro": "Push-уведомления — важный канал связи с пользователем (Принцип 2: Ценность). Оптимизация их доставки важна для пользовательского опыта.",
        "platformTitle": "Платформа:",
        "platformContent": "Firebase Cloud Messaging (FCM).",
        "techniquesTitle": "Техники:",
        "techniquesContent": [
          "<strong>Батчинг:</strong> Отправляйте несколько уведомлений одним вызовом API FCM (`sendMulticast`) для снижения сетевых накладных расходов.",
          "<strong>Темы (Topics):</strong> Используйте темы для массовых рассылок (например, уведомление о новом сообщении в канале), чтобы FCM управлял списком подписчиков.",
          "<strong>Data Messages:</strong> Используйте Data Messages для полного контроля над отображением уведомления на клиенте и возможности прикреплять кастомные данные."
        ]
      },
      "clientApiDbInteraction": {
        "title": "10. Оптимизация Взаимодействия Клиент-API-БД: Сокращение Пути Данных (Принцип 9)",
        "intro": "",
        "clientLevelTitle": "На Уровне Клиента:",
        "clientLevelContent": "Используйте библиотеки для управления состоянием и кэширования данных, полученных по сети (`@apollo/client`, `react-query`/`@tanstack/react-query`). Это позволяет избежать повторных запросов за одними и теми же данными и быстро показывать кэшированные данные.",
        "networkLevelTitle": "На Уровне Сети:",
        "networkLevelContent": "Включите современные протоколы (HTTP/2, HTTP/3) и сжатие (Gzip/Brotli) на вашем API Gateway или Backend сервере для уменьшения объема передаваемых данных и снижения задержки.",
        "backendLevelTitle": "На Уровне Backend:",
        "backendLevelContent": "Оптимизируйте взаимодействие с БД (раздел 4) и внешними сервисами (раздел 7)."
      },
      "authenticationOptimization": {
        "title": "11. Оптимизация Аутентификации: Быстрота и Безопасность",
        "intro": "",
        "statelessJwtTitle": "Stateless (JWT):",
        "statelessJwtContent": "Использование JWT снижает нагрузку на сервер, так как ему не нужно хранить состояние сессий пользователей.",
        "rateLimitingTitle": "Rate Limiting (`@nestjs/throttler`):",
        "rateLimitingContent": "Защита эндпоинтов аутентификации от Brute Force атак, что также снижает нагрузку.",
        "secureHeadersTitle": "Безопасные Заголовки (`helmet`):",
        "secureHeadersContent": "Добавление HTTP-заголовков для защиты от XSS, CSRF и других атак."
      },
      "chatWebSocketOptimization": {
        "title": "12. Оптимизация Чатов (WebSocket): Низкая Задержка и Масштабирование",
        "intro": "WebSocket используется для обмена сообщениями в реальном времени. <strong>Оптимизация WebSocket-соединений критична для отзывчивости чатов</strong> (Принцип 2).",
        "libraryTitle": "Библиотека:",
        "libraryContent": "NestJS Gateways (`@nestjs/websockets`), Socket.IO (если нужна кросс-браузерная совместимость и fallback).",
        "techniquesTitle": "Техники:",
        "techniquesContent": [
          "<strong>Бинарные Форматы:</strong> Передача сообщений в бинарном формате (например, MessagePack) вместо текстового JSON может уменьшить объем данных.",
          "<strong>Батчинг Сообщений:</strong> Буферизируйте сообщения на клиенте и сервере и отправляйте их пачками (например, каждые 50 мс), а не по одному. Снижает количество пакетов.",
          "<strong>Управление Присутствием:</strong> Используйте Redis для быстрого отслеживания статуса онлайн/офлайн пользователей. Heartbeats (пинг-понг) для поддержания соединения и обнаружения отключений.",
          "<strong>Вертикальное/Горизонтальное Масштабирование:</strong> NestJS Gateways могут работать в кластерном режиме. Используйте Redis или другой Pub/Sub механизм (например, Kafka) для обмена сообщениями между инстансами Backend, чтобы сообщения доставлялись всем подписчикам, независимо от того, к какому инстансу Backend они подключены."
        ]
      },
      "animationsOptimization": {
        "title": "13. Оптимизация Анимаций: Плавность и Производительность (Принцип 3, 5)",
        "intro": "Производительные анимации делают интерфейс <strong>качественным</strong> (Принцип 3) и снижают нагрузку на устройство (Принцип 5: Здоровье).",
        "mobileDesktopTitle": "Mobile-Desktop (React Native):",
        "mobileDesktopContent": "Используйте `react-native-reanimated` для анимаций, которые выполняются на нативном потоке, не блокируя поток JavaScript.",
        "webTitle": "Web (Next.js):",
        "webContent": "Используйте `framer-motion` для декларативного создания плавных анимаций.",
        "docDesignTitle": "DocDesign:",
        "docDesignContent": "В DocDesign описаны принципы и параметры анимаций, включая возможность их отключения пользователем (Принцип 12: Прагматизм)."
      },
      "monitoring": {
        "title": "14. Мониторинг с Prometheus и Grafana: Измерение как Основа Кайдзен (Принцип 9)",
        "intro": "Система мониторинга — это ваши <strong>глаза</strong> и <strong>измерительные инструменты</strong> (Шаг 1 Кайдзен).",
        "toolsTitle": "Инструменты:",
        "toolsContent": "Prometheus (сбор метрик), Grafana (визуализация), Alertmanager (уведомления об аномалиях).",
        "whenTitle": "Когда использовать:",
        "whenContent": "Всегда. Настройте мониторинг на всех уровнях: Backend (задержки API, ошибки), БД (время запросов, нагрузка), Redis (попадания в кэш, использование памяти), Kafka (количество сообщений в топиках, лаг консьюмеров), Инфраструктура (CPU, RAM, сеть).",
        "implementationTitle": "Реализация:",
        "implementationContent": "См. подробные шаги по настройке в Руководстве по разработке (раздел 14).",
        "principleTitle": "Принцип:",
        "principleContent": "Используйте метрики для <strong>выявления узких мест</strong> (Шаг 2 Кайдзен) и оценки <strong>эффективности</strong> (Принцип 9) ваших оптимизаций. Настройте <strong>алерты</strong> для проактивного обнаружения проблем."
      },
      "ciCdOptimization": {
        "title": "15. Оптимизация CI/CD: Ускорение Цикла Разработки (Принцип 9)",
        "intro": "Эффективный CI/CD пайплайн ускоряет доставку кода, что является частью <strong>оптимизации всего процесса разработки</strong> (Принцип 9).",
        "toolsTitle": "Инструменты:",
        "toolsContent": "Turborepo (кэширование, параллелизация), GitHub Actions (автоматизация).",
        "techniquesTitle": "Техники:",
        "techniquesContent": [
          "<strong>Кэширование с Turborepo:</strong> Кэшируйте результаты сборки и тестов между запусками в CI и локально.",
          "<strong>Параллельное выполнение:</strong> Запускайте задачи (lint, build, test) для разных пакетов или частей тестов параллельно.",
          "<strong>Оптимизация Docker-образов:</strong> Используйте многоступенчатую сборку и `.dockerignore` для уменьшения размера образов и ускорения сборки/деплоя."
        ]
      },
      "frontendOptimization": {
        "title": "16. Оптимизация Фронтенда: Быстрота и Отзывчивость для Пользователя (Принцип 2, 3)",
        "intro": "Фронтенд должен быть <strong>быстрым и отзывчивым</strong>, чтобы пользователь ощутил <strong>ценность</strong> (Принцип 2) продукта.",
        "webTechniquesTitle": "Техники (Web - Next.js):",
        "webTechniquesContent": [
          "<strong>Code Splitting / Dynamic Imports:</strong> Загружайте код только тогда, когда он нужен (`next/dynamic`).",
          "<strong>SSR/SSG:</strong> Используйте серверный рендеринг или генерацию статики для ускорения первой отрисовки и SEO (`getStaticProps`, `getServerSideProps`).",
          "<strong>Оптимизация Изображений:</strong> Используйте `next/image` или `<picture>` и современные форматы (WebP).",
          "<strong>Анализ Бандла:</strong> Используйте `@next/bundle-analyzer` для выявления самых тяжелых модулей."
        ],
        "reactNativeTechniquesTitle": "Техники (React Native):",
        "reactNativeTechniquesContent": [
          "<strong>Ленивая Загрузка:</strong> Используйте `React.lazy` и `Suspense` для экранов и компонентов, которые не нужны при старте.",
          "<strong>Производительные Списки:</strong> Используйте `FlatList` или `SectionList` с правильной настройкой (`getItemLayout`, `windowSize`) для больших списков сообщений или чатов.",
          "<strong>Оптимизация Изображений:</strong> Используйте `react-native-fast-image`.",
          "<strong>Профилирование:</strong> Используйте Performance Monitor в Debugger Menu React Native для выявления узких мест UI."
        ],
        "generalTechniquesTitle": "Общие техники:",
        "generalTechniquesContent": [
          "Удаление неиспользуемого кода (Tree Shaking), замена тяжелых библиотек на легкие аналоги (например, `dayjs` вместо `moment`), сжатие бандлов (Gzip/Brotli)."
        ]
      },
      "dbScaling": {
        "title": "17. Масштабирование Базы Данных (Репликация и Шардинг): Подготовка к Росту (Принцип 8)",
        "intro": "Эти техники становятся актуальными при значительном росте объема данных и нагрузки. Они являются частью <strong>долгосрочной стратегии масштабирования</strong> (Принцип 8).",
        "replicationTitle": "Репликация (Master-Slave):",
        "replicationContent": "Создание копий БД только для чтения (read replicas). Позволяет распределить нагрузку на чтение.",
        "shardingTitle": "Шардинг:",
        "shardingContent": "Разделение данных большой таблицы на части (шарды) по определенному ключу (`chatId`, `userId`), распределяя их по разным серверам. Позволяет масштабировать как чтение, так и запись. Реализуется логически (в приложении) или с помощью расширений (Citus для PostgreSQL).",
        "whenToApplyTitle": "Когда применять:",
        "whenToApplyContent": "Основываясь на <strong>измерениях</strong> нагрузки и производительности БД (Принцип 9), а не заранее."
      },
      "notes": {
        "title": "18. Примечания: Непрерывный Кайдзен в Оптимизации",
        "prioritizationTitle": "Приоритезация:",
        "prioritizationContent": "Начинайте оптимизацию с тех мест, которые приносят наибольший эффект на текущем этапе проекта (Принцип 12). Для MVP это может быть скорость загрузки Frontend, производительность основных API-запросов.",
        "automationTitle": "Автоматизация:",
        "automationContent": "Максимально автоматизируйте процессы измерения и проверки оптимизаций (CI/CD, алерты в мониторинге) — это часть <strong>Системы</strong> (Принцип 9).",
        "documentationNotesTitle": "Документирование:",
        "documentationNotesContent": "Фиксируйте проведенные оптимизации, их эффект и уроки в этой документации или в задачах/коммитах (Принцип 1: Обучение, Принцип 9: Кайдзен).",
        "cultureTitle": "Культура:",
        "cultureContent": "Создайте культуру, где каждый разработчик несет ответственность за производительность своего кода и активно участвует в поиске и устранении узких мест (Принцип 6)."
      }
    },
    "apiSpec": {
      "title": "Спецификация API BrainMessenger (Интерфейс Системы)",
      "subtitle": "Интерфейс Системы",
      "generalInfo": {
        "title": "1. Общая Информация: API как Точка Взаимодействия с Системой",
        "description": "Этот документ описывает GraphQL API BrainMessenger — <strong>основной интерфейс</strong> (Принцип 9), через который клиентские приложения (Web, Mobile, Desktop) взаимодействуют с серверной частью системы и получают доступ к данным и функциональности. GraphQL выбран за его <strong>эффективность и гибкость</strong> (Принцип 9, 2), позволяя клиентам запрашивать только те данные, которые им необходимы.",
        "projectNameTitle": "Название проекта:",
        "projectNameContent": "BrainMessenger",
        "apiPurposeTitle": "Цель:",
        "apiPurposeContent": "Предоставить четкое и полное описание доступных запросов (Queries) и мутаций (Mutations), их входных и выходных данных, а также правил аутентификации и форматов ошибок. Это обеспечивает <strong>системность</strong> (Принцип 9) взаимодействия между Frontend и Backend и повышает <strong>качество</strong> (Принцип 3) разработки.",
        "baseUrlTitle": "Базовый URL:",
        "baseUrlContent": "`https://api.brainmessenger.com/graphql` (адрес API Gateway, который перенаправляет запросы на Backend Service).",
        "requestFormatTitle": "Формат запросов:",
        "requestFormatContent": "GraphQL-запросы (POST-запросы с `Content-Type: application/json` и телом в формате GraphQL).",
        "authenticationTitle": "Аутентификация:",
        "authenticationContent": "Для большинства методов требуется передать JWT-токен в заголовке `Authorization: Bearer <token>`. Токен получается после успешного логина. Это часть нашей <strong>системы безопасности</strong> (Принцип 3, 5).",
        "relatedDocsTitle": "Связь с другими документами:",
        "relatedDocsContent": [
          "DocTech.md: Общая архитектура системы, включая Backend и API Gateway.",
          "DocDevIn.md: Детали реализации Backend на NestJS и GraphQL.",
          "DocInt.md: Описание интеграций, которые Backend использует (Neon, R2, Firebase и др.).",
          "DocOptimizationIn.md: Подходы к оптимизации производительности API."
        ]
      },
      "graphqlSchema": {
        "title": "2. Схема GraphQL: Структура Доступных Данных и Операций",
        "description": "Полная схема GraphQL доступна по адресу API через инструменты интроспекции (например, GraphQL Playground, Apollo Studio). Ниже приведены основные типы и операции.",
        "dataTypes": {
          "title": "2.1. Типы Данных (Schemas): Описание Структуры Информации",
          "user": {
            "title": "User:",
            "code": "type User {\n  id: ID!\n  email: String!\n  name: String!\n  avatarUrl: String # URL аватара пользователя (хранится в R2)\n  createdAt: DateTime!\n  updatedAt: DateTime!\n  # ... другие поля (например, статус онлайн/оффлайн)\n}"
          },
          "chat": {
            "title": "Chat:",
            "code": "type Chat {\n  id: ID!\n  name: String! # Название чата (для групп/каналов)\n  type: String! # Тип чата (\"personal\", \"group\", \"channel\")\n  users: [User!] # Список участников чата\n  messages(pagination: PaginationInput): [Message!] # Сообщения в чате (с пагинацией)\n  lastMessageAt: DateTime # Время последнего сообщения (для сортировки списка чатов)\n  createdAt: DateTime!\n  updatedAt: DateTime!\n  # ... другие поля (например, фото группы/канала, описание)\n}"
          },
          "message": {
            "title": "Message:",
            "code": "type Message {\n  id: ID!\n  content: String! # Текст сообщения (для текстовых сообщений)\n  fileUrl: String # URL файла, если сообщение является файлом (хранится в R2)\n  fileMetadata: JSON # Метаданные файла (тип, размер, имя) (хранится в Neon/R2)\n  sender: User! # Отправитель сообщения\n  chat: Chat! # Чат, которому принадлежит сообщение\n  createdAt: DateTime! # Время отправки сообщения\n  updatedAt: DateTime!\n  # ... другие поля (например, статус прочтения, реакции)\n}"
          },
          "paginationInput": {
            "title": "PaginationInput:",
            "code": "input PaginationInput {\n  take: Int # Максимальное количество элементов\n  skip: Int # Пропустить элементов (для offset-based пагинации)\n  cursor: String # Курсор (ID) для cursor-based пагинации\n}"
          },
          "authPayload": {
            "title": "AuthPayload:",
            "code": "type AuthPayload {\n  token: String! # JWT токен доступа\n  user: User! # Данные аутентифицированного пользователя\n}"
          },
          "dateTimeJson": {
            "title": "DateTime, JSON:",
            "content": "Стандартные скалярные типы или кастомные скаляры, определенные на Backend."
          }
        },
        "operations": {
          "title": "2.2. Операции (Queries и Mutations): Доступ к Функционалу Системы",
          "authentication": {
            "title": "2.2.1. Аутентификация (Authentication)",
            "registerUser": {
              "title": "`mutation registerUser(input: RegisterInput!): AuthPayload!`",
              "description": "Регистрирует нового пользователя в системе.",
              "input": "`RegisterInput`: `{ email: String!, password: String!, name: String! }` (password min 8 chars, digit, special char - см. валидацию).",
              "authRequired": "Требуется аутентификация: Нет.",
              "scenario": "Сценарий: Пользователь заполняет форму регистрации.",
              "errors": "Ошибки: `400 Bad Request` (неверный формат данных/валидация), `409 Conflict` (email уже используется)."
            },
            "loginUser": {
              "title": "`mutation loginUser(input: LoginInput!): AuthPayload!`",
              "description": "Аутентифицирует пользователя по email и паролю.",
              "input": "`LoginInput`: `{ email: String!, password: String! }`.",
              "authRequired": "Требуется аутентификация: Нет.",
              "scenario": "Сценарий: Пользователь вводит учетные данные для входа.",
              "errors": "Ошибки: `401 Unauthorized` (неверный email или пароль)."
            },
            "logoutUser": {
              "title": "`mutation logoutUser: Boolean!`",
              "description": "Инвалидирует текущий JWT токен на сервере (если реализовано хранение токенов или их черных списков).",
              "authRequired": "Требуется аутентификация: Да (используется текущий токен).",
              "scenario": "Сценарий: Пользователь нажимает \"Выйти\".",
              "returns": "Возвращает: `true` при успешном выходе.",
              "errors": "Ошибки: `401 Unauthorized` (токен недействителен)."
            }
          },
          "user": {
            "title": "2.2.2. Пользователь (User)",
            "getUser": {
              "title": "`query getUser(id: ID!): User`",
              "description": "Получает данные пользователя по его уникальному ID.",
              "authRequired": "Требуется аутентификация: Да (для доступа к любым данным пользователя, кроме, возможно, публичного профиля).",
              "scenario": "Сценарий: Просмотр профиля пользователя.",
              "errors": "Ошибки: `404 Not Found` (пользователь с таким ID не найден)."
            },
            "getCurrentUser": {
              "title": "`query getCurrentUser: User!`",
              "description": "Получает данные текущего аутентифицированного пользователя.",
              "authRequired": "Требуется аутентификация: Да.",
              "scenario": "Сценарий: Загрузка профиля текущего пользователя при старте приложения.",
              "errors": "Ошибки: `401 Unauthorized`."
            },
            "updateUser": {
              "title": "`mutation updateUser(id: ID!, input: UserInput!): User!`",
              "description": "Обновляет данные профиля пользователя.",
              "input": "`UserInput`: `{ name: String, email: String, password: String, avatarUrl: String }`. Поля опциональны.",
              "authRequired": "Требуется аутентификация: Да (и пользователь должен быть владельцем профиля или иметь права администратора).",
              "scenario": "Сценарий: Пользователь редактирует свой профиль.",
              "errors": "Ошибки: `400 Bad Request` (неверный формат данных), `401 Unauthorized`, `403 Forbidden` (нет прав на редактирование этого пользователя), `404 Not Found`."
            },
            "deleteUser": {
              "title": "`mutation deleteUser(id: ID!): Boolean!`",
              "description": "Удаляет аккаунт пользователя.",
              "authRequired": "Требуется аутентификация: Да (и пользователь должен быть владельцем аккаунта).",
              "scenario": "Сценарий: Пользователь решает удалить свою учетную запись.",
              "returns": "Возвращает: `true` при успешном удалении.",
              "errors": "Ошибки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            }
          },
          "chats": {
            "title": "2.2.3. Чаты (Chats)",
            "getChats": {
              "title": "`query getChats: [Chat!]!`",
              "description": "Получает список всех чатов, в которых участвует текущий пользователь.",
              "authRequired": "Требуется аутентификация: Да.",
              "scenario": "Сценарий: Загрузка списка чатов на главном экране.",
              "errors": "Ошибки: `401 Unauthorized`."
            },
            "getChat": {
              "title": "`query getChat(id: ID!): Chat`",
              "description": "Получает данные конкретного чата по ID.",
              "authRequired": "Требуется аутентификация: Да (и пользователь должен быть участником этого чата).",
              "scenario": "Сценарий: Открытие конкретного чата.",
              "errors": "Ошибки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            },
            "createChat": {
              "title": "`mutation createChat(input: CreateChatInput!): Chat!`",
              "description": "Создает новый чат.",
              "input": "`CreateChatInput`: `{ type: String!, name: String, userIds: [ID!]! }`. `type` может быть \"personal\", \"group\", \"channel\". `name` обязателен для \"group\" и \"channel\". `userIds` включает ID создателя и других участников (для \"personal\" и \"group\").",
              "authRequired": "Требуется аутентификация: Да.",
              "scenario": "Сценарий: Пользователь создает новый чат или группу.",
              "errors": "Ошибки: `400 Bad Request` (неверный тип, отсутствуют userIds и т.п.), `401 Unauthorized`, `403 Forbidden` (нет прав на создание такого типа чата)."
            },
            "getMessages": {
              "title": "`query getMessages(chatId: ID!, pagination: PaginationInput): [Message!]!`",
              "description": "Получает список сообщений для заданного чата. Поддерживает пагинацию.",
              "authRequired": "Требуется аутентификация: Да (и пользователь должен быть участником чата).",
              "scenario": "Сценарий: Открытие чата, подгрузка старых сообщений при прокрутке.",
              "errors": "Ошибки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            },
            "sendMessage": {
              "title": "`mutation sendMessage(chatId: ID!, content: String!, fileUrl: String, fileMetadata: JSON): Message!`",
              "description": "Отправляет новое сообщение в чат. Может содержать текст или ссылку на файл.",
              "input": "`chatId`: ID чата. `content`: Текст сообщения. `fileUrl`: URL файла в R2 (опционально). `fileMetadata`: Метаданные файла (опционально).",
              "authRequired": "Требуется аутентификация: Да (и пользователь должен быть участником чата).",
              "scenario": "Сценарий: Пользователь отправляет текстовое сообщение или файл.",
              "errors": "Ошибки: `400 Bad Request`, `401 Unauthorized`, `403 Forbidden` (нет прав писать в этот чат), `404 Not Found` (чат не найден)."
            },
            "deleteMessage": {
              "title": "`mutation deleteMessage(messageId: ID!): Boolean!`",
              "description": "Удаляет сообщение.",
              "authRequired": "Требуется аутентификация: Да (и пользователь должен быть отправителем сообщения или иметь права администратора чата).",
              "scenario": "Сценарий: Пользователь удаляет свое сообщение.",
              "returns": "Возвращает: `true` при успешном удалении.",
              "errors": "Ошибки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            }
          },
          "externalIntegrations": {
            "title": "2.2.4. Внешние Интеграции (через API Backend)",
            "sendVerificationCode": {
              "title": "`mutation sendVerificationCode(email: String!): Boolean!`",
              "description": "Запускает процесс отправки кода подтверждения на указанный email (используя Gmail API). Используется при регистрации или сбросе пароля.",
              "authRequired": "Требуется аутентификация: Нет.",
              "scenario": "Сценарий: Пользователь вводит email на экране регистрации/восстановления пароля.",
              "returns": "Возвращает: `true` при успешной постановке задачи на отправку.",
              "errors": "Ошибки: `400 Bad Request` (неверный формат email), `429 Too Many Requests` (защита от спама)."
            },
            "verifyEmailCode": {
              "title": "`mutation verifyEmailCode(email: String!, code: String!): Boolean!`",
              "description": "Проверяет код подтверждения, полученный по email.",
              "authRequired": "Требуется аутентификация: Нет.",
              "scenario": "Сценарий: Пользователь вводит код из email.",
              "returns": "Возвращает: `true` при успешной проверке.",
              "errors": "Ошибки: `400 Bad Request` (неверный код или email), `404 Not Found` (для данного email нет активного кода)."
            },
            "enableTwoFactorAuth": {
              "title": "`mutation enableTwoFactorAuth(userId: ID!): Boolean!`",
              "description": "Включает/отключает двухфакторную аутентификацию для пользователя. Требует предварительной верификации email. Код для 2FA отправляется на email (Gmail API) при каждом логине после включения.",
              "authRequired": "Требуется аутентификация: Да (пользователь должен управлять своим аккаунтом).",
              "scenario": "Сценарий: Пользователь настраивает безопасность аккаунта.",
              "errors": "Ошибки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`, `400 Bad Request` (email не верифицирован)."
            },
            "disableTwoFactorAuth": {
              "title": "`mutation disableTwoFactorAuth(userId: ID!): Boolean!`",
              "description": "Включает/отключает двухфакторную аутентификацию для пользователя. Требует предварительной верификации email. Код для 2FA отправляется на email (Gmail API) при каждом логине после включения.",
              "authRequired": "Требуется аутентификация: Да (пользователь должен управлять своим аккаунтом).",
              "scenario": "Сценарий: Пользователь настраивает безопасность аккаунта.",
              "errors": "Ошибки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`, `400 Bad Request` (email не верифицирован)."
            },
            "sendTwoFactorCode": {
              "title": "`mutation sendTwoFactorCode(userId: ID!): Boolean!`",
              "description": "Отправляет код двухфакторной аутентификации на email пользователя.",
              "authRequired": "Требуется аутентификация: Частичная (например, после ввода пароля, но до ввода 2FA кода). Логика зависит от флоу аутентификации.",
              "scenario": "Сценарий: Пользователь входит в аккаунт с включенной 2FA.",
              "errors": "Ошибки: `404 Not Found` (пользователь не найден или 2FA не включена), `429 Too Many Requests`."
            },
            "createPaymentSession": {
              "title": "`mutation createPaymentSession(input: PaymentInput!): PaymentSessionPayload!`",
              "description": "Создает сессию оплаты через Stripe для оформления Premium подписки.",
              "input": "`PaymentInput`: `{ planId: ID!, returnUrl: String! }` (ID выбранного тарифного плана, URL для редиректа после оплаты).",
              "authRequired": "Требуется аутентификация: Да.",
              "scenario": "Сценарий: Пользователь нажимает \"Подписаться\" на Premium экране.",
              "errors": "Ошибки: `400 Bad Request` (неверный planId), `401 Unauthorized`."
            }
          }
        }
      },
      "errorHandling": {
        "title": "3. Обработка Ошибок API: Ясная Обратная Связь (Принцип 3, 14)",
        "description": "API возвращает стандартизированные ошибки для <strong>ясной обратной связи</strong> (Принцип 14) с клиентом и поддержания <strong>качества</strong> (Принцип 3).",
        "errorFormatTitle": "Формат ошибок (в соответствии со спецификацией GraphQL):",
        "errorFormatCode": "{\n  \"data\": null, // Обычно null при ошибках верхнего уровня\n  \"errors\": [\n    {\n      \"message\": \"Описание ошибки (может быть локализовано - см. DocLocIn)\",\n      \"locations\": [...], // Расположение ошибки в запросе\n      \"path\": [...],      // Путь к полю, вызвавшему ошибку\n      \"extensions\": {\n        \"code\": \"КОД_ОШИБКИ\", // Стандартизированный код ошибки (например, \"UNAUTHENTICATED\", \"FORBIDDEN\", \"BAD_USER_INPUT\", \"NOT_FOUND\")\n        \"http\": { // Если применимо, HTTP статус код\n          \"status\": 401,\n          \"headers\": {}\n        },\n         \"details\": {} // Дополнительные детали об ошибке (опционально)\n      }\n    }\n    // ... могут быть другие ошибки\n  ]\n}",
        "keyErrorCodesTitle": "Ключевые коды ошибок (extensions.code):",
        "keyErrorCodesList": [
          "`UNAUTHENTICATED`: Требуется аутентификация, но токен отсутствует или недействителен (`HTTP 401`).",
          "`FORBIDDEN`: Аутентификация пройдена, но у пользователя нет прав на выполнение операции (`HTTP 403`).",
          "`BAD_USER_INPUT`: Ошибка валидации входных данных (`HTTP 400`). Детали могут быть в `extensions.details`.",
          "`NOT_FOUND`: Запрошенный ресурс не найден (`HTTP 404`).",
          "`CONFLICT`: Конфликт данных (например, попытка зарегистрировать email, который уже существует) (`HTTP 409`).",
          "`INTERNAL_SERVER_ERROR`: Неожиданная ошибка на сервере (`HTTP 500`).",
          "`RATE_LIMITED`: Превышен лимит запросов (`HTTP 429`)."
        ],
        "localizationErrorsTitle": "Локализация ошибок:",
        "localizationErrorsContent": "Сообщения об ошибках (`message`) могут быть локализованы на стороне Backend на основе заголовка `Accept-Language` или предпочтений пользователя (см. DocLocIn)."
      },
      "notes": {
        "title": "4. Примечания",
        "dataTypes": {
          "title": "Типы данных:",
          "list": [
            "`ID`: Уникальный идентификатор ресурса (обычно строка).",
            "`String`: Текстовая строка.",
            "`Int`, `Float`: Числа.",
            "`Boolean`: Логическое значение (`true`/`false`).",
            "`DateTime`: Дата и время в формате ISO 8601 (например, \"2025-03-14T10:30:00Z\").",
            "`JSON`: Кастомный скаляр для передачи произвольных JSON-объектов (например, для `fileMetadata`).",
            "`!` в конце типа означает, что поле <strong>не может быть null</strong>."
          ]
        },
        "pagination": {
          "title": "Пагинация:",
          "content": "Для списков, которые могут быть длинными (`messages`), используйте пагинацию для эффективной загрузки данных (Принцип 9)."
        },
        "validation": {
          "title": "Валидация:",
          "content": "Backend выполняет строгую валидацию всех входных данных (через DTO и `class-validator`), возвращая ошибки `BAD_USER_INPUT` при их некорректности. Это часть <strong>системы обеспечения качества</strong> (Принцип 3)."
        },
        "security": {
          "title": "Безопасность:",
          "content": "Все запросы, работающие с чувствительными данными или изменяющие состояние системы (кроме регистрации/логина), требуют аутентификации."
        },
        "testingTools": {
          "title": "Инструменты тестирования API:",
          "content": "Используйте GraphQL Playground (часто доступен по адресу `/graphql` в dev-режиме Backend), Postman или Apollo Studio для отправки запросов и тестирования API."
        }
      }
    },
    "technicalDocs": {
      "title": "BrainMessenger Technical Documentation (System and Foundation)",
      "subtitle": "General Information: Architecture of a Digital Asset",
      "generalInfo": {
        "title": "1. General Information: Architecture of a Digital Asset",
        "description": "BrainMessenger is a modern messenger built as a <strong>reliable, scalable, and secure system</strong> (Principle 9), which serves as a <strong>key digital ASSET</strong> (Principle 10). This document provides a high-level overview of the project's <strong>technical foundation</strong> (Principle 8), describing the main components, technologies, and their interaction.",
        "projectNameTitle": "Project Name:",
        "projectNameContent": "BrainMessenger",
        "purposeTitle": "Purpose:",
        "purposeContent": "To provide a general understanding of BrainMessenger's structure, the technology stack used, and the principles underlying its construction, for all team members and stakeholders.",
        "principlesTitle": "Principles reflected in the technical structure:",
        "principlesList": [
          "<strong>System and Optimization (Principle 9):</strong> The project is designed as a set of interconnected, optimized components.",
          "<strong>Long-Term Thinking (Principle 8):</strong> Selection of technologies and architecture considering future scaling and development needs.",
          "<strong>Quality > Quantity (Principle 3):</strong> Use of proven, reliable solutions and focus on code and infrastructure quality.",
          "<strong>Pragmatism and Realism (Principle 12):</strong> Use of ready-made services (Neon, R2, Firebase) where justified, instead of building everything from scratch.",
          "<strong>Value Creation (Principle 2):</strong> The technical structure aims to provide key messenger functions (communication, files, calls) at a high level."
        ]
      },
      "techStack": {
        "title": "2. Technology Stack: Tools for Building the System",
        "description": "We use a modern and flexible set of technologies, allowing us to effectively build and scale BrainMessenger.",
        "frontend": {
          "title": "Frontend (Client Applications):",
          "list": [
            "<strong>React Native (Android, Windows Desktop):</strong> A single codebase for mobile and desktop applications. Chosen for cross-platform compatibility and a large set of ready-made libraries.",
            "<strong>Next.js (Web):</strong> React-framework for web application with SSR/SSG support for performance and SEO.",
            "<strong>TypeScript:</strong> Strict typing for all Frontend code. Increases reliability and simplifies refactoring."
          ]
        },
        "backend": {
          "title": "Backend (Server Logic):",
          "list": [
            "<strong>Node.js:</strong> High-performance JavaScript/TypeScript runtime environment.",
            "<strong>NestJS:</strong> Modular framework for Node.js. Provides a structured architecture (modules, services, controllers/resolvers) and TypeScript support.",
            "<strong>GraphQL:</strong> API protocol. Allows clients to request exactly the data they need, reducing redundancy."
          ]
        },
        "databaseCaching": {
          "title": "Database and Caching:",
          "list": [
            "<strong>PostgreSQL (via Neon):</strong> Reliable relational DBMS. Used as the main storage for structured data (users, chats, messages, metadata). Neon provides a managed service with scaling and replication features.",
            "<strong>Prisma ORM:</strong> Tool for interacting with PostgreSQL from NestJS. Provides typing and query security.",
            "<strong>Redis:</strong> In-memory data store. Used for caching, Rate Limiting, managing WebSocket connection state (user presence)."
          ]
        },
        "fileStorage": {
          "title": "File Storage:",
          "list": [
            "<strong>Cloudflare R2:</strong> Object storage, compatible with S3 API. Used for storing user files (photos, videos, documents, avatars, call recordings), encrypted data. Chosen for low cost and no egress fees."
          ]
        },
        "asyncProcessing": {
          "title": "Asynchronous Processing:",
          "list": [
            "<strong>Kafka:</strong> Distributed message queue system. Used for reliable asynchronous task processing (e.g., image processing, sending notifications) outside the main API thread."
          ]
        },
        "infrastructureDeployment": {
          "title": "Infrastructure and Deployment:",
          "list": [
            "<strong>Docker:</strong> Application containerization. Provides isolation and portability.",
            "<strong>Kubernetes:</strong> Container orchestration. Manages deployment, scaling, and self-healing of services in a cluster.",
            "<strong>Terraform:</strong> Infrastructure as Code (IaC). Automates the creation and management of cloud resources."
          ]
        },
        "testingMonitoringLogging": {
          "title": "Testing, Monitoring, Logging:",
          "list": [
            "<strong>Jest, Cypress, Detox:</strong> Tools for unit, integration, and E2E testing.",
            "<strong>Prometheus, Grafana:</strong> Monitoring system. Collection and visualization of performance metrics and system status.",
            "<strong>Winston, Sentry:</strong> Logging and error tracking system."
          ]
        }
      },
      "architecture": {
        "title": "3. Project Architecture: Interconnection of System Components",
        "description": "BrainMessenger's architecture follows the principles of <strong>modularity and separation of concerns</strong> (Principle 9).",
        "clientApplications": {
          "title": "Client Applications (Frontend):",
          "list": [
            "Web (Next.js), Mobile & Desktop (React Native).",
            "Contain the user interface and user interaction logic.",
            "Interact with the Backend exclusively via <strong>GraphQL API</strong>.",
            "Can directly download files from Cloudflare R2 (if public access) or via Backend (if authentication or URL signing is required)."
          ]
        },
        "apiGateway": {
          "title": "API Gateway (In the future):",
          "content": "Single entry point for all client requests. Can perform authentication, Rate Limiting, routing to the necessary Backend services. At startup, the Backend itself acts as the Gateway."
        },
        "backendService": {
          "title": "Backend Service (NestJS):",
          "list": [
            "Main server component.",
            "Contains <strong>BrainMessenger's business logic</strong> (user management, chats, messages, calls, payments).",
            "Provides <strong>GraphQL API</strong> for client applications.",
            "Interacts with the <strong>Database (Neon/PostgreSQL via Prisma)</strong> for reading/writing structured data.",
            "Interacts with <strong>File Storage (Cloudflare R2)</strong> for uploading/retrieving files (via AWS SDK).",
            "Interacts with <strong>Cache (Redis)</strong> for fast operations.",
            "Queues tasks in <strong>Queue (Kafka)</strong> for asynchronous processing.",
            "Uses external services (Firebase, Stripe, Gmail API)."
          ]
        },
        "database": {
          "title": "Database (Neon/PostgreSQL):",
          "content": "Stores structured data. Scales independently."
        },
        "fileStorage": {
          "title": "File Storage (Cloudflare R2):",
          "content": "Stores unstructured binary data. Scales by volume."
        },
        "caching": {
          "title": "Caching (Redis):",
          "content": "Fast access to temporary data."
        },
        "messageQueue": {
          "title": "Message Queue (Kafka):",
          "content": "Buffering and reliable message delivery between services for asynchronous processing."
        },
        "workers": {
          "title": "Workers (Kafka Consumers):",
          "list": [
            "Separate services that read tasks from Kafka and perform heavy or long operations (image processing, sending large mailings).",
            "Scale independently."
          ]
        },
        "externalServices": {
          "title": "External Services (Firebase, Stripe, Gmail API):",
          "list": [
            "Provide specialized functionality (notifications, payments, email).",
            "Used by the Backend service."
          ]
        },
        "mermaidDiagram": {
          "title": "Architecture Diagram:",
          "code": "graph TD\n    A[Frontend Web (Next.js)] -->|GraphQL API| B(API Gateway / Backend);\n    A -->|Direct File Access (Opt.)| E(Cloudflare R2);\n    F[Frontend Mobile/Desktop (React Native)] -->|GraphQL API| B;\n    F -->|Direct File Access (Opt.)| E;\n    B -->|Prisma Queries/Mutations| C(Neon/PostgreSQL);\n    B -->|AWS SDK (S3 API)| E;\n    B -->|ioredis| D(Redis Cache);\n    B -->|kafkajs Producer| G(Kafka Queue);\n    B -->|Firebase Admin SDK| H(Firebase FCM);\n    B -->|Stripe SDK| I(Stripe);\n    B -->|Google APIs Client| J(Gmail API);\n    G -->|kafkajs Consumer| K(Kafka Workers);\n    K -->|sharp| K; % Image processing\n    K -->|AWS SDK (S3 API)| E;\n    K -->|GraphQL API / Other Service Calls| B; % Report completion, send chat message\n    C -->|Replication (for scaling)| C;\n    C -->|Partitioning/Sharding (for scaling)| C;\n    E -->|CDN| A; % File delivery to Frontend\n    Prometheus(Prometheus) -->|Scrape Metrics| B;\n    Prometheus -->|Scrape Metrics| C;\n    Prometheus -->|Scrape Metrics| D;\n    Prometheus -->|Scrape Metrics| G;\n    Grafana(Grafana) -->|Visualize Metrics| Prometheus;\n    Sentry(Sentry) -->|Error Reports| B;\n    Sentry -->|Error Reports| A;"
        }
      },
      "api": {
        "title": "4. API: Interaction Interface",
        "description": "BrainMessenger's API is implemented using GraphQL with NestJS.",
        "endpointTitle": "Endpoint:",
        "endpointContent": "`/graphql`",
        "structureTitle": "Structure:",
        "structureContent": "Defined by the GraphQL Schema (User, Chat, Message types, etc.) and a set of Queries (for data retrieval) and Mutations (for data modification).",
        "authenticationTitle": "Authentication:",
        "authenticationContent": "JWT tokens in the `Authorization: Bearer <token>` header.",
        "externalApiIntegrationsTitle": "External API Integrations:",
        "externalApiIntegrationsContent": "Interaction with external services (Gmail, Stripe) is done via the Backend, which provides corresponding Mutations in the GraphQL API (see API Specification).",
        "keyFunctionalAreas": {
          "title": "Key functional areas of the API:",
          "list": [
            "Authentication (registration, login, logout, 2FA).",
            "User management (get/update/delete profile).",
            "Chat management (create, get list, get chat data).",
            "Message handling (send text messages, send files, get history).",
            "Contact management.",
            "Application settings (theme, notifications, language).",
            "Premium subscription management.",
            "File management (upload to R2 via Backend).",
            "(In the future) Calls and video calls (call session management)."
          ]
        },
        "detailedSpecTitle": "Detailed API specification is described in:",
        "detailedSpecContent": "DocSpec.md"
      },
      "database": {
        "title": "5. Database (Neon/PostgreSQL): Main Data Storage",
        "description": "",
        "technologyTitle": "Technology:",
        "technologyContent": "PostgreSQL 15.x.",
        "hostingTitle": "Hosting:",
        "hostingContent": "Neon.",
        "roleTitle": "Role:",
        "roleContent": "Relational database for all structured data.",
        "keyTables": {
          "title": "Key tables (defined in backend/prisma/schema.prisma):",
          "list": [
            "User: User information (id, email, password_hash, name, avatarUrl, createdAt, updatedAt, is2FaEnabled).",
            "Chat: Chat information (id, type, name, createdAt, updatedAt, lastMessageAt).",
            "UserChat: Linking table for Many-to-Many relationship between User and Chat (userId, chatId, joinedAt, lastReadMessageId).",
            "Message: Messages in chats (id, chatId, senderId, content, fileUrl, fileMetadata (JSON), createdAt, updatedAt).",
            "Contact: User's contact list (id, userId, contactId).",
            "Transaction: Payment history (for Premium) (id, userId, amount, currency, status, provider, createdAt).",
            "Code: Temporary codes (for email verification, 2FA) (id, userId/email, code, type, expiresAt)."
          ]
        },
        "interactionTitle": "Interaction:",
        "interactionContent": "Backend only via Prisma ORM.",
        "optimizationScalingTitle": "Optimization and Scaling:",
        "optimizationScalingContent": "Indexes, Prisma query optimization, materialized views, partitioning, replication are used (see DocOptimizationIn)."
      },
      "fileStorage": {
        "title": "6. File Storage (Cloudflare R2): Storage for Media and Binary Assets",
        "description": "",
        "technologyTitle": "Technology:",
        "technologyContent": "Object storage, S3-compatible API.",
        "hostingTitle": "Hosting:",
        "hostingContent": "Cloudflare R2.",
        "roleTitle": "Role:",
        "roleContent": "Storage for all unstructured data (user files, avatars, call recordings).",
        "interactionTitle": "Interaction:",
        "interactionContent": "Backend uploads files, Backend or Frontend retrieves files (directly or via signed URLs).",
        "structureTitle": "Structure:",
        "structureContent": "Files are organized by folders/keys (e.g., `avatars/`, `chat-images/`, `sensitive-data/`).",
        "securityTitle": "Security:",
        "securityContent": "Encryption at rest, restricted access, encryption of sensitive data at the application level before upload (see DocInt, DocSecurity)."
      },
      "projectStructure": {
        "title": "7. Project Structure (Monorepository): Code Organization",
        "description": "The project is organized as a monorepository using Turborepo.",
        "purposeTitle": "Purpose:",
        "purposeContent": "To simplify managing multiple applications/packages (backend, web, mobile-desktop, core) and code reuse.",
        "packages": {
          "title": "Packages:",
          "list": [
            "core: Common code.",
            "backend: Server logic.",
            "web: Web application.",
            "mobile-desktop: Mobile/desktop application (React Native).",
            "Infrastructure: Configuration files for deployment (infrastructure/).",
            "Documentation: Project documentation (docs/)."
          ]
        },
        "detailedDescriptionTitle": "Detailed description of the monorepository structure can be found in:",
        "detailedDescriptionContent": "DocDevIn.md (section 2)."
      },
      "security": {
        "title": "8. Security: Fundamental Aspect of the System",
        "description": "Security is built in at all levels (see more in BrainMessenger Security Guide).",
        "authenticationTitle": "Authentication:",
        "authenticationContent": "JWT, 2FA via email.",
        "authorizationTitle": "Authorization:",
        "authorizationContent": "Access rights verification for resources on the Backend.",
        "encryptionTitle": "Encryption:",
        "encryptionContent": "TLS/SSL for data transfer, password hashing (bcrypt/argon2), encryption of sensitive data at the application level before storing in R2.",
        "validationTitle": "Validation:",
        "validationContent": "Strict input data validation on the Backend.",
        "attackProtectionTitle": "Protection against Attacks:",
        "attackProtectionContent": "Rate Limiting, secure HTTP headers.",
        "principleTitle": "Principle:",
        "principleContent": "Security is a continuous process of learning (Principle 1) and improvement (Principle 9), based on responsibility (Principle 6)."
      },
      "deployment": {
        "title": "9. Deployment: Delivering the System to Users",
        "description": "The deployment process is automated.",
        "containerizationTitle": "Containerization:",
        "containerizationContent": "Docker images for Backend, Kafka Consumers.",
        "orchestrationTitle": "Orchestration:",
        "orchestrationContent": "Kubernetes manages containers in the cloud.",
        "iacTitle": "Infrastructure as Code:",
        "iacContent": "Terraform (IaC). Automates the creation and management of cloud resources.",
        "ciCdTitle": "CI/CD:",
        "ciCdContent": "GitHub Actions automates build, testing, and deployment.",
        "webAppDeploymentTitle": "Web application can be deployed separately (e.g., on Vercel or Cloudflare Pages).",
        "webAppDeploymentContent": "",
        "detailedDescriptionTitle": "Detailed description of the deployment process can be found in:",
        "detailedDescriptionList": [
          "DocDevIn.md (section 9)",
          "Deployment Guide"
        ]
      },
      "monitoringLogging": {
        "title": "10. Monitoring and Logging: Visibility into System State",
        "description": "",
        "monitoringTitle": "Monitoring:",
        "monitoringList": [
          "Collection and visualization of performance and system health metrics (CPU, RAM, API/DB latencies, errors).",
          "Tools: Prometheus, Grafana. Allows early problem detection (Principle 9: Kaizen)."
        ],
        "loggingTitle": "Logging:",
        "loggingList": [
          "Collection of structured logs from all components (Backend, workers).",
          "Tools: Winston (for Node.js), Sentry (for error tracking)."
        ],
        "detailedDescriptionTitle": "Detailed description can be found in:",
        "detailedDescriptionList": [
          "BrainMessenger Optimization Guide (section 14)",
          "Monitoring Guide"
        ]
      },
      "externalApiIntegrations": {
        "title": "11. External API Integrations: Using External Levers",
        "description": "The Backend interacts with several external services via their APIs.",
        "gmailApiTitle": "Gmail API:",
        "gmailApiContent": "Sending transactional emails (confirmation, 2FA).",
        "stripeTitle": "Stripe:",
        "stripeContent": "Payment processing and subscriptions.",
        "firebaseFCMTitle": "Firebase FCM:",
        "firebaseFCMContent": "Sending push notifications to mobile devices.",
        "principleTitle": "Principle:",
        "principleContent": "Using these services is a pragmatic (Principle 12) way to quickly add functionality, using ready-made, reliable (Principle 3) solutions.",
        "detailedDescriptionTitle": "Detailed description of integrations can be found in:",
        "detailedDescriptionContent": "DocInt.md"
      },
      "notes": {
        "title": "12. Notes",
        "description": "This documentation provides a high-level overview of the BrainMessenger technical system. For a more detailed understanding of individual parts, refer to related documents:",
        "apiSpecLinkTitle": "API Specification:",
        "apiSpecLinkContent": "DocSpec.md",
        "devGuideLinkTitle": "Development Guide:",
        "devGuideLinkContent": "DocDevIn.md",
        "optimizationGuideLinkTitle": "Optimization Guide:",
        "optimizationGuideLinkContent": "DocOptimizationIn.md",
        "integrationsDocsLinkTitle": "Integrations Documentation:",
        "integrationsDocsLinkContent": "DocInt.md",
        "designDocsLinkTitle": "Design Documentation:",
        "designDocsLinkContent": "DocDesign.md",
        "userGuideLinkTitle": "User Guide:",
        "userGuideLinkContent": "DocUser.md",
        "longTermInvestmentTitle": "Development and maintenance of this technical system is a long-term investment (Principle 8) and a continuous process of learning and improvement (Principle 1, 9)."
      }
    }
  },
  "footer": {
    "sectionTitle": {
      "brand": "BrainMessenger"
    },
    "brandContent": "Your Smart Communication Platform",
    "copyright": "© 2025 BrainMessenger. All rights reserved."
  }
}
