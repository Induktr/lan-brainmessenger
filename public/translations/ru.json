{
  "header": {
    "features": "Функции",
    "news": "Новости",
    "faq": "Вопросы",
    "faqLink": "Вопросы",
    "docs": "Документация",
    "updates": "Обновления",
    "selectLanguage": "Выбрать язык",
    "changeLanguageTooltip": "Сменить язык",
    "lightMode": "Светлая тема",
    "darkMode": "Тёмная тема",
    "openMenu": "Открыть меню",
    "closeMenu": "Закрыть меню",
    "settings": "Настройки",
    "signOut": "Выйти",
    "deleteAccount": "Удалить аккаунт",
    "deleteAccountConfirmTitle": "Подтвердить удаление аккаунта",
    "deleteAccountConfirmMessage": "Вы уверены, что хотите удалить свой аккаунт? Это действие нельзя отменить.",
    "cancel": "Отмена",
    "confirmDelete": "Подтвердить удаление",
    "signIn": "Войти"
  },
  "hero": {
    "title": "Добро пожаловать в BrainMessenger",
    "subtitle": "Ваша умная платформа для общения",
    "getStarted": "Начать",
    "learnMore": "Узнать больше",
    "downloadButton": "Скачать",
    "downloadAndroid": "Скачать для Android"
  },
  "features": {
    "featuresTitle": "Ключевые функции",
    "featuresSubtitle": "Узнайте, что делает нас уникальными",
    "secureMessaging": "Безопасные сообщения",
    "secureMessagingDesc": "Сквозное шифрование для вашей конфиденциальности",
    "smartAssistant": "Умный ассистент",
    "smartAssistantDesc": "ИИ-помощник всегда под рукой",
    "crossPlatform": "Кросс-платформенность",
    "crossPlatformDesc": "Используйте на любом устройстве, где угодно",
    "groupChats": "Груповые чаты",
    "groupChatsDesc": "Общайтесь с несколькими людьми одновременно",
    "privacyFirst": "Конфиденциальность прежде всего",
    "privacyFirstDesc": "Ваши данные - ваши, всегда"
  },
  "news": {
    "latestNews": "Последние новости",
    "readMore": "Читать далее"
  },
  "faq": {
    "title": "Часто задаваемые вопросы",
    "subtitle": "Найдите ответы на часто задаваемые вопросы о BrainMessenger",
    "searchAlt": "Иконка поиска",
    "searchPlaceholder": "Поиск вопросов...",
    "allQuestions": "Все вопросы",
    "noResults": "По вашему запросу не найдено ни одного вопроса.",
    "categories": {
      "general": "Общие",
      "technical": "Технические",
      "security": "Безопасность",
      "pricing": "Цены",
      "generalProject": "Общие вопросы о проекте",
      "technicalQuestions": "Технические вопросы",
      "developmentProcesses": "Процессы разработки",
      "statusRoadmapFuture": "Статус, дорожная карта и будущее",
      "challengesOpportunitiesLimitations": "Вызовы, возможности и ограничения",
      "learnMoreContribute": "Узнать больше и внести вклад"
    },
    "questionsData": {
      "generalProject": {
        "q1": {
          "question": "Какова основная идея BrainMessenger? Что делает его особенным?",
          "answer": "BrainMessenger - это платформа для общения, которая ставит на первое место безопасность, интеллектуальные функции и удобство пользователя. Его особенность заключается в поєднанні сквозного шифрования, ИИ-ассистента и кросс-платформенной доступности."
        },
        "q2": {
          "question": "Какие ключевые принципы лежат в основе разработки BrainMessenger?",
          "answer": "Разработка базируется на принципах создания ценности для пользователя, качества над количеством, прагматизма, целостности и здоровья как фундамента (включая доступность)."
        },
        "q3": {
          "question": "Кто стоит за проектом? Это открытая сообщество или команда?",
          "answer": "На данный момент проект разрабатывается командой энтузиастов, но мы открыты к сотрудничеству и вкладам от сообщества."
        }
      },
      "technicalQuestions": {
        "q1": {
          "question": "Почему был выбран именно такой стек технологий (TypeScript, NestJS, React/RN, PostgreSQL/Neon, GraphQL, Kafka, Redis, Cloudflare R2 и т.д.)?",
          "answer": "Выбор стека обусловлен стремлением к надежности, масштабируемости, скорости разработки и использованию современных подходов. TypeScript обеспечивает типізацію, NestJS – структуру бэкенда, React/RN – гибкость UI, а другие технологии – эффективную работу с данными, сообщениями и файлами."
        },
        "q2": {
          "question": "Почему на старте используется монолитная архитектура, а не сразу микросервисы?",
          "answer": "Монолитная архитектура на старте позволяет быстрее запустить MVP и проверить основные гипотезы. Переход к микросервисам планируется в будущем для лучшей масштабируемости и гибкости."
        },
        "q3": {
          "question": "Какие подходы используются для обеспечения безопасности?",
          "answer": "Мы используем сквозное шифрование (E2EE) для всех приватных чатов, двухфакторную аутентификацию (2FA), регулярные аудиты безопасности и придерживаемся лучших практик защиты данных."
        },
        "q4": {
          "question": "Как реализована функциональность реального времени (обмен сообщениями)?",
          "answer": "Для обмена сообщениями в реальном времени используются WebSockets и, возможно, Kafka для обробки потоков сообщений, что обеспечивает быструю и надежную доставку."
        },
        "q5": {
          "question": "Почему используется GraphQL вместо REST API?",
          "answer": "GraphQL позволяет клиентам запрашивать только те данные, которые им нужны, уменьшая избыточность и улучшая производительность. Это также упрощает разработку API и эволюцию схемы данных."
        },
        "q6": {
          "question": "Как управляются большие объемы данных и файлов?",
          "answer": "Для хранения больших объемов данных используется PostgreSQL (возможно, с Neon для масштабируемости), а для файлов – Cloudflare R2, что обеспечивает надежное и эффективное хранение."
        }
      },
      "developmentProcesses": {
        "q1": {
          "question": "Какой подход к управлению проектом и задачами?",
          "answer": "Мы используем гибкие методологии разработки (Agile/Scrum) с регулярными спринтами, планированием и ретроспективами. Задачи отслеживаются в системе управления проектами."
        },
        "q2": {
          "question": "Как обеспечивается качество кода?",
          "answer": "Качество кода обеспечивается через код-рев'ю, статический анализ (линтеры, форматеры), соблюдение стандартов кодирования и написание тестов."
        },
        "q3": {
          "question": "Какая стратегия тестування используется?",
          "answer": "Наша стратегия включает юнит-тесты, интеграционные тесты и E2E-тесты для обеспечения надежности всех компонентів системы."
        },
        "q4": {
          "question": "Как обробляются ошибки?",
          "answer": "Ошибки отслеживаются с помощью систем моніторингу, логуються и анализируются для быстрого исправления. На клиенте предусмотрены механизмы обробки ошибок для улучшения UX."
        },
        "q5": {
          "question": "Как развертывается проект?",
          "answer": "Развертывание автоматизировано с помощью CI/CD пайплайнов, что обеспечивает быструю и надежную доставку оновлений."
        },
        "q6": {
          "question": "Как мониторится система в продакшене?",
          "answer": "Система мониторится с помощью специализированных инструментов, которые отслеживают производительность, доступность и ошибки в реальном времени."
        }
      },
      "statusRoadmapFuture": {
        "q1": {
          "question": "Каков текущий статус проекта?",
          "answer": "Проект находится на стадии активной разработки MVP. Основные функции обмена сообщениями и безопасности реализованы."
        },
        "q2": {
          "question": "Каковы следующие шаги после завершения MVP?",
          "answer": "После MVP планируется расширение функционала, улучшение производительности, добавление новых интеграций и постепенный переход к микросервисной архитектуре."
        },
        "q3": {
          "question": "Планируется ли переход на микросервисную архитектуру?",
          "answer": "Да, переход на микросервисную архитектуру планируется для обеспечения лучшей масштабируемости, гибкости и независимости разработки отдельных компонентов."
        }
      },
      "challengesOpportunitiesLimitations": {
        "q1": {
          "question": "Каковы основные технические вызовы (подводные камни) в проекте?",
          "answer": "Основные вызовы включают обеспечение высокого уровня безопасности, масштабирование системы под большие нагрузки и реализацию сложных ИИ-функций."
        },
        "q2": {
          "question": "Какие возможности и преимущества предоставляет архитектура и стек проекта?",
          "answer": "Выбранный стек и архитектура обеспечивают гибкость, скорость разработки, высокую производительность и возможность легко внедрять новые технологии."
        },
        "q3": {
          "question": "Каковы ограничения проекта на текущем этапе (MVP)?",
          "answer": "На этапе MVP функционал будет ограничен основными возможностями для быстрого запуска и сбора обратного связи. Некоторые расширенные функции будут добавлены позже."
        }
      },
      "learnMoreContribute": {
        "q1": {
          "question": "Где я могу получить более подробную информацию о проекте?",
          "answer": "Более подробную информацию можно найти в нашей документации (ссылка будет добавлена позже) и на странице проекта на GitHub (если проект открыт)."
        },
        "q2": {
          "question": "Как я могу присоединиться к разработке проекта или внести свой вклад?",
          "answer": "Мы всегда рады новым участникам! Свяжитесь с нами через контактную форму на сайте или через GitHub (если проект открыт), чтобы обговорить возможные варианты сотрудничества."
        },
        "q3": {
          "question": "Где я могу задать дополнительные вопросы?",
          "answer": "Дополнительные вопросы можно задать через контактную форму на сайте, в нашем комьюнити (ссылка будет добавлена) или создав issue на GitHub (если проект открыт)."
    },
    "technicalDocs": {
      "title": "Техническая Документация BrainMessenger (Система и Фундамент)",
      "subtitle": "Общая Информация: Архитектура Цифрового Актива",
      "generalInfo": {
        "title": "1. Общая Информация: Архитектура Цифрового Актива",
        "description": "BrainMessenger — это современный мессенджер, построенный как <strong>надежная, масштабируемая и безопасная система</strong> (Принцип 9), которая служит <strong>ключевым цифровым АКТИВОМ</strong> (Принцип 10). Этот документ предоставляет высокоуровневый обзор <strong>технического фундамента</strong> (Принцип 8) проекта, описывая основные компоненты, технологии и их взаимодействие.",
        "projectNameTitle": "Название проекта:",
        "projectNameContent": "BrainMessenger",
        "purposeTitle": "Цель:",
        "purposeContent": "Дать общее понимание структуры BrainMessenger, используемого стека технологий и принципов, лежащих в основе его построения, для всех членов команды и заинтересованных лиц.",
        "principlesTitle": "Принципы, отраженные в технической структуре:",
        "principlesList": [
          "<strong>Система и Оптимизация (Принцип 9):</strong> Проект спроектирован как набор взаимосвязанных, оптимизированных компонентов.",
          "<strong>Долгосрочное Мышление (Принцип 8):</strong> Выбор технологий и архитектуры с учетом будущих потребностей масштабирования и развития.",
          "<strong>Качество > Количество (Принцип 3):</strong> Использование проверенных, надежных решений и фокус на качестве кода и инфраструктуры.",
          "<strong>Прагматизм и Реализм (Принцип 12):</strong> Использование готовых сервисов (Neon, R2, Firebase) там, где это оправдано, вместо создания всего с нуля.",
          "<strong>Создание Ценности (Принцип 2):</strong> Техническая структура направлена на обеспечение ключевых функций мессенджера (общение, файлы, звонки) на высоком уровне."
        ]
      },
      "techStack": {
        "title": "2. Технологический Стек: Инструментарий для Построения Системы",
        "description": "Мы используем современный и гибкий набор технологий, позволяющий эффективно строить и масштабировать BrainMessenger.",
        "frontend": {
          "title": "Frontend (Клиентские Приложения):",
          "list": [
            "<strong>React Native (Android, Windows Desktop):</strong> Единая кодовая база для мобильного и десктопного приложения. Выбран за кроссплатформенность и большой набор готовых библиотек.",
            "<strong>Next.js (Web):</strong> React-фреймворк для веб-приложения с поддержкой SSR/SSG для производительности и SEO.",
            "<strong>TypeScript:</strong> Строгая типизация для всего Frontend-кода. Повышает надежность и упрощает рефакторинг."
          ]
        },
        "backend": {
          "title": "Backend (Серверная Логика):",
          "list": [
            "<strong>Node.js:</strong> Высокопроизводительная среда выполнения JavaScript/TypeScript.",
            "<strong>NestJS:</strong> Модульный фреймворк для Node.js. Обеспечивает структурированную архитектуру (модули, сервисы, контроллеры/резолверы) и поддержку TypeScript.",
            "<strong>GraphQL:</strong> Протокол API. Позволяет клиентам запрашивать точно те данные, которые нужны, снижая избыточность."
          ]
        },
        "databaseCaching": {
          "title": "База Данных и Кэширование:",
          "list": [
            "<strong>PostgreSQL (через Neon):</strong> Надежная реляционная СУБД. Используется как основное хранилище структурированных данных (пользователи, чаты, сообщения, метаданные). Neon предоставляет управляемый сервис с функциями масштабирования и репликации.",
            "<strong>Prisma ORM:</strong> Инструмент для взаимодействия с PostgreSQL из NestJS. Обеспечивает типизацию и безопасность запросов.",
            "<strong>Redis:</strong> In-memory хранилище данных. Используется для кэширования, Rate Limiting, управления состоянием WebSocket-соединений (присутствие пользователей)."
          ]
        },
        "fileStorage": {
          "title": "Хранилище Файлов:",
          "list": [
            "<strong>Cloudflare R2:</strong> Объектное хранилище, совместимое с S3 API. Используется для хранения файлов пользователей (фото, видео, документы, аватары, записи звонков), зашифрованных данных. Выбран за низкую стоимость и отсутствие платы за исходящий трафик."
          ]
        },
        "asyncProcessing": {
          "title": "Асинхронная Обработка:",
          "list": [
            "<strong>Kafka:</strong> Распределенная система очередей сообщений. Используется для надежной асинхронной обработки задач (например, обработка изображений, отправка уведомлений) вне основного потока API."
          ]
        },
        "infrastructureDeployment": {
          "title": "Инфраструктура и Развертывание:",
          "list": [
            "<strong>Docker:</strong> Контейнеризация приложений. Обеспечивает изоляцию и переносимость.",
            "<strong>Kubernetes:</strong> Оркестрация контейнеров. Управляет развертыванием, масштабированием и самовосстановлением сервисов в кластере.",
            "<strong>Terraform:</strong> Инфраструктура как код (IaC). Автоматизирует создание и управление облачными ресурсами."
          ]
        },
        "testingMonitoringLogging": {
          "title": "Тестирование, Мониторинг, Логирование:",
          "list": [
            "<strong>Jest, Cypress, Detox:</strong> Инструменты для модульного, интеграционного и E2E-тестирования.",
            "<strong>Prometheus, Grafana:</strong> Система мониторинга. Сбор и визуализация метрик производительности и состояния системы.",
            "<strong>Winston, Sentry:</strong> Система логирования и отслеживания ошибок."
          ]
        }
      },
      "architecture": {
        "title": "3. Архитектура Проекта: Взаимосвязь Компонентов Системы",
        "description": "Архитектура BrainMessenger следует принципам <strong>модульности и разделения ответственности</strong> (Принцип 9).",
        "clientApplications": {
          "title": "Клиентские Приложения (Frontend):",
          "list": [
            "Web (Next.js), Mobile & Desktop (React Native).",
            "Содержат пользовательский интерфейс и логику взаимодействия с пользователем.",
            "Взаимодействуют с Backend исключительно через <strong>GraphQL API</strong>.",
            "Могут напрямую скачивать файлы из Cloudflare R2 (если доступ публичный) или через Backend (если требуется аутентификация или подпись URL)."
          ]
        },
        "apiGateway": {
          "title": "API Gateway (В будущем):",
          "content": "Единая точка входа для всех клиентских запросов. Может выполнять аутентификацию, Rate Limiting, маршрутизацию на нужные Backend-сервисы. На старте роль Gateway выполняет сам Backend."
        },
        "backendService": {
          "title": "Backend Service (NestJS):",
          "list": [
            "Основной серверный компонент.",
            "Содержит <strong>бизнес-логику</strong> BrainMessenger (управление пользователями, чатами, сообщениями, звонками, платежами).",
            "Предоставляет <strong>GraphQL API</strong> для клиентских приложений.",
            "Взаимодействует с <strong>Базой Данных (Neon/PostgreSQL через Prisma)</strong> для чтения/записи структурированных данных.",
            "Взаимодействует с <strong>Хранилищем Файлов (Cloudflare R2)</strong> для загрузки/получения файлов (через AWS SDK).",
            "Взаимодействует с <strong>Кэшем (Redis)</strong> для быстрых операций.",
            "Ставит задачи в <strong>Очередь (Kafka)</strong> для асинхронной обработки.",
            "Использует внешние сервисы (Firebase, Stripe, Gmail API)."
          ]
        },
        "database": {
          "title": "База Данных (Neon/PostgreSQL):",
          "content": "Хранит структурированные данные. Масштабируется независимо."
        },
        "fileStorage": {
          "title": "Хранилище Файлов (Cloudflare R2):",
          "content": "Хранит неструктурированные бинарные данные. Масштабируется по объему."
        },
        "caching": {
          "title": "Кэширование (Redis):",
          "content": "Быстрый доступ к временным данным."
        },
        "messageQueue": {
          "title": "Очередь Сообщений (Kafka):",
          "content": "Буферизация и надежная доставка сообщений между сервисами для асинхронной обработки."
        },
        "workers": {
          "title": "Воркеры (Kafka Consumers):",
          "list": [
            "Отдельные сервисы, читающие задачи из Kafka и выполняющие тяжелые или долгие операции (обработка изображений, отправка больших рассылок).",
            "Масштабируются независимо."
          ]
        },
        "externalServices": {
          "title": "Внешние Сервисы (Firebase, Stripe, Gmail API):",
          "list": [
            "Предоставляют специализированный функционал (уведомления, платежи, email).",
            "Используются Backend-сервисом."
          ]
        },
        "mermaidDiagram": {
          "title": "Архитектурная Схема:",
          "code": "graph TD\n    A[Frontend Web (Next.js)] -->|GraphQL API| B(API Gateway / Backend);\n    A -->|Direct File Access (Opt.)| E(Cloudflare R2);\n    F[Frontend Mobile/Desktop (React Native)] -->|GraphQL API| B;\n    F -->|Direct File Access (Opt.)| E;\n    B -->|Prisma Queries/Mutations| C(Neon/PostgreSQL);\n    B -->|AWS SDK (S3 API)| E;\n    B -->|ioredis| D(Redis Cache);\n    B -->|kafkajs Producer| G(Kafka Queue);\n    B -->|Firebase Admin SDK| H(Firebase FCM);\n    B -->|Stripe SDK| I(Stripe);\n    B -->|Google APIs Client| J(Gmail API);\n    G -->|kafkajs Consumer| K(Kafka Workers);\n    K -->|sharp| K; % Image processing\n    K -->|AWS SDK (S3 API)| E;\n    K -->|GraphQL API / Other Service Calls| B; % Report completion, send chat message\n    C -->|Replication (for scaling)| C;\n    C -->|Partitioning/Sharding (for scaling)| C;\n    E -->|CDN| A; % File delivery to Frontend\n    Prometheus(Prometheus) -->|Scrape Metrics| B;\n    Prometheus -->|Scrape Metrics| C;\n    Prometheus -->|Scrape Metrics| D;\n    Prometheus -->|Scrape Metrics| G;\n    Grafana(Grafana) -->|Visualize Metrics| Prometheus;\n    Sentry(Sentry) -->|Error Reports| B;\n    Sentry -->|Error Reports| A;"
        }
      },
      "api": {
        "title": "4. API: Интерфейс Взаимодействия",
        "description": "API BrainMessenger реализовано на GraphQL с использованием NestJS.",
        "endpointTitle": "Endpoint:",
        "endpointContent": "`/graphql`",
        "structureTitle": "Структура:",
        "structureContent": "Определяется GraphQL Схемой (типы User, Chat, Message и др.) и набором Queries (для получения данных) и Mutations (для изменения данных).",
        "authenticationTitle": "Аутентификация:",
        "authenticationContent": "JWT-токены в заголовке `Authorization: Bearer <token>`.",
        "externalApiIntegrationsTitle": "Внешние API Интеграции:",
        "externalApiIntegrationsContent": "Взаимодействие с внешними сервисами (Gmail, Stripe) осуществляется через Backend, который предоставляет соответствующие Mutations в GraphQL API (см. Спецификацию API).",
        "keyFunctionalAreas": {
          "title": "Ключевые функциональные области API:",
          "list": [
            "Аутентификация (регистрация, логин, логаут, 2FA).",
            "Управление пользователями (получение/обновление/удаление профиля).",
            "Управление чатами (создание, получение списка, получение данных чата).",
            "Работа с сообщениями (отправка текстовых сообщений, отправка файлов, получение истории).",
            "Управление контактами.",
            "Настройки приложения (тема, уведомления, язык).",
            "Управление Premium-подпиской.",
            "Управление файлами (загрузка в R2 через Backend).",
            "(В будущем) Звонки и видеозвонки (управление сессиями звонков)."
          ]
        },
        "detailedSpecTitle": "Подробная спецификация API описана в:",
        "detailedSpecContent": "DocSpec.md"
      },
      "database": {
        "title": "5. База Данных (Neon/PostgreSQL): Хранилище Основных Данных",
        "description": "",
        "technologyTitle": "Технология:",
        "technologyContent": "PostgreSQL 15.x.",
        "hostingTitle": "Хостинг:",
        "hostingContent": "Neon.",
        "roleTitle": "Роль:",
        "roleContent": "Реляционная база данных для всех структурированных данных.",
        "keyTables": {
          "title": "Ключевые таблицы (определены в backend/prisma/schema.prisma):",
          "list": [
            "User: Информация о пользователях (id, email, password_hash, name, avatarUrl, createdAt, updatedAt, is2FaEnabled).",
            "Chat: Информация о чатах (id, type, name, createdAt, updatedAt, lastMessageAt).",
            "UserChat: Связующая таблица для Many-to-Many связи между User и Chat (userId, chatId, joinedAt, lastReadMessageId).",
            "Message: Сообщения в чатах (id, chatId, senderId, content, fileUrl, fileMetadata (JSON), createdAt, updatedAt).",
            "Contact: Список контактов пользователя (id, userId, contactId).",
            "Transaction: История платежей (для Premium) (id, userId, amount, currency, status, provider, createdAt).",
            "Code: Временные коды (для email верификации, 2FA) (id, userId/email, code, type, expiresAt)."
          ]
        },
        "interactionTitle": "Взаимодействие:",
        "interactionContent": "Только Backend через Prisma ORM.",
        "optimizationScalingTitle": "Оптимизация и Масштабирование:",
        "optimizationScalingContent": "Используются индексы, оптимизация запросов Prisma, материализованные представления, партиционирование, репликация (см. DocOptimizationIn)."
      },
      "fileStorage": {
        "title": "6. Хранилище Файлов (Cloudflare R2): Хранилище Медиа и Бинарных Активов",
        "description": "",
        "technologyTitle": "Технология:",
        "technologyContent": "Объектное хранилище, S3-совместимый API.",
        "hostingTitle": "Хостинг:",
        "hostingContent": "Cloudflare R2.",
        "roleTitle": "Роль:",
        "roleContent": "Хранение всех неструктурированных данных (файлы пользователей, аватарки, записи звонков).",
        "interactionTitle": "Взаимодействие:",
        "interactionContent": "Backend загружает файлы, Backend или Frontend получает файлы (напрямую или через подписанные URL).",
        "structureTitle": "Структура:",
        "structureContent": "Файлы организованы по папкам/ключам (например, `avatars/`, `chat-images/`, `sensitive-data/`).",
        "securityTitle": "Безопасность:",
        "securityContent": "Шифрование в покое, ограниченный доступ, шифрование чувствительных данных на уровне приложения перед загрузкой (см. DocInt, DocSecurity)."
      },
      "projectStructure": {
        "title": "7. Проектная Структура (Монорепозиторий): Организация Кода",
        "description": "Проект организован как монорепозиторий с использованием Turborepo.",
        "purposeTitle": "Цель:",
        "purposeContent": "Упростить управление несколькими приложениями/пакетами (backend, web, mobile-desktop, core) и переиспользование кода.",
        "packages": {
          "title": "Пакеты:",
          "list": [
            "core: Общий код.",
            "backend: Серверная логика.",
            "web: Веб-приложение.",
            "mobile-desktop: Мобильное/десктопное приложение (React Native).",
            "Инфраструктура: Файлы конфигурации для развертывания (infrastructure/).",
            "Документация: Проектная документация (docs/)."
          ]
        },
        "detailedDescriptionTitle": "Подробное описание структуры монорепозитория см. в:",
        "detailedDescriptionContent": "DocDevIn.md (раздел 2)."
      },
      "security": {
        "title": "8. Безопасность: Фундаментальный Аспект Системы",
        "description": "Безопасность встроена на всех уровнях (см. подробнее в Руководстве по безопасности BrainMessenger).",
        "authenticationTitle": "Аутентификация:",
        "authenticationContent": "JWT, 2FA через email.",
        "authorizationTitle": "Авторизация:",
        "authorizationContent": "Проверка прав доступа к ресурсам на Backend.",
        "encryptionTitle": "Шифрование:",
        "encryptionContent": "TLS/SSL для передачи данных, шифрование паролей (bcrypt/argon2), шифрование чувствительных данных на уровне приложения перед хранением в R2.",
        "validationTitle": "Валидация:",
        "validationContent": "Строгая валидация входных данных на Backend.",
        "attackProtectionTitle": "Защита от Атак:",
        "attackProtectionContent": "Rate Limiting, безопасные HTTP-заголовки.",
        "principleTitle": "Принцип:",
        "principleContent": "Безопасность — это постоянный процесс обучения (Принцип 1) и совершенствования (Принцип 9), основанный на ответственности (Принцип 6)."
      },
      "deployment": {
        "title": "9. Развертывание: Доставка Системы Пользователям",
        "description": "Процесс развертывания автоматизирован.",
        "containerizationTitle": "Контейнеризация:",
        "containerizationContent": "Docker-образы для Backend, Kafka Consumers.",
        "orchestrationTitle": "Оркестрация:",
        "orchestrationContent": "Kubernetes управляет контейнерами в облаке.",
        "iacTitle": "Инфраструктура как Код:",
        "iacContent": "Terraform (IaC). Автоматизирует создание и управление облачными ресурсами.",
        "ciCdTitle": "CI/CD:",
        "ciCdContent": "GitHub Actions автоматизирует сборку, тестирование и деплой.",
        "webAppDeploymentTitle": "Веб-приложение может деплоиться отдельно (например, на Vercel или Cloudflare Pages).",
        "webAppDeploymentContent": "",
        "detailedDescriptionTitle": "Подробное описание процесса деплоя см. в:",
        "detailedDescriptionList": [
          "DocDevIn.md (раздел 9)",
          "Руководстве по развертыванию"
        ]
      },
      "monitoringLogging": {
        "title": "10. Мониторинг и Логирование: Видимость Состояния Системы",
        "description": "",
        "monitoringTitle": "Мониторинг:",
        "monitoringList": [
          "Сбор и визуализация метрик производительности и здоровья системы (CPU, RAM, задержки API/БД, ошибки).",
          "Инструменты: Prometheus, Grafana. Позволяет выявлять проблемы на ранней стадии (Принцип 9: Кайдзен)."
        ],
        "loggingTitle": "Логирование:",
        "loggingList": [
          "Сбор структурированных логов от всех компонентов (Backend, воркеры).",
          "Инструменты: Winston (для Node.js), Sentry (для отслеживания ошибок)."
        ],
        "detailedDescriptionTitle": "Подробное описание см. в:",
        "detailedDescriptionList": [
          "Руководстве по оптимизации BrainMessenger (раздел 14)",
          "Руководстве по мониторингу"
        ]
      },
      "externalApiIntegrations": {
        "title": "11. Внешние API Интеграции: Использование Внешних Рычагов",
        "description": "Backend взаимодействует с несколькими внешними сервисами через их API.",
        "gmailApiTitle": "Gmail API:",
        "gmailApiContent": "Отправка транзакционных email (подтверждение, 2FA).",
        "stripeTitle": "Stripe:",
        "stripeContent": "Обработка платежей и подписок.",
        "firebaseFCMTitle": "Firebase FCM:",
        "firebaseFCMContent": "Отправка push-уведомлений на мобильные устройства.",
        "principleTitle": "Принцип:",
        "principleContent": "Использование этих сервисов — прагматичный (Принцип 12) способ быстро добавить функционал, используя готовые, надежные (Принцип 3) решения.",
        "detailedDescriptionTitle": "Подробное описание интеграций см. в:",
        "detailedDescriptionContent": "DocInt.md"
      },
      "notes": {
        "title": "12. Примечания",
        "description": "Эта документация предоставляет высокоуровневый обзор технической системы BrainMessenger. Для более детального понимания отдельных частей обращайтесь к связанным документам:",
        "apiSpecLinkTitle": "Спецификация API:",
        "apiSpecLinkContent": "DocSpec.md",
        "devGuideLinkTitle": "Руководство по разработке:",
        "devGuideLinkContent": "DocDevIn.md",
        "optimizationGuideLinkTitle": "Руководство по оптимизации:",
        "optimizationGuideLinkContent": "DocOptimizationIn.md",
        "integrationsDocsLinkTitle": "Документация интеграций:",
        "integrationsDocsLinkContent": "DocInt.md",
        "designDocsLinkTitle": "Документация дизайна:",
        "designDocsLinkContent": "DocDesign.md",
        "userGuideLinkTitle": "Руководство пользователя:",
        "userGuideLinkContent": "DocUser.md",
        "longTermInvestmentTitle": "Разработка и поддержка этой технической системы — это долгосрочная инвестиция (Принцип 8) и непрерывный процесс обучения и совершенствования (Принцип 1, 9)."
      }
    }
  }
}
  },
  "docs": {
    "general": {
      "title": "BrainMessenger - Ваш Цифровой Актив для Эффективной Коммуникации",
      "subtitle": "Введение: Построение Системы Ценности",
      "introduction": {
        "title": "Введение: Построение Системы Ценности",
        "content": "Добро пожаловать в репозиторий BrainMessenger. Это не просто очередной мессенджер. Это целенаправленный проект, направленный на создание <strong>надежной, масштабируемой и безопасной СИСТЕМЫ</strong> (Принцип 9), которая станет <strong>ключевым цифровым АКТИВОМ</strong> (Принцип 10) для каждого пользователя. Наша главная цель – <strong>упростить сложное</strong> (принцип Маргулана Сейсембаева), предоставляя интуитивно понятные и мощные инструменты для эффективной коммуникации и взаимодействия в современном цифровом мире.<br/><br/>BrainMessenger построен на <strong>прочном фундаменте</strong> (Принцип 8) глубоких принципов, осознанного планирования и <strong>непрерывного обучения</strong> (Принцип 1). Каждая строка кода, каждое принятое решение – это <strong>долгосрочная инвестиция</strong> (Принцип 8) в <strong>качество</strong> (Принцип 3) и <strong>ценность</strong> (Принцип 2) нашего продукта."
      },
      "visionAndMission": {
        "title": "Видение и Миссия: Наш Долгосрочный Взгляд",
        "visionTitle": "Наше Видение:",
        "visionContent": "Создать ведущий цифровой актив для коммуникации, который поможет миллионам пользователей по всему миру эффективно обмениваться информацией, строить сообщества и достигать своих целей.",
        "missionTitle": "Наша Миссия:",
        "missionContent": "Упрощать сложное взаимодействие, предоставляя надежный, безопасный и удобный мессенджер, построенный на принципах качества, прозрачности и непрерывного совершенствования."
      },
      "keyPrinciples": {
        "title": "Ключевые Принципы: Фундамент Нашей Системы",
        "intro": "Наши действия и решения руководствуются набором ключевых принципов, которые служат <strong>фундаментом</strong> (Принцип 8) всего проекта BrainMessenger. Это не просто слова, а <strong>личные алгоритмы и стандарты (Кайдзен, Принцип 9)</strong>, разработанные через опыт и рефлексию (Принцип 1):",
        "principles": [
          "<strong>Непрерывное Обучение и Рост (Принцип 1):</strong> Процесс создания BrainMessenger – это полигон для глубокого обучения в технологиях, архитектуре и психологии пользователей. Мы учимся на каждом шаге, превращая ошибки в уроки.",
          "<strong>Создание Ценности (Принцип 2):</strong> Польза для пользователя – в основе всего. Мы строим то, что действительно решает проблемы и делает жизнь лучше.",
          "<strong>Качество Превыше Количества (Принцип 3):</strong> Мы стремимся делать вещи хорошо, а не просто быстро. Надежность, продуманность и внимание к деталям – наши приоритеты.",
          "<strong>Осознанность и Присутствие (Принцип 4):</strong> Быть внимательным к процессу, пользователям и команде.",
          "<strong>Здоровье как Фундамент (Принцип 5):</strong> Физическое и ментальное благополучие команды (и будущих пользователей) – основа продуктивности и устойчивости.",
          "<strong>Ответственность и Проактивность (Принцип 6):</strong> Мы берем ответственность за результат и действуем превентивно.",
          "<strong>Целостность (Принцип 7):</strong> Наши слова соответствуют нашим действиям.",
          "<strong>Долгосрочное Мышление (Принцип 8):</strong> Мы инвестируем время и усилия с прицелом на будущее.",
          "<strong>Система и Оптимизация (Принцип 9):</strong> Мы строим процессы и архитектуру как систему, постоянно ища пути повышения эффективности (Кайдзен).",
          "<strong>Создание Богатства > Зарабатывание Денег (Принцип 10):</strong> Фокус на создании АКТИВА (BrainMessenger), который приносит ценность и работает в долгосрочной перспективе.",
          "<strong>Гибкость и Адаптивность (Принцип 11):</strong> Готовность менять тактику и инструменты, сохраняя видение.",
          "<strong>Прагматизм и Реализм (Принцип 12):</strong> Принятие решений на основе реальных данных и возможностей.",
          "<strong>Настойчивость (Принцип 13):</strong> Не сдаваться перед трудностями, извлекать уроки из неудач.",
          "<strong>Использование Внешней Экспертизы и Обратной Связи (Принцип 14):</strong> Мы учимся у других, прислушиваемся к конструктивной критике.",
          "<strong>Склонность к Действию (Принцип 15):</strong> На ранних этапах важнее начать делать и получать обратную связь, чем бесконечно планировать."
        ],
        "outro": "Эти принципы, вдохновленные философией Маргулана Сейсембаева и практиками ведущих ИТ-компаний, формируют нашу культуру и подход к разработке."
      },
      "aboutMVP": {
        "title": "О Проекте BrainMessenger (Фокус на MVP)",
        "intro": "Наш текущий фокус – на разработке <strong>Минимально Жизнеспособного Продукта (MVP)</strong>. MVP – это первый, <strong>прагматичный</strong> (Принцип 12) шаг к реализации нашего видения. Мы строим <strong>прочный технический фундамент</strong> (Принцип 8), который позволит нам быстро и эффективно развивать продукт в будущем.",
        "featuresTitle": "MVP включает базовые, но <strong>высококачественные и надежные</strong> (Принцип 3) функции, предоставляющие ключевую <strong>ценность</strong> (Принцип 2):",
        "features": [
          "<strong>Базовый Обмен Сообщениями:</strong> Отправка и получение текстовых сообщений в личных чатах и группах/каналах.",
          "<strong>Обмен Файлами:</strong> Загрузка и скачивание файлов (с оптимизацией изображений).",
          "<strong>Каналы и Групы:</strong> Базовое создание групп/каналов, присоединение к публичным каналам и чтение контента.",
          "<strong>Базовое Управление Учетной Записью:</strong> Регистрация, вход/выход, редактирование профиля (имя, аватар), базовые настройки безопасности.",
          "<strong>Основные Настройки UI:</strong> Выбор темы (Светлая/Темная), базовые настройки уведомлений и языка.",
          "<strong>Базовая Мультиязычность:</strong> Поддержка нескольких языков интерфейса (английский, русский и другие согласно DocLocIn.md)."
        ],
        "outro": "Функционал за пределами MVP (аудио/видеозвонки, расширенные функции безопасности/конфиденциальности, премиум-подписка, полный набор анимаций, интеграции ИИ) запланирован на последующие этапы Дорожной карты."
      },
      "howWeBuild": {
        "title": "Как Мы Строим: История Создания и Процесс Кайдзен",
        "intro": "Процесс создания BrainMessenger – это живая история, основанная на наших принципах. Мы строим его <strong>систематически</strong> (Принцип 9), шаг за шагом, документируя каждый этап и постоянно ища возможности для <strong>улучшения (Кайдзен)</strong>.",
        "steps": [
          "<strong>Осознанное Планирование (Принцип 4):</strong> Проект начался с четкого определения глобальных целей и их декомпозиции на достижимые этапы (Дорожная карта).",
          "<strong>Выбор Фундамента (Принцип 8, 12):</strong> Мы тщательно отобрали стек технологий – надежные и <strong>прагматичные</strong> инструменты (TypeScript, NestJS, React/RN, PostgreSQL/Neon, Cloudflare R2, Kafka, Redis), формирующие <strong>прочный технический фундамент</strong>.",
          "<strong>Построение Ядра MVP:</strong> Реализация началась с базовых, критически важных частей системы (Аутентификация, Базовый UI, Инфраструктура, Обработка Файлов). Мы применяем <strong>Склонность к Действию</strong> (Принцип 15), фокусируясь на построении работающих компонентов, даже если они пока минимальны.",
          "<strong>Непрерывное Обучение и Применение Знаний (Принцип 1):</strong> Каждая новая задача, особенно связанная с изучением или интеграцией технологий (как видно в <a href=\"https://www.notion.so/2025-2026-1576e78881b7435e9c3c2cf174e61b91?pvs=4\" target=\"_blank\" rel=\"noopener noreferrer\">Видео Трекере</a> и задачах), рассматривается как возможность для роста. Мы документуем этот процесс с помощью видео и рефлексии (Кайдзен-Час).",
          "<strong>Системный Подход к Качеству (Принцип 3, 9):</strong> Мы интегрируем тестирование на ранних этапах цикла разработки (Unit-тесты), настраиваем CI/CD пайплайны для автоматических перепроверок, и используем инструменты мониторинга (Prometheus, Grafana, Sentry) и логирования (Winston, ELK) для непрерывного контроля за <strong>здоровьем системы</strong> (Принцип 5) в реальном времени.",
          "<strong>Документация как Часть Системы Знаний:</strong> Весь процесс разработки, архитектурные решения, стандарты и требования тщательно документуются. Это не просто формальность, а часть создания <strong>системы знаний</strong>, которая ускоряет онбординг, упрощает поддержку и позволяет принимать обоснованные решения в будущем."
        ],
        "outro": "Мы строим BrainMessenger как живой, эволюционирующий организм, постоянно адаптируясь и улучшаясь на основе наших принципов и обратной связи от процесса разработки и будущих пользователей."
      },
      "technologyStack": {
        "title": "Стек Технологий: Наши Инструменты для Создания Актива",
        "intro": "Мы выбрали стек, который является <strong>прагматичным</strong> (Принцип 12), <strong>надежным</strong> (Принцип 3) и <strong>масштабируемым</strong> (Принцип 8) для создания нашего <strong>цифрового АКТИВА</strong>.",
        "stack": [
          "<strong>Язык:</strong> <a href=\"https://www.typescriptlang.org/\" target=\"_blank\" rel=\"noopener noreferrer\">TypeScript</a> - Статическая типізація для повышения качества и надежности кода.",
          "<strong>Бэкенд:</strong> <a href=\"https://nodejs.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Node.js</a>, <a href=\"https://nestjs.com/\" target=\"_blank\" rel=\"noopener noreferrer\">NestJS</a> - Эффективный и структурированный фреймворк для серверной логики и GraphQL API.",
          "<strong>Фронтенд:</strong> <a href=\"https://react.dev/\" target=\"_blank\" rel=\"noopener noreferrer\">React</a>, <a href=\"https://nextjs.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Next.js</a> (Веб), <a href=\"https://reactnative.dev/\" target=\"_blank\" rel=\"noopener noreferrer\">React Native</a> (Мобильный/Десктоп) - Кросс-платформенная разработка UI с фокусом на производительности.",
          "<strong>API:</strong> <a href=\"https://graphql.org/\" target=\"_blank\" rel=\"noopener noreferrer\">GraphQL</a> - Гибкое взаимодействие между клиентом и сервером.",
          "<strong>Реальное время:</strong> WebSockets - Мгновенная доставка сообщений.",
          "<strong>База данных:</strong> <a href=\"https://www.postgresql.org/\" target=\"_blank\" rel=\"noopener noreferrer\">PostgreSQL</a> (через <a href=\"https://neon.tech/\" target=\"_blank\" rel=\"noopener noreferrer\">Neon</a>) - Надежная и масштабируемая база данных. Neon как управляемый сервис уменьшает операционные расходы (Прагматизм).",
          "<strong>ORM:</strong> <a href=\"https://www.prisma.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Prisma</a> - Типобезопасное и надежное взаимодействие с базой данных, защита от SQL-инъекций (Качество, Безпека).",
          "<strong>Кэшування:</strong> <a href=\"https://redis.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Redis</a> - Высокопроизводительное кеширование и управление состоянием.",
          "<strong>Черги:</strong> <a href=\"https://kafka.apache.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Kafka</a> - Надежная асинхронная обробка задач.",
          "<strong>Хранилище файлов:</strong> <a href=\"https://www.cloudflare.com/developer/r2/\" target=\"_blank\" rel=\"noopener noreferrer\">Cloudflare R2</a> - Объектное хранилище с выгодными тарифами и без платы за исходящий трафик (Прагматизм, АКТИВ).",
          "<strong>Уведомления:</strong> <a href=\"https://firebase.google.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Firebase</a> - Управляемый сервис для push-уведомлений.",
          "<strong>Электронная почта/2FA:</strong> <a href=\"https://developers.google.com/gmail/api\" target=\"_blank\" rel=\"noopener noreferrer\">Gmail API</a> - Надежная доставка транзакционных писем (коды подтверждения, 2FA).",
          "<strong>Платежи:</strong> <a href=\"https://stripe.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Stripe</a>, Cryptomus (За пределами MVP) - Монетизация АКТИВУ, Прагматизм.",
          "<strong>Тестирование:</strong> Jest, Cypress, Detox, k6, OWASP ZAP/Burp Suite (план) - Комплексный подход к обеспечению качества.",
          "<strong>Развертывание:</strong> <a href=\"https://vercel.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Vercel</a> (Веб), Docker, <a href=\"https://kubernetes.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Kubernetes</a> - Автоматизованное и масштабированное развертывание.",
          "<strong>Мониторинг:</strong> Prometheus, Grafana, Sentry (план) - Видимость системы и анализ Кайдзен."
        ]
      },
      "architecture": {
        "title": "Архітектура: Еволюція Системы",
        "intro": "В настоящее время BrainMessenger реализован как <strong>монолитное приложение на базе NestJS</strong>. Это <strong>прагматичное</strong> (Принцип 12) решение для MVP, позволяющее быстро запустить продукт и проверить основные гипотезы.",
        "future": "В будущем, с ростом проекта и увеличением нагрузки, мы планируем поэтапный переход к <strong>микросервисной архитектуре</strong> с использованием <strong>Strangler Pattern</strong>. Это <strong>долгосрочная стратегия</strong> (Принцип 8), которая позволит независимо масштабировать и развивать отдельные компоненты (чаты, дзвінки, ИИ, платежи), повышая общую <strong>надежность и гибкость</strong> системы (Принцип 3, 11).",
        "interaction": "Взаимодействие между компонентами будет происходить через <strong>GraphQL API</strong> (синхронно) и <strong>Kafka</strong> (асинхронно), используя <strong>Apollo Federation</strong> (в будущем) для построения единой схемы API из нескольких микросервисов."
      },
      "projectStatus": {
        "title": "Статус Проекта: Текущий Этап (MVP)",
        "content": "На данный момент проект находится на этапе активной разработки <strong>MVP</strong> (согласно <a href=\"https://www.notion.so/MVP-11a2a21315e54eb3b3c90171b4c7493d?pvs=4\" target=\"_blank\" rel=\"noopener noreferrer\">Инструкции по Требованиям к MVP</a>). Мы сосредоточены на завершении основной функциональности обмена сообщениями, обработки файлов, создания групп/каналов и базовых настроек, одновременно укрепляя <strong>технический фундамент</strong> (Принцип 8) и внедряя процессы <strong>непрерывного обучения</strong> и <strong>Кайдзен</strong> в нашу ежедневную работу.",
        "progress": "Прогресс документируется через задачи, код в репозитории и видеозаписи, которые демонстрируют наш путь и <strong>процесс создания</strong> (Принцип 1)."
      },
      "gettingStarted": {
        "title": "Начало Работы (Для Разработчиков)",
        "intro": "Хотите присоединиться к нам в создании этого цифрового АКТИВА? Вот как начать:",
        "steps": [
          "Клонуйте репозиторий:<br/>```bash<br/>git clone <https://github.com/xAI/BrainMessenger.git> # Приклад<br/>cd BrainMessenger<br/>```",
          "Встановіть залежності:<br/>```bash<br/>npm install # Turborepo встановить залежності для всіх пакетів<br/>```",
          "Настройте змінні середовища: Скопіюйте `.env.example` до `.env` та заповніть необхідні дані для інтеграцій (Neon, R2, Firebase тощо). <strong>Не комітьте ваш файл `.env`!</strong><br/>```bash<br/>cp .env.example .env<br/># Заповніть .env<br/>```",
          "Настройте базу данных: Запустіть локальний PostgreSQL или используйте екземпляр Neon, затем примените миграции Prisma.<br/>```bash<br/>cd backend<br/>npx prisma migrate dev --name initial_setup # Або npx prisma migrate deploy для продакшену<br/>cd ..<br/>```",
          "Запустіть сервіси в режимі розробки:<br/>```bash<br/>turbo run dev # Це запустить dev-сервери бекенду та фронтенду<br/># Або перейдіть до конкретних пакетів та запустіть їхні dev-скрипти:<br/># cd backend && npm run start:dev<br/># cd packages/web && npm run dev<br/># cd packages/mobile-desktop && npm run android / npm run windows<br/>```"
        ],
        "outro": "Більш детальні інструкції щодо локального налаштування та розробки можна знайти в <a href=\"link_to_development_guide_doc\" target=\"_blank\" rel=\"noopener noreferrer\">Посібнику з Розробки</a>."
      },
      "documentationSystem": {
        "title": "Документація: Наша Система Знань",
        "intro": "Цей README надає загальний огляд. Вся детальна інформація про проект міститься в нашій <strong>комплексній системі документації</strong>. Вивчення цих документів є частиною процесу <strong>навчання</strong> (Принцип 1) та розуміння <strong>системи</strong> (Принцип 9):",
        "links": [
          "<a href=\"docs/AllRequirements/Docs/Planning/DocReq.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Документація Вимог</strong></a>: Що ми будуємо (функціональні та нефункціональні вимоги).",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocDevIn.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Посібник з Розробки</strong></a>: Як ми пишемо код (структура, стандарти, інструменти, процес CI/CD).",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocTech.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Технічна Документація</strong></a>: Загальний огляд архітектури та стеку.",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocSpec.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Специфікація API</strong></a>: Як взаємодіють компоненти (опис GraphQL API).",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocInt.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Документація Інтеграцій</strong></a>: Як ми використовуємо зовнішні сервіси (Neon, R2, Firebase, Stripe тощо) як <strong>важелі</strong>.",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocSecurity.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Посібник з Безпеки</strong></a>: Як ми захищаємо АКТИВ та дані (принципи, методи, інструменти, процес).",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocPer.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Посібник з Продуктивності</strong></a>: Як ми робимо систему швидкою (метрики, техніки, інструменти оптимізації).",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocMonLog.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Посібник з Моніторингу та Логування</strong></a>: Як ми бачимо стан системи (метрики, логи, сповіщення).",
          "<a href=\"docs/AllRequirements/Docs/Design/Design/DocUI.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Документація UI</strong></a>: Як виглядає додаток и чому (макети, компоненти, принципи дизайну).",
          "<a href=\"docs/AllRequirements/Docs/Sound/DocSound.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Посібник з Аудіо</strong></a>: Як аудіо використовується для покращення UX.",
          "<a href=\"docs/AllRequirements/Docs/Support/DocSupport.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Посібник з Підтримки та Обслуговування</strong></a>: Як ми підтримуємо систему та користувачів после релізу.",
          "<a href=\"docs/AllRequirements/Docs/Testing/DocSpecError.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Специфікація Помилок</strong></a>: Як ми обробляємо та повідомляємо про помилки.",
          "<a href=\"docs/AllRequirements/Docs/Testing/DocTesting.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Посібник з Тестування</strong></a>: Як ми перевіряємо якість та надійність.",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocMigrationMicro.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>План Міграції Мікросервісів</strong></a>: Наша довгострокова стратегія архітектурної еволюції.",
          "<a href=\"docs/AllRequirements/Docs/Planning/DocReq.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Інструкція з Вимог до MVP</strong></a>: Детальний аналіз вимог до MVP та статус реалізації)."
        ]
      },
      "contribution": {
        "title": "Внесок",
        "content": "Ми вітаємо внески у створення цього цифрового АКТИВУ! Якщо у вас є ідеї, пропозиції або ви хочете допомогти з кодом, будь ласка, зверніться до <a href=\"CONTRIBUTING.md\" target=\"_blank\" rel=\"noopener noreferrer\">Посібника з Внесків</a> (якщо доступний)."
      }
    },
    "design": {
      "title": "Документація Дизайна BrainMessenger",
      "subtitle": "Система Качества и Ценности",
      "section1": {
        "title": "1. Введение: Дизайн как Фундамент Ценности",
        "name": "BrainMessenger Design System",
        "description": "Эта дизайн-система определяет визуальные и функциональные стандарты для интерфейса BrainMessenger. Наша цель — создать интерфейс, который не просто выглядит хорошо, но и является <strong>интуитивно понятным, эффективным и доступным</strong> (Принцип 2: Создание Ценности), опираясь на принципы <strong>качества > количества</strong> (Принцип 3) и <strong>прагматизма</strong> (Принцип 12) в выборе решений.",
        "goal": "Обеспечить <strong>единообразие, надежность и позитивный пользовательский опыт</strong> на всех платформах (Windows, Android, веб), делая BrainMessenger <strong>полезным АКТИВОМ</strong> (Принцип 10) для пользователей.",
        "principles_title": "Принципы, которыми руководствуется дизайн:",
        "principles": [
          "<strong>Создание Ценности (Принцип 2):</strong> Дизайн должен быть функциональным и решать задачи пользователя максимально удобно и эффективно.",
          "<strong>Качество > Количество (Принцип 3):</strong> Фокус на отточенности ключевых элементов, а не на множестве непродуманных деталей. Дизайн должен быть <strong>надежным</strong> и <strong>продуманным</strong>.",
          "<strong>Прагматизм и Реализм (Принцип 12):</strong> Выбор дизайнерских решений, реализуемых с учетом технических ограничений (например, оптимизация анимаций).",
          "<strong>Целостность (Принцип 7):</strong> Визуальная и функциональная целостность на всех платформах.",
          "<strong>Здоровье как Фундамент (Принцип 5):</strong> Внимание к доступности (WCAG), чтобы дизайн не создавал излишней нагрузки (зрительной, когнитивной) на пользователя."
        ]
      },
      "section2": {
        "title": "2. Цветовая палитра: Визуальный язык BrainMessenger",
        "intro": "Цвета разделены для Light и Dark режимов, поддерживая переключение темы (функция \"Night Mode\"). Все цвета заданы в HEX.",
        "light_mode_title": "2.1. Light Mode",
        "light_mode_table": [
          ["Категория", "Цвет (HEX)", "Назначение"],
          ["<strong>Primary Gradient</strong>", "`#A7F43A` → `#00C853`", "Основной градиент для акцентных элементов (кнопки \"Get Started\", иконки)"],
          ["<strong>Accent</strong>", "`#FF6347`", "Акцентные элементы (ошибки, важные сообщения)"],
          ["<strong>Secondary", "`#00BFFF`", "Второстепенные кнопки, ссылки"],
          ["<strong>Success</strong>", "`#96C93D`", "Подтверждение, успешные действия"],
          ["<strong>Background</strong>", "`#1A1A1A`", "Основной фон"],
          ["<strong>Surface</strong>", "`#333333`", "Карточки, панели, фоны сообщений"],
          ["<strong>Text Primary</strong>", "`#FFFFFF`", "Основной текст"],
          ["<strong>Text Secondary", "`#D9E8D9`", "Вторичный текст, подсказки"],
          ["<strong>Disabled</strong>", "`#4D4D4D`", "Неактивные элементы"],
          ["<strong>Border</strong>", "`#B0B0B0`", "Границы, разделители"]
        ],
        "premium_colors_title": "2.3. Цвета Премиум-Функций (Визуальное выделение Ценности)",
        "premium_colors": [
          "<strong>Premium Accent:</strong> `#FFD600` (Золотой)",
          "<strong>Premium Secondary:</strong> `#2196F3` (Синий)",
          "Используются для визуального выделения премиум-функций (например, в анимациях нейронных связей, специальных элементах UI), подчеркивая их <strong>дополнительную ценность</strong> (Принцип 2, 10)."
        ],
        "color_application_title": "2.4. Применение Цветов (Примеры)",
        "color_application": [
          {
            "title": "Welcome Screen (со скриншота):",
            "items": [
              "Фон: `#1A1A1A` (Dark Mode).",
              "Кнопка \"Get Started\": Градиент `#F2F047` → `#1ED94F`.",
              "Иконка чата: `#F2F047` (обводка) с белым символом внутри.",
            "Текст: `#FFFFFF` (Welcome to Brain Messenger), `#D9E8D9` (подсказка)."
            ]
          },
          {
            "title": "Переключение темы:",
            "items": [
              "Реализовано через глобальный флаг `themeMode` (`Light`/`Dark`).",
              "Пример в React Native:\n```jsx\nimport { useColorScheme } from 'react-native';\nconst themeMode = useColorScheme() === 'dark' ? 'Dark' : 'Light';\nconst backgroundColor = themeMode === 'Dark' ? '#1A1A1A' : '#FFFFFF'; // Пример выбора фона\n```"
            ]
          }
        ],
        "usage_recommendations_title": "2.5. Рекомендации по Использованию Цветов",
        "usage_recommendations": [
          "<strong>Градиенты:</strong> Используйте `#A7F43A` → `#00C853` или `#F2F047` → `#1ED94F` (в зависимости от темы) для ключевых действий и акцентных элементов, привлекающих внимание к <strong>ценности</strong> (Принцип 2).",
          "<strong>Темная тема:</strong> Используйте `#1A1A1A` или `#212121` как основной фон для снижения нагрузки на глаза (связь с Принципом 5: Здоров'я).",
          "<strong>Контраст:</strong> Всегда проверяйте контрастность текста и элементов для обеспечения <strong>доступности</strong> (WCAG 2.1 AA) и соответствия Принципу 7 (Целостность). Используйте инструменты вроде WebAIM Contrast Checker."
        ]
      },
      "section3": {
        "title": "3. Типографика: Читабельность как Основа Эффективности",
        "intro": "Выбор шрифта и его применение базируются на обеспечении максимальной читабельности и доступности, что является критически важным для эффективного усвоения информации и снижения когнитивной нагрузки (связь с Принципом 5: Здоров'я и Принципом 2: Ценность).",
        "primary_font_title": "3.1. Основной шрифт",
        "primary_font": [
          "<strong>Семейство:</strong> Roboto (Google Fonts)",
          "<strong>Запасной:</strong> Sans-serif",
          "<strong>Причина:</strong> Высокая читабельность на разных размерах экрана, широкая поддержка символов (мультиязычность), открытая лицензия и доступность."
        ],
        "sizes_styles_title": "3.2. Размеры и стили (Шкала для Иерархии)",
        "sizes_styles_table": [
          ["Уровень", "Размер", "Начертание", "Использование"],
          ["H1 (Заголовок)", "24px", "Bold", "Основные заголовки экранов (например, \"Чаты\")"],
          ["H2 (Подзаголовок)", "18px", "Medium", "Второстепенные заголовки, названия групп"],
          ["Body", "16px", "Regular", "Основной текст сообщений, список чатов"],
          ["Caption", "14px", "Regular", "Подписи под фото, время сообщений, дрібний текст"],
          ["Button", "16px", "Medium", "Текст кнопок дій"]
        ],
        "notes_title": "Примітки:",
        "notes": [
          "<strong>Висота рядка (Line Height):</strong> Мінімум 1.5 для основного тексту для покращення читабельності.",
          "<strong>Кастомизация (Принцип 2):</strong> Пользователь может выбрать альтернативный шрифт в настройках (например, Open Sans) для адаптации под свои предпочтения.",
          "<strong>Доступность:</strong> Соблюдение контраста и минимального размера шрифта для соответствия WCAG."
        ]
      },
      "section4": {
        "title": "4. Анімації: Оптимізація та Сенс (Принцип 12: Прагматизм)",
        "intro": "Анімації в BrainMessenger використовуються для покращення користувацького досвіду, надання візуального зворотного зв'язку та надання інтерфейсу жвавості. Однак вони мають бути <strong>прагматичними, оптимізованими</strong> (<2 ГБ RAM), і <strong>не створювати зайвого навантаження</strong> (зв'язок з Принципом 5: Здоров'я).",
        "principles_title": "4.1. Принципи Анімацій",
        "principles": [
          "<strong>Смысл:</strong> Каждая анимация должна иметь четкую цель – объяснить переход, привлечь внимание к важному, подтвердить действие.",
          "<strong>Плавность:</strong> Использование `ease-in-out` или `ease-out` для натурального движения.",
          "<strong>Оптимизация:</strong> Анимации не должны замедлять интерфейс или споживать много ресурсов. Тривалість підібрана для балансу между плавностью и скоростью.",
          "<strong>Доступность:</strong> Избегание слишком быстрых или мигающих анимаций, которые могут вызвать дискомфорт или приступы у чувствительных пользователей."
        ],
        "list_title": "4.2. Список Анімацій (Примеры)",
        "list_table": [
          ["Название", "Описание", "Триггер", "Параметры", "Связь с Принципами", "Кольоры (Light/Dark)"],
          ["Переключение слайдов", "Сдвиг слайдов (Welcome Screen)", "Свайп/клик по стрелке", "0.3 сек, slide left/right", "P2 (Онбординг)", "#96C93D / #96C93D"],
          ["Открытие чата", "Чат появляется снизу вверх", "Клик по чату в списке", "0.3 сек, ease-in-out", "P2 (Навигация)", "#00BFFF / #00BFFF"],
          ["Нажатие кнопки", "Визуальный фидбек при клике (уменьшение)", "Клик по кнопке", "0.2 сек, scale", "P2 (Фидбек)", "Градиент #F2F047→#1ED94F"],
          ["Отправка сообщения", "Сообщение появляется с плавным появлением", "Клик \"Отправить\"", "0.3 сек, fade-in", "P2 (Фидбек)", "#96C93D / #96C93D"],
          ["Переход между экранами", "Сдвиг экрана вправо/влево (базовая навигация)", "Навигация", "0.3 сек, slide", "P2 (Навигация)", "#B0B0B0 / #4D4D4D"],
          ["Анимация иконок (Morph)", "Преобразование иконки (например, mute → unmute)", "Клик (переключение состояния)", "0.4 сек, morph", "P2 (Состояние)", "#FF6347 / #FF6347"],
          ["Волны при нажатии (Ripple)", "Радиальные волны от точки нажатия (фидбек)", "Клик по кнопке/элементу", "0.3 сек, ripple", "P2 (Фидбек)", "#F2F047 / #F2F047"],
          ["Глитч-эффект (Premium)", "Искажение текста для премиум (визуализация)", "Активация подписки", "0.2 сек, glitch", "P2, P10 (Выделение)", "#FF6347 / #FF6347"],
          ["Нейронные связи (Premium)", "Пульсирующие линии (визуализация Актива)", "Премиум-экран", "0.5 сек, pulse", "P2, P10 (Выделение)", "#96C93D / #96C93D"]
        ],
        "implementation_examples_title": "4.3. Примеры Реализации (Фрагменты кода)",
        "css_ripple_title": "CSS для Ripple-эффекта:",
        "css_ripple_code": ".ripple {\\n  background: linear-gradient(45deg, #F2F047, #1ED94F); /* Або інші кольори/градієнт */\\n  border-radius: 50%;\\n  animation: ripple 0.3s ease-out;\\n}\\n@keyframes ripple {\\n  to { transform: scale(2); opacity: 0; }\\n}",
        "rn_icon_title": "React Native для анімованої іконки:",
        "rn_icon_code": "import Animated from 'react-native-reanimated'; // Пример библиотеки\\nimport Icon from 'react-native-vector-icons/MaterialIcons'; // Пример библиотеки\\n\\nconst color = themeMode === 'Dark' ? '#FFFFFF' : '#333333';\\n// Створення анімованого компонента Icon\\nconst AnimatedIcon = Animated.createAnimatedComponent(Icon);\\n\\n// Пример использования с анимацией scale (припускаючи, что 'scale' - это Animated.Value)\\n<AnimatedIcon name=\\\"volume-up\\\" color={color} style={{ transform: [{ scale: scale }] }} />"
      },
      "section5": {
        "title": "5. Вирівнювання та Сітка: Структура та Порядок (Принцип 9: Система)",
        "intro": "Використання послідовної системи вирівнювання та модульної сітки — это основа для создания <strong>системного, легко подтримуваемого и визуально гармоничного</strong> интерфейса (Принцип 9: Система).",
        "base_grid": "<strong>Базовая Сітка:</strong> 8px (базовый шаг для определения размеров элементов, отступов, интервалов). Все значения должны быть кратны 8 (или 4 для очень мелких элементов).",
        "alignment_title": "<strong>Вирівнювання:</strong>",
        "alignment": [
          "Используется принцип <strong>визуальной иерархии</strong>: более важные элементы располагаются выше или визуально доминируют.",
          "<strong>Вертикальный поток:</strong> Контент на экранах организуется сверху вниз: Заголовок → Поле ввода → Кнопка действия.",
          "<strong>Горизонтальное выравнивание:</strong> Элементы в контейнерах выравниваются по левому краю (для LTR) или правому краю (для RTL), если нет необходимости в центрировании (например, заголовки в шапке).",
          "<strong>Отступы (Padding/Margin):</strong> Используются значения из шкалы, кратной 8px (8, 16, 24, 32, 40, 48 px и т.д.) для создания четких интервалов между элементами и группами элементов."
        ],
        "adaptability_title": "<strong>Адаптивність та Респонсивність:</strong>",
        "adaptability": [
          "Дизайн адаптируется под различные размеры экрана для обеспечения <strong>ценности</strong> (Принцип 2) на любом устройстве.",
          "<strong>Мобільні пристрої:</strong> 320px–767px (Обычно одноколоночный макет).",
          "<strong>Планшеты:</strong> 768px–1023px (Возможно, двухколоночный макет, боковые панели).",
          "<strong>Десктоп:</strong> 1024px+ (Широкий макет, многоколоночный дизайн, боковые панели)."
        ]
      },
      "section6": {
        "title": "6. Принципи Доступності (WCAG 2.1 AA): Дизайн для Всіх (Принцип 5: Здоров'я, Принцип 7: Цілісність)",
        "intro": "<strong>Доступність — это не опция, а фундаментальное требование</strong> (схоже с Принципом 5: Здоров'я как Фундамент) для создания <strong>целостного</strong> (Принцип 7) и <strong>ценного</strong> (Принцип 2) продукта, которым могут пользоваться все, независимо от их способностей или используемых технологий. Мы стремимся соответствовать уровню WCAG 2.1 AA.",
        "principles": [
          "<strong>Контрастность Кольорів:</strong> Текстовые элементы должны иметь минимальный контраст 4.5:1 (для обычного текста) и 3:1 (для крупного текста или иконок) по отношению к фону. Это проверяется для обеих тем (Light/Dark).",
          "<strong>Навігація з Клавіатури:</strong> Все интерактивные элементы (кнопки, посилання, поля ввода) должны быть доступны для навигации с помощью клавиатуры (Tab, Shift+Tab) и активации (Enter, Space).",
          "<strong>Підтримка Екранних Читалок (Screen Readers):</strong> Использование семантической разметки (HTML) и ARIA-атрибутов для предоставления контекста и информации пользователям экранных читалок (например, описания для иконок, состояния элементов).",
          "<strong>Візуальний Индикатор Фокуса:</strong> Для пользователей клавиатуры должен быть четкий и видимый индикатор текущего сфокусированного элемента (например, синяя обводка `#007BFF`).",
          "<strong>Обробка Помилок:</strong> Сообщения об ошибках должны быть четкими, понятными и легко определяемыми пользователями, включая пользователей экранных читалок.",
          "<strong>Підтримка RTL (Справа Налево):</strong> Дизайн адаптируется для языков с направлением письма справа налево (например, арабский), включая зеркальное отображение макета, иконок и текста (см. DocLocIn.md)."
        ]
      },
      "section7": {
        "title": "7. Примітки та Рекомендації",
        "notes": [
          "<strong>Кастомизация Пользователем:</strong> Помните, что некоторые аспекты дизайна (цвета чатов, шрифты) пользователь может изменять в настройках. Дизайн системы должен учитывать эту гибкость.",
          "<strong>Тестирование на Реальных Устройствах:</strong> Все компоненты дизайна необходимо тестировать на разнообразных устройствах, с различными разрешениями экрана и в разных условиях освещения, чтобы убедиться в их эффективности и доступности.",
          "<strong>Живая Документация:</strong> Эта дизайн-система — живой документ. Она будет дополняться новыми компонентами, шаблонами и рекомендациями по мере развития продукта, отражая принципы <strong>непрерывного совершенствования</strong> (Принцип 1) и <strong>системного подхода</strong> (Принцип 9).",
          "<strong>Дизайн как часть Процесса Кайдзен:</strong> Дизайн-решения анализируются и улучшаются на основе обратной связи и реального использования, интегрируясь в общий процесс Кайдзен (Принцип 9, 14)."
        ]
      }
    },
    "localizationGuide": {
      "title": "Руководство по Локализации BrainMessenger",
      "subtitle": "Доступность и Масштабирование",
      "section1": {
        "title": "1. Введение: Расширение Ценности через Доступность",
        "name": "BrainMessenger Design System",
        "description": "Это руководство описывает процесс локализации BrainMessenger — ключевой шаг для обеспечения доступности и ценности (Принцип 2) продукта для широкой аудитории по всему миру. Мы рассматриваем локализацию не просто как перевод строк, а как систематический процесс (Принцип 9) адаптации интерфейса и контента, который позволит нам масштабировать наше влияние (Принцип 2, 8).",
        "goal": "Сделать BrainMessenger понятным и удобным для пользователей из разных культур, начиная с базового набора языков и создавая надежную систему (Принцип 9) для легкого добавления новых в будущем.",
        "current_status": "Базовая поддержка английского языка (MVP). Идет планирование и подготовка к добавлению новых языков в рамках текущих этапов разработки (см. Дорожную карту).",
        "principles_title": "Принципы, которыми руководствуется локализация:",
        "principles": [
          "Создание Ценности (Принцип 2): Локализация напрямую повышает ценность продукта для неанглоязычных пользователей.",
          "Система и Оптимизация (Принцип 9): Процесс локализации строится как четкая, повторяемая система для эффективности.",
          "Прагматизм и Реализм (Принцип 12): Выбор начального набора языков основывается на потенциальном охвате и ресурсах.",
          "Внешняя Экспертиза и Обратная Связь (Принцип 14): Привлечение профессиональных переводчиков и сбор обратной связи от пользователей на разных языках."
        ]
      },
      "section2": {
        "title": "2. Цели Локализации",
        "goals": [
          "Обеспечить поддержку минимум 5 ключевых языков (Английский, Испанский, Французский, Русский, Арабский) для старта MVP — (Требование NFR-11, соответствующее Принципу 12: Прагматизм).",
          "Реализовать адаптацию пользовательского интерфейса для языков с направлением письма справа налево (RTL), таких как арабский (Принцип 2: Доступность).",
          "Поддерживать единообразие терминологии и стиля во всех переводах, используя централизованные инструменты (Принцип 9: Система).",
          "Создать эффективный и простой процесс добавления новых языков по мере роста базы пользователей и поступления запросов (Принцип 9: Масштабирование, Принцип 12: Прагматизм, Принцип 14: Обратная связь)."
        ]
      },
      "section3": {
        "title": "3. Инструменты и Технологии: Надежный Фундамент (Принцип 8, 9)",
        "intro": "Выбор инструментов основан на прагматизме (Принцип 12), надежности и поддержке системного подхода (Принцип 9).",
        "tools_table": [
          ["Инструмент", "Назначение", "Установка/Конфигурация"],
          ["i18next", "Основная библиотека для управления переводами в Frontend (React Native). Поддерживает интерполяцию, контексты.", "npm install i18next react-i18next"],
          ["react-intl", "Библиотека для локализованного форматирования дат, чисел, валют в Frontend.", "npm install react-intl"],
          ["Transifex", "Профессиональная платформа для управления переводами, привлечения переводчиков и обеспечения качества перевода.", "Регистрация на transifex.com"],
          ["rtlcss", "Утилита для автоматической трансформации CSS-стилей для поддержки RTL-языков.", "npm install -g rtlcss (глобально) или npm install rtlcss --save-dev"],
          ["JSON файлы", "Формат хранения переводов.", "Стандартный."]
        ]
      },
      "section4": {
        "title": "4. Структура Файлов Переводов: Порядок в Системе (Принцип 9)",
        "intro": "Переводы организованы в четкой файловой структуре для удобства управления (Принцип 9: Система).",
        "location_title": "4.1. Расположение",
        "location_content": "Файлы переводов хранятся в директории locales внутри frontend/src:\\n\\nfrontend/\\n├── src/\\n│ ├── locales/\\n│ │ ├── en.json # Английский (базовый)\\n│ │ ├── es.json # Испанский\\n│ │ ├── fr.json # Французский\\n│ │ ├── ru.json # Русский\\n│ │ ├── ar.json # Арабский (пример RTL)\\n│ └── index.ts # Конфигурация i18next",
        "format_title": "4.2. Формат JSON: Контекст и Гибкость",
        "format_content": "Ключи: Используется camelCase. Ключи должны быть описательными и отражать контекст использования строки (например, sendButton вместо просто send).\\n\\nЗначения: Содержат переводимый текст. Поддерживается интерполяция для вставки динамических данных (например, имена пользователей).",
        "format_example": "Пример en.json:\\n\\n```json\\n{\\n  \\\"welcomeTitle\\\": \\\"Welcome to BrainMessenger!\\\",\\n  \\\"sendButton\\\": \\\"Send\\\",\\n  \\\"errors\\\": {\\n    \\\"unauthorized\\\": \\\"Please log in again to continue.\\\",\\n    \\\"notFound\\\": \\\"The requested item could not be found.\\\"\\n  },\\n  \\\"chat\\\": {\\n    \\\"newMessageNotification\\\": \\\"New message from {{name}}\\\",\\n    \\\"unreadCount\\\": \\\"{{count}} unread messages\\\"\\n  },\\n  \\\"settings\\\": {\\n    \\\"language\\\": \\\"Language\\\",\\n    \\\"theme\\\": \\\"Theme\\\"\\n  }\\n}\\n```",
        "rtl_flag_title": "4.3. RTL-флаг: Адаптация Интерфейса",
        "rtl_flag_content": "Для языков с направлением справа налево в начало соответствующего JSON-файла добавляется метаданные для индикации:",
        "rtl_flag_example": "```json\\n{\\n  \\\"rtl\\\": true,\\n  \\\"welcomeTitle\\\": \\\"مرحبًا بك في BrainMessenger!\\\"\\n  // ... остальные переводы\\n}\\n```\\n\\nЭтот флаг используется Frontend-приложением для соответствующей адаптации стилей и макета."
      },
      "section5": {
        "title": "5. Настройка Локализации: Интеграция в Систему (Принцип 9)",
        "intro": "Локализация интегрируется как в Frontend (для отображения переведенного UI), так и в Backend (для возврата локализованных ошибок или уведомлений).",
        "frontend_title": "5.1. Frontend (React Native): Использование i18next",
        "frontend_init_title": "Инициализация i18next:",
        "frontend_init_code": "В главном файле приложения или файла конфигурации (frontend/src/index.ts или подобном):\\n\\n```jsx\\nimport i18n from 'i18next'\\nimport { initReactI18next } from 'react-i18next'\\n\\n// Импорт всех файлов локалей\\nimport en from './locales/en.json'\\nimport es from './locales/es.json'\\nimport fr from './locales/fr.json'\\nimport ru from './locales/ru.json'\\nimport ar from './locales/ar.json'\\n\\n// Определение ресурсов\\nconst resources = {\\n  en: { translation: en },\\n  es: { translation: es },\\n  fr: { translation: fr },\\n  ru: { translation: ru },\\n  ar: { translation: ar },\\n};\\n\\ni18n\\n  .use(initReactI18next) // Подключение react-i18next\\n  .init({\\n    resources,\\n    lng: 'en', // Язык по умолчанию при первом запуске (может определяться по системным настройкам или выбору пользователя)\\n    fallbackLng: 'en', // Резервный язык, если текущий перевод отсутствует\\n    interpolation: {\\n      escapeValue: false // Позволяет использовать HTML теги в переводах (осторожно!)\\n    }\\n  });\\n\\nexport default i18n;\\n```",
        "frontend_usage_title": "Использование перевода в компонентах:",
        "frontend_usage_code": "Используйте хук useTranslation для доступа к функции t и объекту i18n.\\n\\n```jsx\\nimport { useTranslation } from 'react-i18next';\\nimport { Text, Button, View } from 'react-native';\\n\\nconst WelcomeScreen = () => {\\n  const { t, i18n } = useTranslation(); // Получаем функцию t и объект i18n\\n\\n  return (\\n    <View>\\n      {/* Использование простого перевода */}\\n      <Text>{t('welcomeTitle')}</Text>\\n      \\n      {/* Использование перевода с интерполяцией */}\\n      {/* Предполагается, что где-то есть состояние unreadCount */}\\n      <Text>{t('chat.unreadCount', { count: 5 })}</Text> \\n\\n      {/* Использование перевода для текста кнопки */}\\n      <Button title={t('sendButton')} onPress={sendMessage} />\\n      \\n      {/* Пример смены языка */}\\n      <Button title={t('settings.language')} onPress={() => i18n.changeLanguage('ar')} />\\n    </View>\\n  );\\n};\\n```",
        "frontend_change_title": "Смена языка:",
        "frontend_change_content": "Язык меняется вызовом i18n.changeLanguage('код_языка'). Обычно это делается в настройках пользователя.",
        "backend_title": "5.2. Backend (NestJS): Локализация Ошибок и Уведомлений",
        "backend_intro": "Backend может возвращать локализованные сообщения об ошибках или уведомления, опираясь на язык, переданный Frontend (например, в заголовке Accept-Language или настройках пользователя).",
        "backend_code": "Использование локализованных сообщений при выбрасывании ошибок:\\n\\n```typescript\\nimport { HttpException, HttpStatus }n from '@nestjs/common';\\nimport { t } from 'i18next'; // Предполагается, что i18next инициализирован и в Backend\\n\\n// В сервисе или контроллере\\nif (!user) {\\n  // Определяем язык пользователя (например, из request.headers['accept-language'])\\n  const userLang = determineUserLanguage(request); \\n  throw new HttpException(t('errors.unauthorized', { lng: userLang }), HttpStatus.UNAUTHORIZED);\\n}\\n```",
        "backend_note": "Локаль пользователя определяется из заголовка Accept-Language (стандартный подход) или сохраняется в профиле пользователя в базе данных после его выбора в настройках приложения.",
        "rtl_adaptation_title": "5.3. RTL-адаптация (Справа Налево): Зеркальное Отображение Системы",
        "rtl_adaptation_intro": "Для языков с RTL (арабский, иврит и др.) необходимо зеркально отобразить макет и некоторые элементы интерфейса.",
        "rtl_css_title": "Стили (CSS/CSS-in-JS):",
        "rtl_css_code": "Используйте rtlcss в процессе сборки или условные стили в коде. rtlcss автоматически преобразует свойства вроде margin-left, padding-right, text-align: left и т.п. в их RTL-эквиваленты (margin-right, padding-left, text-align: right).\\n\\n```css\\n/* Исходный CSS для LTR */\\n.message-bubble {\\n  margin-left: 10px;\\n  text-align: left;\\n}\\n/* После обработки rtlcss для RTL */\\n.message-bubble {\\n  margin-right: 10px;\\n  text-align: right;\\n}\\n```",
        "rtl_rn_title": "React Native:",
        "rtl_rn_code": "React-Native имеет встроенную поддержку RTL через I18nManager.\\n\\n```jsx\\nimport { I18nManager } from 'react-native';\\nimport i18n from './index'; // Ваш файл инициализации i18next\\n\\n// В главном файле приложения, перед рендером\\nconst isRTL = i18n.language === 'ar' || i18n.language === 'he'; // Проверяем, является ли текущий язык RTL\\n\\n// ForceRTL может потребовать перезагрузки приложения для полной силы\\nif (isR1L !== I18nManager.isRTL) {\\n  I18nManager.forceRTL(isRTL);\\n  // Optional: Restart the app to apply RTL layout fully\\n  // RNRestart.Restart(); \\n}\\n\\n// Некоторые стили могут требовать ручной адаптации, если auto-conversion недостаточно\\nconst containerStyle = {\\n  flexDirection: isRTL ? 'row-reverse' : 'row',\\n  textAlign: isRTL ? 'right' : 'left',\\n};\\n```",
        "rtl_icons_title": "Иконки:",
        "rtl_icons_content": "Некоторые иконки (например, стрелки \"назад\", \"далее\") должны быть зеркально отображены для RTL. Это можно делать условно в коде или использовать RTL-ready наборы иконок."
      },
      "section6": {
        "title": "6. Процесс Добавления Нового Языка: Масштабируемая Система (Принцип 9)",
        "intro": "Процесс добавления нового языка построен как четкая, повторяемая последовательность действий для обеспечения эффективности (Принцип 9).",
        "file_title": "Создание базового файла перевода:",
        "file_content": "Скопируйте актуальный en.json (или другой наиболее полный файл) в frontend/src/locales/<code>.json, где <code> — двухбуквенный код нового языка (например, de.json для немецкого).\\nДобавьте rtl: true в начало файла, если новый язык RTL.",
        "transifex_title": "Загрузка на платформу переводов (Transifex):",
        "transifex_content": "Загрузите новый файл <code>.json в проект BrainMessenger на Transifex. Система автоматически определит, какие строки нуждаются в переводе.",
        "process_title": "Организация процесса перевода:",
        "process_content": "Назначьте переводчиков (профессионалов или проверенных участников сообщества, Принцип 14) для нового языка в Transifex.\\nОтвечайте на их вопросы по контексту строк.\\nКонтролируйте прогресс перевода в Transifex.",
        "export_title": "Экспорт и Интеграция перевода:",
        "export_content": "После завершения перевода экспортируйте готовый файл <code>.json из Transifex.\\nПоместите его обратно в директорию frontend/src/locales/.\\nИмпортируйте новый ресурс в файле инициализации i18next (frontend/src/index.ts) и добавьте его в объект resources.",
        "ui_title": "Добавление опции выбора языка в UI:",
        "ui_content": "Добавьте новый язык в список доступных языков в разделе \"Настройки\" > \"Язык\".",
        "testing_title": "Тестирование:",
        "testing_intro": "Критически важный шаг (Принцип 3: Качество). Переключите язык в настройках приложения.",
        "testing_scenarios": [
          "Корректность перевода всех строк в UI.",
          "Отсутствие обрезки текста (некоторые языки длиннее английского).",
          "Корректное отображение UI для RTL-языков (зеркальность, выравнивание).",
          "Интерполяция и Форматирование: Проверьте экраны, где используются динамические данные (имена, счетчики, даты, числа), убедитесь, что они форматируются правильно для текущей локали.",
          "Локализованные ошибки: Инициируйте различные ошибки (неправильный логин, отсутствие элемента), проверьте, что сообщения об ошибках приходят на выбранном языке."
        ]
      },
      "section7": {
        "title": "7. Поддерживаемые Языки (Начальный Список и План)",
        "intro": "Начальный список языков, выбранный по прагматическим соображениям (Принцип 12) и потенциальному охвату.",
        "languages_table": [
          ["Код", "Язык", "Направление", "Статус", "План (Q 2025)"],
          ["en", "Английский", "LTR", "Реализован (Базовый)", "-"],
          ["es", "Испанский", "LTR", "В плане (Q3)", "Q3"],
          ["fr", "Франглийский", "LTR", "В плане (Q3)", "Q3"],
          ["ru", "Русский", "LTR", "В плане (Q3)", "Q3"],
          ["ar", "Арабский", "RTL", "В плане (Q3, требуется RTL)", "Q3"]
        ],
        "expansion_note": "Расширение списка: Новые языки будут добавляться на основе обратной связи (Принцип 14) и анализа потенциальной ценности (Принцип 2) для роста аудитории (например, если >10% запросов о поддержке нового языка)."
      },
      "section8": {
        "title": "8. Рекомендации: Лучшие Практики Локализации",
        "dev_title": "8.1. Для Разработчиков (Пишем Код, Готовый к Миру)",
        "dev_points": [
          "Не хардкодьте строки! Все строки, которые видит пользователь, должны быть вынесены в файлы локализации и использоваться через функцию t('ключ') (Принцип 9: Система).",
          "Используйте интерполяцию для строк с переменными данными (t('chat.newMessageNotification', { name: user.name })), а не конкатенацию строк в коде.",
          "Учитывайте плюрализацию (формы единственного/множественного числа) при работе со счетчиками ({{count}} unread messages). i18next и react-intl поддерживают это.",
          "Используйте react-intl для всех операций с датами, числами, валютами, чтобы их формат был корректным для каждой локали (Принцип 3: Качество, Принцип 2: Ценность).",
          "Тестируйте UI с длинными переводами (например, немецкий, который часто длиннее английского) и RTL-языками, чтобы убедиться, что макет не ломается и текст не обрезается (Принцип 3: Качество)."
        ],
        "design_title": "8.2. Для Дизайнеров (Рисуем Макеты, Гибкие к Языкам)",
        "design_points": [
          "Учитывайте, что текст на других языках может быть на 30% (и более) длиннее английского. Оставляйте достаточно пространства в компонентах.",
          "Проектируйте макеты с учетом зеркального отображения для RTL. Иконки направлений, расположение текста и элементов должны меняться (Принцип 2: Доступность)."
        ],
        "translator_title": "8.3. Для Переводчиков (Создаем Понятный Контент)",
        "translator_points": [
          "Сохраняйте контекст. Одно и то же английское слово может переводиться по-разному в зависимости от того, где оно используется (например, \"Send\" для сообщения или для заявки). Платформы вроде Transifex помогают добавлять контекстные комментарии.",
          "Придерживайтесь последовательной терминологии, используйте глоссарий, если он есть.",
          "Сохраняйте тон приложения (дружелюбный, но профессиональный, особенно в системных сообщениях и ошибках).",
          "Используйте возможности интерполяции и плюрализации в файлах перевода."
        ]
      },
      "section9": {
        "title": "9. Форматирование (Даты, Числа, Валюты): Детали, Создающие Качество (Принцип 3)",
        "intro": "Корректное отображение локализованных данных критически важно для качества (Принцип 3) и удобства (Принцип 2).",
        "dates_title": "Даты и Время:",
        "dates_code": "```jsx\\nimport { FormattedDate, FormattedTime } from 'react-intl';\\n\\n// Отобразит дату в формате, соответствующем текущей локали\\n<FormattedDate value={new Date()} /> // Например, \\\"3/14/2025\\\" (en-US) или \\\"14.3.2025\\\" (de-DE)\\n<FormattedDate value={new Date()} weekday=\\\"long\\\" year=\\\"numeric\\\" month=\\\"long\\\" day=\\\"numeric\\\" /> // \\\"Friday, March 14, 2025\\\"\\n\\n// Отобразит время\\n<FormattedTime value={new Date()} /> // Например, \\\"3:00:00 PM\\\" (en-US) или \\\"15:00:00\\\" (de-DE)\\n```",
        "numbers_title": "Числа и Валюты:",
        "numbers_code": "```jsx\\nimport { FormattedNumber, FormattedCurrency } from 'react-intl';\\n\\n// Отобразит число с локальным разделителем тысяч и десятичным знаком\\n<FormattedNumber value={1234.56} /> // \\\"1,234.56\\\" (en-US) или \\\"1.234,56\\\" (de-DE)\\n\\n// Отобразит число как процент\\n<FormattedNumber value={0.75} style=\\\"percent\\\" /> // \\\"75%\\\"\\n\\n// Отобразит число как валюту (требует кода валюты)\\n<FormattedCurrency value={123.45} currency=\\\"USD\\\" /> // \\\"$123.45\\\" (en-US)\\n```\\n\\nДля работы с react-intl необходимо обернуть ваше приложение в IntlProvider и загрузить соответствующие данные локали (react-intl/locale-data)."
      },
      "section10": {
        "title": "10. Тестирование Локализации: Гарантия Качества (Принцип 3, 9)",
        "intro": "Тестирование — неотъемлемая часть системы обеспечения качества (Принцип 3, 9).",
        "scenarios_title": "Сценарии Тестирования:",
        "scenarios_points": [
          "Переключение языка: Убедитесь, что смена языка в настройках мгновенно (или после перезапуска, если требуется I18nManager) применяет новый перевод и RTL-макет.",
          "Отображение всех строк: Проверьте основные экраны и диалоги, чтобы убедиться, что все видимые пользователю строки переведены.",
          "Длинный текст: Проверьте UI с языками, известными своей длиной (например, немецкий, который часто длиннее английского) и RTL-языками, чтобы убедиться, что текст не обрезается, элементы не накладываются друг на друга.",
          "RTL-интерфейс: Тщательно проверьте UI на арабском (или другом RTL-языке): направление текста, выравнивание элементов, отображение иконок направлений, положение скроллбаров.",
          "Интерполяция и Форматирование: Проверьте экраны, где используются динамические данные (имена, счетчики, даты, числа), убедитесь, что они форматируются правильно для текущей локали.",
          "Локализованные ошибки: Инициируйте различные ошибки (неправильный логин, отсутствие элемента), проверьте, что сообщения об ошибках приходят на выбранном языке."
        ]
      },
      "tools_title": "Инструменты:",
      "tools_points": [
        "Ручное тестирование: Основной метод. Тестирование на реальных устройствах с разными локалями.",
        "Автоматизированные тесты (Cypress/detox): Можно написать тесты, которые проверяют наличие определенных ключей перевода на странице или даже делают скриншоты UI для сравнения LTR/RTL макетов (Принцип 9: Система)."
      ],
      "criteria_title": "Критерии Успеха Тестирования:",
      "criteria_points": [
        "100% пользовательских строк переведены.",
        "Отсутствие обрезки или наложения текста в UI.",
        "Корректное и полное RTL-отображение для соответствующих языков.",
        "Правильное локализованное форматирование дат, чисел, валют."
      ]
    },
    "section11": {
      "title": "11. Примечания",
      "notes": [
        "План: Полная реализация поддержки 5 ключевых языков запланирована на Q3 2025 (см. Дорожную карту), после завершения этапа построения технологического фундамента и начала разработки MVP.",
        "Масштабирование: Система разработана так, чтобы добавление новых языков в будущем было эффективным (Принцип 9). Основные затраты — это сам перевод.",
        "Ограничения: Технические логи, сообщения сервера для отладки не переводятся. Локализация касается только пользовательского интерфейса и сообщений, предназначенных для конечного пользователя."
      ]
    }
  },
  "integrationsGuide": {
    "title": "Документация Интеграций BrainMessenger",
    "subtitle": "Построение Надежной Системы с Внешними Рычагами",
    "introduction": {
      "title": "1. Введение: Интеграции как Часть Фундамента Системы",
      "description": "Этот документ описывает, как BrainMessenger интегрируется с ключевыми внешними сервисами. Мы выбираем эти интеграции <strong>прагматично</strong> (Принцип 12), рассматривая их как <strong>рычаги</strong> (принцип Маргулана), которые позволяют нам не изобретать колесо, а использовать <strong>надежные и масштабируемые</strong> (Принцип 8, 9) сторонние решения для ускорения разработки и обеспечения <strong>качества</strong> (Принцип 3) нашего продукта. Эти интеграции являются неотъемлемой частью нашего <strong>технологического фундамента</strong> (Принцип 8).",
      "principlesTitle": "Принципы, которыми руководствуется выбор и настройка интеграций:",
      "principles": [
        "<strong>Система и Оптимизация (Принцип 9):</strong> Интеграции должны быть частью единой, хорошо продуманной системы, где каждый компонент выполняет свою роль эффективно.",
        "<strong>Прагматизм и Реализм (Принцип 12):</strong> Выбор сервисов с учетом текущих потребностей, бюджета (бесплатные/доступные тарифы на старте) и простоты интеграции.",
        "<strong>Долгосрочное Мышление (Принцип 8):</strong> Выбор сервисов, способных масштабироваться вместе с ростом проекта.",
        "<strong>Качество > Количество (Принцип 3):</strong> Фокус на надежности и производительности интеграций, даже если их список на старте небольшой.",
        "<strong>Создание Ценности (Принцип 2):</strong> Каждая интеграция должна добавлять реальную ценность для конечного пользователя (например, надежное хранение файлов, мгновенные уведомления)."
      ]
    },
    "overview": {
      "title": "2. Обзор Ключевых Интеграций: Наши Внешние Компоненты Системы",
      "table": [
        ["Сервис", "Назначение", "Роль в BrainMessenger", "Основные функции", "Связь с Принципами"],
        ["<strong>Neon</strong>", "Управляемый PostgreSQL БД", "Хранение всех <strong>структурированных данных</strong> (пользователи, чаты, сообщения, метаданные файлов). Фундамент данных.", "Хостинг PostgreSQL, масштабирование, доступ через строку подключения.", "P8 (Долгосрочное), P9 (Система), P12 (Прагматизм - бесплатный тариф)."],
        ["<strong>Cloudflare R2</strong>", "Облачное Хранилище (S3-совместимое)", "Хранение всех <strong>неструктурированных данных</strong> (файлы пользователей, аватарки, записи звонков, зашифрованные метаданные). Хранилище Активов.", "Надежное хранение объектов, CDN-доставка, отсутствие платы за исходящий трафик.", "P8 (Долгосрочное), P10 (Активы), P12 (Прагматизм - бесплатный тариф, нет платы за трафик), P3 (Качество - CDN)."],
        ["<strong>Firebase</strong>", "Push-уведомления", "Мгновенная доставка уведомлений пользователям на мобильные устройства.", "Отправка push-уведомлений (FCM).", "P2 (Ценность - информирование), P9 (Система - надежная доставка), P12 (Прагматизм - готовое решение)."],
        ["<strong>Stripe</strong>", "Платежная Система", "Обработка платежей за Premium-подписку. Доступ к платежам как к рычагу создания Ценности/Богатства.", "Прием платежей, управление подписками.", "P2 (Ценность - премиум), P10 (Богатство/Активы), P9 (Система - автоматизация платежей)."],
        ["<strong>Gmail API</strong>", "Сервис отправки email", "Отправка критически важных email (коды подтверждения для регистрации и 2FA).", "Отправка транзакционных email.", "P3 (Качество - надежная доставка email), P9 (Система - часть аутентификации), P5 (Здоровье - безопасность пользователя)."]
        ]
      },
      "neonIntegration": {
        "title": "3. Интеграция с Neon: Фундамент Структурированных Данных",
        "generalInfo": {
          "title": "3.1. Общая Информация",
          "description": "Neon предоставляет управляемый сервис PostgreSQL. Мы используем его как <strong>основное хранилище структурированных данных</strong>, таких как информация о пользователях, чатах, сообщениях и метаданных файлов.",
          "advantages": [
            "<strong>Прагматизм (P12):</strong> Бесплатный тариф на старте (30 ГБ) полностью покрывает начальные потребности.",
            "<strong>Система и Долгосрочное Мышление (P9, P8):</strong> Управляемый сервис снижает операционную нагрузку, автоматическое масштабирование и репликация доступны на платных планах, обеспечивая готовность к росту.",
            "<strong>Качество (P3):</strong> Надежность и производительность PostgreSQL как проверенной СУБД."
          ],
          "role": "Роль: Ядро, к которому обращается Backend для всех CRUD-операций над метаданными."
        },
        "configuration": {
          "title": "3.2. Конфигурация: Подключение к Системе Данных",
          "steps": [
            "1. <strong>Регистрация и Создание Проекта:</strong>",
            "Создайте аккаунт на `https://neon.tech`.",
            "Создайте новый проект (например, `brainmessenger-prod`) в консоли Neon.",
            "2. <strong>Настройка Базы Данных:</strong>",
            "Neon автоматически предоставляет инстанс PostgreSQL.",
            "<strong>Примените схему базы данных:</strong> Используйте Prisma Migrate для инициализации структуры таблиц (см. `database/schema.prisma` и Руководство по разработке).",
            "3. <strong>Переменные Окружения:</strong>",
            "Получите <strong>строку подключения</strong> (Connection Details) из консоли Neon (Settings → Connection Details).",
            "Добавьте в ваш `.env` файл:"
          ],
          "envExample": "```env\\n# Строка подключения к базе данных Neon\\nDATABASE_URL=postgresql://<user>:<password>@<neon-host>/<dbname>?sslmode=require\\n```",
          "note1": "*Примечание:* Используйте `sslmode=require` для безопасного соединения.",
          "backendCode": "4. <strong>Подключение Backend (NestJS + Prisma):</strong>\\nPrisma использует `DATABASE_URL` для подключения. Убедитесь, что Prisma Client сгенерирован (`npx prisma generate`).\\nИспользуйте `PrismaService` (из `nestjs-prisma`) для всех операций с БД.\\n```typescript\\n// backend/src/app.module.ts (или db.module.ts)\\nimport { Module } from '@nestjs/common';\\nimport { PrismaService } from 'nestjs-prisma'; // Убедитесь, что PrismaModule импортирован в app.module\\n\\n@Module({\\n  providers: [PrismaService], // PrismaService доступен для инъекции\\n  exports: [PrismaService],\\n})\\nexport class DbModule {}\\n```"
        },
        "interactionScenarios": {
          "title": "3.3. Методы и Сценарии Взаимодействия: API Данных",
          "description": "Все взаимодействия с Neon происходят через Prisma ORM в Backend, что обеспечивает <strong>типизацию, безопасность и системность</strong> (Принцип 3, 9).",
          "signup": {
            "title": "Сценарий: Регистрация пользователя:",
            "interaction": "<strong>Взаимодействие:</strong> Backend получает данные пользователя → Использует `PrismaService` для создания новой записи в таблице `users`.",
            "code": "<strong>Пример кода (Backend Service):</strong>\\n```typescript\\n// backend/src/auth/auth.service.ts\\nimport { Injectable } from '@nestjs/common';\\nimport { PrismaService } from 'nestjs-prisma';\\nimport { Prisma } from '@prisma/client'; // Импорт типов Prisma\\n\\n@Injectable()\\nexport class AuthService {\\n  constructor(private prisma: PrismaService) {}\\n\\n  async signUp(data: Prisma.UserCreateInput) {\\n    // Пример: пароль должен быть захэширован ДО сохранения\\n    const hashedPassword = await hashPassword(data.password); // Использование утилиты для хэширования\\n    return this.prisma.user.create({\\n      data: {\\n        email: data.email,\\n        name: data.name,\\n        password: hashedPassword, // Сохраняем захэшированный пароль\\n        // ... другие поля по схеме\\n      },\\n    });\\n  }\\n}\\n```",
            "result": "<strong>Результат:</strong> Данные пользователя надежно сохранены в Neon."
          },
          "getChats": {
            "title": "Сценарий: Получение списка чатов пользователя:",
            "interaction": "<strong>Взаимодействие:</strong> Frontend запрашивает чаты через GraphQL API → Backend использует `PrismaService` для выполнения запроса к таблице `chats` (возможно, с фильтрацией по `userId` и `include` для метаданных).",
            "code": "<strong>Пример кода (Backend Service):</strong>\\n```typescript\\n// backend/src/chat/chat.service.ts\\nimport { Injectable } from '@nestjs/common';\\nimport { PrismaService } from 'nestjs-prisma';\\n\\n@Injectable()\\nexport class ChatService {\\n  constructor(private prisma: PrismaService) {}\\n\\n  async getUserChats(userId: string) {\\n    // Используем индексы @@index([userId]) для оптимизации (Принцип 9, Оптимизация)\\n    return this.prisma.chat.findMany({\\n      where: {\\n        users: { // Предполагается связь Many-to-Many с таблицей UserChat\\n          some: {\\n            userId: userId,\\n          },\\n        },\\n      },\\n      select: { // Выбираем только необходимые поля (Принцип 9, Оптимизация)\\n        id: true,\\n        name: true,\\n        type: true,\\n        // ... другие нужные поля\\n      },\\n      orderBy: { // Сортировка по дате последнего сообщения для актуальности (Принцип 2, Ценность)\\n        lastMessageAt: 'desc',\\n      },\\n    });\\n  }\\n}\\n```"
          },
          "saveMessage": {
            "title": "Сценарий: Сохранение сообщения:",
            "interaction": "<strong>Взаимодействие:</strong> Пользователь отправляет сообщение → Frontend отправляет его через GraphQL API → Backend использует `PrismaService` для создания новой записи в таблице `messages`, связывая ее с `chatId` и `userId`.",
            "code": "<strong>Пример кода (Backend Service):</strong>\\n```typescript\\n// backend/src/message/message.service.ts\\nimport { Injectable } from '@nestjs/common';\\nimport { PrismaService } from 'nestjs-prisma';\\nimport { Prisma } from '@prisma/client';\\n\\n@Injectable()\\nexport class MessageService {\\n  constructor(private prisma: PrismaService) {}\\n\\n  async createMessage(data: Prisma.MessageCreateInput) {\\n    // Используем транзакцию, если нужно обновить дату последнего сообщения в чате\\n    return this.prisma.$transaction(async (tx) => {\\n      const message = await tx.message.create({ data });\\n      await tx.chat.update({\\n        where: { id: data.chatId },\\n        data: { lastMessageAt: message.createdAt }, // Обновляем время последнего сообщения\\n      });\\n      return message;\\n    });\\n  }\\n}\\n```"
          }
        },
        "errorHandling": {
          "title": "3.4. Обработка Ошибок Интеграции: Поддержание Качества Системы",
          "description": "Надежная система должна уметь обрабатывать ошибки внешних зависимостей (Принцип 3: Качество).",
          "connectionError": {
            "title": "Connection Error:",
            "cause": "Причина: Невозможно установить соединение с Neon. Неверная строка подключения (`DATABASE_URL`), проблемы с сетью, недоступность сервиса Neon.",
            "solution": "Решение: Проверить переменную окружения `DATABASE_URL`, статус сервиса Neon. Логировать ошибку на Backend (Sentry/Winston)."
          },
          "queryError": {
            "title": "Database Query Error:",
            "cause": "Причина: Ошибка выполнения запроса к БД (например, нарушение уникальности, неверный тип данных). Ошибка в логике Backend, несоответствие схемы БД.",
            "solution": "Решение: Отладить запрос в Backend, проверить логи Prisma. Логировать ошибку."
          },
          "rateLimitError": {
            "title": "Rate Limit Exceeded (на платных тарифах):",
            "cause": "Причина: Превышены лимиты на количество запросов или вычислительные ресурсы в Neon. Высокая нагрузка, неоптимизированные запросы, недостаточный тарифный план.",
            "solution": "Решение: Оптимизировать запросы (см. Руководство по оптимизации), рассмотреть переход на более высокий тарифный план Neon."
          }
        }
      },
      "r2Integration": {
        "title": "4. Интеграция с Cloudflare R2: Хранилище Цифровых Активов",
        "generalInfo": {
          "title": "4.1. Общая Информация",
          "description": "Cloudflare R2 — это сервис объектного хранилища, совместимый с S3 API. Мы используем его для хранения <strong>всех файлов пользователей</strong>, таких как изображения, видео, документы, а также зашифрованные данные.",
          "advantages": [
            "<strong>Прагматизм (P12), Создание Богатства/Активов (P10):</strong> <strong>Отсутствие платы за исходящий трафик</strong> — критически важное преимущество для мессенджера, где пользователи активно обмениваются файлами. Бесплатный тариф 10 ГБ на старте.",
            "<strong>Качество (P3):</strong> Высокая производительность и надежность благодаря глобальной сети Cloudflare.",
            "<strong>Долгосрочное Мышление (P8), Система (P9):</strong> S3-совместимый API позволяет легко использовать стандартные библиотеки и инструменты, обеспечивая гибкость в будущем."
          ],
          "role": "Роль: Децентрализованное хранилище для крупных бинарных объектов, снижающее нагрузку на основную базу данных."
        },
        "configuration": {
          "title": "4.2. Конфигурация: Подключение к Хранилищу Активов",
          "steps": [
            "1. <strong>Создание Бакета:</strong>",
            "Войдите в Cloudflare Dashboard → R2.",
            "Нажмите <strong>\"Create Bucket\"</strong>.",
            "Назовите бакет (например, `brainmessenger-files`). Название должно быть уникальным в рамках всех аккаунтов Cloudflare.",
            "<strong>Настройки:</strong> Включите шифрование в покое (Encryption at rest) — это часть нашей <strong>системы безопасности</strong> (Принцип 3, 5). Ограничьте публичный доступ к бакету, доступ будет осуществляться через подписанные URL (если требуется) или через Backend.",
            "2. <strong>Ключи Доступа:</strong>",
            "В Cloudflare Dashboard перейдите в R2 → Manage R2 API Tokens.",
            "Создайте новый API-токен. Предоставьте ему минимально необходимые разрешения (например, Read and Write to specific buckets).",
            "Скопируйте `Access Key ID` и `Secret Access Key`.",
            "3. <strong>Переменные Окружения:</strong>",
            "Добавьте в ваш `.env` файл:"
          ],
          "envExample": "```env\\n# Cloudflare R2 Credentials\\nR2_ENDPOINT=<Your R2 Endpoint> # Формат: https://<account-id>.r2.cloudflarestorage.com\\nR2_ACCESS_KEY=<Your Access Key ID>\\nR2_SECRET_KEY=<Your Secret Access Key>\\nR2_BUCKET=brainmessenger-files # Название вашего бакета\\n\\n# Ключ шифрования для конфиденциальных данных (важно для P3, P5, P10)\\nENCRYPTION_KEY=<Your 32-byte (256-bit) hex or base64 encryption key> # Сгенерируйте надежный ключ!\\n```",
          "note": "*Примечание:* <strong>Не коммитьте эти ключи в Git!</strong> (Принцип 3, 5, 6). Используйте `.env.example` без чувствительных данных. <strong>ENCRYPTION_KEY</strong> должен быть сгенерирован надежно и храниться в безопасности.",
          "backendCode": "4. <strong>Подключение Backend (`@aws-sdk/client-s3`):</strong>\\nR2 совместим с S3 API, поэтому можно использовать стандартный AWS SDK для S3.\\nУстановите SDK: `npm install @aws-sdk/client-s3`.\\nИнициализируйте S3 Client в вашем Backend-сервисе (например, `StorageService`).\\n```typescript\\n// backend/src/storage/storage.service.ts\\nimport { Injectable } from '@nestjs/common';\\nimport { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3';\\nimport { getSignedUrl } from '@aws-sdk/s3-request-presigner'; // Для подписанных URL\\nimport { createCipheriv, randomBytes, createDecipheriv } from 'crypto'; // Для шифрования\\n\\n@Injectable()\\nexport class StorageService {\\n  private r2: S3Client;\\n  private encryptionKey: Buffer; // Ключ для шифрования\\n\\n  constructor() {\\n    this.r2 = new S3Client({\\n      region: 'auto', // R2 не использует регионы в классическом понимании\\n      endpoint: process.env.R2_ENDPOINT,\\n      credentials: {\\n        accessKeyId: process.env.R2_ACCESS_KEY,\\n        secretAccessKey: process.env.R2_SECRET_KEY,\\n      },\\n    });\\n    // Важно: ENCRYPTION_KEY должен быть Buffer 32 байт для aes-256-cbc\\n    this.encryptionKey = Buffer.from(process.env.ENCRYPTION_KEY, 'hex'); // Или 'base64'\\n    if (this.encryptionKey.length !== 32) {\\n         // Логировать ошибку или выбросить исключение - ключ неверной длины\\n         console.error(\\\"Invalid ENCRYPTION_KEY length. Must be 32 bytes for aes-256-cbc.\\\");\\n         // process.exit(1); // Возможно, стоит остановить приложение\\n    }\\n  }\\n\\n  // Утилита для шифрования (часть системы безопасности - P3, P5)\\n  private encrypt(data: string): { encrypted: string, iv: string } {\\n    const iv = randomBytes(16); // Initialization Vector, 16 байт для aes-256-cbc\\n    const cipher = createCipheriv('aes-256-cbc', this.encryptionKey, iv);\\n    let encrypted = cipher.update(data, 'utf8', 'hex');\\n    encrypted += cipher.final('hex');\\n    return { encrypted, iv: iv.toString('hex') };\\n  }\\n\\n  // Утилита для дешифрования\\n  private decrypt(encrypted: string, iv: string): string {\\n      const decipher = createDecipheriv('aes-256-cbc', this.encryptionKey, Buffer.from(iv, 'hex'));\\n      let decrypted = decipher.update(encrypted, 'hex', 'utf8');\\n      decrypted += decipher.final('utf8');\\n      return decrypted;\\n  }\\n\\n  // ... методы для работы с R2 (загрузка, скачивание, удаление)\\n}\\n```"
        },
        "interactionScenarios": {
          "title": "4.3. Методы и Сценарии Взаимодействия: API Хранилища",
          "description": "Взаимодействие с R2 осуществляется через Backend, что позволяет контролировать доступ, обрабатывать файлы (например, оптимизация изображений перед загрузкой) и управлять метаданными в БД (Принцип 9: Система).",
          "uploadFile": {
            "title": "Сценарий: Загрузка файла пользователем:",
            "interaction": "<strong>Взаимодействие:</strong> Пользователь прикрепляет файл в чате → Frontend отправляет файл на Backend → Backend (`StorageService`) загружает файл в R2 → Backend сохраняет метаданные файла (URL, тип, размер) в Neon → Backend отправляет сообщение в чат с ссылкой на файл.",
            "code": "<strong>Пример кода (Backend Service):</strong>\\n```typescript\\n// backend/src/storage/storage.service.ts (продолжение)\\n// ... S3Client и encryptionKey инициализация ...\\n\\nasync uploadFile(fileBuffer: Buffer, fileName: string, mimeType: string): Promise<string> {\\n  const key = `uploads/${Date.now()}-${fileName}`; // Уникальный ключ файла\\n  const params = {\\n    Bucket: process.env.R2_BUCKET,\\n    Key: key,\\n    Body: fileBuffer,\\n    ContentType: mimeType, // Важно для отдачи файла\\n  };\\n  const command = new PutObjectCommand(params);\\n  await this.r2.send(command); // Асинхронная загрузка\\n\\n  // Возвращаем URL для сохранения в БД. R2 позволяет прямые ссылки, если настроен публичный домен.\\n  // ИЛИ генерируем подписанный URL для ограниченного доступа (более безопасно).\\n  // Пример прямой ссылки (требует настройки Public Access URL в CF Dashboard):\\n  // const publicUrl = `${process.env.R2_ENDPOINT.replace('.r2.cloudflarestorage.com', '.r2.dev')}/${process.env.R2_BUCKET}/${key}`;\\n  // Для своего домена (предпочтительно):\\n  const fileUrl = `https://r2.brainmessenger.com/${key}`; // Ваш настроенный домен Cloudflare Workers/Pages\\n\\n  return fileUrl;\\n}\\n\\n//backend/src/chat/chat.service.ts (интеграция uploadFile)\\n// ... constructor с StorageService ...\\nasync sendFileMessage(chatId: string, userId: string, file: Express.Multer.File): Promise<Message> {\\n   // Опционально: обработка изображения перед загрузкой (см. DocOptimizationIn)\\n   // const processedFileBuffer = await this.imageProcessingService.processImage(file.buffer, 800, 600); // Пример\\n   const fileUrl = await this.storageService.uploadFile(file.buffer, file.originalname, file.mimetype);\\n\\n   // Создаем сообщение в БД со ссылкой на файл\\n   return this.prisma.message.create({\\n     data: {\\n       chatId,\\n       userId,\\n       content: '[File]', // Или другое обозначение файла\\n       fileUrl: fileUrl, // Сохраняем ссылку на файл в БД\\n       // fileMetadata: { type: file.mimetype, size: file.size }, // Опционально: сохранение метаданных в JSON поле или отдельной таблице\\n     },\\n   });\\n}\\n```",
            "result": "<strong>Результат:</strong> Файл надежно хранится в R2, ссылка на него доступна в БД для отображения в чате."
          },
          "sensitiveData": {
            "title": "Сценарий: Хранение конфиденциальных данных (например, зашифрованные метаданные):",
            "interaction": "<strong>Взаимодействие:</strong> При регистрации или обновлении профиля Backend шифрует чувствительные данные (например, резервные email, секретные вопросы) и сохраняет их в R2 в отдельном бакете или папке.",
            "code": "<strong>Пример кода (Backend Service):</strong>\\n```typescript\\n// backend/src/storage/storage.service.ts (продолжение)\\n// ... методы encrypt/decrypt ...\\n\\nasync storeSensitiveData(userId: string, sensitiveInfo: any): Promise<string> {\\n   const encryptedData = {};\\n   for (const key in sensitiveInfo) {\\n       if (sensitiveInfo.hasOwnProperty(key)) {\\n           const { encrypted, iv } = this.encrypt(JSON.stringify(sensitiveInfo[key])); // Шифруем каждое поле или весь объект\\n           encryptedData[key] = { encrypted, iv };\\n       }\\n   }\\n\\n   const key = `sensitive/${userId}/metadata.json`;\\n   const params = {\\n       Bucket: process.env.R2_BUCKET, // Или отдельный бакет для чувствительных данных\\n       Key: key,\\n       Body: JSON.stringify(encryptedData),\\n       ContentType: 'application/json',\\n   };\\n   const command = new PutObjectCommand(params);\\n   await this.r2.send(command);\\n   return `https://r2.brainmessenger.com/${key}`; // Ссылка для внутреннего использования\\n}\\n\\n// backend/src/user/user.service.ts (интеграция storeSensitiveData)\\n// ... constructor с StorageService ...\\nasync createUserWithSensitiveData(userData: any, sensitiveData: any) {\\n    // Создаем пользователя в БД\\n    const user = await this.prisma.user.create({ data: userData });\\n    // Сохраняем зашифрованные данные в R2\\n    const sensitiveDataUrl = await this.storageService.storeSensitiveData(user.id, sensitiveData);\\n    // Сохраняем ссылку на зашифрованные данные в БД (опционально)\\n    await this.prisma.user.update({\\n        where: { id: user.id },\\n        data: { sensitiveDataUrl: sensitiveDataUrl } // Добавить поле sensitiveDataUrl в схему Prisma\\n    });\\n    return user;\\n}\\n```",
            "result": "<strong>Результат:</strong> Конфиденциальные данные надежно зашифрованы и хранятся отдельно от основной БД в R2. Доступ к ним возможен только через Backend с использованием ключа шифрования."
          },
          "getFile": {
            "title": "Сценарий: Получение файла (для отображения или скачивания):",
            "interaction": "<strong>Взаимодействие:</strong> Frontend получает URL файла из метаданных сообщения (из Neon) → Frontend (или Backend, если требуется аутентификация/подписанные URL) использует этот URL для скачивания файла напрямую из R2.",
            "code": "<strong>Реализация:</strong> Если бакет R2 настроен с Public Access URL (через Cloudflare Workers/Pages), Frontend может обращаться напрямую. Если доступ ограничен, Backend может генерировать временные подписанные URL через `@aws-sdk/s3-request-presigner`.\\n```typescript\\n// backend/src/storage/storage.service.ts (продолжение)\\n// ... S3Client инициализация ...\\n\\n// Метод для генерации подписанного URL (более безопасный подход для приватных файлов)\\nasync getSignedFileUrl(fileKey: string): Promise<string> {\\n    const command = new GetObjectCommand({\\n        Bucket: process.env.R2_BUCKET,\\n        Key: fileKey,\\n    });\\n    // Сгенерировать подписанный URL, действительный, например, 60 секунд\\n    const signedUrl = await getSignedUrl(this.r2, command, { expiresIn: 60 });\\n    return signedUrl;\\n}\\n```"
          }
        },
        "errorHandling": {
          "title": "4.4. Обработка Ошибок Интеграции: Хранилище Активов",
          "forbidden": {
            "title": "403 Forbidden:",
            "cause": "Причина: Ошибка доступа к бакету R2. Неверные ключи доступа (`R2_ACCESS_KEY`, `R2_SECRET_KEY`), неверные разрешения токена, попытка доступа к приватному файлу без аутентификации/подписанного URL.",
            "solution": "Решение: Проверить переменные окружения, разрешения токена R2. Убедиться, что логика доступа (публичный URL vs подписанный URL) реализована корректно. Логировать ошибку."
          },
          "notFound": {
            "title": "404 Not Found:",
            "cause": "Причина: Файл отсутствует в R2. Неверный ключ файла (`Key`), файл был удален.",
            "solution": "Решение: Проверить ключ файла, который был сохранен в Neon. Убедиться, что файл действительно был загружен. Логировать ошибку."
          },
          "tooManyRequests": {
            "title": "429 Too Many Requests:",
            "cause": "Причина: Превышен лимит запросов к R2 API. Высокая частота запросов загрузки/скачивания.",
            "solution": "Решение: Внедрить Rate Limiting на Backend (см. Руководство по оптимизации). Оптимизировать логику работы с файлами."
          },
          "encryptionError": {
            "title": "Encryption/Decryption Error:",
            "cause": "Причина: Ошибка шифрования/дешифрования. Неверный ключ шифрования (`ENCRYPTION_KEY`), поврежденный IV, поврежденные зашифрованные данные.",
            "solution": "Решение: Убедиться, что используется правильный ключ (`ENCRYPTION_KEY`), который совпадает с ключом, использованным при шифровании. Проверить целостность данных и IV. Логировать критическую ошибку."
          }
        }
      },
      "neonR2Interaction": {
        "title": "5. Взаимодействие Neon и Cloudflare R2: Оптимизация Хранения Данных (Принцип 9, 12)",
        "description": "Мы используем Neon и R2 совместно, чтобы создать оптимизированную систему хранения данных, где каждый сервис выполняет свою лучшую функцию (Принцип 9).",
        "scenario": [
          "<strong>Neon (PostgreSQL):</strong> Хранит <strong>структурированные метаданные</strong>, которые часто запрашиваются и по которым выполняются сложные запросы (пользователи, чаты, текстовые сообщения, ссылки на файлы).",
          "<strong>Cloudflare R2:</strong> Хранит <strong>неструктурированные бинарные данные</strong> большого размера (файлы), которые реже запрашиваются и не требуют сложной логики выборки по содержимому).",
          "<strong>Сценарий комплексного взаимодействия:</strong>",
          "1. Пользователь отправляет файл через чат (Frontend -> Backend).",
          "2. Backend (`StorageService`) <strong>загружает файл в Cloudflare R2</strong> (используя S3 API). Получает URL файла (или ключ).",
          "3. Backend (`ChatService`) <strong>сохраняет метаданные сообщения в Neon через Prisma</strong>, включая полученный URL/ключ файла.",
          "4. Когда другой пользователь открывает чат, Backend (`ChatService`) <strong>получает список сообщений из Neon через Prisma</strong>, включая URL/ключи файлов.",
          "5. Frontend отображает список сообщений и использует URL/ключи для <strong>скачивания файлов напрямую из R2</strong> (или через Backend, если требуется аутентификация)."
        ],
        "advantagesTitle": "Преимущества такого разделения:",
        "advantages": [
          "<strong>Оптимизация производительности БД:</strong> PostgreSQL не \"засоряется\" большими бинарными данными, что улучшает скорость текстовых запросов (Принцип 9).",
          "<strong>Снижение стоимости:</strong> R2 предлагает очень выгодные тарифы для хранения больших объемов данных без платы за исходящий трафик, что <strong>прагматично</strong> (Принцип 12) и способствует созданию <strong>актива</strong> (Принцип 10).",
          "<strong>Масштабируемость:</strong> Каждый сервис масштабируется независимо в соответствии со своим типом нагрузки (Neon для транзакций, R2 для объема/трафика файлов).",
          "<strong>Надежность:</strong> Разделение ответственности между сервисами повышает общую отказоустойчивость системы."
        ]
      },
      "otherIntegrations": {
        "title": "6. Другие Интеграции: Расширение Функционала Системы (Принцип 2, 12)",
        "description": "Эти интеграции добавляют <strong>ценность</strong> (Принцип 2) и используют <strong>прагматичные, готовые решения</strong> (Принцип 12).",
        "firebase": {
          "title": "6.1. Firebase (Push-уведомления)",
          "purpose": "Назначение: Мгновенная доставка уведомлений о новых сообщениях, звонках и системных событиях пользователям мобильных приложений.",
          "role": "Роль: <strong>Критически важный компонент системы уведомлений</strong> (Принцип 9) для поддержания вовлеченности пользователей и оперативного информирования (Принцип 2).",
          "configuration": "Конфигурация: Переменная окружения: `FIREBASE_CREDENTIALS_PATH` (путь к JSON-файлу учетных данных сервисного аккаунта Firebase). <strong>Храните этот файл безопасно!</strong>",
          "example": "Используется библиотека `firebase-admin` в Backend NestJS. Пример использования: Отправка уведомления при получении нового сообщения (см. Руководство по оптимизации для батчинга и тем)."
        },
        "stripe": {
          "title": "6.2. Stripe (Платежи)",
          "purpose": "Назначение: Обработка подписок на Premium-функционал BrainMessenger.",
          "role": "Роль: <strong>Финансовый рычаг</strong> для поддержки развития проекта (Принцип 10: Создание Богатства) и предоставления дополнительной <strong>ценности</strong> (Принцип 2) премиум-пользователям.",
          "configuration": "Конфигурация: Переменная окружения: `STRIPE_SECRET_KEY`.",
          "example": "Используется библиотека `stripe` в Backend NestJS. Пример использования: Создание сессии оплаты при попытке оформить подписку. Обработка вебхуков для подтверждения успешной оплаты."
        },
        "gmailApi": {
          "title": "6.3. Gmail API (Отправка Email)",
          "purpose": "Назначение: Отправка транзакционных email, таких как коды подтверждения для регистрации и двухфакторной аутентификации (2FA), уведомления о сбросе пароля.",
        "role": "Роль: <strong>Критически важный компонент системы аутентификации и безопасности</strong> (Принцип 9, 5).",
          "configuration": "Конфигурация: Требует настройки сервисного аккаунта Google Cloud и получения учетных данных (см. Техническую документацию, раздел 10.1). Переменные окружения для учетных данных сервисного аккаунта или API-ключей.",
          "example": "Пример использования: Вызов API для отправки письма с кодом подтверждения после ввода email при регистрации или включении 2FA (см. Спецификацию API, раздел 2.4)."
        }
      },
      "recommendations": {
        "title": "7. Рекомендации по Интеграциям: Поддержание Здоровья Системы (Принцип 3, 5, 9)",
        "intro": "Чтобы интеграции оставались <strong>надежными, безопасными и эффективными</strong> (Принцип 3, 9), следуйте этим рекомендациям, связанным с поддержанием \"здоровья\" системы (Принцип 5, применительно к технике):",
        "security": {
          "title": "Безопасность:",
          "points": [
            "<strong>Никогда не коммитьте ключи и секреты в Git.</strong> Используйте переменные окружения и системы управления секретами в продакшен-окружении (например, Kubernetes Secrets, HashiCorp Vault).",
            "Регулярно проводите <strong>ротацию API-токенов</strong> (R2, Firebase, Gmail, Stripe) для повышения безопасности.",
            "Используйте <strong>принцип минимальных привилегий</strong> при создании API-токенов: давайте им только те разрешения, которые действительно необходимы."
          ]
        },
        "scaling": {
          "title": "Масштабирование:",
          "points": [
            "<strong>Мониторьте использование ресурсов</strong> (место в Neon/R2, запросы к API Firebase/Stripe) через консоли соответствующих сервисов. Будьте готовы перейти на платный тариф при росте нагрузки (Принцип 8, 12).",
            "Используйте <strong>оптимизационные подходы</strong> (например, батчинг запросов к Firebase, индексирование в Neon, см. Руководство по оптимизации), чтобы отложить необходимость перехода на более дорогие тарифы."
          ]
        },
        "monitoring": {
          "title": "Мониторинг и Логирование:",
          "points": [
            "Настройте <strong>логирование ошибок интеграций</strong> в NestJS (Winston, Sentry).",
            "Используйте <strong>системы мониторинга</strong> (Prometheus/Grafana) для отслеживания метрик запросов к внешним сервисам (задержки, количество ошибок) — это часть <strong>Кайдзен</strong> (Принцип 9), позволяющая выявлять проблемы на ранней стадии."
          ]
        },
        "errorHandling": {
          "title": "Обработка Ошибок:",
          "points": [
            "Реализуйте <strong>грамотную обработку ошибок</strong> от внешних сервисов на Backend. Логируйте их подробно.",
            "Для критически важных операций (например, регистрация, платежи) предусмотрите механизмы <strong>повторных попыток (retries)</strong> или <strong>компенсирующих действий</strong> (например, отметка платежа как незавершенного) при временных сбоях внешних сервисов."
          ]
        },
        "documentation": {
          "title": "Документация:",
          "content": "Поддерживайте эту документацию в актуальном состоянии, отражая изменения в используемых сервисах или добавлении новых интеграций (Принцип 1: Обучение, Принцип 9: Система)."
        }
      }
    },
    "optimizationGuide": {
      "title": "Руководство по Оптимизации BrainMessenger (Принцип Кайдзен в Действии)",
      "subtitle": "Введение: Оптимизация как Непрерывный Процесс Улучшения",
      "introduction": {
        "title": "1. Введение: Оптимизация как Непрерывный Процесс Улучшения",
        "description": "Этот документ подробно описывает подходы, инструменты и техники, которые мы используем для оптимизации производительности BrainMessenger. Оптимизация — это не одноразовая задача, а <strong>непрерывный процесс улучшения</strong> (Принцип 1, 9: Кайдзен), который позволяет нам обеспечить <strong>высокое качество, надежность и масштабируемость</strong> (Принцип 3, 8) приложения.",
        "goalTitle": "Цель:",
        "goalContent": "Идентифицировать и устранять узкие места в производительности на всех уровнях системы (Frontend, Backend, База данных, Инфраструктура), чтобы BrainMessenger оставался <strong>быстрым, отзывчивым и эффективным</strong> (Принцип 2) даже при значительной нагрузке (цель — 1 миллион активных пользователей), поддерживая <strong>здоровье системы</strong> (Принцип 5, применительно к технике).",
        "audienceTitle": "Аудитория:",
        "audienceContent": "Backend, Frontend, Mobile, Desktop и DevOps разработчики, сфокусированные на производительности и масштабировании.",
        "principlesTitle": "Принципы, которыми руководствуется оптимизация:",
        "principles": [
          "<strong>Система и Оптимизация (Принцип 9: Кайдзен):</strong> Оптимизация является ключевым аспектом нашей системы разработки. Используется цикличный подход: Измерение → Анализ → Улучшение → Проверка.",
          "<strong>Качество > Количество (Принцип 3):</strong> Лучше иметь несколько критически важных оптимизаций, чем много мелких, не дающих значительного эффекта.",
          "<strong>Прагматизм и Реализм (Принцип 12):</strong> Оптимизируем то, что действительно влияет на производительность и пользовательский опыт, основываясь на реальных данных, а не на догадках.",
          "<strong>Постоянное Обучение (Принцип 1):</strong> Изучение новых техник и инструментов оптимизации, анализ результатов и уроков.",
          "<strong>Настойчивость (Принцип 13):</strong> Оптимизация может быть сложной. Требуется упорство для выявления и решения глубоких проблем производительности.",
          "<strong>Здоровье как Фундамент (Принцип 5):</strong> Оптимизация системы (например, снижение потребления памяти/CPU) напрямую влияет на \"здоровье\" серверов и устройств пользователей.",
          "<strong>Внешняя Экспертиза (Принцип 14):</strong> Использование стандартных инструментов (Prometheus, Grafana, V8 Profiler), изучение опыта других команд (Google, Next.js и т.д.)."
        ]
      },
      "generalPrinciple": {
        "title": "2. Общий Принцип Оптимизации (Цикл Кайдзен)",
        "intro": "Наш подход к оптимизации следует <strong>циклу Кайдзен (Принцип 9)</strong>:",
        "step1": {
          "title": "1. Измерение (Measure):",
          "content": "Соберите данные о производительности. Используйте инструменты мониторинга (Prometheus, Sentry), профилирования (V8 Profiler), анализа бандлов (Webpack Bundle Analyzer, `@next/bundle-analyzer`)."
        },
        "step2": {
          "title": "2. Анализ (Analyze):",
          "content": "Определите <strong>узкие места (bottlenecks)</strong> на основе собранных данных. Где система тратит больше всего времени или ресурсов?"
        },
        "step3": {
          "title": "3. Улучшение (Improve):",
          "content": "Примените конкретные техники оптимизации, описанные в этом руководстве, для устранения выявленных узких мест."
        },
        "step4": {
          "title": "4. Проверка (Verify):",
          "content": "Снова измерьте производительность после внесенных изменений. Убедитесь, что оптимизация дала ожидаемый эффект и не вызвала регрессий (не ухудшила другие аспекты)."
        },
        "step5": {
          "title": "5. Повторение:",
          "content": "Производительность может меняться с ростом нагрузки и функционала. Повторяйте цикл Кайдзен непрерывно."
        }
      },
      "imageProcessing": {
        "title": "3. Оптимизация Обработки Изображений: Эффективность и Скорость (Принцип 9, 2)",
        "intro": "Обработка изображений может быть ресурсоемкой. <strong>Оптимизация этого процесса напрямую влияет на скорость загрузки контента и отзывчивость приложения</strong> (Принцип 2: Ценность).",
        "libraryTitle": "Библиотека:",
        "libraryContent": "`sharp` (на базе `libvips`). Выбран как <strong>прагматичное</strong> (Принцип 12) и <strong>высокопроизводительное</strong> (Принцип 9) решение для Node.js.",
        "applicationAreasTitle": "Области применения:",
        "applicationAreasContent": "Изменение размера, сжатие, конвертация формата для аватаров, изображений в чатах.",
        "keyTechniqueTitle": "Ключевая техника:",
        "keyTechniqueContent": "<strong>Асинхронная обработка</strong> в фоновом режиме через Kafka.",
        "implementationStepsTitle": "Шаги по внедрению (Backend):",
        "step1": {
          "title": "1. Установите `sharp`:",
          "content": "Убедитесь, что `libvips` установлен в вашей операционной системе или Docker-образе.",
          "code": "```bash\\nnpm install sharp\\n```"
        },
        "step2": {
          "title": "2. Создайте сервис обработки изображений:",
          "content": "Инкапсулируйте логику в отдельном сервисе (часть <strong>системы</strong> - Принцип 9).",
          "code": "```typescript\\n// backend/src/image-processing/image-processing.service.ts\\nimport { Injectable } from '@nestjs/common';\\nimport sharp from 'sharp';\\n\\n@Injectable()\\nexport class ImageProcessingService {\\n  // Метод для изменения размера, сжатия и конвертации в WebP\\n  async processImage(buffer: Buffer, width: number, height?: number): Promise<Buffer> {\\n    // resize({ width, height, withoutEnlargement: true }) - избегаем увеличения, если исходник меньше\\n    // webp({ quality: 80 }) - сжатие в формат WebP (хорошее сжатие при сохранении качества)\\n    // withMetadata({ orientation: true }) - сохраняем ориентацию из EXIF, остальное удаляем (экономия размера - Принцип 9)\\n    return sharp(buffer)\\n      .resize(width, height, { withoutEnlargement: true })\\n      .webp({ quality: 80 })\\n      .withMetadata({ orientation: true })\\n      .toBuffer();\\n  }\\n\\n  // Метод для простого изменения размера\\n  async resizeImage(buffer: Buffer, width: number, height?: number): Promise<Buffer> {\\n       return sharp(buffer)\\n           .resize(width, height, { withoutEnlargement: true })\\n           .toBuffer();\\n  }\\n\\n   // Метод для конвертации в определенный формат\\n   async convertToFormat(buffer: Buffer, format: keyof sharp.Format): Promise<Buffer> {\\n       return sharp(buffer).toFormat(format).toBuffer();\\n   }\\n}\\n```"
        },
        "step3": {
          "title": "3. Интеграция с загрузкой файлов (Backend Controller/Service):",
          "content": "",
          "code": "```typescript\\n// backend/src/upload/upload.controller.ts (пример обработки загрузки аватара)\\nimport { Controller, Post, UploadedFile, UseInterceptors, Body, Inject } from '@nestjs/common';\\nimport { FileInterceptor } from '@nestjs/platform-express';\\nimport { ImageProcessingService } from '../image-processing/image-processing.service';\\nimport { StorageService } from '../storage/storage.service';\\nimport { UserService } from '../user/user.service';\\n\\n@Controller('upload')\\nexport class UploadController {\\n  constructor(\\n    private imageProcessingService: ImageProcessingService,\\n    private storageService: StorageService,\\n    private userService: UserService,\\n    // ... инъекция Kafka продюсера для асинхронной обработки\\n  ) {}\\n\\n  @Post('avatar')\\n  @UseInterceptors(FileInterceptor('file')) // 'file' - имя поля формы\\n  async uploadAvatar(@UploadedFile() file: Express.Multer.File, @Body('userId') userId: string) {\\n    // Оптимизация: Обработка изображения перед загрузкой в R2\\n    const processedImageBuffer = await this.imageProcessingService.processImage(file.buffer, 300, 300); // Изменить размер и сжать\\n    const fileName = `avatars/${userId}-${Date.now()}.webp`; // Уникальное имя файла в папке avatars\\n    const mimeType = 'image/webp'; // Соответствует формату WebP\\n\\n    // Загрузка обработанного файла в Cloudflare R2\\n    const avatarUrl = await this.storageService.uploadFile(processedImageBuffer, fileName, mimeType);\\n\\n    // Обновление ссылки на аватар в профиле пользователя в Neon\\n    await this.userService.updateUserAvatar(userId, avatarUrl);\\n\\n    // Возвращаем URL аватара клиенту\\n    return { avatarUrl };\\n  }\\n\\n  @Post('chat-image')\\n  @UseInterceptors(FileInterceptor('file'))\\n  async uploadChatImage(@UploadedFile() file: Express.Multer.File, @Body('chatId') chatId: string, @Body('userId') userId: string) {\\n      // Отправка задачи на обработку изображения в Kafka для асинхронной обработки (Принцип 9)\\n      const taskPayload = { fileBuffer: file.buffer.toString('base64'), fileName: file.originalname, mimeType: file.mimetype, chatId, userId };\\n      // Предполагается, что у вас есть Kafka продюсер сервис\\n      // await this.kafkaProducerService.sendMessage('image-processing-topic', JSON.stringify(taskPayload));\\n\\n      // Немедленный ответ клиенту, что файл принят в обработку\\n      return { status: 'processing', originalFileName: file.originalname };\\n\\n      // ИЛИ, если синхронная обработка приемлема для небольших файлов:\\n      /*\\n      const processedImageBuffer = await this.imageProcessingService.processImage(file.buffer, 800); // Изменить размер\\n      const fileName = `chat-images/${chatId}-${Date.now()}.webp`;\\n      const mimeType = 'image/webp';\\n      const imageUrl = await this.storageService.uploadFile(processedImageBuffer, fileName, mimeType);\\n\\n      // Создание сообщения типа 'image' в чате\\n      // await this.chatService.sendImageMessage(chatId, userId, imageUrl);\\n\\n      return { imageUrl };\\n      */\\n  }\\n}\\n```"
        },
        "step4": {
          "title": "4. Асинхронность через Kafka (для тяжелых задач):",
          "content": "Для обработки изображений в чатах (которые могут быть большими) используйте <strong>Kafka</strong> (см. раздел 8) для <strong>асинхронной обработки</strong>. Backend быстро принимает файл от клиента и ставит задачу в очередь Kafka. Отдельный воркер (consumer Kafka) забирает задачу, обрабатывает изображение с помощью `sharp`, загружает в R2 и только после этого создает сообщение в чате через API. Это <strong>снижает время ответа API</strong> (Принцип 9) и улучшает пользовательский опыт."
        }
      },
      "dbOptimization": {
        "title": "4. Оптимизация Базы Данных (Neon/PostgreSQL): Ускорение Доступа к Данным (Принцип 9, 8)",
        "intro": "База данных часто становится узким местом. Оптимизация запросов и структуры БД критически важна для <strong>долгосрочной производительности</strong> (Принцип 8) и <strong>эффективности системы</strong> (Принцип 9).",
        "platformTitle": "Платформа:",
        "platformContent": "Neon (управляемый PostgreSQL).",
        "toolTitle": "Инструмент:",
        "toolContent": "Prisma ORM.",
        "analysisToolTitle": "Инструмент анализа:",
        "analysisToolContent": "`EXPLAIN ANALYZE` в SQL-клиенте Neon или `prisma.queryRaw` с `EXPLAIN ANALYZE`.",
        "monitoringToolTitle": "Инструмент мониторинга:",
        "monitoringToolContent": "Prometheus + `postgres_exporter` (см. раздел 14).",
        "indexing": {
          "title": "4.1. Индексация: Ускорение Поиска и Фильтрации",
          "intro": "Индексы позволяют базе данных быстрее находить нужные строки.",
          "whenTitle": "Когда использовать:",
          "whenContent": "На полях, которые часто используются в `WHERE`, `JOIN`, `ORDER BY`.",
          "applicationAreasTitle": "Области применения в BrainMessenger:",
          "applicationAreasContent": "`userId`, `chatId`, `createdAt` (в таблице `Message`), `email` (в таблице `User`), поля для поиска.",
          "prismaTitle": "Реализация (Prisma):",
          "prismaContent": "Добавляйте `@index` в `schema.prisma`.",
          "prismaCode": "```prisma\\n// schema.prisma\\nmodel Message {\\n  id        String   @id @default(cuid())\\n  content   String\\n  createdAt DateTime @default(now()) @map(\\\"created_at\\\") // Пример @map для snake_case в БД\\n  chatId    String @map(\\\"chat_id\\\")\\n  userId    String @map(\\\"user_id\\\")\\n  chat      Chat     @relation(fields: [chatId], references: [id])\\n  user      User     @relation(fields: [userId], references: [id])\\n\\n  // Комбинированный индекс для быстрых запросов сообщений в чате по времени\\n  @@index([chatId, createdAt])\\n  // Индекс для быстрого получения сообщений по пользователю (например, для статистики)\\n  @@index([userId])\\n  // Индекс для поиска по содержимому (если требуется полнотекстовый поиск - рассмотреть tsearch)\\n  // @@index([content]) // Только для простых фильтров LIKE\\n}\\n\\nmodel User {\\n    id    String @id @default(cuid())\\n    email String @unique // Уникальный индекс для быстрого поиска по email (логин, регистрация)\\n    name  String\\n    // ... другие поля\\n}\\n\\nmodel Chat {\\n   id          String @id @default(cuid())\\n   lastMessageAt DateTime? @map(\\\"last_message_at\\\") // Для сортировки чатов (нужен индекс)\\n   // ... другие поля\\n   @@index([lastMessageAt]) // Индекс для сортировки списка чатов\\n}\\n```",
          "applicationTitle": "Применение:",
          "applicationContent": "После изменения `schema.prisma` выполните миграцию (`npx prisma migrate dev`)."
        },
        "queryOptimization": {
          "title": "4.2. Оптимизация Запросов (Prisma): Пишем Эффективный Код Взаимодействия с БД",
          "intro": "",
          "selectFieldsTitle": "Выбирайте только нужные поля (`select`):",
          "selectFieldsContent": "Не запрашивайте `SELECT *`. Указывайте поля, которые вам действительно нужны. Это уменьшает объем данных, передаваемых по сети и обрабатываемых БД.",
          "selectFieldsCode": "```typescript\\n// Плохо\\nconst user = await prisma.user.findUnique({ where: { id: userId } }); // Выберет все поля\\n\\n// Хорошо (если нужен только email и name)\\nconst user = await prisma.user.findUnique({\\n  where: { id: userId },\\n  select: {\\n    email: true,\\n    name: true,\\n  },\\n});\\n```",
          "nPlus1Title": "Избегайте N+1 проблем (`include`):",
          "nPlus1Content": "Если вам нужны связанные данные (например, автор сообщения при получении списка сообщений), используйте `include` или `select` со вложенными полями вместо выполнения отдельного запроса для каждого элемента.",
          "nPlus1Code": "```typescript\\n// Плохо (N+1 проблема - отдельный запрос за каждым пользователем)\\nconst messages = await prisma.message.findMany({ where: { chatId: chatId } });\\nfor (const message of messages) {\\n  const sender = await prisma.user.findUnique({ where: { id: message.userId } });\\n  // ... использовать sender\\n}\\n\\n// Хорошо (используем include для получения автора сообщения одним запросом)\\nconst messagesWithSender = await prisma.message.findMany({\\n  where: { chatId: chatId },\\n  include: {\\n    user: { // Включаем данные пользователя, связанного с сообщением через поле 'user' в модели Message\\n      select: { id: true, name: true, avatarUrl: true } // Выбираем только нужные поля пользователя\\n    },\\n  },\\n  orderBy: { createdAt: 'asc' }, // Пример: сообщения в хронологическом порядке\\n  take: 50, // Пример: пагинация\\n});\\n```",
          "paginationTitle": "Пагинация (`skip`, `take`, `cursor`):",
          "paginationContent": "Для получения больших списков (сообщения в чате, список чатов) используйте пагинацию, чтобы не загружать все данные сразу. `cursor`-пагинация предпочтительнее для бесконечной прокрутки.",
          "paginationCode": "```typescript\\n// Пример пагинации с take и skip\\nconst messages = await prisma.message.findMany({\\n    where: { chatId: chatId },\\n    orderBy: { createdAt: 'asc' },\\n    skip: (page - 1) * pageSize, // Пропустить N сообщений\\n    take: pageSize, // Взять M сообщений\\n});\\n\\n// Пример Cursor-based пагинации (для \\\"показать еще\\\")\\nconst messages = await prisma.message.findMany({\\n    where: { chatId: chatId },\\n    orderBy: { createdAt: 'asc' },\\n    cursor: { id: lastMessageId }, // Начать после последнего сообщения\\n    skip: 1, // Пропустить само последнее сообщение\\n    take: pageSize,\\n});\\n```"
        },
        "prismaAccelerate": {
          "title": "4.3. Prisma Accelerate: Глобальный Кэш и Пул Соединений",
          "intro": "Prisma Accelerate предоставляет глобальную сеть серверов (Edge locations), которые кэшируют результаты запросов и управляют пулом соединений к вашей БД Neon.",
          "whenTitle": "Когда использовать:",
          "whenContent": "Для снижения задержки запросов (latency) для пользователей по всему миру и оптимизации использования пула соединений БД.",
          "implementationTitle": "Реализация:",
          "implementationContent": "Настраивается в консоли Prisma. Ваша `DATABASE_URL` заменяется на URL Prisma Accelerate."
        },
        "materializedViews": {
          "title": "4.4. Материализованные Представления: Кэширование Сложных Агрегаций",
          "intro": "Материализованные представления — это по сути кэшированные результаты сложных запросов или агрегаций (например, количество сообщений в чате, последние активные пользователи в группе). Они хранятся на диске и могут быть быстро прочитаны.",
          "whenTitle": "Когда использовать:",
          "whenContent": "Для запросов, которые выполняются часто, но требуют сложных вычислений (JOINs, GROUP BY, агрегатные функции) над большими таблицами, и данные в которых не должны быть абсолютно актуальными каждую миллисекунду.",
          "applicationAreasTitle": "Области применения:",
          "applicationAreasContent": "Статистика чатов (общее количество сообщений, участников), списки \"топ\" пользователей (например, по количеству отправленных сообщений).",
          "implementationTitle": "Реализация (SQL, через Prisma `queryRaw` или SQL-клиент Neon):",
          "implementationContent": "```sql\\n-- Создать материализованное представление для подсчета сообщений в каждом чате\\nCREATE MATERIALIZED VIEW chat_message_counts AS\\nSELECT\\n    \\\"chatId\\\",\\n    COUNT(*) as \\\"messageCount\\\"\\nFROM \\\"Message\\\"\\nGROUP BY \\\"chatId\\\";\\n\\n-- Создать индекс на представлении для быстрого поиска по chatId (необязательно, но часто полезно)\\nCREATE INDEX idx_chat_message_counts_chat_id ON chat_message_counts (\\\"chatId\\\");\\n```",
          "updateTitle": "Обновление:",
          "updateContent": "Материализованные представления нужно <strong>периодически обновлять</strong>, чтобы отразить изменения в базовых таблицах. Это делается командой `REFRESH MATERIALIZED VIEW <view_name>;`. Частота обновления зависит от того, насколько актуальными должны быть данные (например, раз в час, раз в день).",
          "updateCode": "```sql\\n-- Обновить представление (может блокировать чтение во время выполнения)\\nREFRESH MATERIALIZED VIEW chat_message_counts;\\n\\n-- Обновить представление без блокировки чтения (для больших представлений)\\nREFRESH MATERIALIZED VIEW CONCURRENTLY chat_message_counts; -- Требует уникального индекса\\n```",
          "usageTitle": "Использование в Prisma:",
          "usageContent": "Запрашивайте как обычную таблицу.",
          "usageCode": "```typescript\\nconst chatStats = await prisma.chatMessageCounts.findMany({\\n  select: { chatId: true, messageCount: true },\\n  where: { chatId: 'some-chat-id' },\\n});\\n```"
        },
        "partitioning": {
          "title": "4.5. Партиционирование Таблиц: Разделение Больших Объемов Данных",
          "intro": "Партиционирование физически разделяет очень большие таблицы (например, `Message`) на более мелкие части (партиции) на основе значения в определенном столбце (например, `createdAt` или `chatId`).",
          "whenTitle": "Когда использовать:",
          "whenContent": "Когда таблица становится настолько большой (миллиарды строк), что индексы уже не справляются, и запросы начинают замедляться из-за необходимости сканировать слишком много данных.",
          "applicationAreasTitle": "Области применения:",
          "applicationAreasContent": "Таблица `Message` — идеальный кандидат для партиционирования по времени создания (`createdAt`) или по ID чата (`chatId`).",
          "implementationTitle": "Реализация (SQL, через Prisma `queryRaw` или SQL-клиент Neon):",
          "implementationContent": "PostgreSQL поддерживает нативное партиционирование.",
          "implementationCode": "```sql\\n-- Создать главную партиционированную таблицу по диапазону дат\\nCREATE TABLE messages (\\n    id TEXT NOT NULL,\\n    content TEXT NOT NULL,\\n    created_at TIMESTAMP WITH TIME ZONE NOT NULL,\\n    chat_id TEXT NOT NULL,\\n    user_id TEXT NOT NULL,\\n    PRIMARY KEY (id, created_at) -- Ключ партиционирования должен быть частью первичного ключа\\n) PARTITION BY RANGE (created_at); -- Партиционируем по диапазону поля created_at\\n\\n-- Создать партиции (например, по месяцам)\\nCREATE TABLE messages_2025_03 PARTITION OF messages\\n    FOR VALUES FROM ('2025-03-01 00:00:00+00') TO ('2025-04-01 00:00:00+00');\\n\\nCREATE TABLE messages_2025_04 PARTITION OF messages\\n    FOR VALUES FROM ('2025-04-01 00:00:00+00') TO ('2025-05-01 00:00:00+00');\\n\\n-- ... создавать новые партиции по мере необходимости (автоматически или вручную)\\n\\n-- Создать индексы для партиционированной таблицы (применяются ко всем партициям)\\nCREATE INDEX ON messages (\\\"chat_id\\\", \\\"created_at\\\");\\nCREATE INDEX ON messages (\\\"user_id\\\");\\n```",
          "advantagesTitle": "Преимущества:",
          "advantagesContent": "Запросы, включающие фильтр по ключу партиционирования (например, `WHERE created_at BETWEEN ...`), будут сканировать только нужные партиции, что значительно ускоряет их выполнение. Управление старыми данными (удаление) становится проще (можно просто удалить старые партиции).",
          "prismaRelationTitle": "Связь с Prisma:",
          "prismaRelationContent": "Prisma работает с партиционированной таблицей как с обычной."
        }
      },
      "graphqlOptimization": {
        "title": "5. Оптимизация GraphQL API (NestJS + Prisma): Эффективная Передача Данных",
        "intro": "GraphQL сам по себе является инструментом <strong>оптимизации</strong> (Принцип 9) по сравнению с REST (клиент запрашивает только нужные данные). Однако и его можно оптимизировать.",
        "analysisToolTitle": "Инструмент анализа:",
        "analysisToolContent": "`graphql-query-complexity` для защиты от сложных запросов.",
        "dataloader": {
          "title": "5.1. DataLoader: Решение Проблемы N+1 в GraphQL",
          "intro": "DataLoader — это утилита, которая помогает решить проблему N+1 запросов при работе с графами данных. Если у вас есть список объектов, и для каждого объекта нужно подтянуть связанный с ним объект (например, список сообщений и для каждого сообщения его автора), DataLoader соберет все ID связанных объектов и сделает один пакетный запрос к БД.",
          "whenTitle": "Когда использовать:",
          "whenContent": "В резолверах GraphQL, когда вам нужно получить связанные объекты для списка родительских объектов.",
          "applicationAreasTitle": "Области применения:",
          "applicationAreasContent": "Получение данных автора для каждого сообщения в чате, получение списка участников для каждого чата в списке чатов пользователя.",
          "implementationTitle": "Реализация:",
          "implementationContent": "Создайте отдельные DataLoader для каждого типа объекта, который нужно подтягивать. Интегрируйте их в контекст GraphQL запроса.",
          "implementationCode": "```typescript\\n// backend/src/graphql/loaders/user.loader.ts\\nimport { Injectable, Scope } from '@nestjs/common';\\nimport DataLoader from 'dataloader';\\nimport { PrismaService } from 'nestjs-prisma';\\nimport { User } from '@prisma/client'; // Импорт модели Prisma\\n\\n// Scope.REQUEST - важно, чтобы DataLoader был уникален для каждого запроса GraphQL\\n@Injectable({ scope: Scope.REQUEST })\\nexport class UserLoader {\\n  private loader: DataLoader<string, User>;\\n\\n  constructor(private prisma: PrismaService) {\\n    // Создаем новый DataLoader. Функция batchLoadFn принимает массив ключей (user IDs)\\n    this.loader = new DataLoader<string, User>(\\n      async (ids: readonly string[]) => {\\n        // Выполняем ОДИН запрос к БД, чтобы получить ВСЕх пользователей по их ID\\n        const users = await this.prisma.user.findMany({\\n          where: {\\n            id: { in: Array.from(ids) }, // Array.from(ids) для совместимости с Prisma\\n          },\\n        });\\n\\n        // Важно: Вернуть массив результатов, упорядоченный по исходному массиву ids\\n        const userMap = new Map(users.map(user => [user.id, user]));\\n        return ids.map(id => userMap.get(id)); // Возвращаем пользователей в том же порядке, что и запросили\\n      },\\n      { cache: true } // Включаем кэширование внутри запроса GraphQL\\n    );\\n  }\\n\\n  // Метод для загрузки одного пользователя по ID\\n  load(id: string): Promise<User> {\\n    return this.loader.load(id);\\n  }\\n\\n  // Метод для загрузки списка пользователей по ID\\n  loadMany(ids: string[]): Promise<(Error | User)[]> {\\n      return this.loader.loadMany(ids);\\n  }\\n}\\n```\\nИнтегрируйте лоадеры в контекст GraphQL (`backend/src/graphql/graphql.module.ts` или `app.module.ts`):\\n```typescript\\n// backend/src/graphql/graphql.module.ts\\nimport { Module } from '@nestjs/common';\\nimport { GraphQLModule } from '@nestjs/graphql';\\nimport { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';\\nimport { UserLoader } from './loaders/user.loader'; // Импорт лоадера\\n// ... другие импорты резолверов и модулей\\n\\n@Module({\\n  imports: [\\n    GraphQLModule.forRoot<ApolloDriverConfig>({\\n      driver: ApolloDriver,\\n      // ... другие настройки GraphQL (schema path, context, etc.)\\n      context: ({ req, connection }) => {\\n        // Создаем контекст для каждого запроса\\n        const context = { req }; // Добавляем объект запроса\\n         if (connection) {\\n           // Для WebSocket (подписки)\\n           // context.loaders = new Loaders(); // Если лоадеры создаются здесь\\n         } else {\\n           // Для HTTP запросов (queries/mutations)\\n           // Создаем лоадеры и добавляем их в контекст\\n           context.loaders = {\\n              userLoader: new UserLoader(/* зависимости */), // Нужно инжектить PrismaService\\n              // ... другие лоадеры\\n           };\\n           // Пример инъекции зависимостей в лоадер (может потребовать FactoryProvider)\\n           // context.loaders = {\\n           //     userLoader: req.loaders.userLoader, // Если используете Request-scoped провайдеры NestJS\\n           // };\\n         }\\n        return context;\\n      },\\n      // plugins: [complexityPlugin], // Плагин для анализа сложности запросов\\n    }),\\n    // ... импорт других модулей\\n  ],\\n   providers: [UserLoader], // Добавляем лоадер как провайдер (для Request scope)\\n})\\nexport class GraphqlModule {}\\n```",
          "usageTitle": "Используйте лоадеры в резолверах:",
          "usageContent": "",
          "usageCode": "```typescript\\n// backend/src/message/message.resolver.ts\\nimport { Resolver, ResolveField, Parent, Context } from '@nestjs/graphql';\\nimport { Message } from '@prisma/client'; // Импорт модели Prisma\\nimport { UserLoader } from '../graphql/loaders/user.loader'; // Импорт лоадера\\n\\n@Resolver('Message') // Указываем GraphQL тип, к которому относится резолвер\\nexport class MessageResolver {\\n  @ResolveField('user') // Определяем резолвер для поля 'user' в типе Message\\n  async resolveUser(@Parent() message: Message, @Context() context: any) {\\n    // Используем userLoader из контекста для загрузки пользователя по message.userId\\n    // DataLoader автоматически соберет все message.userId в текущем запросе и загрузит их батчем\\n    return context.loaders.userLoader.load(message.userId);\\n  }\\n}\\n```"
        },
        "queryComplexityAnalysis": {
          "title": "5.2. Анализ Сложности Запросов: Защита от \"Тяжелых\" Запросов",
          "intro": "GraphQL позволяет клиенту запрашивать данные произвольной вложенности, что может привести к очень \"тяжелым\" запросам, сильно нагружающим сервер и БД.",
          "toolTitle": "Инструмент:",
          "toolContent": "`graphql-query-complexity`.",
          "whenTitle": "Когда использовать:",
          "whenContent": "Всегда включайте защиту от сложности в продакшене.",
          "principleTitle": "Принцип работы:",
          "principleContent": "Плагин анализирует запрос до его выполнения и вычисляет его \"сложность\" (например, как сумму \"стоимости\" каждого поля). Если сложность превышает заданный порог, запрос отклоняется.",
          "implementationTitle": "Реализация:",
          "implementationContent": "Настройте плагин в NestJS GraphQLModule (см. Руководство по разработке)."
        },
        "persistedQueries": {
          "title": "5.3. Persisted Queries: Кэширование Запросов на Уровне Сети",
          "intro": "Persisted Queries позволяют клиенту отправлять на сервер не полный текст GraphQL запроса, а только его хэш. Сервер по этому хэшу находит полный запрос (если он ему знаком) и выполняет его.",
          "whyTitle": "Почему:",
          "whyContent": "Уменьшает объем данных, передаваемых по сети, что ускоряет запросы, особенно на мобильных устройствах. Улучшает эффективность кэширования на CDN.",
          "whenTitle": "Когда использовать:",
          "whenContent": "Для часто повторяющихся запросов из клиента.",
          "implementationTitle": "Реализация:",
          "implementationContent": "Требует поддержки как на стороне клиента (Apollo Client поддерживает), так и на стороне сервера (Apollo Server поддерживает). На сервере нужно хранить соответствие хэшей и запросов (например, в Redis)."
        }
      },
      "backendLogicOptimization": {
        "title": "6. Оптимизация Backend Логики (NestJS): Эффективность Кода",
        "intro": "",
        "toolsTitle": "Инструменты:",
        "toolsContent": "Профилирование Node.js (V8 Profiler), обнаружение утечек памяти (`heapdump`).",
        "whenTitle": "Когда использовать:",
        "whenContent": "Для выявления \"горячих\" участков кода, потребляющих много CPU или памяти, и диагностики проблем с памятью.",
        "processTitle": "Процесс:",
        "processContent": "Используйте инструменты профилирования для <strong>измерения</strong> (Шаг 1 Кайдзен). Анализируйте результаты (Шаг 2). Вносите изменения в код (Шаг 3). Повторите (Шаг 4).",
        "recommendationsTitle": "Рекомендации:",
        "recommendationsContent": "Избегайте синхронных операций, блокирующих основной поток Node.js. Используйте асинхронные API. Оптимизируйте циклы, работу с большими массивами/объектами."
      },
      "caching": {
        "title": "7. Кэширование (Redis): Снижение Нагрузки на БД и Ускорение (Принцип 9)",
        "intro": "Кэширование позволяет хранить часто запрашиваемые данные в быстрой памяти (Redis), чтобы не обращаться к более медленной БД (Neon) при каждом запросе. Это ключевой <strong>рычаг</strong> для повышения <strong>эффективности системы</strong> (Принцип 9).",
        "libraryTitle": "Библиотека:",
        "libraryContent": "`ioredis`, `@nestjs/cache-manager`, `cache-manager-redis-store`.",
        "patternTitle": "Pаттерн:",
        "patternContent": "Cache-Aside (чтение из кэша, если нет — чтение из БД и запись в кэш).",
        "applicationAreasTitle": "Области применения:",
        "applicationAreasContent": "Часто запрашиваемые, относительно редко изменяющиеся данные (профили пользователей, настройки приложения, результаты сложных запросов/агрегаций, материализованных представлений).",
        "implementationTitle": "Реализация:",
        "implementationContent": "Настройте Redis в NestJS и используйте его в сервисах.",
        "invalidationTitle": "Ключевой аспект:",
        "invalidationContent": "<strong>Инвалидация кэша</strong>. При изменении данных в БД, удаляйте соответствующие ключи из Redis, чтобы клиенты не получали устаревшие данные."
      },
      "asyncProcessing": {
        "title": "8. Асинхронная Обработка (Kafka): Надежность и Отзывчивость (Принцип 9, 2)",
        "intro": "Используйте <strong>Kafka</strong> для выполнения задач, которые не требуют немедленного ответа пользователю (отправка email, обработка изображений, нотификации, аналитика).",
        "libraryTitle": "Библиотека:",
        "libraryContent": "`kafkajs`.",
        "whyTitle": "Почему:",
        "whyContent": "Kafka — <strong>надежная распределенная система очередей</strong>, гарантирующая доставку сообщений и позволяющая масштабировать обработку задач независимо от основного API (воркеры-консьюмеры).",
        "applicationAreasTitle": "Области применения:",
        "applicationAreasContent": [
          "Обработка изображений/видео после загрузки.",
          "Отправка больших объемов push-уведомлений.",
          "Генерация отчетов или статистики.",
          "Архивирование старых сообщений/файлов."
        ],
        "patternTitle": "Паттерн:",
        "patternContent": "<strong>Producer-Consumer</strong>. Backend-API ставит задачи в топик Kafka (Producer). Отдельные сервисы/воркеры (Consumer) читают задачи из топика и выполняют их в фоновом режиме.",
        "partitioningTitle": "Партиционирование в Kafka:",
        "partitioningContent": "Используйте ключи сообщений (например, `userId`, `chatId`), чтобы сообщения, относящиеся к одному пользователю/чату, попадали в одну партицию. Это гарантирует порядок обработки внутри партиции, что может быть важно для некоторых задач.",
        "monitoringTitle": "Мониторинг:",
        "monitoringContent": "Используйте <strong>Kafdrop</strong> для визуального мониторинга топиков, сообщений и состояния консьюмер-групп."
      },
      "pushNotificationsOptimization": {
        "title": "9. Оптимизация Push-уведомлений (Firebase FCM): Эффективная Доставка Информации (Принцип 2)",
        "intro": "Push-уведомления — важный канал связи с пользователем (Принцип 2: Ценность). Оптимизация их доставки важна для пользовательского опыта.",
        "platformTitle": "Платформа:",
        "platformContent": "Firebase Cloud Messaging (FCM).",
        "techniquesTitle": "Техники:",
        "techniquesContent": [
          "<strong>Батчинг:</strong> Отправляйте несколько уведомлений одним вызовом API FCM (`sendMulticast`) для снижения сетевых накладных расходов.",
          "<strong>Темы (Topics):</strong> Используйте темы для массовых рассылок (например, уведомление о новом сообщении в канале), чтобы FCM управлял списком подписчиков.",
          "<strong>Data Messages:</strong> Используйте Data Messages для полного контроля над отображением уведомления на клиенте и возможности прикреплять кастомные данные."
        ]
      },
      "clientApiDbInteraction": {
        "title": "10. Оптимизация Взаимодействия Клиент-API-БД: Сокращение Пути Данных (Принцип 9)",
        "intro": "",
        "clientLevelTitle": "На Уровне Клиента:",
        "clientLevelContent": "Используйте библиотеки для управления состоянием и кэширования данных, полученных по сети (`@apollo/client`, `react-query`/`@tanstack/react-query`). Это позволяет избежать повторных запросов за одними и теми же данными и быстро показывать кэшированные данные.",
        "networkLevelTitle": "На Уровне Сети:",
        "networkLevelContent": "Включите современные протоколы (HTTP/2, HTTP/3) и сжатие (Gzip/Brotli) на вашем API Gateway или Backend сервере для уменьшения объема передаваемых данных и снижения задержки.",
        "backendLevelTitle": "На Уровне Backend:",
        "backendLevelContent": "Оптимизируйте взаимодействие с БД (раздел 4) и внешними сервисами (раздел 7)."
      },
      "authenticationOptimization": {
        "title": "11. Оптимизация Аутентификации: Быстрота и Безопасность",
        "intro": "",
        "statelessJwtTitle": "Stateless (JWT):",
        "statelessJwtContent": "Использование JWT снижает нагрузку на сервер, так как ему не нужно хранить состояние сессий пользователей.",
        "rateLimitingTitle": "Rate Limiting (`@nestjs/throttler`):",
        "rateLimitingContent": "Защита эндпоинтов аутентификации от Brute Force атак, что также снижает нагрузку.",
        "secureHeadersTitle": "Безопасные Заголовки (`helmet`):",
        "secureHeadersContent": "Добавление HTTP-заголовков для защиты от XSS, CSRF и других атак."
      },
      "chatWebSocketOptimization": {
        "title": "12. Оптимизация Чатов (WebSocket): Низкая Задержка и Масштабирование",
        "intro": "WebSocket используется для обмена сообщениями в реальном времени. <strong>Оптимизация WebSocket-соединений критична для отзывчивости чатов</strong> (Принцип 2).",
        "libraryTitle": "Библиотека:",
        "libraryContent": "NestJS Gateways (`@nestjs/websockets`), Socket.IO (если нужна кросс-браузерная совместимость и fallback).",
        "techniquesTitle": "Техники:",
        "techniquesContent": [
          "<strong>Бинарные Форматы:</strong> Передача сообщений в бинарном формате (например, MessagePack) вместо текстового JSON может уменьшить объем данных.",
          "<strong>Батчинг Сообщений:</strong> Буферизируйте сообщения на клиенте и сервере и отправляйте их пачками (например, каждые 50 мс), а не по одному. Снижает количество пакетов.",
          "<strong>Управление Присутствием:</strong> Используйте Redis для быстрого отслеживания статуса онлайн/офлайн пользователей. Heartbeats (пинг-понг) для поддержания соединения и обнаружения отключений.",
          "<strong>Вертикальное/Горизонтальное Масштабирование:</strong> NestJS Gateways могут работать в кластерном режиме. Используйте Redis или другой Pub/Sub механизм (например, Kafka) для обмена сообщениями между инстансами Backend, чтобы сообщения доставлялись всем подписчикам, независимо от того, к какому инстансу Backend они подключены."
        ]
      },
      "animationsOptimization": {
        "title": "13. Оптимизация Анимаций: Плавность и Производительность (Принцип 3, 5)",
        "intro": "Производительные анимации делают интерфейс <strong>качественным</strong> (Принцип 3) и снижают нагрузку на устройство (Принцип 5: Здоровье).",
        "mobileDesktopTitle": "Mobile-Desktop (React Native):",
        "mobileDesktopContent": "Используйте `react-native-reanimated` для анимаций, которые выполняются на нативном потоке, не блокируя поток JavaScript.",
        "webTitle": "Web (Next.js):",
        "webContent": "Используйте `framer-motion` для декларативного создания плавных анимаций.",
        "docDesignTitle": "DocDesign:",
        "docDesignContent": "В DocDesign описаны принципы и параметры анимаций, включая возможность их отключения пользователем (Принцип 12: Прагматизм)."
      },
      "monitoring": {
        "title": "14. Мониторинг с Prometheus и Grafana: Измерение как Основа Кайдзен (Принцип 9)",
        "intro": "Система мониторинга — это ваши <strong>глаза</strong> и <strong>измерительные инструменты</strong> (Шаг 1 Кайдзен).",
        "toolsTitle": "Инструменты:",
        "toolsContent": "Prometheus (сбор метрик), Grafana (визуализация), Alertmanager (уведомления об аномалиях).",
        "whenTitle": "Когда использовать:",
        "whenContent": "Всегда. Настройте мониторинг на всех уровнях: Backend (задержки API, ошибки), БД (время запросов, нагрузка), Redis (попадания в кэш, использование памяти), Kafka (количество сообщений в топиках, лаг консьюмеров), Инфраструктура (CPU, RAM, сеть).",
        "implementationTitle": "Реализация:",
        "implementationContent": "См. подробные шаги по настройке в Руководстве по разработке (раздел 14).",
        "principleTitle": "Принцип:",
        "principleContent": "Используйте метрики для <strong>выявления узких мест</strong> (Шаг 2 Кайдзен) и оценки <strong>эффективности</strong> (Принцип 9) ваших оптимизаций. Настройте <strong>алерты</strong> для проактивного обнаружения проблем."
      },
      "ciCdOptimization": {
        "title": "15. Оптимизация CI/CD: Ускорение Цикла Разработки (Принцип 9)",
        "intro": "Эффективный CI/CD пайплайн ускоряет доставку кода, что является частью <strong>оптимизации всего процесса разработки</strong> (Принцип 9).",
        "toolsTitle": "Инструменты:",
        "toolsContent": "Turborepo (кэширование, параллелизация), GitHub Actions (автоматизация).",
        "techniquesTitle": "Техники:",
        "techniquesContent": [
          "<strong>Кэширование с Turborepo:</strong> Кэшируйте результаты сборки и тестов между запусками в CI и локально.",
          "<strong>Параллельное выполнение:</strong> Запускайте задачи (lint, build, test) для разных пакетов или частей тестов параллельно.",
          "<strong>Оптимизация Docker-образов:</strong> Используйте многоступенчатую сборку и `.dockerignore` для уменьшения размера образов и ускорения сборки/деплоя."
        ]
      },
      "frontendOptimization": {
        "title": "16. Оптимизация Фронтенда: Быстрота и Отзывчивость для Пользователя (Принцип 2, 3)",
        "intro": "Фронтенд должен быть <strong>быстрым и отзывчивым</strong>, чтобы пользователь ощутил <strong>ценность</strong> (Принцип 2) продукта.",
        "webTechniquesTitle": "Техники (Web - Next.js):",
        "webTechniquesContent": [
          "<strong>Code Splitting / Dynamic Imports:</strong> Загружайте код только тогда, когда он нужен (`next/dynamic`).",
          "<strong>SSR/SSG:</strong> Используйте серверный рендеринг или генерацию статики для ускорения первой отрисовки и SEO (`getStaticProps`, `getServerSideProps`).",
          "<strong>Оптимизация Изображений:</strong> Используйте `next/image` или `<picture>` и современные форматы (WebP).",
          "<strong>Анализ Бандла:</strong> Используйте `@next/bundle-analyzer` для выявления самых тяжелых модулей."
        ],
        "reactNativeTechniquesTitle": "Техники (React Native):",
        "reactNativeTechniquesContent": [
          "<strong>Ленивая Загрузка:</strong> Используйте `React.lazy` и `Suspense` для экранов и компонентов, которые не нужны при старте.",
          "<strong>Производительные Списки:</strong> Используйте `FlatList` или `SectionList` с правильной настройкой (`getItemLayout`, `windowSize`) для больших списков сообщений или чатов.",
          "<strong>Оптимизация Изображений:</strong> Используйте `react-native-fast-image`.",
          "<strong>Профилирование:</strong> Используйте Performance Monitor в Debugger Menu React Native для выявления узких мест UI."
        ],
        "generalTechniquesTitle": "Общие техники:",
        "generalTechniquesContent": [
          "Удаление неиспользуемого кода (Tree Shaking), замена тяжелых библиотек на легкие аналоги (например, `dayjs` вместо `moment`), сжатие бандлов (Gzip/Brotli)."
        ]
      },
      "dbScaling": {
        "title": "17. Масштабирование Базы Данных (Репликация и Шардинг): Подготовка к Росту (Принцип 8)",
        "intro": "Эти техники становятся актуальными при значительном росте объема данных и нагрузки. Они являются частью <strong>долгосрочной стратегии масштабирования</strong> (Принцип 8).",
        "replicationTitle": "Репликация (Master-Slave):",
        "replicationContent": "Создание копий БД только для чтения (read replicas). Позволяет распределить нагрузку на чтение.",
        "shardingTitle": "Шардинг:",
        "shardingContent": "Разделение данных большой таблицы на части (шарды) по определенному ключу (`chatId`, `userId`), распределяя их по разным серверам. Позволяет масштабировать как чтение, так и запись. Реализуется логически (в приложении) или с помощью расширений (Citus для PostgreSQL).",
        "whenToApplyTitle": "Когда применять:",
        "whenToApplyContent": "Основываясь на <strong>измерениях</strong> нагрузки и производительности БД (Принцип 9), а не заранее."
      },
      "notes": {
        "title": "18. Примечания: Непрерывный Кайдзен в Оптимизации",
        "prioritizationTitle": "Приоритезация:",
        "prioritizationContent": "Начинайте оптимизацию с тех мест, которые приносят наибольший эффект на текущем этапе проекта (Принцип 12). Для MVP это может быть скорость загрузки Frontend, производительность основных API-запросов.",
        "automationTitle": "Автоматизация:",
        "automationContent": "Максимально автоматизируйте процессы измерения и проверки оптимизаций (CI/CD, алерты в мониторинге) — это часть <strong>Системы</strong> (Принцип 9).",
        "documentationNotesTitle": "Документирование:",
        "documentationNotesContent": "Фиксируйте проведенные оптимизации, их эффект и уроки в этой документации или в задачах/коммитах (Принцип 1: Обучение, Принцип 9: Кайдзен).",
        "cultureTitle": "Культура:",
        "cultureContent": "Создайте культуру, где каждый разработчик несет ответственность за производительность своего кода и активно участвует в поиске и устранении узких мест (Принцип 6)."
      }
    },
    "apiSpec": {
      "title": "Спецификация API BrainMessenger (Интерфейс Системы)",
      "subtitle": "Интерфейс Системы",
      "generalInfo": {
        "title": "1. Общая Информация: API как Точка Взаимодействия с Системой",
        "description": "Этот документ описывает GraphQL API BrainMessenger — <strong>основной интерфейс</strong> (Принцип 9), через который клиентские приложения (Web, Mobile, Desktop) взаимодействуют с серверной частью системы и получают доступ к данным и функциональности. GraphQL выбран за его <strong>эффективность и гибкость</strong> (Принцип 9, 2), позволяя клиентам запрашивать только те данные, которые им необходимы.",
        "projectNameTitle": "Название проекта:",
        "projectNameContent": "BrainMessenger",
        "apiPurposeTitle": "Цель:",
        "apiPurposeContent": "Предоставить четкое и полное описание доступных запросов (Queries) и мутаций (Mutations), их входных и выходных данных, а также правил аутентификации и форматов ошибок. Это обеспечивает <strong>системность</strong> (Принцип 9) взаимодействия между Frontend и Backend и повышает <strong>качество</strong> (Принцип 3) разработки.",
        "baseUrlTitle": "Базовый URL:",
        "baseUrlContent": "`https://api.brainmessenger.com/graphql` (адрес API Gateway, который перенаправляет запросы на Backend Service).",
        "requestFormatTitle": "Формат запросов:",
        "requestFormatContent": "GraphQL-запросы (POST-запросы с `Content-Type: application/json` и телом в формате GraphQL).",
        "authenticationTitle": "Аутентификация:",
        "authenticationContent": "Для большинства методов требуется передать JWT-токен в заголовке `Authorization: Bearer <token>`. Токен получается после успешного логина. Это часть нашей <strong>системы безопасности</strong> (Принцип 3, 5).",
        "relatedDocsTitle": "Связь с другими документами:",
        "relatedDocsContent": [
          "DocTech.md: Общая архитектура системы, включая Backend и API Gateway.",
          "DocDevIn.md: Детали реализации Backend на NestJS и GraphQL.",
          "DocInt.md: Описание интеграций, которые Backend использует (Neon, R2, Firebase и др.).",
          "DocOptimizationIn.md: Подходы к оптимизации производительности API."
        ]
      },
      "graphqlSchema": {
        "title": "2. Схема GraphQL: Структура Доступных Данных и Операций",
        "description": "Полная схема GraphQL доступна по адресу API через инструменты интроспекции (например, GraphQL Playground, Apollo Studio). Ниже приведены основные типы и операции.",
        "dataTypes": {
          "title": "2.1. Типы Данных (Schemas): Описание Структуры Информации",
          "user": {
            "title": "User:",
            "code": "type User {\n  id: ID!\n  email: String!\n  name: String!\n  avatarUrl: String # URL аватара пользователя (хранится в R2)\n  createdAt: DateTime!\n  updatedAt: DateTime!\n  # ... другие поля (например, статус онлайн/оффлайн)\n}"
          },
          "chat": {
            "title": "Chat:",
            "code": "type Chat {\n  id: ID!\n  name: String! # Название чата (для групп/каналов)\n  type: String! # Тип чата (\"personal\", \"group\", \"channel\")\n  users: [User!] # Список участников чата\n  messages(pagination: PaginationInput): [Message!] # Сообщения в чате (с пагинацией)\n  lastMessageAt: DateTime # Время последнего сообщения (для сортировки списка чатов)\n  createdAt: DateTime!\n  updatedAt: DateTime!\n  # ... другие поля (например, фото группы/канала, описание)\n}"
          },
          "message": {
            "title": "Message:",
            "code": "type Message {\n  id: ID!\n  content: String! # Текст сообщения (для текстовых сообщений)\n  fileUrl: String # URL файла, если сообщение является файлом (хранится в R2)\n  fileMetadata: JSON # Метаданные файла (тип, размер, имя) (хранится в Neon/R2)\n  sender: User! # Отправитель сообщения\n  chat: Chat! # Чат, которому принадлежит сообщение\n  createdAt: DateTime! # Время отправки сообщения\n  updatedAt: DateTime!\n  # ... другие поля (например, статус прочтения, реакции)\n}"
          },
          "paginationInput": {
            "title": "PaginationInput:",
            "code": "input PaginationInput {\n  take: Int # Максимальное количество элементов\n  skip: Int # Пропустить элементов (для offset-based пагинации)\n  cursor: String # Курсор (ID) для cursor-based пагинации\n}"
          },
          "authPayload": {
            "title": "AuthPayload:",
            "code": "type AuthPayload {\n  token: String! # JWT токен доступа\n  user: User! # Данные аутентифицированного пользователя\n}"
          },
          "dateTimeJson": {
            "title": "DateTime, JSON:",
            "content": "Стандартные скалярные типы или кастомные скаляры, определенные на Backend."
          }
        },
        "operations": {
          "title": "2.2. Операции (Queries и Mutations): Доступ к Функционалу Системы",
          "authentication": {
            "title": "2.2.1. Аутентификация (Authentication)",
            "registerUser": {
              "title": "`mutation registerUser(input: RegisterInput!): AuthPayload!`",
              "description": "Регистрирует нового пользователя в системе.",
              "input": "`RegisterInput`: `{ email: String!, password: String!, name: String! }` (password min 8 chars, digit, special char - см. валидацию).",
              "authRequired": "Требуется аутентификация: Нет.",
              "scenario": "Сценарий: Пользователь заполняет форму регистрации.",
              "errors": "Ошибки: `400 Bad Request` (неверный формат данных/валидация), `409 Conflict` (email уже используется)."
            },
            "loginUser": {
              "title": "`mutation loginUser(input: LoginInput!): AuthPayload!`",
              "description": "Аутентифицирует пользователя по email и паролю.",
              "input": "`LoginInput`: `{ email: String!, password: String! }`.",
              "authRequired": "Требуется аутентификация: Нет.",
              "scenario": "Сценарий: Пользователь вводит учетные данные для входа.",
              "errors": "Ошибки: `401 Unauthorized` (неверный email или пароль)."
            },
            "logoutUser": {
              "title": "`mutation logoutUser: Boolean!`",
              "description": "Инвалидирует текущий JWT токен на сервере (если реализовано хранение токенов или их черных списков).",
              "authRequired": "Требуется аутентификация: Да (используется текущий токен).",
              "scenario": "Сценарий: Пользователь нажимает \"Выйти\".",
              "returns": "Возвращает: `true` при успешном выходе.",
              "errors": "Ошибки: `401 Unauthorized` (токен недействителен)."
            }
          },
          "user": {
            "title": "2.2.2. Пользователь (User)",
            "getUser": {
              "title": "`query getUser(id: ID!): User`",
              "description": "Получает данные пользователя по его уникальному ID.",
              "authRequired": "Требуется аутентификация: Да (для доступа к любым данным пользователя, кроме, возможно, публичного профиля).",
              "scenario": "Сценарий: Просмотр профиля пользователя.",
              "errors": "Ошибки: `404 Not Found` (пользователь с таким ID не найден)."
            },
            "getCurrentUser": {
              "title": "`query getCurrentUser: User!`",
              "description": "Получает данные текущего аутентифицированного пользователя.",
              "authRequired": "Требуется аутентификация: Да.",
              "scenario": "Сценарий: Загрузка профиля текущего пользователя при старте приложения.",
              "errors": "Ошибки: `401 Unauthorized`."
            },
            "updateUser": {
              "title": "`mutation updateUser(id: ID!, input: UserInput!): User!`",
              "description": "Обновляет данные профиля пользователя.",
              "input": "`UserInput`: `{ name: String, email: String, password: String, avatarUrl: String }`. Поля опциональны.",
              "authRequired": "Требуется аутентификация: Да (и пользователь должен быть владельцем профиля или иметь права администратора).",
              "scenario": "Сценарий: Пользователь редактирует свой профиль.",
              "errors": "Ошибки: `400 Bad Request` (неверный формат данных), `401 Unauthorized`, `403 Forbidden` (нет прав на редактирование этого пользователя), `404 Not Found`."
            },
            "deleteUser": {
              "title": "`mutation deleteUser(id: ID!): Boolean!`",
              "description": "Удаляет аккаунт пользователя.",
              "authRequired": "Требуется аутентификация: Да (и пользователь должен быть владельцем аккаунта).",
              "scenario": "Сценарий: Пользователь решает удалить свою учетную запись.",
              "returns": "Возвращает: `true` при успешном удалении.",
              "errors": "Ошибки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            }
          },
          "chats": {
            "title": "2.2.3. Чаты (Chats)",
            "getChats": {
              "title": "`query getChats: [Chat!]!`",
              "description": "Получает список всех чатов, в которых участвует текущий пользователь.",
              "authRequired": "Требуется аутентификация: Да.",
              "scenario": "Сценарий: Загрузка списка чатов на главном экране.",
              "errors": "Ошибки: `401 Unauthorized`."
            },
            "getChat": {
              "title": "`query getChat(id: ID!): Chat`",
              "description": "Получает данные конкретного чата по ID.",
              "authRequired": "Требуется аутентификация: Да (и пользователь должен быть участником этого чата).",
              "scenario": "Сценарий: Открытие конкретного чата.",
              "errors": "Ошибки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            },
            "createChat": {
              "title": "`mutation createChat(input: CreateChatInput!): Chat!`",
              "description": "Создает новый чат.",
              "input": "`CreateChatInput`: `{ type: String!, name: String, userIds: [ID!]! }`. `type` может быть \"personal\", \"group\", \"channel\". `name` обязателен для \"group\" и \"channel\". `userIds` включает ID создателя и других участников (для \"personal\" и \"group\").",
              "authRequired": "Требуется аутентификация: Да.",
              "scenario": "Сценарий: Пользователь создает новый чат или группу.",
              "errors": "Ошибки: `400 Bad Request` (неверный тип, отсутствуют userIds и т.п.), `401 Unauthorized`, `403 Forbidden` (нет прав на создание такого типа чата)."
            },
            "getMessages": {
              "title": "`query getMessages(chatId: ID!, pagination: PaginationInput): [Message!]!`",
              "description": "Получает список сообщений для заданного чата. Поддерживает пагинацию.",
              "authRequired": "Требуется аутентификация: Да (и пользователь должен быть участником чата).",
              "scenario": "Сценарий: Открытие чата, подгрузка старых сообщений при прокрутке.",
              "errors": "Ошибки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            },
            "sendMessage": {
              "title": "`mutation sendMessage(chatId: ID!, content: String!, fileUrl: String, fileMetadata: JSON): Message!`",
              "description": "Отправляет новое сообщение в чат. Может содержать текст или ссылку на файл.",
              "input": "`chatId`: ID чата. `content`: Текст сообщения. `fileUrl`: URL файла в R2 (опционально). `fileMetadata`: Метаданные файла (опционально).",
              "authRequired": "Требуется аутентификация: Да (и пользователь должен быть участником чата).",
              "scenario": "Сценарий: Пользователь отправляет текстовое сообщение или файл.",
              "errors": "Ошибки: `400 Bad Request`, `401 Unauthorized`, `403 Forbidden` (нет прав писать в этот чат), `404 Not Found` (чат не найден)."
            },
            "deleteMessage": {
              "title": "`mutation deleteMessage(messageId: ID!): Boolean!`",
              "description": "Удаляет сообщение.",
              "authRequired": "Требуется аутентификация: Да (и пользователь должен быть отправителем сообщения или иметь права администратора чата).",
              "scenario": "Сценарий: Пользователь удаляет свое сообщение.",
              "returns": "Возвращает: `true` при успешном удалении.",
              "errors": "Ошибки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            }
          },
          "externalIntegrations": {
            "title": "2.2.4. Внешние Интеграции (через API Backend)",
            "sendVerificationCode": {
              "title": "`mutation sendVerificationCode(email: String!): Boolean!`",
              "description": "Запускает процесс отправки кода подтверждения на указанный email (используя Gmail API). Используется при регистрации или сбросе пароля.",
              "authRequired": "Требуется аутентификация: Нет.",
              "scenario": "Сценарий: Пользователь вводит email на экране регистрации/восстановления пароля.",
              "returns": "Возвращает: `true` при успешной постановке задачи на отправку.",
              "errors": "Ошибки: `400 Bad Request` (неверный формат email), `429 Too Many Requests` (защита от спама)."
            },
            "verifyEmailCode": {
              "title": "`mutation verifyEmailCode(email: String!, code: String!): Boolean!`",
              "description": "Проверяет код подтверждения, полученный по email.",
              "authRequired": "Требуется аутентификация: Нет.",
              "scenario": "Сценарий: Пользователь вводит код из email.",
              "returns": "Возвращает: `true` при успешной проверке.",
              "errors": "Ошибки: `400 Bad Request` (неверный код или email), `404 Not Found` (для данного email нет активного кода)."
            },
            "enableTwoFactorAuth": {
              "title": "`mutation enableTwoFactorAuth(userId: ID!): Boolean!`",
              "description": "Включает/отключает двухфакторную аутентификацию для пользователя. Требует предварительной верификации email. Код для 2FA отправляется на email (Gmail API) при каждом логине после включения.",
              "authRequired": "Требуется аутентификация: Да (пользователь должен управлять своим аккаунтом).",
              "scenario": "Сценарий: Пользователь настраивает безопасность аккаунта.",
              "errors": "Ошибки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`, `400 Bad Request` (email не верифицирован)."
            },
            "disableTwoFactorAuth": {
              "title": "`mutation disableTwoFactorAuth(userId: ID!): Boolean!`",
              "description": "Включает/отключает двухфакторную аутентификацию для пользователя. Требует предварительной верификации email. Код для 2FA отправляется на email (Gmail API) при каждом логине после включения.",
              "authRequired": "Требуется аутентификация: Да (пользователь должен управлять своим аккаунтом).",
              "scenario": "Сценарий: Пользователь настраивает безопасность аккаунта.",
              "errors": "Ошибки: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`, `400 Bad Request` (email не верифицирован)."
            },
            "sendTwoFactorCode": {
              "title": "`mutation sendTwoFactorCode(userId: ID!): Boolean!`",
              "description": "Отправляет код двухфакторной аутентификации на email пользователя.",
              "authRequired": "Требуется аутентификация: Частичная (например, после ввода пароля, но до ввода 2FA кода). Логика зависит от флоу аутентификации.",
              "scenario": "Сценарий: Пользователь входит в аккаунт с включенной 2FA.",
              "errors": "Ошибки: `404 Not Found` (пользователь не найден или 2FA не включена), `429 Too Many Requests`."
            },
            "createPaymentSession": {
              "title": "`mutation createPaymentSession(input: PaymentInput!): PaymentSessionPayload!`",
              "description": "Создает сессию оплаты через Stripe для оформления Premium подписки.",
              "input": "`PaymentInput`: `{ planId: ID!, returnUrl: String! }` (ID выбранного тарифного плана, URL для редиректа после оплаты).",
              "authRequired": "Требуется аутентификация: Да.",
              "scenario": "Сценарий: Пользователь нажимает \"Подписаться\" на Premium экране.",
              "errors": "Ошибки: `400 Bad Request` (неверный planId), `401 Unauthorized`."
            }
          }
        }
      },
      "errorHandling": {
        "title": "3. Обработка Ошибок API: Ясная Обратная Связь (Принцип 3, 14)",
        "description": "API возвращает стандартизированные ошибки для <strong>ясной обратной связи</strong> (Принцип 14) с клиентом и поддержания <strong>качества</strong> (Принцип 3).",
        "errorFormatTitle": "Формат ошибок (в соответствии со спецификацией GraphQL):",
        "errorFormatCode": "{\n  \"data\": null, // Обычно null при ошибках верхнего уровня\n  \"errors\": [\n    {\n      \"message\": \"Описание ошибки (может быть локализовано - см. DocLocIn)\",\n      \"locations\": [...], // Расположение ошибки в запросе\n      \"path\": [...],      // Путь к полю, вызвавшему ошибку\n      \"extensions\": {\n        \"code\": \"КОД_ОШИБКИ\", // Стандартизированный код ошибки (например, \"UNAUTHENTICATED\", \"FORBIDDEN\", \"BAD_USER_INPUT\", \"NOT_FOUND\")\n        \"http\": { // Если применимо, HTTP статус код\n          \"status\": 401,\n          \"headers\": {}\n        },\n         \"details\": {} // Дополнительные детали об ошибке (опционально)\n      }\n    }\n    // ... могут быть другие ошибки\n  ]\n}",
        "keyErrorCodesTitle": "Ключевые коды ошибок (extensions.code):",
        "keyErrorCodesList": [
          "`UNAUTHENTICATED`: Требуется аутентификация, но токен отсутствует или недействителен (`HTTP 401`).",
          "`FORBIDDEN`: Аутентификация пройдена, но у пользователя нет прав на выполнение операции (`HTTP 403`).",
          "`BAD_USER_INPUT`: Ошибка валидации входных данных (`HTTP 400`). Детали могут быть в `extensions.details`.",
          "`NOT_FOUND`: Запрошенный ресурс не найден (`HTTP 404`).",
          "`CONFLICT`: Конфликт данных (например, попытка зарегистрировать email, который уже существует) (`HTTP 409`).",
          "`INTERNAL_SERVER_ERROR`: Неожиданная ошибка на сервере (`HTTP 500`).",
          "`RATE_LIMITED`: Превышен лимит запросов (`HTTP 429`)."
        ],
        "localizationErrorsTitle": "Локализация ошибок:",
        "localizationErrorsContent": "Сообщения об ошибках (`message`) могут быть локализованы на стороне Backend на основе заголовка `Accept-Language` или предпочтений пользователя (см. DocLocIn)."
      },
      "notes": {
        "title": "4. Примечания",
        "dataTypes": {
          "title": "Типы данных:",
          "list": [
            "`ID`: Уникальный идентификатор ресурса (обычно строка).",
            "`String`: Текстовая строка.",
            "`Int`, `Float`: Числа.",
            "`Boolean`: Логическое значение (`true`/`false`).",
            "`DateTime`: Дата и время в формате ISO 8601 (например, \"2025-03-14T10:30:00Z\").",
            "`JSON`: Кастомный скаляр для передачи произвольных JSON-объектов (например, для `fileMetadata`).",
            "`!` в конце типа означает, что поле <strong>не может быть null</strong>."
          ]
        },
        "pagination": {
          "title": "Пагинация:",
          "content": "Для списков, которые могут быть длинными (`messages`), используйте пагинацию для эффективной загрузки данных (Принцип 9)."
        },
        "validation": {
          "title": "Валидация:",
          "content": "Backend выполняет строгую валидацию всех входных данных (через DTO и `class-validator`), возвращая ошибки `BAD_USER_INPUT` при их некорректности. Это часть <strong>системы обеспечения качества</strong> (Принцип 3)."
        },
        "security": {
          "title": "Безопасность:",
          "content": "Все запросы, работающие с чувствительными данными или изменяющие состояние системы (кроме регистрации/логина), требуют аутентификации."
        },
        "testingTools": {
          "title": "Инструменты тестирования API:",
          "content": "Используйте GraphQL Playground (часто доступен по адресу `/graphql` в dev-режиме Backend), Postman или Apollo Studio для отправки запросов и тестирования API."
        }
      }
    }
  }
