{
  "header": {
    "features": "Features",
    "news": "News",
    "faq": "FAQ",
    "faqLink": "FAQ",
    "docs": "Docs",
    "updates": "Updates",
    "selectLanguage": "Select language",
    "changeLanguageTooltip": "Change language",
    "lightMode": "Light Mode",
    "darkMode": "Dark Mode",
    "openMenu": "Open menu",
    "closeMenu": "Close menu",
    "settings": "Settings",
    "signOut": "Sign Out",
    "deleteAccount": "Delete Account",
    "deleteAccountConfirmTitle": "Confirm Account Deletion",
    "deleteAccountConfirmMessage": "Are you sure you want to delete your account? This action cannot be undone.",
    "cancel": "Cancel",
    "confirmDelete": "Confirm Deletion",
    "signIn": "Sign In"
  },
  "hero": {
    "title": "Welcome to BrainMessenger",
    "subtitle": "Your Smart Communication Platform",
    "getStarted": "Get Started",
    "learnMore": "Learn More",
    "connectSmarterTitle": "Connect Smarter with BrainMessenger",
    "connectSmarterSubtitle": "Experience the next generation of messaging with advanced features, unparalleled security, and seamless communication across all your devices.",
    "downloadButton": "Download",
    "downloadAndroid": "Download for Android"
  },
  "features": {
    "featuresTitle": "Key Features",
    "featuresSubtitle": "Discover what makes us unique",
    "secureMessaging": "Secure Messaging",
    "secureMessagingDesc": "End-to-end encryption for your privacy",
    "smartAssistant": "Smart Assistant",
    "smartAssistantDesc": "AI-powered help at your fingertips",
    "crossPlatform": "Cross Platform",
    "crossPlatformDesc": "Use on any device, anywhere",
    "groupChats": "Group Chats",
    "groupChatsDesc": "Connect with multiple people at once",
    "privacyFirst": "Privacy First",
    "privacyFirstDesc": "Your data is yours, always"
  },
  "news": {
    "latestNews": "Latest news",
    "readMore": "Read More",
    "previousButton": "Previous news item",
    "nextButton": "Next news item",
    "pauseAutoplay": "Pause autoplay",
    "playAutoplay": "Play autoplay"
  },
  "roadmap": {
    "title": {
      "section": "Roadmap",
      "projectLaunch": "Project Launch",
      "enhancedSecurity": "Enhanced Security",
      "advancedCollaboration": "Advanced Collaboration",
      "mobileEnhancement": "Mobile Enhancement",
      "aiIntegration": "AI Integration",
      "globalExpansion": "Global Expansion",
      "enterpriseSolutions": "Enterprise Solutions",
      "futureInnovation": "Future Innovation"
    },
    "subtitle": {
      "section": "Our Future Vision"
    },
    "status": {
      "completed": "Completed",
      "inProgress": "In Progress",
      "upcoming": "Upcoming"
    },
    "description": {
      "projectLaunch": "Initial launch of BrainMessenger with core features.",
      "enhancedSecurity": "Strengthening security protocols and features.",
      "advancedCollaboration": "Introducing advanced collaboration tools.",
      "mobileEnhancement": "Enhancing mobile application experience.",
      "aiIntegration": "Integrating AI-powered features for smarter communication.",
      "globalExpansion": "Expanding BrainMessenger's reach globally.",
      "enterpriseSolutions": "Developing solutions for enterprise clients.",
      "futureInnovation": "Exploring and implementing future technologies."
    },
    "features": {
      "secureMessagingInfrastructure": "Secure messaging infrastructure",
      "crossPlatformCompatibility": "Cross-platform compatibility",
      "basicUserInterface": "Basic user interface",
      "endToEndEncryption": "End-to-end encryption",
      "twoFactorAuthentication": "Two-factor authentication",
      "fileSharingCapabilities": "File sharing capabilities",
      "teamWorkspaces": "Team workspaces",
      "realTimeCollaboration": "Real-time collaboration",
      "advancedFileSharing": "Advanced file sharing",
      "nativeMobileApps": "Native mobile apps",
      "offlineFunctionality": "Offline functionality",
      "pushNotifications": "Push notifications",
      "smartMessageCategorization": "Smart message categorization",
      "automatedResponses": "Automated responses",
      "contentAnalysis": "Content analysis",
      "multiLanguageSupport": "Multi-language support",
      "regionalDataCenters": "Regional data centers",
      "culturalAdaptations": "Cultural adaptations",
      "advancedAdminControls": "Advanced admin controls",
      "customIntegrations": "Custom integrations",
      "enterpriseSupport": "Enterprise support",
      "emergingTechnologies": "Emerging technologies",
      "communityDrivenFeatures": "Community-driven features",
      "platformExpansion": "Platform expansion"
    },
    "date": {
      "jan2024": "January 2024",
      "mar2024": "March 2024",
      "jun2024": "June 2024",
      "sep2024": "September 2024",
      "nov2024": "November 2024",
      "jan2025": "January 2025",
      "mar2025": "March 2025",
      "jun2025": "June 2025",
      "beyond2025": "Beyond 2025"
    }
  },
  "faq": {
    "title": "Frequently Asked Questions",
    "subtitle": "Find answers to common questions about BrainMessenger",
    "searchAlt": "Search icon",
    "searchPlaceholder": "Search questions...",
    "allQuestions": "All Questions",
    "noResults": "No questions found matching your search.",
    "categories": {
      "general": "General",
      "technical": "Technical",
      "security": "Security",
      "pricing": "Pricing",
      "generalProject": "General Project Questions",
      "technicalQuestions": "Technical Questions",
      "developmentProcesses": "Development Processes",
      "statusRoadmapFuture": "Status, Roadmap, and Future",
      "challengesOpportunitiesLimitations": "Challenges, Opportunities, and Limitations",
      "learnMoreContribute": "Learn More and Contribute"
    },
    "questionsData": {
      "generalProject": {
        "q1": {
          "question": "What is the main idea behind BrainMessenger? What makes it special?",
          "answer": "BrainMessenger is not just another messenger. Our main idea is to create a Digital ASSET (Principle 10) that simplifies complex interaction (Margulan Seisembayev's principle) and serves as a reliable tool for effective communication. We are focused on quality (Principle 3), security (Principle 5), and reliability (Principle 3), not just a set of features. We are building a SYSTEM (Principle 9) that reflects our principles and is constantly improving."
        },
        "q2": {
          "question": "What key principles underpin the development of BrainMessenger?",
          "answer": "The project is based on a set of 15 key principles (see My Key Principles), inspired by Margulan Seisembayev and IT industry best practices. The most important ones influencing code and processes are: Continuous Learning (Principle 1), Value Creation (Principle 2), Quality > Quantity (Principle 3), System and Optimization (Kaizen, Principle 9), Long-Term Thinking (Principle 8), Pragmatism and Realism (Principle 12), Persistence (Principle 13), Bias for Action (Principle 15). We strive for these principles to permeate all aspects of the project."
        },
        "q3": {
          "question": "Who is behind the project? Is it an open community or a team?",
          "answer": "Currently, the project is at an early stage and is actively being developed by one person (you), who is the driving force and bears responsibility (Principle 6) for its construction. In the future, it is planned to attract contributors and possibly form a team. The project is open for contributions (see CONTRIBUTING.md)."
        }
      },
      "technicalQuestions": {
        "q1": {
          "question": "Why was this particular technology stack chosen (TypeScript, NestJS, React/RN, PostgreSQL/Neon, GraphQL, Kafka, Redis, Cloudflare R2, etc.)?",
          "answer": "The choice of stack is based on pragmatism (Principle 12), long-term thinking (Principle 8), and the pursuit of quality (Principle 3) and scalability (NFR-14, NFR-15).\n*   TypeScript: Increases code reliability and maintainability through strong typing.\n*   NestJS: Provides a powerful, modular architecture for the Backend, simplifying the construction of scalable applications.\n*   React/React Native/Next.js: Allow building UI for different platforms from a single codebase (cross-platform) and provide good performance.\n*   PostgreSQL (Neon): A reliable, proven relational database with extensive scaling and optimization capabilities. Neon as a managed service reduces operational overhead (Pragmatism).\n*   Prisma: Chosen as a reliable ORM, providing type safety and built-in protection against SQL injection (Quality, Security).\n*   GraphQL: Allows clients to request only the data they actually need with a single query, optimizing network interaction (especially for mobile clients) and reducing data redundancy compared to REST. GraphQL also simplifies fetching related data (solving N+1 problems with DataLoader).\n*   Kafka: Chosen for reliable asynchronous task processing, which is critical for scalability and fault tolerance.\n*   Redis: High-performance In-memory store for caching, Rate Limiting, and real-time state management.\n*   Cloudflare R2: Object storage with very favorable terms (no egress fees), ideal for storing user files (Pragmatism, ASSET).\n\nThis stack allows laying a solid technical foundation (Principle 8) for future development."
        },
        "q2": {
          "question": "Why is a monolithic architecture used at the start, rather than microservices immediately?",
          "answer": "Using a monolithic architecture at the start (MVP) is a pragmatic and realistic decision (Principle 12). It allows for rapid development and iteration of basic functionality, minimizing complexity at an early stage when the team is small. Launching the MVP is more important than building an overly complex architecture. Once the MVP will be completed and the project starts to grow, a phased transition to microservices is planned (see Microservice Migration Plan)."
        },
        "q3": {
          "question": "What approaches are used to ensure security?",
          "answer": "Security is a fundamental aspect (Principle 5) and a priority (see Security Guide).\n*   Data encryption in transit (TLS 1.2+) and at rest (AES for sensitive data, encryption in R2).\n*   Strong password hashing (bcrypt/argon2).\n*   Using Prisma to prevent SQL injection.\n*   Validation of all input data on the Backend.\n*   Two-factor authentication (2FA) via email.\n*   Rate Limiting to protect against brute-force and DDoS attacks.\n*   Regular vulnerability scanning.\n*   Storing secrets in secure locations (Kubernetes Secrets)."
        },
        "q4": {
          "question": "How is real-time functionality implemented (message exchange)?",
          "answer": "Real-time functionality (message exchange) is implemented using WebSockets. The Backend (NestJS Gateway) manages WebSocket connections, and clients subscribe to chat events. Message delivery occurs via WebSocket. For scaling WebSockets in a microservice architecture, Redis Pub/Sub or Kafka will be used."
        },
        "q5": {
          "question": "Why is GraphQL used instead of REST API?",
          "answer": "GraphQL allows clients to request only the data they actually need with a single query. This optimizes network interaction (especially for mobile clients) and reduces data redundancy compared to REST. GraphQL also simplifies fetching related data (solving N+1 problems with DataLoader)."
        },
        "q6": {
          "question": "How are large volumes of data and files managed?",
          "answer": "*   Structured data (messages, users, chats): Stored in PostgreSQL (Neon). Indexes and query optimization (Prisma) are used for fast retrieval. As it grows, table partitioning and database replication are planned.\n*   Unstructured data (files, images): Stored in Cloudflare R2. Asynchronous processing (Kafka) is used for image optimization before uploading. R2 is chosen for scalability and favorable traffic rates."
        }
      },
      "developmentProcesses": {
        "q1": {
          "question": "What is the approach to project and task management?",
          "answer": "The project is managed using a planning system (see My Planning System 2025-2026) in Notion. Global goals are decomposed into stages (Roadmap), weekly planning, and a task tracker are used. An important element is the Kaizen Hour (Principle 9) for daily reflection, analyzing bottlenecks, and finding ways to improve."
        },
        "q2": {
          "question": "How is code quality ensured?",
          "answer": "Code quality is ensured through systematic approaches (Principle 3, 9):\n*   Using TypeScript with strict typing.\n*   Adhering to coding standards (ESLint, Prettier).\n*   Code review of all changes.\n*   Automated testing at different levels (Unit, Integration, E2E).\n*   Continuous Integration (CI) for automatic code and test checks on every commit/PR."
        },
        "q3": {
          "question": "What testing strategy is used?",
          "answer": "A multi-level testing strategy is used (see Testing Guide), combining manual and automated testing: Unit, Integration, API, E2E, Load, Security, Regression. Tests are integrated into CI/CD. The focus is on verifying key requirements (FRs, NFRs)."
        },
        "q4": {
          "question": "How are errors handled?",
          "answer": "Errors are handled centrally and uniformly on the Backend (NestJS Exception Filters) and converted to a standard API response format with codes (extensions.code). On the Frontend, errors are processed based on these codes, displaying a clear message to the user and suggesting an action. All errors are thoroughly logged (Winston → ELK) and sent to Sentry for tracking and analysis (see Error Specification, Monitoring Guide)."
        },
        "q5": {
          "question": "How is the project deployed?",
          "answer": "Deployment is automated through a CI/CD pipeline (GitHub Actions). Docker is used for containerization and Kubernetes for orchestration in the cloud. Infrastructure is described as code (Terraform). The process includes automatic build, testing, image publishing, and Rolling Updates in Kubernetes for zero-downtime deployment (see Deployment Guide)."
        },
        "q6": {
          "question": "How is the system monitored in production?",
          "answer": "The monitoring system is the eyes and ears of the project (Principle 9, 5). The following are used:\n*   Prometheus for collecting performance and resource metrics.\n*   Grafana for visualizing metrics and dashboards.\n*   Sentry for tracking application errors (Frontend and Backend).\n*   ELK Stack (or Kibana with Winston) for centralized logging and analysis.\n*   Alertmanager for configuring automatic alerts about problems.\nThese tools allow for proactive problem identification and optimization (see Monitoring Guide)."
        }
      },
      "statusRoadmapFuture": {
        "q1": {
          "question": "What is the current status of the project?",
          "answer": "The project is in the active development phase of the Minimum Viable Product (MVP). The main technological foundation has been laid, key UI elements and basic security have been implemented. The core messaging, file handling, and group/channel creation are in progress. (See BrainMessenger Project Requirements (MVP) Guide)."
        },
        "q2": {
          "question": "What are the next steps after completing the MVP?",
          "answer": "After completing the MVP, the next steps include adding advanced functions (audio/video calls, Premium, extended security, full set of animations and localization), further performance optimization, and preparing for scaling. A detailed plan is presented in the BrainMessenger Roadmap (see Roadmap)."
        },
        "q3": {
          "question": "Is a transition to a microservice architecture planned?",
          "answer": "Yes, the transition to microservices is part of the long-term development strategy (Principle 8). It is planned in stages, starting from Q1 2026, using the Strangler Pattern approach. This will allow components to be scaled independently, increasing fault tolerance and flexibility (see Microservice Migration Plan)."
        }
      },
      "challengesOpportunitiesLimitations": {
        "q1": {
          "question": "What are the main technical challenges (pitfalls) in the project?",
          "answer": "*   Implementing reliable real-time functionality (WebSockets): Managing thousands of simultaneous connections, reliable message delivery, managing online/offline status.\n*   Scaling the database with large data volumes: Managing the growth of the messages table (partitioning), optimizing complex queries.\n*   Handling and delivering files: Efficient uploading, image optimization, secure downloading from Cloudflare R2.\n*   Transitioning to microservices: Increased operational complexity, configuring inter-service communication (Kafka, GraphQL Federation), data migration.\n*   Maintaining high quality and performance: Continuous optimization at all levels (Backend, Frontend, Infrastructure) as load and functionality grow."
        },
        "q2": {
          "question": "What opportunities and advantages does the project's architecture and stack provide?",
          "answer": "*   High scalability: The chosen technologies (NestJS, Kubernetes, Kafka, Redis, Neon, R2) allow the application to be scaled horizontally to support a large number of users.\n*   Reliability and fault tolerance: Using reliable services, asynchronous processing (Kafka), monitoring, and, in the future, microservices increases the system's resilience to failures.\n*   High performance: GraphQL, caching, query optimization, asynchronous processing contribute to the application's fast operation.\n*   Cross-platform compatibility: React Native and Next.js allow creating applications for all major platforms from a single codebase (for UI).\n*   Code quality and maintainability: TypeScript, NestJS, Prisma, coding standards, testing simplify development and reduce the number of defects.\n*   Cost-effectiveness (at the start): Using free/affordable tiers (Neon, R2) and proven open-source solutions.\n*   Rich ecosystem: Using popular technologies with a large community and many ready-made libraries."
        },
        "q3": {
          "question": "What are the project's limitations at the current stage (MVP)?",
          "answer": "*   Limited set of features compared to the vision (no calls, Premium, enhanced security).\n*   Limited multilingualism and accessibility options (expansion planned).\n*   The architecture is currently monolithic, which imposes limitations on independent scaling of individual parts.\n*   There may be performance limitations under load significantly exceeding the target for MVP (~1000 simultaneous users) before implementing deep optimizations and microservices."
        }
      },
      "learnMoreContribute": {
        "q1": {
          "question": "Where can I get more detailed information about the project?",
          "answer": "More detailed information can be found in our documentation (the link will be added later) and on the project's GitHub page (if the project is open source)."
        },
        "q2": {
          "question": "How can I join the project's development or contribute?",
          "answer": "We are always happy to welcome new participants! Contact us via the contact form on the website or via GitHub (if the project is open) to discuss possible options for cooperation."
        },
        "q3": {
          "question": "Where can I ask additional questions?",
          "answer": "Additional questions can be asked via the contact form on the website, in our community (link will be added) or by creating an issue on GitHub (if the project is open)."
        }
    }
  },
  "docs": {
    "general": {
      "title": "BrainMessenger - Your Digital Asset for Effective Communication",
      "subtitle": "Introduction: Building a System of Value",
      "introduction": {
        "title": "Introduction: Building a System of Value",
        "content": "Welcome to the BrainMessenger repository. This is not just another messenger. It is a purposeful project aimed at creating a <strong>reliable, scalable, and secure SYSTEM</strong> (Principle 9) that will become a <strong>key digital ASSET</strong> (Principle 10) for every user. Our main goal is to <strong>simplify complexity</strong> (Margulan Seisembayev's principle), providing intuitive and powerful tools for effective communication and interaction in the modern digital world.<br/><br/>BrainMessenger is built upon a <strong>strong foundation</strong> (Principle 8) of deep principles, conscious planning, and <strong>continuous learning</strong> (Principle 1). Every line of code, every decision made – this is a <strong>long-term investment</strong> (Principle 8) in the <strong>quality</strong> (Principle 3) and <strong>value</strong> (Principle 2) of our product."
      },
      "visionAndMission": {
        "title": "Vision and Mission: Our Long-Term View",
        "visionTitle": "Our Vision:",
        "visionContent": "To create a leading digital asset for communication that helps millions of users worldwide effectively exchange information, build communities, and achieve their goals.",
        "missionTitle": "Our Mission:",
        "missionContent": "To simplify complex interaction by providing a reliable, secure, and user-friendly messenger built on principles of quality, transparency, and continuous improvement."
      },
      "keyPrinciples": {
        "title": "Key Principles: The Foundation of Our System",
        "intro": "Our actions and decisions are guided by a set of key principles that serve as the <strong>foundation</strong> (Principle 8) of the entire BrainMessenger project. These are not just words, but <strong>personal algorithms and standards (Kaizen, Principle 9)</strong>, developed through experience and reflection (Principle 1):",
        "principles": [
          "<strong>Continuous Learning and Growth (Principle 1):</strong> The process of creating BrainMessenger is a proving ground for deep learning in technology, architecture, and user psychology. We learn at every step, turning mistakes into lessons.",
          "<strong>Creating Value (Principle 2):</strong> The user's benefit is at the core of everything. We build something that genuinely solves problems and makes life better.",
          "<strong>Quality Over Quantity (Principle 3):</strong> We strive to do things well, not just quickly. Reliability, thoughtfulness, and attention to detail are our priorities.",
          "<strong>Mindfulness and Presence (Principle 4):</strong> Being attentive to the process, users, and the team.",
          "<strong>Health as a Foundation (Principle 5):</strong> The physical and mental well-being of the team (and future users) is the basis for productivity and sustainability.",
          "<strong>Responsibility and Proactivity (Principle 6):</strong> We take responsibility for the outcome and act preemptively.",
          "<strong>Integrity (Principle 7):</strong> Our words align with our actions.",
          "<strong>Long-term Thinking (Principle 8):</strong> We invest time and effort with a view to the future.",
          "<strong>System and Optimization (Principle 9):</strong> We build processes and architecture as a system, constantly seeking ways to increase efficiency (Kaizen).",
          "<strong>Creating Wealth > Earning Money (Principle 10):</strong> Focusing on creating an ASSET (BrainMessenger) that brings value and works in the long term.",
          "<strong>Flexibility and Adaptability (Principle 11):</strong> Willingness to change tactics and tools while maintaining the vision.",
          "<strong>Pragmatism and Realism (Principle 12):</strong> Making decisions based on real data and capabilities.",
          "<strong>Persistence (Principle 13):</strong> Not giving up in the face of difficulties, extracting lessons from failures.",
          "<strong>Using External Expertise and Feedback (Principle 14):</strong> We learn from others, listen to constructive criticism.",
          "<strong>Bias for Action (Principle 15):</strong> In the early stages, it's more important to start doing and get feedback than to plan endlessly."
        ],
        "outro": "These principles, inspired by the philosophy of Margulan Seisembayev and the practices of leading IT companies, shape our culture and development approach."
      },
      "aboutMVP": {
        "title": "About the BrainMessenger Project (MVP Focus)",
        "intro": "Our current focus – on the development of the <strong>Minimum Viable Product (MVP)</strong>. MVP – this is the first, <strong>pragmatic</strong> (Principle 12) step towards realizing our vision. We are building a <strong>solid technical foundation</strong> (Principle 8) that will allow us to quickly and efficiently develop the product in the future.",
        "featuresTitle": "The MVP includes basic but <strong>high-quality and reliable</strong> (Principle 3) features that provide key <strong>value</strong> (Principle 2):",
        "features": [
          "<strong>Basic Messaging:</strong> Sending and receiving text messages in personal chats and groups/channels.",
          "<strong>File Sharing:</strong> Uploading and downloading files (with image optimization).",
          "<strong>Channels and Groups:</strong> Basic creation of groups/channels, joining public channels, and reading content.",
          "<strong>Basic Account Management:</strong> Registration, login/logout, profile editing (name, avatar), basic security settings.",
          "<strong>Core UI Settings:</strong> Choosing the theme (Light/Dark), basic notification and language settings.",
          "<strong>Basic Security:</strong> Data encryption (TLS, password hashing, basic measures against SQLi/XSS/DDoS), email confirmation during registration.",
          "<strong>Adaptive UI:</strong> An interface adapted for mobile (Android, iOS) and web platforms.",
          "<strong>Basic Multilingualism:</strong> Support for several interface languages (English, Russian, and others as per DocLocIn.md)."
        ],
        "outro": "Functionality beyond the MVP (audio/video calls, advanced security/privacy features, premium subscription, full animation set, AI integrations) is planned for subsequent stages of the Roadmap."
      },
      "howWeBuild": {
        "title": "How We Build: The Story of Creation and the Kaizen Process",
        "intro": "The process of creating BrainMessenger is a living story, based on our principles. We build it <strong>systematically</strong> (Principle 9), step by step, documenting each stage and continuously seeking opportunities for <strong>improvement (Kaizen)</strong>.",
        "steps": [
          "<strong>Mindful Planning (Principle 4):</strong> The project began with a clear definition of global goals and their decomposition into achievable stages (Roadmap).",
          "<strong>Choosing the Foundation (Principle 8, 12):</strong> We carefully selected the technology stack – reliable and <strong>pragmatic</strong> tools (TypeScript, NestJS, React/RN, PostgreSQL/Neon, Cloudflare R2, Kafka, Redis) that form a <strong>solid technical foundation</strong>.",
          "<strong>Building the MVP Core:</strong> Implementation started with the basic, critical parts of the system (Authentication, Basic UI, Infrastructure, File Handling). We apply <strong>Bias for Action</strong> (Principle 15), focusing on building working components, even if they are minimal for now.",
          "<strong>Continuous Learning and Applying Knowledge (Principle 1):</strong> Every new task, especially related to learning or integrating technologies (as seen in the <a href=\"https://www.notion.so/2025-2026-1576e78881b7435e9c3c2cf174e61b91?pvs=4\" target=\"_blank\" rel=\"noopener noreferrer\">Video Tracker</a> and tasks), is viewed as an opportunity for growth. We document this process through videos and reflection (Kaizen-Hour).",
          "<strong>Systemic Approach to Quality (Principle 3, 9):</strong> We integrate testing early in the development cycle (Unit tests), configure CI/CD pipelines for automated checks, and use monitoring (Prometheus, Grafana, Sentry) and logging (Winston, ELK) tools for continuous control over the <strong>system's health</strong> (Principle 5) in real time.",
          "<strong>Documentation as Part of the Knowledge System:</strong> The entire development process, architectural decisions, standards, and requirements are carefully documented. This is not just a formality, but part of creating a <strong>knowledge system</strong> that accelerates onboarding, simplifies support, and enables informed decision-making in the future."
        ],
        "outro": "We are building BrainMessenger as a living, evolving organism, constantly adapting and improving based on our principles and feedback from the development process and future users."
      },
      "technologyStack": {
        "title": "Technology Stack: Our Tools for Creating the Asset",
        "intro": "We have chosen a stack that is <strong>pragmatic</strong> (Principle 12), <strong>reliable</strong> (Principle 3), and <strong>scalable</strong> (Principle 8) to create our <strong>digital ASSET</strong>.",
        "stack": [
          "<strong>Language:</strong> <a href=\"https://www.typescriptlang.org/\" target=\"_blank\" rel=\"noopener noreferrer\">TypeScript</a> - Static typing to enhance code quality and reliability.",
          "<strong>Backend:</strong> <a href=\"https://nodejs.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Node.js</a>, <a href=\"https://nestjs.com/\" target=\"_blank\" rel=\"noopener noreferrer\">NestJS</a> - Efficient and structured framework for server logic and GraphQL API.",
          "<strong>Frontend:</strong> <a href=\"https://react.dev/\" target=\"_blank\" rel=\"noopener noreferrer\">React</a>, <a href=\"https://nextjs.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Next.js</a> (Web), <a href=\"https://reactnative.dev/\" target=\"_blank\" rel=\"noopener noreferrer\">React Native</a> (Mobile/Desktop) - Cross-platform UI development focusing on performance.",
          "<strong>API:</strong> <a href=\"https://graphql.org/\" target=\"_blank\" rel=\"noopener noreferrer\">GraphQL</a> - Flexible interaction between client and server.",
          "<strong>Real-time:</strong> WebSockets - Instant message delivery.",
          "<strong>Database:</strong> <a href=\"https://www.postgresql.org/\" target=\"_blank\" rel=\"noopener noreferrer\">PostgreSQL</a> (via <a href=\"https://neon.tech/\" target=\"_blank\" rel=\"noopener noreferrer\">Neon</a>) - Reliable and scalable database. Neon as a managed service reduces operational overhead (Pragmatism).",
          "<strong>ORM:</strong> <a href=\"https://www.prisma.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Prisma</a> - Type-safe and reliable database interaction, protection against SQL injection (Quality, Security).",
          "<strong>Caching:</strong> <a href=\"https://redis.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Redis</a> - High-performance caching and state management.",
          "<strong>Queues:</strong> <a href=\"https://kafka.apache.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Kafka</a> - Reliable asynchronous task processing.",
          "<strong>File Storage:</strong> <a href=\"https://www.cloudflare.com/developer/r2/\" target=\"_blank\" rel=\"noopener noreferrer\">Cloudflare R2</a> - Object storage with favorable pricing and no egress fees (Pragmatism, ASSET).",
          "<strong>Notifications:</strong> <a href=\"https://firebase.google.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Firebase</a> - Managed service for push notifications.",
          "<strong>Email/2FA:</strong> <a href=\"https://developers.google.com/gmail/api\" target=\"_blank\" rel=\"noopener noreferrer\">Gmail API</a> - Reliable delivery of transactional emails (Confirmation codes, 2FA).",
          "<strong>Payments:</strong> <a href=\"https://stripe.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Stripe</a>, Cryptomus (Beyond MVP) - ASSET monetization, Pragmatism.",
          "<strong>Testing:</strong> Jest, Cypress, Detox, k6, OWASP ZAP/Burp Suite (plan) - Comprehensive approach to ensuring quality.",
          "<strong>Deployment:</strong> <a href=\"https://vercel.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Vercel</a> (Web), Docker, <a href=\"https://kubernetes.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Kubernetes</a> - Automated and scalable deployment.",
          "<strong>Monitoring:</strong> Prometheus, Grafana, Sentry (plan) - System visibility and Kaizen analysis."
        ]
      },
      "architecture": {
        "title": "Architecture: The Evolution of the System",
        "intro": "Currently, BrainMessenger is implemented as a <strong>monolithic application based on NestJS</strong>. This is a <strong>pragmatic</strong> (Principle 12) decision for the MVP, allowing us to quickly launch the product and validate core hypotheses.",
        "future": "In the future, as the project grows and the load increases, we plan a phased transition to a <strong>microservice architecture</strong> using the <strong>Strangler Pattern</strong>. This is a <strong>long-term strategy</strong> (Principle 8) that will enable independent scaling and development of individual components (chats, calls, AI, payments), increasing the system's overall <strong>reliability and flexibility</strong> (Principle 3, 11).",
        "interaction": "Interaction between components will be via <strong>GraphQL API</strong> (synchronously) and <strong>Kafka</strong> (asynchronously), using <strong>Apollo Federation</strong> (in the future) to build a unified API schema from multiple microservices."
      },
      "projectStatus": {
        "title": "Project Status: Current Stage (MVP)",
        "content": "At this time, the project is in the active development stage of the <strong>MVP</strong> (as per the <a href=\"https://www.notion.so/MVP-11a2a21315e54eb3b3c90171b4c7493d?pvs=4\" target=\"_blank\" rel=\"noopener noreferrer\">MVP Requirements Instruction</a>). We are focused on completing the core messaging functionality, file handling, group/channel creation, and basic settings, while simultaneously strengthening the <strong>technical foundation</strong> (Principle 8) and embedding <strong>continuous learning</strong> and <strong>Kaizen</strong> processes into our daily work.",
        "progress": "Progress is documented through tasks, code in the repository, and video recordings that showcase our journey and the <strong>process of creation</strong> (Principle 1)."
      },
      "gettingStarted": {
        "title": "Getting Started (For Developers)",
        "intro": "Want to join us in building this digital ASSET? Here's how to get started:",
        "steps": [
          "Clone the repository:<br/>```bash<br/>git clone <URL of your repository><br/>cd BrainMessenger<br/>```",
          "Install dependencies:<br/>```bash<br/>npm install # Turborepo will install dependencies for all packages<br/>```",
          "Set up environment variables: Copy `.env.example` to `.env` and fill in the necessary data for integrations (Neon, R2, Firebase, etc.). <strong>Do not commit your `.env` file!</strong><br/>```bash<br/>cp .env.example .env<br/># Fill in .env<br/>```",
          "Set up the database: Run a local PostgreSQL or use a Neon instance, then apply Prisma migrations.<br/>```bash<br/>cd backend<br/>npx prisma migrate dev --name initial_setup # Or npx prisma migrate deploy for production<br/>cd ..<br/>```",
          "Start services in development mode:<br/>```bash<br/>turbo run dev # This will start backend and frontend dev servers<br/># Or navigate to specific packages and run their dev scripts:<br/># cd backend && npm run start:dev<br/># cd packages/web && npm run dev<br/># cd packages/mobile-desktop && npm run android / npm run windows<br/>```"
        ],
        "outro": "More detailed instructions on local setup and development can be found in the <a href=\"link_to_development_guide_doc\" target=\"_blank\" rel=\"noopener noreferrer\">Development Guide</a>."
      },
      "documentationSystem": {
        "title": "Documentation: Our System of Knowledge",
        "intro": "This README provides a high-level overview. All detailed information about the project is contained within our <strong>comprehensive system of documentation</strong>. Exploring these documents is part of the <strong>learning</strong> process (Principle 1) and understanding the <strong>system</strong> (Principle 9):",
        "links": [
          "<a href=\"docs/AllRequirements/Docs/Planning/DocReq.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Requirements Documentation</strong></a>: What we are building (functional and non-functional requirements).",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocDevIn.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Development Guide</strong></a>: How we write code (structure, standards, tools, CI/CD process).",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocTech.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Technical Documentation</strong></a>: High-level overview of the architecture and stack.",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocSpec.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>API Specification</strong></a>: How components interact (GraphQL API description).",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocInt.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Integrations Documentation</strong></a>: How we use external services (Neon, R2, Firebase, Stripe, etc.) as <strong>levers</strong>.",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocSecurity.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Security Guide</strong></a>: How we protect the ASSET and data (principles, methods, tools, process).",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocPer.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Performance Guide</strong></a>: How we make the system fast (metrics, techniques, optimization tools).",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocMonLog.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Monitoring and Logging Guide</strong></a>: How we see the system's state (metrics, logs, alerts).",
          "<a href=\"docs/AllRequirements/Docs/Design/Design/DocUI.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>UI Documentation</strong></a>: What the application looks like and why (layouts, components, design principles).",
          "<a href=\"docs/AllRequirements/Docs/Sound/DocSound.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Audio Guide</strong></a>: How audio is used to enhance UX.",
          "<a href=\"docs/AllRequirements/Docs/Support/DocSupport.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Support and Maintenance Guide</strong></a>: How we support the system and users after release.",
          "<a href=\"docs/AllRequirements/Docs/Testing/DocSpecError.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Error Specification</strong></a>: How we handle and report errors.",
          "<a href=\"docs/AllRequirements/Docs/Testing/DocTesting.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Testing Guide</strong></a>: How we verify quality and reliability.",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocMigrationMicro.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Microservice Migration Plan</strong></a>: Our long-term architectural evolution strategy.",
          "<a href=\"docs/AllRequirements/Docs/Planning/DocReq.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>MVP Requirements Instruction</strong></a>: Detailed analysis of MVP requirements and implementation status."
        ]
      },
      "contribution": {
        "title": "Contribution",
        "content": "We welcome contributions to the building of this digital ASSET! If you have ideas, suggestions, or want to help with the code, please refer to the <a href=\"CONTRIBUTING.md\" target=\"_blank\" rel=\"noopener noreferrer\">Contribution Guide</a> (if available)."
      }
    },
    "design": {
      "title": "Документация Дизайна BrainMessenger",
      "subtitle": "Система Качества и Ценности",
      "section1": {
        "title": "1. Введение: Дизайн как Фундамент Ценности",
        "name": "BrainMessenger Design System",
        "description": "Эта дизайн-система определяет визуальные и функциональные стандарты для интерфейса BrainMessenger. Наша цель — создать интерфейс, который не просто выглядит хорошо, но и является <strong>интуитивно понятным, эффективным и доступным</strong> (Принцип 2: Создание Ценности), опираясь на принципы <strong>качества > количества</strong> (Принцип 3) и <strong>прагматизма</strong> (Принцип 12) в выборе решений.",
        "goal": "Обеспечить <strong>единообразие, надежность и позитивный пользовательский опыт</strong> на всех платформах (Windows, Android, веб), делая BrainMessenger <strong>полезным АКТИВОМ</strong> (Принцип 10) для пользователей.",
        "principles_title": "Принципы, которыми руководствуется дизайн:",
        "principles": [
          "<strong>Создание Ценности (Принцип 2):</strong> Дизайн должен быть функциональным и решать задачи пользователя максимально удобно и эффективно.",
          "<strong>Качество > Количество (Принцип 3):</strong> Фокус на отточенности ключевых элементов, а не на множестве непродуманных деталей. Дизайн должен быть <strong>надежным</strong> и <strong>продуманным</strong>.",
          "<strong>Прагматизм и Реализм (Принцип 12):</strong> Выбор дизайнерских решений, реализуемых с учетом технических ограничений (например, оптимизация анимаций).",
          "<strong>Целостность (Принцип 7):</strong> Визуальная и функциональная целостность на всех платформах.",
          "<strong>Здоровье как Фундамент (Принцип 5):</strong> Внимание к доступности (WCAG), чтобы дизайн не создавал излишней нагрузки (зрительной, когнитивной) на пользователя."
        ]
      },
      "section2": {
        "title": "2. Цветовая палитра: Визуальный язык BrainMessenger",
        "intro": "Цвета разделены для Light и Dark режимов, поддерживая переключение темы (функция \"Night Mode\"). Все цвета заданы в HEX.",
        "light_mode_title": "2.1. Light Mode",
        "light_mode_table": [
          ["Категория", "Цвет (HEX)", "Назначение"],
          ["<strong>Primary Gradient</strong>", "`#A7F43A` → `#00C853`", "Основной градиент для акцентных элементов (кнопки \"Get Started\", иконки)"],
          ["<strong>Accent</strong>", "`#FF6347`", "Акцентные элементы (ошибки, важные сообщения)"],
          ["<strong>Secondary</strong>", "`#00BFFF`", "Второстепенные кнопки, ссылки, интерактивные элементы"],
          ["<strong>Success</strong>", "`#96C93D`", "Подтверждение, успешные действия"],
          ["<strong>Background</strong>", "`#FFFFFF`", "Основной фон"],
          ["<strong>Surface</strong>", "`#F0F0F0`", "Карточки, панели, фоны сообщений"],
          ["<strong>Text Primary</strong>", "`#333333`", "Основной текст"],
          ["<strong>Text Secondary</strong>", "`#4D4D4D`", "Вторичный текст, подсказки, метаданные"],
          ["<strong>Disabled</strong>", "`#B0B0B0`", "Неактивные элементы"],
          ["<strong>Border</strong>", "`#E8E8D9`", "Границы, разделители"]
        ],
        "dark_mode_title": "2.2. Dark Mode",
        "dark_mode_table": [
          ["Категория", "Цвет (HEX)", "Назначение"],
          ["<strong>Primary Gradient</strong>", "`#F2F047` → `#1ED94F`", "Основной градиент для акцентных элементов"],
          ["<strong>Accent</strong>", "`#FF6347`", "Акцентные элементы (ошибки)"],
          ["<strong>Secondary</strong>", "`#00BFFF`", "Второстепенные кнопки, ссылки"],
          ["<strong>Success</strong>", "`#96C93D`", "Подтверждение, успешные действия"],
          ["<strong>Background</strong>", "`#1A1A1A`", "Основной фон"],
          ["<strong>Surface</strong>", "`#333333`", "Карточки, панели, фоны сообщений"],
          ["<strong>Text Primary</strong>", "`#FFFFFF`", "Основной текст"],
          ["<strong>Text Secondary</strong>", "`#D9E8D9`", "Вторичный текст, подсказки"],
          ["<strong>Disabled</strong>", "`#4D4D4D`", "Неактивные элементы"],
          ["<strong>Border</strong>", "`#B0B0B0`", "Границы, разделители"]
        ],
        "premium_colors_title": "2.3. Цвета Премиум-Функций (Визуальное выделение Ценности)",
        "premium_colors": [
          "<strong>Premium Accent:</strong> `#FFD600` (Золотой)",
          "<strong>Premium Secondary:</strong> `#2196F3` (Синий)",
          "Используются для визуального выделения премиум-функций (например, в анимациях нейронных связей, специальных элементах UI), подчеркивая их <strong>дополнительную ценность</strong> (Принцип 2, 10)."
        ],
        "color_application_title": "2.4. Применение Цветов (Примеры)",
        "color_application": [
          {
            "title": "Welcome Screen (из скриншота):",
            "items": [
              "Фон: `#1A1A1A` (Dark Mode).",
              "Кнопка \"Get Started\": Градиент `#F2F047` → `#1ED94F`.",
              "Иконка чата: `#F2F047` (обводка) с белым символом внутри.",
              "Текст: `#FFFFFF` (Welcome to Brain Messenger), `#D9E8D9` (подсказка)."
            ]
          },
          {
            "title": "Переключение темы:",
            "items": [
              "Реализовано через глобальный флаг `themeMode` (`Light`/`Dark`).",
              "Пример в React Native:\n```jsx\nimport { useColorScheme } from 'react-native';\nconst themeMode = useColorScheme() === 'dark' ? 'Dark' : 'Light';\nconst backgroundColor = themeMode === 'Dark' ? '#1A1A1A' : '#FFFFFF'; // Пример выбора фона\n```"
            ]
          }
        ],
        "usage_recommendations_title": "2.5. Рекомендации по Использованию Цветов",
        "usage_recommendations": [
          "<strong>Градиенты:</strong> Используйте `#A7F43A` → `#00C853` или `#F2F047` → `#1ED94F` (в зависимости от темы) для ключевых действий и акцентных элементов, привлекающих внимание к <strong>ценности</strong> (Принцип 2).",
          "<strong>Темная тема:</strong> Используйте `#1A1A1A` или `#212121` как основной фон для снижения нагрузки на глаза (связь с Принципом 5: Здоровье).",
          "<strong>Контраст:</strong> Всегда проверяйте контрастность текста и элементов для обеспечения <strong>доступности</strong> (WCAG 2.1 AA) и соответствия Принципу 7 (Целостность). Используйте инструменты вроде WebAIM Contrast Checker."
        ]
      },
      "section3": {
        "title": "3. Типографика: Читаемость как Основа Эффективности",
        "intro": "Выбор шрифта и его применение основаны на обеспечении максимальной читаемости и доступности, что критически важно для эффективного усвоения информации и снижения когнитивной нагрузки (связь с Принципом 5: Здоровье и Принципом 2: Ценность).",
        "primary_font_title": "3.1. Основной шрифт",
        "primary_font": [
          "<strong>Семейство:</strong> Roboto (Google Fonts)",
          "<strong>Запасной:</strong> Sans-serif",
          "<strong>Причина:</strong> Высокая читаемость на разных размерах экрана, широкая поддержка символов (мультиязычность), открытая лицензия и доступность."
        ],
        "sizes_styles_title": "3.2. Размеры и стили (Шкала для Иерархии)",
        "sizes_styles_table": [
          ["Уровень", "Размер", "Начертание", "Использование"],
          ["H1 (Заголовок)", "24px", "Bold", "Основные заголовки экранов (например, \"Чаты\")"],
          ["H2 (Подзаголовок)", "18px", "Medium", "Второстепенные заголовки, названия групп"],
          ["Body", "16px", "Regular", "Основной текст сообщений, список чатов"],
          ["Caption", "14px", "Regular", "Подписи под фото, время сообщений, мелкий текст"],
          ["Button", "16px", "Medium", "Текст кнопок действий"]
        ],
        "notes_title": "Примечания:",
        "notes": [
          "<strong>Высота строки (Line Height):</strong> Минимум 1.5 для основного текста для улучшения читаемости.",
          "<strong>Кастомизация (Принцип 2):</strong> Пользователь может выбрать альтернативный шрифт в настройках (например, Open Sans) для адаптации под свои предпочтения.",
          "<strong>Доступность:</strong> Соблюдение контраста и минимального размера шрифта для соответствия WCAG."
        ]
      },
      "section4": {
        "title": "4. Анимации: Оптимизация и Смысл (Принцип 12: Прагматизм)",
        "intro": "Анимации в BrainMessenger используются для улучшения пользовательского опыта, предоставления визуальной обратной связи и придания интерфейсу живости. Однако они должны быть <strong>прагматичными, оптимизированными</strong> (<2 ГБ RAM), и <strong>не создавать излишней нагрузки</strong> (связь с Принципом 5: Здоровье).",
        "principles_title": "4.1. Принципы Анимаций",
        "principles": [
          "<strong>Смысл:</strong> Каждая анимация должна иметь четкую цель – объяснить переход, привлечь внимание к важному, подтвердить действие.",
          "<strong>Плавность:</strong> Использование `ease-in-out` или `ease-out` для натурального движения.",
          "<strong>Оптимизация:</strong> Анимации не должны замедлять интерфейс или потреблять много ресурсов. Длительность подобрана для баланса между плавностью и скоростью.",
          "<strong>Доступность:</strong> Избегание слишком быстрых или мигающих анимаций, которые могут вызвать дискомфорт или приступы у чувствительных пользователей."
        ],
        "list_title": "4.2. Список Анимаций (Примеры)",
        "list_table": [
          ["Название", "Описание", "Триггер", "Параметры", "Связь с Принципами", "Цвета (Light/Dark)"],
          ["Переключение слайдов", "Сдвиг слайдов (Welcome Screen)", "Свайп/клик по стрелке", "0.3 сек, slide left/right", "P2 (Онбординг)", "#96C93D / #96C93D"],
          ["Открытие чата", "Чат появляется снизу вверх", "Клик по чату в списке", "0.3 сек, ease-in-out", "P2 (Навигация)", "#00BFFF / #00BFFF"],
          ["Нажатие кнопки", "Визуальный фидбек при клике (уменьшение)", "Клик по кнопке", "0.2 сек, scale", "P2 (Фидбек)", "Градиент #F2F047→#1ED94F"],
          ["Отправка сообщения", "Сообщение появляется с плавным появлением", "Клик \"Отправить\"", "0.3 сек, fade-in", "P2 (Фидбек)", "#96C93D / #96C93D"],
          ["Переход между экранами", "Сдвиг экрана вправо/влево (базовая навигация)", "Навигация", "0.3 сек, slide", "P2 (Навигация)", "#B0B0B0 / #4D4D4D"],
          ["Анимация иконок (Morph)", "Преобразование иконки (например, mute → unmute)", "Клик (переключение состояния)", "0.4 сек, morph", "P2 (Состояние)", "#FF6347 / #FF6347"],
          ["Волны при нажатии (Ripple)", "Радиальные волны от точки нажатия (фидбек)", "Клик по кнопке/элементу", "0.3 сек, ripple", "P2 (Фидбек)", "#F2F047 / #F2F047"],
          ["Глитч-эффект (Premium)", "Искажение текста для премиум (визуализация)", "Активация подписки", "0.2 сек, glitch", "P2, P10 (Выделение)", "#FF6347 / #FF6347"],
          ["Нейронные связи (Premium)", "Пульсирующие линии (визуализация Актива)", "Премиум-экран", "0.5 сек, pulse", "P2, P10 (Выделение)", "#96C93D / #96C93D"]
        ],
        "implementation_examples_title": "4.3. Примеры Реализации (Фрагменты кода)",
        "css_ripple_title": "CSS для Ripple-эффекта:",
        "css_ripple_code": ".ripple {\n  background: linear-gradient(45deg, #F2F047, #1ED94F); /* Или другие цвета/градиент */\n  border-radius: 50%;\n  animation: ripple 0.3s ease-out;\n}\n@keyframes ripple {\n  to { transform: scale(2); opacity: 0; }\n}",
        "rn_icon_title": "React Native для анімованої іконки:",
        "rn_icon_code": "import Animated from 'react-native-reanimated'; // Пример библиотеки\nimport Icon from 'react-native-vector-icons/MaterialIcons'; // Пример библиотеки\n\nconst color = themeMode === 'Dark' ? '#FFFFFF' : '#333333';\n// Создание анімованого компонента Icon\nconst AnimatedIcon = Animated.createAnimatedComponent(Icon);\n\n// Пример использования с анимацией scale (припускаючи, что 'scale' - это Animated.Value)\n<AnimatedIcon name=\"volume-up\" color={color} style={{ transform: [{ scale: scale }] }} />"
      },
      "section5": {
        "title": "5. Выравнивание и Сетка: Структура и Порядок (Принцип 9: Система)",
        "intro": "Использование последовательной системы выравнивания и модульной сетки — это основа для создания <strong>системного, легко поддерживаемого и визуально гармоничного</strong> интерфейса (Принцип 9: Система).",
        "base_grid": "<strong>Базовая Сетка:</strong> 8px (базовый шаг для определения размеров элементов, отступов, интервалов). Все значения должны быть кратны 8 (или 4 для очень мелких элементов).",
        "alignment_title": "<strong>Выравнивание:</strong>",
        "alignment": [
          "Используется принцип <strong>визуальной иерархии</strong>: более важные элементы располагаются выше или визуально доминируют.",
          "<strong>Вертикальный поток:</strong> Контент на экранах организуется сверху вниз: Заголовок → Поле ввода → Кнопка действия.",
          "<strong>Горизонтальное выравнивание:</strong> Элементы в контейнерах выравниваются по левому краю (для LTR) или правому краю (для RTL), если нет необходимости в центрировании (например, заголовки в шапке).",
          "<strong>Отступы (Padding/Margin):</strong> Используются значения из шкалы, кратной 8px (8, 16, 24, 32, 40, 48 px и т.д.) для создания четких интервалов между элементами и группами элементов."
        ],
        "adaptability_title": "<strong>Адаптивность и Отзывчивость:</strong>",
        "adaptability": [
          "Дизайн адаптируется под различные размеры экрана для обеспечения <strong>ценности</strong> (Принцип 2) на любом устройстве.",
          "<strong>Мобильные устройства:</strong> 320px–767px (Обычно одноколоночный макет).",
          "<strong>Планшеты:</strong> 768px–1023px (Возможно, двухколоночный макет, боковые панели).",
          "<strong>Десктоп:</strong> 1024px+ (Широкий макет, многоколоночный дизайн, боковые панели)."
        ]
      },
      "section6": {
        "title": "6. Принципы Доступности (WCAG 2.1 AA): Дизайн для Всех (Принцип 5: Здоровье, Принцип 7: Целостность)",
        "intro": "<strong>Доступность — это не опция, а фундаментальное требование</strong> (схоже с Принципом 5: Здоровье как Фундамент) для создания <strong>целостного</strong> (Принцип 7) и <strong>ценного</strong> (Принцип 2) продукта, которым могут пользоваться все, независимо от их способностей или используемых технологий. Мы стремимся соответствовать уровню WCAG 2.1 AA.",
        "principles": [
          "<strong>Контрастность Цветов:</strong> Текстовые элементы должны иметь минимальный контраст 4.5:1 (для обычного текста) и 3:1 (для крупного текста или иконок) по отношению к фону. Это проверяется для обеих тем (Light/Dark).",
          "<strong>Навигация с Клавиатуры:</strong> Все интерактивные элементы (кнопки, ссылки, поля ввода) должны быть доступны для навигации с помощью клавиатуры (Tab, Shift+Tab) и активации (Enter, Space).",
          "<strong>Поддержка Экранных Читалок (Screen Readers):</strong> Использование семантической разметки (HTML) и ARIA-атрибутов для предоставления контекста и информации пользователям экранных читалок (например, описания для иконок, состояния элементов).",
          "<strong>Визуальный Индикатор Фокуса:</strong> Для пользователей клавиатуры должен быть четкий и видимый индикатор текущего сфокусированного элемента (например, синяя обводка `#007BFF`).",
          "<strong>Обработка Ошибок:</strong> Сообщения об ошибках должны быть четкими, понятными и легко определяемыми пользователями, включая пользователей экранных читалок.",
          "<strong>Поддержка RTL (Справа Налево):</strong> Дизайн адаптируется для языков с направлением письма справа налево (например, арабский), включая зеркальное отображение макета, иконок и текста (см. DocLocIn.md)."
        ]
      },
      "section7": {
        "title": "7. Примечания и Рекомендации",
        "notes": [
          "<strong>Кастомизация Пользователем:</strong> Помните, что некоторые аспекты дизайна (цвета чатов, шрифты) пользователь может изменять в настройках. Дизайн системы должен учитывать эту гибкость.",
          "<strong>Тестирование на Реальных Устройствах:</strong> Все компоненты дизайна необходимо тестировать на разнообразных устройствах, с различными разрешениями экрана и в разных условиях освещения, чтобы убедиться в их эффективности и доступности.",
          "<strong>Живая Документация:</strong> Эта дизайн-система — живой документ. Она будет дополняться новыми компонентами, шаблонами и рекомендациями по мере развития продукта, отражая принципы <strong>непрерывного совершенствования</strong> (Принцип 1) и <strong>системного подхода</strong> (Принцип 9).",
          "<strong>Дизайн как часть Процесса Кайдзен:</strong> Дизайн-решения анализируются и улучшаются на основе обратной связи и реального использования, интегрируясь в общий процесс Кайдзен (Принцип 9, 14)."
        ]
      }
    },
    "localizationGuide": {
      "title": "BrainMessenger Optimization Guide (Kaizen Principle in Action)",
      "subtitle": "Introduction: Optimization as a Continuous Improvement Process",
      "introduction": {
        "title": "1. Introduction: Optimization as a Continuous Improvement Process",
        "description": "This document describes in detail the approaches, tools, and techniques we use to optimize BrainMessenger's performance. Optimization is not a one-time task, but a <strong>continuous improvement process</strong> (Principle 1, 9: Kaizen) that allows us to ensure the application's <strong>high quality, reliability, and scalability</strong> (Principle 3, 8).",
        "goalTitle": "Goal:",
        "goalContent": "Identify and eliminate performance bottlenecks at all system levels (Frontend, Backend, Database, Infrastructure) to ensure BrainMessenger remains <strong>fast, responsive, and efficient</strong> (Principle 2) even under significant load (target - 1 million active users), while maintaining <strong>system health</strong> (Principle 5, applicable to technology).",
        "audienceTitle": "Audience:",
        "audienceContent": "Backend, Frontend, Mobile, Desktop, and DevOps developers focused on performance and scalability.",
        "principlesTitle": "Principles guiding optimization:",
        "principles": [
          "<strong>System and Optimization (Principle 9: Kaizen):</strong> Optimization is a key aspect of our development system. A cyclical approach is used: Measure → Analyze → Improve → Verify.",
          "<strong>Quality > Quantity (Principle 3):</strong> It is better to have a few critically important optimizations than many minor ones that yield little effect.",
          "<strong>Pragmatism and Realism (Principle 12):</strong> We optimize what truly impacts performance and user experience, based on real data, not assumptions.",
          "<strong>Continuous Learning (Principle 1):</strong> Studying new optimization techniques and tools, analyzing results and lessons learned.",
          "<strong>Persistence (Principle 13):</strong> Optimization can be complex. Persistence is required to identify and solve deep performance issues.",
          "<strong>Health as Foundation (Principle 5):</strong> System optimization (e.g., reducing memory/CPU consumption) directly impacts the \"health\" of servers and user devices.",
          "<strong>External Expertise (Principle 14):</strong> Using standard tools (Prometheus, Grafana, V8 Profiler), studying the experience of other teams (Google, Next.js, etc.)."
        ]
      },
      "generalPrinciple": {
        "title": "2. General Optimization Principle (Kaizen Cycle)",
        "intro": "Our approach to optimization follows the <strong>Kaizen cycle (Principle 9)</strong>:",
        "step1": {
          "title": "1. Measure:",
          "content": "Collect performance data. Use monitoring tools (Prometheus, Sentry), profiling (V8 Profiler), bundle analysis (Webpack Bundle Analyzer, `@next/bundle-analyzer`)."
        },
        "step2": {
          "title": "2. Analyze:",
          "content": "Identify <strong>bottlenecks</strong> based on collected data. Where does the system spend most time or resources?"
        },
        "step3": {
          "title": "3. Improve:",
          "content": "Apply specific optimization techniques described in this guide to address identified bottlenecks."
        },
        "step4": {
          "title": "4. Verify:",
          "content": "Re-measure performance after changes. Ensure optimization had the expected effect and did not cause regressions (did not worsen other aspects)."
        },
        "step5": {
          "title": "5. Repeat:",
          "content": "Performance may change with increasing load and functionality. Repeat the Kaizen cycle continuously."
        }
      },
      "imageProcessing": {
        "title": "3. Image Processing Optimization: Efficiency and Speed (Principle 9, 2)",
        "intro": "Image processing can be resource-intensive. <strong>Optimizing this process directly affects content loading speed and application responsiveness</strong> (Principle 2: Value).",
        "libraryTitle": "Library:",
        "libraryContent": "`sharp` (based on `libvips`). Chosen as a <strong>pragmatic</strong> (Principle 12) and <strong>high-performance</strong> (Principle 9) solution for Node.js.",
        "applicationAreasTitle": "Application Areas:",
        "applicationAreasContent": "Resizing, compression, format conversion for avatars, chat images.",
        "keyTechniqueTitle": "Key Technique:",
        "keyTechniqueContent": "<strong>Asynchronous processing</strong> in the background via Kafka.",
        "implementationStepsTitle": "Implementation Steps (Backend):",
        "step1": {
          "title": "1. Install `sharp`:",
          "content": "Ensure `libvips` is installed in your operating system or Docker image.",
          "code": "```bash\\nnpm install sharp\\n```"
        },
        "step2": {
          "title": "2. Create an image processing service:",
          "content": "Encapsulate logic in a separate service (part of the <strong>system</strong> - Principle 9).",
          "code": "```typescript\\n// backend/src/image-processing/image-processing.service.ts\\nimport { Injectable, Scope } from '@nestjs/common';\\nimport sharp from 'sharp';\\n\\n@Injectable()\\nexport class ImageProcessingService {\\n  // Method for resizing, compressing, and converting to WebP\\n  async processImage(buffer: Buffer, width: number, height?: number): Promise<Buffer> {\\n    // resize({ width, height, withoutEnlargement: true }) - avoid enlargement if source is smaller\\n    // webp({ quality: 80 }) - compress to WebP format (good compression while maintaining quality)\\n    // withMetadata({ orientation: true }) - preserve orientation from EXIF, remove others (size saving - Principle 9)\\n    return sharp(buffer)\\n      .resize(width, height, { withoutEnlargement: true })\\n      .webp({ quality: 80 })\\n      .withMetadata({ orientation: true })\\n      .toBuffer();\\n  }\\n\\n  // Method for simple resizing\\n  async resizeImage(buffer: Buffer, width: number, height?: number): Promise<Buffer> {\\n       return sharp(buffer)\\n           .resize(width, height, { withoutEnlargement: true })\\n           .toBuffer();\\n  }\\n\\n   // Method for converting to a specific format\\n   async convertToFormat(buffer: Buffer, format: keyof sharp.Format): Promise<Buffer> {\\n       return sharp(buffer).toFormat(format).toBuffer();\\n   }\\n}\\n```"
        },
        "step3": {
          "title": "3. Integrate with file upload (Backend Controller/Service):",
          "content": "",
          "code": "```typescript\\n// backend/src/upload/upload.controller.ts (avatar upload handling example)\\nimport { Controller, Post, UploadedFile, UseInterceptors, Body, Inject } from '@nestjs/common';\\nimport { FileInterceptor } from '@nestjs/platform-express';\\nimport { ImageProcessingService } from '../image-processing/image-processing.service';\\nimport { StorageService } from '../storage/storage.service';\\nimport { UserService } from '../user/user.service';\\n\\n@Controller('upload')\\nexport class UploadController {\\n  constructor(\\n    private imageProcessingService: ImageProcessingService,\\n    private storageService: StorageService,\\n    private userService: UserService,\\n    // ... Kafka producer injection for asynchronous processing\\n  ) {}\\n\\n  @Post('avatar')\\n  @UseInterceptors(FileInterceptor('file')) // 'file' - form field name\\n  async uploadAvatar(@UploadedFile() file: Express.Multer.File, @Body('userId') userId: string) {\\n    // Optimization: Process image before uploading to R2\\n    const processedImageBuffer = await this.imageProcessingService.processImage(file.buffer, 300, 300); // Resize and compress\\n    const fileName = `avatars/${userId}-${Date.now()}.webp`; // Unique file name in avatars folder\\n    const mimeType = 'image/webp'; // Corresponds to WebP format\\n\\n    // Upload processed file to Cloudflare R2\\n    const avatarUrl = await this.storageService.uploadFile(processedImageBuffer, fileName, mimeType);\\n\\n    // Update avatar link in user profile in Neon\\n    await this.userService.updateUserAvatar(userId, avatarUrl);\\n\\n    // Return avatar URL to client\\n    return { avatarUrl };\\n  }\\n\\n  @Post('chat-image')\\n  @UseInterceptors(FileInterceptor('file'))\\n  async uploadChatImage(@UploadedFile() file: Express.Multer.File, @Body('chatId') chatId: string, @Body('userId') userId: string) {\\n      // Send image processing task to Kafka for asynchronous processing (Principle 9)\\n      const taskPayload = { fileBuffer: file.buffer.toString('base64'), fileName: file.originalname, mimeType: file.mimetype, chatId, userId };\\n      // Assumes you have a Kafka producer service\\n      // await this.kafkaProducerService.sendMessage('image-processing-topic', JSON.stringify(taskPayload));\\n\\n      // Immediate response to client that file is accepted for processing\\n      return { status: 'processing', originalFileName: file.originalname };\\n\\n      // OR, if synchronous processing is acceptable for small files:\\n      /*\\n      const processedImageBuffer = await this.imageProcessingService.processImage(file.buffer, 800); // Resize\\n      const fileName = `chat-images/${chatId}-${Date.now()}.webp`;\\n      const mimeType = 'image/webp';\\n      const imageUrl = await this.storageService.uploadFile(processedImageBuffer, fileName, mimeType);\\n\\n      // Create 'image' type message in chat\\n      // await this.chatService.sendImageMessage(chatId, userId, imageUrl);\\n\\n      return { imageUrl };\\n      */\\n  }\\n}\\n```"
        },
        "step4": {
          "title": "4. Asynchronicity via Kafka (for heavy tasks):",
          "content": "For processing images in chats (which can be large), use <strong>Kafka</strong> (see section 8) for <strong>asynchronous processing</strong>. The Backend quickly accepts the file from the client and queues the task in Kafka. A separate worker (Kafka consumer) picks up the task, processes the image using `sharp`, uploads it to R2, and only then creates a message in the chat via API. This <strong>reduces API response time</strong> (Principle 9) and improves user experience."
        }
      },
      "dbOptimization": {
        "title": "4. Database Optimization (Neon/PostgreSQL): Accelerating Data Access (Principle 9, 8)",
        "intro": "The database often becomes a bottleneck. Optimizing queries and DB structure is critical for <strong>long-term performance</strong> (Principle 8) and <strong>system efficiency</strong> (Principle 9).",
        "platformTitle": "Platform:",
        "platformContent": "Neon (managed PostgreSQL).",
        "toolTitle": "Tool:",
        "toolContent": "Prisma ORM.",
        "analysisToolTitle": "Analysis Tool:",
        "analysisToolContent": "`EXPLAIN ANALYZE` in Neon SQL client or `prisma.queryRaw` with `EXPLAIN ANALYZE`.",
        "monitoringToolTitle": "Monitoring Tool:",
        "monitoringToolContent": "Prometheus + `postgres_exporter` (see section 14).",
        "indexing": {
          "title": "4.1. Indexing: Accelerating Search and Filtering",
          "intro": "Indexes allow the database to find desired rows faster.",
          "whenTitle": "When to use:",
          "whenContent": "On fields frequently used in `WHERE`, `JOIN`, `ORDER BY` clauses.",
          "applicationAreasTitle": "Application areas in BrainMessenger:",
          "applicationAreasContent": "`userId`, `chatId`, `createdAt` (in `Message` table), `email` (in `User` table), search fields.",
          "prismaTitle": "Implementation (Prisma):",
          "prismaContent": "Add `@index` in `schema.prisma`.",
          "prismaCode": "```prisma\\n// schema.prisma\\nmodel Message {\\n  id        String   @id @default(cuid())\\n  content   String\\n  createdAt DateTime @default(now()) @map(\\\"created_at\\\") // Example @map for snake_case in DB\\n  chatId    String @map(\\\"chat_id\\\")\\n  userId    String @map(\\\"user_id\\\")\\n  chat      Chat     @relation(fields: [chatId], references: [id])\\n  user      User     @relation(fields: [userId], references: [id])\\n\\n  // Combined index for fast chat message queries by time\\n  @@index([chatId, createdAt])\\n  // Index for fast retrieval of messages by user (e.g., for statistics)\\n  @@index([userId])\\n  // Index for content search (if full-text search is required - consider tsearch)\\n  // @@index([content]) // Only for simple LIKE filters\\n}\\n\\nmodel User {\\n    id    String @id @default(cuid())\\n    email String @unique // Unique index for fast email search (login, registration)\\n    name  String\\n    // ... other fields\\n}\\n\\nmodel Chat {\\n   id          String @id @default(cuid())\\n   lastMessageAt DateTime? @map(\\\"last_message_at\\\") // For sorting chats (needs index)\\n   // ... other fields\\n   @@index([lastMessageAt]) // Index for sorting chat list\\n}\\n```",
          "applicationTitle": "Application:",
          "applicationContent": "After modifying `schema.prisma`, run migration (`npx prisma migrate dev`)."
        },
        "queryOptimization": {
          "title": "4.2. Query Optimization (Prisma): Writing Efficient DB Interaction Code",
          "intro": "",
          "selectFieldsTitle": "Select only necessary fields (`select`):",
          "selectFieldsContent": "Do not query `SELECT *`. Specify only the fields you truly need. This reduces the amount of data transferred over the network and processed by the DB.",
          "selectFieldsCode": "```typescript\\n// Bad\\nconst user = await prisma.user.findUnique({ where: { id: userId } }); // Will select all fields\\n\\n// Good (if only email and name are needed)\\nconst user = await prisma.user.findUnique({\\n  where: { id: userId },\\n  select: {\\n    email: true,\\n    name: true,\\n  },\\n});\\n```",
          "nPlus1Title": "Avoid N+1 problems (`include`):",
          "nPlus1Content": "If you need related data (e.g., message author when getting a list of messages), use `include` or `select` with nested fields instead of executing a separate query for each item.",
          "nPlus1Code": "```typescript\\n// Bad (N+1 problem - separate query for each user)\\nconst messages = await prisma.message.findMany({ where: { chatId: chatId } });\\nfor (const message of messages) {\\n  const sender = await prisma.user.findUnique({ where: { id: message.userId } });\\n  // ... use sender\\n}\\n\\n// Good (use include to fetch message author in a single query)\\nconst messagesWithSender = await prisma.message.findMany({\\n  where: { chatId: chatId },\\n  include: {\\n    user: { // Include user data related to the message via the 'user' field in the Message model\\n      select: { id: true, name: true, avatarUrl: true } // Select only necessary user fields\\n    },\\n  },\\n  orderBy: { createdAt: 'asc' }, // Example: messages in chronological order\\n  take: 50, // Example: pagination\\n});\\n```",
          "paginationTitle": "Pagination (`skip`, `take`, `cursor`):",
          "paginationContent": "For fetching large lists (chat messages, chat list), use pagination to avoid loading all data at once. `cursor`-based pagination is preferred for infinite scrolling.",
          "paginationCode": "```typescript\\n// Example pagination with take and skip\\nconst messages = await prisma.message.findMany({\\n    where: { chatId: chatId },\\n    orderBy: { createdAt: 'asc' },\\n    skip: (page - 1) * pageSize, // Skip N messages\\n    take: pageSize, // Take M messages\\n});\\n\\n// Example Cursor-based pagination (for \\\"show more\\\")\\nconst messages = await prisma.message.findMany({\\n    where: { chatId: chatId },\\n    orderBy: { createdAt: 'asc' },\\n    cursor: { id: lastMessageId }, // Start after the last message\\n    skip: 1, // Skip the last message itself\\n    take: pageSize,\\n});\\n```"
        },
        "prismaAccelerate": {
          "title": "4.3. Prisma Accelerate: Global Cache and Connection Pool",
          "intro": "Prisma Accelerate provides a global network of servers (Edge locations) that cache query results and manage a connection pool to your Neon DB.",
          "whenTitle": "When to use:",
          "whenContent": "To reduce query latency for users worldwide and optimize DB connection pool usage.",
          "implementationTitle": "Implementation:",
          "implementationContent": "Configured in the Prisma console. Your `DATABASE_URL` is replaced with the Prisma Accelerate URL."
        },
        "materializedViews": {
          "title": "4.4. Materialized Views: Caching Complex Aggregations",
          "intro": "Materialized views are essentially cached results of complex queries or aggregations (e.g., number of messages in a chat, last active users in a group). They are stored on disk and can be read quickly.",
          "whenTitle": "When to use:",
          "whenContent": "For queries that are executed frequently but require complex computations (JOINs, GROUP BY, aggregate functions) over large tables, and where the data does not need to be absolutely up-to-date every millisecond.",
          "applicationAreasTitle": "Application Areas:",
          "applicationAreasContent": "Chat statistics (total messages, participants), \"top\" user lists (e.g., by number of messages sent).",
          "implementationTitle": "Implementation (SQL, via Prisma `queryRaw` or Neon SQL client):",
          "implementationContent": "```sql\\n-- Create a materialized view to count messages in each chat\\nCREATE MATERIALIZED VIEW chat_message_counts AS\\nSELECT\\n    \\\"chatId\\\",\\n    COUNT(*) as \\\"messageCount\\\"\\nFROM \\\"Message\\\"\\nGROUP BY \\\"chatId\\\";\\n\\n-- Create an index on the view for fast search by chatId (optional, but often useful)\\nCREATE INDEX idx_chat_message_counts_chat_id ON chat_message_counts (\\\"chatId\\\");\\n```",
          "updateTitle": "Update:",
          "updateContent": "Materialized views need to be <strong>periodically refreshed</strong> to reflect changes in the base tables. This is done with the `REFRESH MATERIALIZED VIEW <view_name>;` command. The refresh frequency depends on how current the data needs to be (e.g., hourly, daily).",
          "updateCode": "```sql\\n-- Refresh view (may block reads during execution)\\nREFRESH MATERIALIZED VIEW chat_message_counts;\\n\\n-- Refresh view without blocking reads (for large views)\\nREFRESH MATERIALIZED VIEW CONCURRENTLY chat_message_counts; -- Requires a unique index\\n```",
          "usageTitle": "Usage in Prisma:",
          "usageContent": "Query as a regular table.",
          "usageCode": "```typescript\\nconst chatStats = await prisma.chatMessageCounts.findMany({\\n  select: { chatId: true, messageCount: true },\\n  where: { chatId: 'some-chat-id' },\\n});\\n```"
        },
        "partitioning": {
          "title": "4.5. Table Partitioning: Dividing Large Data Volumes",
          "intro": "Partitioning physically divides very large tables (e.g., `Message`) into smaller parts (partitions) based on a value in a specific column (e.g., `createdAt` or `chatId`).",
          "whenTitle": "When to use:",
          "whenContent": "When a table becomes so large (billions of rows) that indexes alone are insufficient, and queries start to slow down due to the need to scan too much data.",
          "applicationAreasTitle": "Application Areas:",
          "applicationAreasContent": "The `Message` table is an ideal candidate for partitioning by creation time (`createdAt`) or chat ID (`chatId`).",
          "implementationTitle": "Implementation (SQL, via Prisma `queryRaw` or Neon SQL client):",
          "implementationContent": "PostgreSQL supports native partitioning.",
          "implementationCode": "```sql\\n-- Create the main partitioned table by date range\\nCREATE TABLE messages (\\n    id TEXT NOT NULL,\\n    content TEXT NOT NULL,\\n    created_at TIMESTAMP WITH TIME ZONE NOT NULL,\\n    chat_id TEXT NOT NULL,\\n    user_id TEXT NOT NULL,\\n    PRIMARY KEY (id, created_at) -- Partition key must be part of the primary key\\n) PARTITION BY RANGE (created_at); -- Partition by range of created_at field\\n\\n-- Create partitions (e.g., by month)\\nCREATE TABLE messages_2025_03 PARTITION OF messages\\n    FOR VALUES FROM ('2025-03-01 00:00:00+00') TO ('2025-04-01 00:00:00+00');\\n\\nCREATE TABLE messages_2025_04 PARTITION OF messages\\n    FOR VALUES FROM ('2025-04-01 00:00:00+00') TO ('2025-05-01 00:00:00+00');\\n\\n-- ... create new partitions as needed (automatically or manually)\\n\\n-- Create indexes for the partitioned table (apply to all partitions)\\nCREATE INDEX ON messages (\\\"chat_id\\\", \\\"created_at\\\");\\nCREATE INDEX ON messages (\\\"user_id\\\");\\n```",
          "advantagesTitle": "Advantages:",
          "advantagesContent": "Queries including a filter by the partitioning key (e.g., `WHERE created_at BETWEEN ...`) will scan only the necessary partitions, significantly speeding up execution. Managing old data (deletion) becomes simpler (you can just drop old partitions).",
          "prismaRelationTitle": "Relation with Prisma:",
          "prismaRelationContent": "Prisma interacts with a partitioned table as with a regular one."
        }
      },
      "graphqlOptimization": {
        "title": "5. GraphQL API Optimization (NestJS + Prisma): Efficient Data Transfer",
        "intro": "GraphQL itself is an <strong>optimization</strong> tool (Principle 9) compared to REST (client requests only necessary data). However, it can still be optimized.",
        "analysisToolTitle": "Analysis Tool:",
        "analysisToolContent": "`graphql-query-complexity` for protection against complex queries.",
        "dataloader": {
          "title": "5.1. DataLoader: Solving the N+1 Problem in GraphQL",
          "intro": "DataLoader is a utility that helps solve the N+1 query problem when working with data graphs. If you have a list of objects, and for each object, you need to fetch a related object (e.g., a list of messages and their author for each message), DataLoader will collect all IDs of related objects and make a single batch request to the DB.",
          "whenTitle": "When to use:",
          "whenContent": "In GraphQL resolvers, when you need to fetch related objects for a list of parent objects.",
          "applicationAreasTitle": "Application Areas:",
          "applicationAreasContent": "Fetching author data for each message in a chat, fetching a list of participants for each chat in a user's chat list.",
          "implementationTitle": "Implementation:",
          "implementationContent": "Create separate DataLoaders for each object type that needs to be fetched. Integrate them into the GraphQL request context.",
          "implementationCode": "```typescript\\n// backend/src/graphql/loaders/user.loader.ts\\nimport { Injectable, Scope } from '@nestjs/common';\\nimport DataLoader from 'dataloader';\\nimport { PrismaService } from 'nestjs-prisma';\\nimport { User } from '@prisma/client'; // Prisma model import\\n\\n// Scope.REQUEST - important for DataLoader to be unique per GraphQL request\\n@Injectable({ scope: Scope.REQUEST })\\nexport class UserLoader {\\n  private loader: DataLoader<string, User>;\\n\\n  constructor(private prisma: PrismaService) {\\n    // Create a new DataLoader. The batchLoadFn function takes an array of keys (user IDs)\\n    this.loader = new DataLoader<string, User>(\\n      async (ids: readonly string[]) => {\\n        // Execute ONE DB query to fetch ALL users by their IDs\\n        const users = await this.prisma.user.findMany({\\n          where: {\\n            id: { in: Array.from(ids) }, // Array.from(ids) for Prisma compatibility\\n          },\\n        });\\n\\n        // Important: Return an array of results ordered by the original 'ids' array\\n        const userMap = new Map(users.map(user => [user.id, user]));\\n        return ids.map(id => userMap.get(id)); // Return users in the same order as requested\\n      },\\n      { cache: true } // Enable caching within the GraphQL request\\n    );\\n  }\\n\\n  // Method to load a single user by ID\\n  load(id: string): Promise<User> {\\n    return this.loader.load(id);\\n  }\\n\\n  // Method to load a list of users by ID\\n  loadMany(ids: string[]): Promise<(Error | User)[]> {\\n      return this.loader.loadMany(ids);\\n  }\\n}\\n```\\nIntegrate loaders into the GraphQL context (`backend/src/graphql/graphql.module.ts` or `app.module.ts`):\\n```typescript\\n// backend/src/graphql/graphql.module.ts\\nimport { Module } from '@nestjs/common';\\nimport { GraphQLModule } from '@nestjs/graphql';\\nimport { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';\\nimport { UserLoader }nfrom './loaders/user.loader'; // Loader import\\n// ... other resolver and module imports\\n\\n@Module({\\n  imports: [\\n    GraphQLModule.forRoot<ApolloDriverConfig>({\\n      driver: ApolloDriver,\\n      // ... other GraphQL settings (schema path, context, etc.)\\n      context: ({ req, connection }) => {\\n        // Create context for each request\\n        const context = { req }; // Add request object\\n         if (connection) {\\n           // For WebSocket (subscriptions)\\n           // context.loaders = new Loaders(); // If loaders are created here\\n         } else {\\n           // For HTTP requests (queries/mutations)\\n           // Create loaders and add them to context\\n           context.loaders = {\\n              userLoader: new UserLoader(/* dependencies */), // PrismaService needs to be injected\\n              // ... other loaders\\n           };\\n           // Example of dependency injection into loader (may require FactoryProvider)\\n           // context.loaders = {\\n           //     userLoader: req.loaders.userLoader, // If using Request-scoped NestJS providers\\n           // };\\n         }\\n        return context;\\n      },\\n      // plugins: [complexityPlugin], // Plugin for query complexity analysis\\n    }),\\n    // ... import other modules\\n  ],\\n   providers: [UserLoader], // Add loader as a provider (for Request scope)\\n})\\nexport class GraphqlModule {}\\n```",
          "usageTitle": "Use loaders in resolvers:",
          "usageContent": "",
          "usageCode": "```typescript\\n// backend/src/message/message.resolver.ts\\nimport { Resolver, ResolveField, Parent, Context } from '@nestjs/graphql';\\nimport { Message } from '@prisma/client'; // Prisma model import\\nimport { UserLoader } from '../graphql/loaders/user.loader'; // Loader import\\n\\n@Resolver('Message') // Specify GraphQL type the resolver belongs to\\nexport class MessageResolver {\\n  @ResolveField('user') // Define resolver for 'user' field in Message type\\n  async resolveUser(@Parent() message: Message, @Context() context: any) {\\n    // Use userLoader from context to load user by message.userId\\n    // DataLoader will automatically collect all message.userId in the current request and load them in a batch\\n    return context.loaders.userLoader.load(message.userId);\\n  }\\n}\\n```"
        },
        "queryComplexityAnalysis": {
          "title": "5.2. Query Complexity Analysis: Protection Against \"Heavy\" Queries",
          "intro": "GraphQL allows clients to request arbitrarily nested data, which can lead to very \"heavy\" queries that heavily burden the server and DB.",
          "toolTitle": "Tool:",
          "toolContent": "`graphql-query-complexity`.",
          "whenTitle": "When to use:",
          "whenContent": "Always enable complexity protection in production.",
          "principleTitle": "Operating Principle:",
          "principleContent": "The plugin analyzes the query before execution and calculates its \"complexity\" (e.g., as the sum of the \"cost\" of each field). If the complexity exceeds a set threshold, the query is rejected.",
          "implementationTitle": "Implementation:",
          "implementationContent": "Configure the plugin in NestJS GraphQLModule (see Development Guide)."
        },
        "persistedQueries": {
          "title": "5.3. Persisted Queries: Network-Level Query Caching",
          "intro": "Persisted Queries allow the client to send only a hash of a GraphQL query to the server, instead of the full text. The server finds the full query by this hash (if known) and executes it.",
          "whyTitle": "Why:",
          "whyContent": "Reduces the amount of data transferred over the network, which speeds up queries, especially on mobile devices. Improves CDN caching efficiency.",
          "whenTitle": "When to use:",
          "whenContent": "For frequently repeated client queries.",
          "implementationTitle": "Implementation:",
          "implementationContent": "Requires support on both client-side (Apollo Client supports) and server-side (Apollo Server supports). The server needs to store the mapping between hashes and queries (e.g., in Redis)."
        }
      },
      "backendLogicOptimization": {
        "title": "6. Backend Logic Optimization (NestJS): Code Efficiency",
        "intro": "",
        "toolsTitle": "Tools:",
        "toolsContent": "Node.js profiling (V8 Profiler), memory leak detection (`heapdump`).",
        "whenTitle": "When to use:",
        "whenContent": "For identifying \"hot\" code sections consuming significant CPU or memory, and diagnosing memory issues.",
        "processTitle": "Process:",
        "processContent": "Use profiling tools for <strong>measurement</strong> (Kaizen Step 1). Analyze results (Step 2). Make code changes (Step 3). Repeat (Step 4).",
        "recommendationsTitle": "Recommendations:",
        "recommendationsContent": "Avoid synchronous operations that block the main Node.js thread. Use asynchronous APIs. Optimize loops, and operations with large arrays/objects."
      },
      "caching": {
        "title": "7. Caching (Redis): Reducing DB Load and Acceleration (Principle 9)",
        "intro": "Caching allows storing frequently requested data in fast memory (Redis) to avoid accessing the slower DB (Neon) on every request. This is a key <strong>lever</strong> for improving <strong>system efficiency</strong> (Principle 9).",
        "libraryTitle": "Library:",
        "libraryContent": "`ioredis`, `@nestjs/cache-manager`, `cache-manager-redis-store`.",
        "patternTitle": "Pattern:",
        "patternContent": "Cache-Aside (read from cache, if not present – read from DB and write to cache).",
        "applicationAreasTitle": "Application Areas:",
        "applicationAreasContent": "Frequently requested, relatively rarely changing data (user profiles, application settings, results of complex queries/aggregations, materialized views).",
        "implementationTitle": "Implementation:",
        "implementationContent": "Configure Redis in NestJS and use it in services.",
        "invalidationTitle": "Key Aspect:",
        "invalidationContent": "<strong>Cache invalidation</strong>. When data changes in the DB, delete corresponding keys from Redis so clients do not receive stale data."
      },
      "asyncProcessing": {
        "title": "8. Asynchronous Processing (Kafka): Reliability and Responsiveness (Principle 9, 2)",
        "intro": "Use <strong>Kafka</strong> for tasks that do not require an immediate response to the user (sending emails, image processing, notifications, analytics).",
        "libraryTitle": "Library:",
        "libraryContent": "`kafkajs`.",
        "whyTitle": "Why:",
        "whyContent": "Kafka is a <strong>reliable distributed queue system</strong> that guarantees message delivery and allows scaling task processing independently of the main API (worker-consumers).",
        "applicationAreasTitle": "Application Areas:",
        "applicationAreasContent": [
          "Image/video processing after upload.",
          "Sending large volumes of push notifications.",
          "Generating reports or statistics.",
          "Archiving old messages/files."
        ],
        "patternTitle": "Pattern:",
        "patternContent": "<strong>Producer-Consumer</strong>. The Backend-API queues tasks in a Kafka topic (Producer). Separate services/workers (Consumers) read tasks from the topic and execute them in the background.",
        "partitioningTitle": "Partitioning in Kafka:",
        "partitioningContent": "Use message keys (e.g., `userId`, `chatId`) to ensure messages related to the same user/chat land in the same partition. This guarantees processing order within a partition, which can be important for some tasks.",
        "monitoringTitle": "Monitoring:",
        "monitoringContent": "Use <strong>Kafdrop</strong> for visual monitoring of topics, messages, and consumer group states."
      },
      "pushNotificationsOptimization": {
        "title": "9. Push Notification Optimization (Firebase FCM): Efficient Information Delivery (Principle 2)",
        "intro": "Push notifications are an important communication channel with the user (Principle 2: Value). Optimizing their delivery is crucial for user experience.",
        "platformTitle": "Platform:",
        "platformContent": "Firebase Cloud Messaging (FCM).",
        "techniquesTitle": "Techniques:",
        "techniquesContent": [
          "<strong>Batching:</strong> Send multiple notifications with a single FCM API call (`sendMulticast`) to reduce network overhead.",
          "<strong>Topics:</strong> Use topics for mass broadcasts (e.g., new channel message notification) to let FCM manage subscriber lists.",
          "<strong>Data Messages:</strong> Use Data Messages for full control over notification display on the client and the ability to attach custom data."
        ]
      },
      "clientApiDbInteraction": {
        "title": "10. Client-API-DB Interaction Optimization: Reducing Data Path (Principle 9)",
        "intro": "",
        "clientLevelTitle": "At the Client Level:",
        "clientLevelContent": "Use libraries for state management and caching network-fetched data (`@apollo/client`, `react-query`/`@tanstack/react-query`). This helps avoid redundant requests for the same data and quickly display cached data.",
        "networkLevelTitle": "At the Network Level:",
        "networkLevelContent": "Enable modern protocols (HTTP/2, HTTP/3) and compression (Gzip/Brotli) on your API Gateway or Backend server to reduce data volume and latency.",
        "backendLevelTitle": "At the Backend Level:",
        "backendLevelContent": "Optimize interaction with DB (section 4) and external services (section 7)."
      },
      "authenticationOptimization": {
        "title": "11. Authentication Optimization: Speed and Security",
        "intro": "",
        "statelessJwtTitle": "Stateless (JWT):",
        "statelessJwtContent": "Using JWT reduces server load as it does not need to store user session states.",
        "rateLimitingTitle": "Rate Limiting (`@nestjs/throttler`):",
        "rateLimitingContent": "Protecting authentication endpoints from Brute Force attacks, which also reduces load.",
        "secureHeadersTitle": "Secure Headers (`helmet`):",
        "secureHeadersContent": "Adding HTTP headers to protect against XSS, CSRF, and other attacks."
      },
      "chatWebSocketOptimization": {
        "title": "12. Chat Optimization (WebSocket): Low Latency and Scalability",
        "intro": "WebSocket is used for real-time message exchange. <strong>Optimizing WebSocket connections is critical for chat responsiveness</strong> (Principle 2).",
        "libraryTitle": "Library:",
        "libraryContent": "NestJS Gateways (`@nestjs/websockets`), Socket.IO (if cross-browser compatibility and fallback are needed).",
        "techniquesTitle": "Techniques:",
        "techniquesContent": [
          "<strong>Binary Formats:</strong> Transmitting messages in binary format (e.g., MessagePack) instead of text JSON can reduce data volume.",
          "<strong>Message Batching:</strong> Buffer messages on client and server and send them in batches (e.g., every 50 ms) instead of one by one. Reduces packet count.",
          "<strong>Presence Management:</strong> Use Redis to quickly track online/offline user status. Heartbeats (ping-pong) for connection maintenance and disconnection detection.",
          "<strong>Vertical/Horizontal Scaling:</strong> NestJS Gateways can operate in cluster mode. Use Redis or another Pub/Sub mechanism (e.g., Kafka) to exchange messages between Backend instances, ensuring messages are delivered to all subscribers, regardless of which Backend instance they are connected to."
        ]
      },
      "animationsOptimization": {
        "title": "13. Animation Optimization: Smoothness and Performance (Principle 3, 5)",
        "intro": "Performant animations make the interface <strong>high quality</strong> (Principle 3) and reduce device load (Principle 5: Health).",
        "mobileDesktopTitle": "Mobile-Desktop (React Native):",
        "mobileDesktopContent": "Use `react-native-reanimated` for animations that run on the native thread, not blocking the JavaScript thread.",
        "webTitle": "Web (Next.js):",
        "webContent": "Use `framer-motion` for declarative creation of smooth animations.",
        "docDesignTitle": "DocDesign:",
        "docDesignContent": "DocDesign describes animation principles and parameters, including the option for users to disable them (Principle 12: Pragmatism)."
      },
      "monitoring": {
        "title": "14. Monitoring with Prometheus and Grafana: Measurement as the Foundation of Kaizen (Principle 9)",
        "intro": "A monitoring system is your <strong>eyes</strong> and <strong>measurement tools</strong> (Kaizen Step 1).",
        "toolsTitle": "Tools:",
        "toolsContent": "Prometheus (metric collection), Grafana (visualization), Alertmanager (anomaly notifications).",
        "whenTitle": "When to use:",
        "whenContent": "Always. Set up monitoring at all levels: Backend (API latency, errors), DB (query time, load), Redis (cache hits, memory usage), Kafka (message count in topics, consumer lag), Infrastructure (CPU, RAM, network).",
        "implementationTitle": "Implementation:",
        "implementationContent": "See detailed setup steps in the Development Guide (section 14).",
        "principleTitle": "Principle:",
        "principleContent": "Use metrics to <strong>identify bottlenecks</strong> (Kaizen Step 2) and assess the <strong>efficiency</strong> (Principle 9) of your optimizations. Set up <strong>alerts</strong> for proactive problem detection."
      },
      "ciCdOptimization": {
        "title": "15. CI/CD Optimization: Accelerating the Development Cycle (Principle 9)",
        "intro": "An efficient CI/CD pipeline accelerates code delivery, which is part of <strong>optimizing the entire development process</strong> (Principle 9).",
        "toolsTitle": "Tools:",
        "toolsContent": "Turborepo (caching, parallelization), GitHub Actions (automation).",
        "techniquesTitle": "Techniques:",
        "techniquesContent": [
          "<strong>Caching with Turborepo:</strong> Cache build and test results between CI runs and locally.",
          "<strong>Parallel Execution:</strong> Run tasks (lint, build, test) for different packages or test parts in parallel.",
          "<strong>Docker Image Optimization:</strong> Use multi-stage builds and `.dockerignore` to reduce image size and speed up build/deploy."
        ]
      },
      "frontendOptimization": {
        "title": "16. Frontend Optimization: Speed and Responsiveness for the User (Principle 2, 3)",
        "intro": "The frontend must be <strong>fast and responsive</strong> for the user to perceive the product's <strong>value</strong> (Principle 2).",
        "webTechniquesTitle": "Techniques (Web - Next.js):",
        "webTechniquesContent": [
          "<strong>Code Splitting / Dynamic Imports:</strong> Load code only when needed (`next/dynamic`).",
          "<strong>SSR/SSG:</strong> Use server-side rendering or static site generation to speed up initial render and SEO (`getStaticProps`, `getServerSideProps`).",
          "<strong>Image Optimization:</strong> Use `next/image` or `<picture>` and modern formats (WebP).",
          "<strong>Bundle Analysis:</strong> Use `@next/bundle-analyzer` to identify the heaviest modules."
        ],
        "reactNativeTechniquesTitle": "Techniques (React Native):",
        "reactNativeTechniquesContent": [
          "<strong>Lazy Loading:</strong> Use `React.lazy` and `Suspense` for screens and components not needed at startup.",
          "<strong>Performant Lists:</strong> Use `FlatList` or `SectionList` with proper configuration (`getItemLayout`, `windowSize`) for large message or chat lists.",
          "<strong>Image Optimization:</strong> Use `react-native-fast-image`.",
          "<strong>Profiling:</strong> Use Performance Monitor in the React Native Debugger Menu to identify UI bottlenecks."
        ],
        "generalTechniquesTitle": "General Techniques:",
        "generalTechniquesContent": [
          "Dead code elimination (Tree Shaking), replacing heavy libraries with lighter alternatives (e.g., `dayjs` instead of `moment`), bundle compression (Gzip/Brotli)."
        ]
      },
      "dbScaling": {
        "title": "17. Database Scaling (Replication and Sharding): Preparing for Growth (Principle 8)",
        "intro": "These techniques become relevant with significant growth in data volume and load. They are part of a <strong>long-term scaling strategy</strong> (Principle 8).",
        "replicationTitle": "Replication (Master-Slave):",
        "replicationContent": "Creating read-only copies of the DB (read replicas). Allows distributing read load.",
        "shardingTitle": "Sharding:",
        "shardingContent": "Dividing data of a large table into parts (shards) based on a specific key (`chatId`, `userId`), distributing them across different servers. Allows scaling both reads and writes. Implemented logically (in the application) or using extensions (Citus for PostgreSQL).",
        "whenToApplyTitle": "When to Apply:",
        "whenToApplyContent": "Based on <strong>measurements</strong> of DB load and performance (Principle 9), not in advance."
      },
      "notes": {
        "title": "18. Notes: Continuous Kaizen in Optimization",
        "prioritizationTitle": "Prioritization:",
        "prioritizationContent": "Start optimizing in areas that yield the greatest impact at the current stage of the project (Principle 12). For an MVP, this might be frontend loading speed, or core API query performance.",
        "automationTitle": "Automation:",
        "automationContent": "Automate measurement and optimization verification processes as much as possible (CI/CD, monitoring alerts) — this is part of the <strong>System</strong> (Principle 9).",
        "documentationNotesTitle": "Documentation:",
        "documentationNotesContent": "Document conducted optimizations, their effect, and lessons learned in this documentation or in tasks/commits (Principle 1: Learning, Principle 9: Kaizen).",
        "cultureTitle": "Culture:",
        "cultureContent": "Foster a culture where every developer is responsible for their code's performance and actively participates in identifying and eliminating bottlenecks (Principle 6)."
      }
    },
    "userGuide": {
      "title": "BrainMessenger User Guide",
      "subtitle": "Your Hub for Effective Communication and Growth",
      "introduction": {
        "title": "1. Introduction: Welcome to Your Interaction System",
        "p1": "<strong>Welcome to BrainMessenger!</strong>",
        "p2": "BrainMessenger is not just a messenger, but <strong>your personal system</strong> for secure, convenient, and <strong>effective communication and interaction</strong> (Principle 2: Value Creation, Principle 9: System). We created this <strong>digital ASSET</strong> (Principle 10) to <strong>simplify complexity</strong> (Margulan), providing you with a reliable tool for connecting with others and organizing your communication.",
        "p3": "This guide is your compass in the world of BrainMessenger. It is structured so you can quickly master key functions and use the application as <strong>effectively</strong> as possible (Principle 9).",
        "p4": "<strong>For whom:</strong> BrainMessenger is designed for a wide audience and is available on all major platforms: iOS (version 13+), Android (version 9+), as well as a full-fledged web version for modern browsers (Chrome, Firefox, Safari, Edge). We strive for maximum <strong>accessibility</strong> (Principle 5) for everyone.",
        "p5": "<strong>How to start:</strong> The most <strong>pragmatic</strong> (Principle 12) way is to install the application from the respective app store or open the website `https://brainmessenger.com`."
      },
      "gettingStarted": {
        "title": "2. Getting Started: First Steps in the BrainMessenger System",
        "p1": "Your registration and login process is designed as a <strong>simple and secure system</strong> (Principle 9, 5).",
        "registration": {
          "title": "2.1. Registration: Creating Your Profile in the System",
          "steps": [
            "1. Open the application or go to the website.",
            "2. Click the <strong>\"Get Started\"</strong> (Register) button on the welcome screen.",
            "3. Follow the step-by-step instructions:",
            "<strong>Enter Email:</strong> Your active email address (e.g., `user@example.com`). It will be used for notifications, login, and access recovery. Make sure the email format is correct.",
            "<strong>Create Password:</strong> Come up with a <strong>strong password</strong> (minimum 8 characters, including at least one digit and one special character, e.g., `MyStrongP@ss!1`). The security of your account is part of our <strong>foundation</strong> (Principle 5, 8).",
            "<strong>Enter Name:</strong> Your display name in BrainMessenger.",
            "<strong>Confirm Email:</strong> We will send an 8-digit confirmation code to the specified email (see API Specification, DocInt). Check your mail (including the \"Spam\" folder). Enter the code in the application.",
            "4. Click the confirmation button at each step."
          ],
          "result": "*Result:* Your account has been successfully created. You become part of the <strong>BrainMessenger system</strong>."
        },
        "login": {
          "title": "2.2. Login: Accessing Your Interaction Network",
          "steps": [
            "1. On the welcome screen, select <strong>\"Log In\"</strong> (Sign In).",
            "2. Enter your registered email and password.",
            "3. Click <strong>\"Log In\"</strong> (Sign In)."
          ],
          "note": "*Note:* If you have two-factor authentication (2FA) enabled for additional security (see section 3.5), you will need to enter an additional code received by email after entering your password."
        },
        "logout": {
          "title": "2.3. Logout: Ending Your Current Session",
          "steps": [
            "1. Open the main menu (usually a \"burger\" icon or your avatar in the top corner).",
            "2. Go to the <strong>\"Settings\"</strong> section.",
            "3. Scroll down and select <strong>\"Log Out\"</strong>.",
            "4. Confirm your action if required."
          ]
        }
      },
      "mainFunctions": {
        "title": "3. Key Functions: Tools for Effective Communication (Principle 2)",
        "p1": "BrainMessenger provides a set of <strong>tools</strong> (Principle 10) for various types of communication, focused on providing you with <strong>value</strong> (Principle 2).",
        "chatsAndMessages": {
          "title": "3.1. Chats and Messages: Your Personal Communication System Space",
          "sections": [
            "<strong>View chats:</strong> The main screen displays a <strong>systematically organized</strong> (Principle 9) list of all your chats (personal, group, channels). Chats with new messages are always at the top.",
            "<strong>Creating a new chat:</strong>",
            "1. Click the <strong>\"+\"</strong> icon (usually in the top right corner).",
            "2. Select <strong>\"New Chat\"</strong> or \"New Group\", \"New Channel\".",
            "3. Select contacts or add participants, specify a name (for groups/channels).",
            "4. Click <strong>\"Create\"</strong>.",
            "<strong>Sending a message:</strong>",
            "1. Open the desired chat.",
            "2. Enter text in the message input field at the bottom.",
            "3. Click the <strong>\"Send\"</strong> icon.",
            "<strong>Sending files:</strong>",
            "1. In the message input field, click the paperclip icon.",
            "2. Select a file (photo, video, document). The maximum file size for upload is 100 MB.",
            "3. Click <strong>\"Send\"</strong>. Files are securely stored in Cloudflare R2 (see DocInt).",
            "<strong>Searching chats and messages:</strong> Use the search bar at the top of the Main screen. Searching is fast and <strong>effective</strong> (Principle 9).",
            "<strong>Archiving chats:</strong> To remove a chat from the main list without deleting it, swipe it left (on mobile) or use the context menu and select <strong>\"Archive\"</strong>. Access to the archive is through the main menu. Part of your workspace <strong>organization system</strong> (Principle 9)."
          ]
        },
        "calls": {
          "title": "3.2. Calls and Video Calls: Direct Interaction",
          "sections": [
            "<strong>Start a call:</strong> In an open chat, click the phone (audio) or camera (video) icon.",
            "<strong>Conferences:</strong> Create a group chat and use the \"Start Call\" function.",
            "<strong>Call history:</strong> View a list of all past calls in the <strong>\"Calls\"</strong> section of the main menu.",
            "<strong>Quality settings:</strong> During a call, you can select video/audio quality (low, medium, high) for <strong>pragmatic</strong> (Principle 12) use of internet traffic."
          ]
        },
        "filesAndMedia": {
          "title": "3.3. Files and Media: Centralized Access to Exchange",
          "sections": [
            "<strong>Viewing files from chat:</strong> In an open chat, go to the chat information (click on the name/avatar in the header) and select the <strong>\"Media\"</strong> section. All files you have exchanged in this chat are collected here. You can filter them by type."
          ]
        },
        "contacts": {
          "title": "3.4. Contacts: Managing Your Connection Network",
          "sections": [
            "<strong>Contact list:</strong> Available in the <strong>\"Contacts\"</strong> section of the main menu.",
            "<strong>Search and add:</strong> Search for existing users or add new ones by email/phone."
          ]
        },
        "settings": {
          "title": "3.5. Settings: Adapting the System to Yourself (Principle 2)",
          "p1": "The \"Settings\" section allows you to personalize BrainMessenger, making it more <strong>valuable and convenient</strong> specifically for you.",
          "sections": [
            "<strong>Profile:</strong> Change name, photo, email, password. Configure security settings (e.g., enable <strong>two-factor authentication (2FA)</strong> for additional account protection). Related to <strong>responsibility</strong> (Principle 6) for your data security.",
            "<strong>Notifications:</strong> Configure notification types, sounds, vibration.",
            "<strong>Appearance (Theme):</strong> Select <strong>\"Light\"</strong> or <strong>\"Dark\"</strong> theme. Dark theme can reduce eye strain (related to Principle 5: Health).",
            "<strong>Language:</strong> Select the interface language from the list of available languages. Changes apply quickly. Right-to-left (RTL) languages are supported, making the application <strong>accessible</strong> (Principle 2, 5) for different regions (see DocLocIn).",
            "<strong>Battery and Animation Settings:</strong> Enable or disable interface animations. This is a <strong>pragmatic</strong> (Principle 12) solution for saving battery life and device resources (Principle 5).",
            "<strong>Chat Settings (Customization):</strong> In each chat, you can change its visual appearance (background colors, fonts), which adds <strong>value</strong> (Principle 2) through personalization."
          ]
        },
        "premiumSubscription": {
          "title": "3.6. Premium Subscription: Additional Features and Support for Asset Development (Principle 2, 10)",
          "p1": "Premium subscription provides access to advanced features that enhance the <strong>value</strong> (Principle 2) of your experience, and is a way to support the <strong>long-term development</strong> (Principle 8) of BrainMessenger as a <strong>digital Asset</strong> (Principle 10).",
          "sections": [
            "<strong>Benefits:</strong> Familiarize yourself with exclusive Premium features in the <strong>\"Settings\" → \"Premium\"</strong> section.",
            "<strong>Purchase:</strong> Select a tariff plan and subscribe through a secure payment system (Stripe, see DocInt).",
            "<strong>Payment history:</strong> View information about your transactions."
          ]
        }
      },
      "faq": {
        "title": "4. Frequently Asked Questions (FAQ): Quick Answers from the Knowledge System",
        "p1": "This section contains answers to typical questions, based on our <strong>accumulated experience</strong> (Principle 1, 14).",
        "q1": {
          "question": "Q: What should I do if I didn't receive a confirmation code during registration?",
          "answer": "A: Check your \"Spam\" folder in your email. If there is no code, return to the code entry screen and click <strong>\"Resend Code\"</strong>."
        },
        "q2": {
          "question": "Q: How to restore password?",
          "answer": "A: On the login screen, click <strong>\"Forgot Password?\"</strong> and follow the instructions sent to your email."
        },
        "q3": {
          "question": "Q: How to delete my account and data?",
          "answer": "A: You can initiate account deletion in <strong>\"Settings\" → \"Profile\"</strong> by selecting <strong>\"Delete Account\"</strong>. Your data will be securely deleted in accordance with the privacy policy (see DocSecurity)."
        },
        "q4": {
          "question": "Q: Does BrainMessenger support end-to-end encryption?",
          "answer": "A: Yes, the security and <strong>integrity</strong> (Principle 7) of your data is our priority. All personal chats use end-to-end encryption."
        }
      },
      "tips": {
        "title": "5. Useful Tips: Optimizing Your Experience (Principle 9)",
        "p1": "A few tips for more <strong>effective</strong> (Principle 9) use of BrainMessenger:",
        "sections": [
          "<strong>Use onboarding:</strong> The first screen with a slider contains useful information about the application.",
          "<strong>Optimize performance on your device:</strong> If the application runs slowly or consumes a lot of battery, try disabling animations in <strong>\"Settings\" → \"Battery & Animations\"</strong>. This is a <strong>pragmatic</strong> step to preserve your device's <strong>health</strong> (Principle 5).",
          "<strong>Keep chats organized:</strong> Use the archiving function to hide less relevant dialogues.",
          "<strong>Explore settings:</strong> Explore all options in \"Settings\" to fully adapt the application to yourself."
        ]
      },
      "support": {
        "title": "6. Support: We Are Ready to Assist (Principle 2, 14)",
        "p1": "If you have questions or problems, please contact us. Your <strong>feedback</strong> helps us <strong>improve the system</strong> (Principle 9).",
        "sections": [
          "<strong>Via the app:</strong> Open the main menu, select <strong>\"Support\"</strong> → <strong>\"Contact Us\"</strong>.",
          "<strong>By email:</strong> You can also write to us directly at `support@brainmessenger.com`."
        ],
        "p2": "We strive to respond to requests quickly and provide you with the most useful <strong>assistance</strong> (Margulan)."
      }
    },
    "devGuide": {
      "title": "BrainMessenger Development Guide",
      "subtitle": "Applying Principles in Code",
      "introduction": {
        "title": "1. Introduction: The Development Process as a System of Improvement",
        "description": "This document is your guide to the BrainMessenger development process. We are building this project not chaotically, but as a <strong>holistic system</strong> (Principle 9), where every team member (or you yourself) acts in accordance with <strong>clear standards and principles</strong>, striving for <strong>continuous improvement</strong> (Principle 1, 9). This process directly affects the <strong>quality</strong> (Principle 3) of the final product and its transformation into a <strong>valuable ASSET</strong> (Principle 10).",
        "goal": "Ensure a <strong>unified, efficient, and scalable</strong> development process, simplify onboarding for new participants, and maintain a high level of <strong>code and architecture quality</strong> at every stage, including deep learning and application of technologies (as seen in the video tracker).",
        "audience": "Everyone who writes code or manages the BrainMessenger development process (Frontend, Backend, Mobile, Desktop, DevOps developers).",
        "principles_title": "Principles guiding the development process:",
        "principles": [
          "<strong>System and Optimization (Principle 9):</strong> Repository structure, coding standards, CI/CD, tool usage — everything is aimed at creating an efficient and predictable system. <strong>Kaizen</strong> is applied to the development process itself.",
          "<strong>Quality > Quantity (Principle 3):</strong> Priority is given to writing clean, testable, and maintainable code, even if it takes more time initially.",
          "<strong>Continuous Learning (Principle 1):</strong> The development process includes learning new technologies, pragmatically applying them, and reflecting on the experience gained (as documented in the video tracker and Kaizen hours).",
          "<strong>Pragmatism and Realism (Principle 12):</strong> Choosing tools and approaches suitable for the current stage of the project, without unnecessary complexity.",
          "<strong>Long-term Thinking (Principle 8):</strong> Architectural decisions are made with future scalability and maintainability in mind. Code is written to be easily evolvable.",
          "<strong>Responsibility and Proactivity (Principle 6):</strong> Each developer is responsible for the quality of their code, tests, and actively participates in process improvement."
        ]
      },
      "repoStructure": {
        "title": "2. Repository Structure: Monorepo as a Code Organization System",
        "description": "The project is organized as a <strong>monorepository</strong>, using <strong>Turborepo</strong> for package management. This is a conscious choice designed to increase <strong>efficiency</strong> (Principle 9) through code reuse and <strong>optimization</strong> (Principle 9) of build and testing processes.",
        "core_title": "<code>core</code>:",
        "core_content": "Contains code that is the <strong>core of the system</strong> (Principle 9) and can be used on any platform (API client, common utilities, business logic not tied to UI/server). Reuse increases <strong>efficiency</strong> (Principle 9) and <strong>consistency</strong> (Principle 7).",
        "mobile_desktop_title": "<code>mobile-desktop</code>:",
        "mobile_desktop_content": "Contains code for the <strong>client Asset</strong> (Principle 10) on mobile and desktop platforms.",
        "web_title": "<code>web</code>:",
        "web_content": "Contains code for the <strong>client Asset</strong> on the web platform.",
        "backend_title": "<code>backend</code>:",
        "backend_content": "Contains code for the <strong>server-side of the system</strong>, processing requests, interacting with the database, and external services. This is a critically important <strong>leverage</strong> (Margulan) for the entire application.",
        "infrastructure_title": "<code>infrastructure</code>:",
        "infrastructure_content": "Contains configurations for <strong>deploying the system</strong> (Principle 9) on cloud resources.",
        "docs_title": "<code>docs</code>:",
        "docs_content": "Contains <strong>documentation — part of the knowledge system</strong> (Principle 1), necessary for efficient work and onboarding.",
        "turbo_title": "<code>turbo.json</code>:",
        "turbo_content": "Defines how Turborepo manages tasks (build, test, linting) across the monorepo, using <strong>caching and parallel execution</strong> to <strong>optimize</strong> (Principle 9) development time."
      },
      "techStack": {
        "title": "3. Technology Stack: Tools for Building a Foundation (Principle 8)",
        "intro": "The choice of stack is based on <strong>pragmatism, reliability, and potential for long-term development</strong> (Principle 8, 12). We use <strong>proven technologies</strong> that allow for rapid building while laying a <strong>solid foundation</strong> (Principle 8).",
        "table": [
          ["Component", "Technology", "Version", "Purpose", "Connection to Principles"],
          ["Frontend: Mobile", "React Native", "0.72+", "Creating UI for Android from a single codebase.", "P9 (System), P12 (Pragmatism), P2 (Value - cross-platform)."],
          ["Frontend: Desktop", "React Native for Windows (RNW)", "0.72+", "Creating UI for Windows from a single codebase.", "P9 (System), P12 (Pragmatism), P2 (Value - cross-platform)."],
          ["Frontend: Web", "Next.js, Tailwind CSS", "14.x", "Web application with SSR/SSG for SEO and performance, utility-first styling.", "P2 (Value), P9 (System - framework), P12 (Pragmatism)."],
          ["Frontend: General", "TypeScript", "5.x", "Strong static typing for increased <strong>quality and reliability</strong> of code.", "P3 (Quality), P9 (System - predictability)."],
          ["Backend", "Node.js, NestJS", "22.x, 10.x", "Server logic, GraphQL API, high performance of Node.js, modularity of NestJS.", "P9 (System - modularity), P8 (Long-term - Node.js scalability)."],
          ["ORM", "Prisma", "5.x", "Convenient and secure work with the database (PostgreSQL).", "P3 (Quality - query security), P9 (System - DB abstraction)."],
          ["Database", "PostgreSQL (Neon)", "15.x", "Main storage for structured data. Reliable relational DBMS.", "P8 (Long-term), P9 (System), P12 (Pragmatism)."],
          ["File Storage", "Cloudflare R2 (S3-compatible)", "-", "Storing media files and binary data. Cost-effective and scalable.", "P10 (Assets), P12 (Pragmatism), P8 (Long-term)."],
          ["Caching", "Redis", "7.x", "Data caching, Rate Limiting, WebSocket presence management.", "P9 (System - efficiency), P3 (Quality - load reduction), P5 (Health - responsiveness)."],
          ["Asynchronicity", "Kafka", "3.x", "Reliable asynchronous processing of background tasks (image processing).", "P9 (System - separation of concerns), P3 (Quality - reliability)."],
          ["Orchestration", "Kubernetes", "1.24+", "Container management, automatic scaling, self-healing.", "P8 (Long-term), P9 (System - complexity management), P3 (Quality - fault tolerance)."],
          ["Infrastructure", "Terraform", "1.5+", "Automating the creation and management of infrastructure (IaC).", "P9 (System - automation), P3 (Quality - infrastructure predictability)."],
          ["Testing", "Jest, Cypress, Detox", "-", "Unit, integration, E2E tests for ensuring <strong>quality</strong>.", "P3 (Quality), P9 (System - automated verification)."],
          ["Profiling", "V8 Profiler, Chrome DevTools", "-", "Tools for <strong>measuring and optimizing performance</strong>.", "P1 (Learning), P9 (System - Kaizen), P13 (Persistence)."],
          ["Kafka Monitoring", "Kafdrop", "-", "Visual monitoring of Kafka queues.", "P9 (System), P5 (Health - systems, problem visibility)."]
        ]
      },
      "codingStandards": {
        "title": "4. Coding Standards: Discipline as the Foundation of Quality (Principle 3, 9)",
        "intro": "Adhering to coding standards is an expression of <strong>discipline</strong> and part of the <strong>quality assurance system</strong>. It makes code predictable, easy to read, and maintainable by other developers (or yourself in the future).",
        "generalPrinciples": {
          "title": "4.1. General Principles",
          "principles": [
            "<strong>DRY (Don’t Repeat Yourself):</strong> Avoid code duplication. Use common functions, components, hooks in the <code>core</code> package.",
            "<strong>KISS (Keep It Simple, Stupid):</strong> Strive for simple solutions. Don't overcomplicate unnecessarily. <strong>Simplifying the complex</strong> (Margulan) applies to code as well.",
            "<strong>Naming:</strong> Use English for all identifiers (variables, functions, classes), comments. Be consistent.",
            "<strong>Comments:</strong> Mandatory for:",
            "Complex business logic (e.g., payment processing, WebSocket connection management).",
            "Integrations with external services (where non-obvious API details may exist).",
            "Critical code sections (authentication, encryption, set operations).",
            "Non-obvious solutions or workarounds (with explanation)."
          ]
        },
        "namingConventions": {
          "title": "4.2. Naming Conventions",
          "conventions": [
            "<strong>Variables and functions:</strong> <code>camelCase</code> (e.g., <code>getUserProfile</code>, <code>chatMessage</code>).",
            "<strong>Classes and modules:</strong> <code>PascalCase</code> (e.g., <code>UserService</code>, <code>ChatModule</code>).",
            "<strong>Constants:</strong> <code>UPPER_SNAKE_CASE</code> (e.g., <code>MAX_FILE_SIZE</code>, <code>DEFAULT_TIMEOUT</code>).",
            "<strong>Files and folders:</strong> <code>kebab-case</code> (e.g., <code>user-service.ts</code>, <code>chat-screen.tsx</code>, <code>image-processing</code>).",
            "<strong>API Endpoints (in GraphQL context):</strong> Resolvers and their fields are named according to the domain model, often following REST-like logic (e.g., query <code>getUser</code>, mutation <code>sendMessage</code>)."
          ]
        },
        "formattingLinting": {
          "title": "4.3. Formatting and Linting: Automating Order Maintenance",
          "intro": "Use automatic tools to ensure consistent formatting and adherence to basic coding rules. This is part of the <strong>automated quality system</strong> (Principle 9).",
          "prettier_title": "<strong>Formatting:</strong> <strong>Prettier</strong> — an automatic code formatter.",
          "prettier_content": "Configure <code>.prettierrc</code> in the project root. Recommended settings: 2 spaces for indents, no semicolons at the end of lines, single quotes for strings.",
          "prettier_code": "```json\n{\n  \"tabWidth\": 2,\n  \"semi\": false,\n  \"singleQuote\": true,\n  \"trailingComma\": \"es5\"\n}\n```",
          "eslint_title": "<strong>Linting:</strong> <strong>ESLint</strong> — a static code analyzer for identifying problems.",
          "eslint_content": "Use a configuration like Airbnb or Standard, adapted for TypeScript, React/React Native, NestJS. Configure rules in <code>.eslintrc.js</code>.\nIntegrate ESLint into your code editor for real-time feedback."
        },
        "codeStructure": {
          "title": "4.4. Code Structure: Modularity and Clear Boundaries",
          "intro": "The code is organized modularly within each package, following the principles of <strong>systematization</strong> (Principle 9) and separation of concerns.",
          "corePackage": {
            "title": "Core (<code>packages/core</code>):",
            "points": [
              "<code>api/</code>: Code for interacting with the BrainMessenger GraphQL API (Apollo Client).",
              "<code>hooks/</code>: Reusable hooks for React/React Native.",
              "<code>utils/</code>: Pure utility functions, independent of a specific platform."
            ]
          },
          "mobileDesktopPackage": {
            "title": "Mobile-Desktop (<code>packages/mobile-desktop</code>):",
            "points": [
              "<code>components/</code>: Small, reusable UI components (<code>Button</code>, <code>MessageBubble</code>).",
              "<code>screens/</code>: Components representing entire screens (<code>ChatScreen</code>, <code>SettingsScreen</code>).",
              "<code>theme/</code>: Files with color schemes and typography, defined in DocDesign.",
              "<code>platform/</code>: Code specific to Android or Windows (e.g., working with native modules)."
            ]
          },
          "webPackage": {
            "title": "Web (<code>packages/web</code>):",
            "points": [
              "<code>pages/</code>: Next.js page components.",
              "<code>components/</code>: UI components for the web (can reuse logic from <code>core/hooks</code> or <code>core/utils</code>).",
              "<code>styles/</code>: Style files (Tailwind CSS)."
            ]
          },
          "backendPackage": {
            "title": "Backend (<code>backend</code>):",
            "points": [
              "NestJS structure: Modules (<code>auth</code>, <code>user</code>, <code>chat</code>, <code>message</code>), services (<code>AuthService</code>, <code>UserService</code>), controllers (for REST, if any) or resolvers (for GraphQL), DTO (Data Transfer Objects), Entities (defined by Prisma).",
              "<code>src/</code>: Source code.",
              "<code>test/</code>: Tests."
            ]
          }
        }
      },
      "libraries": {
        "title": "5. Used Libraries: Choosing the Right Tools (Principle 12)",
        "intro": "We choose libraries that solve problems <strong>pragmatically</strong> (Principle 12), ensure <strong>quality</strong> (Principle 3), and integrate well into our <strong>system</strong> (Principle 9).",
        "common": {
          "title": "5.1. Common (Core)",
          "libs": [
            "<code>@apollo/client</code> (and related): GraphQL client for making requests to the Backend API. Used in <code>core</code> and imported into <code>mobile-desktop</code> and <code>web</code>. Ensures <strong>efficiency</strong> (Principle 9) through cache management."
          ]
        },
        "mobileDesktop": {
          "title": "5.2. Mobile-Desktop (React Native)",
          "libs": [
            "<code>react-native-reanimated</code>, <code>moti</code>, <code>lottie-react-native</code>: Libraries for creating <strong>smooth and performant animations</strong> (see DocDesign). Related to Principle 3 (UI Quality) and Principle 5 (Health - load reduction).",
            "<code>@react-navigation/native</code> (and related): Navigation between application screens. <strong>Systematic</strong> (Principle 9) transition management.",
            "<code>react-native-sound</code>: Basic library for playing sounds (messages, calls). See Sound Documentation."
          ]
        },
        "web": {
          "title": "5.3. Web (Next.js)",
          "libs": [
            "<code>next</code>, <code>react</code>, <code>react-dom</code>: The foundation of the web application. Next.js provides a <strong>system</strong> (Principle 9) for SSR, SSG, routing, and <strong>optimization</strong> (see DocOptimizationIn).",
            "<code>tailwindcss</code>: Utility-first CSS framework for fast and <strong>pragmatic</strong> (Principle 12) styling.",
            "<code>framer-motion</code>: Library for <strong>quality</strong> (Principle 3) animations on the web."
          ]
        },
        "backend": {
          "title": "5.4. Backend (NestJS)",
          "libs": [
            "<code>@nestjs/*</code>: Core NestJS packages (core, common, platform-express/fastify, graphql, typeorm/prisma, jwt, passport, websockets, etc.). Provide a <strong>modular, scalable system</strong> (Principle 9).",
            "<code>@nestjs/prisma</code>: NestJS and Prisma integration.",
            "<code>graphql</code>, <code>@nestjs/graphql</code>, <code>apollo-server-express</code>: GraphQL API implementation.",
            "<code>@prisma/client</code>: Prisma ORM client for interacting with Neon (PostgreSQL).",
            "<code>@aws-sdk/client-s3</code>, <code>@aws-sdk/s3-request-presigner</code>: Working with Cloudflare R2 (S3-compatible).",
            "<code>ioredis</code>: Redis client for caching and other tasks.",
            "<code>kafkajs</code>: Kafka client for asynchronous tasks.",
            "<code>firebase-admin</code>: Firebase SDK (Push notifications).",
            "<code>stripe</code>: Stripe SDK (Payments).",
            "<code>googleapis</code>: Google APIs SDK (Gmail API).",
            "<code>bcrypt</code> or <code>argon2</code>: Library for <strong>secure</strong> (Principle 3, 5) password hashing."
          ]
        },
        "crossPackage": {
          "title": "5.5. Common (Cross-Package)",
          "libs": [
            "<code>typescript</code>: Development language.",
            "<code>winston</code> or <code>pino</code>: Library for <strong>structured logging</strong> (Principle 9).",
            "<code>@sentry/node</code>, <code>@sentry/react</code>, <code>@sentry/react-native</code>: Sentry clients for <strong>production error tracking</strong> (part of the <strong>quality</strong> and <strong>Kaizen</strong> system).",
            "<code>core-js</code>, <code>regenerator-runtime</code>: Polyfills for supporting modern JavaScript features in older environments (e.g., new Set methods in ES2024).",
            "<code>zod</code> or <code>class-validator</code>/<code>class-transformer</code>: Libraries for <strong>data validation</strong>, ensuring <strong>quality</strong> (Principle 3) at the system input."
          ]
        },
        "setMethods": {
          "title": "5.6. Working with Sets in ES2024+: Example of Applying New Knowledge (Principle 1)",
          "intro": "<strong>Continuous learning</strong> (Principle 1) and applying <strong>pragmatic</strong> (Principle 12) language tools are part of our philosophy. New <code>Set</code> object methods in ECMAScript 2024 (supported in Node.js 22+, modern browsers) provide a <strong>cleaner, more readable, and often more efficient</strong> (Principle 9) way to work with unique data sets compared to manual loops or conversions to arrays.",
          "areas": {
            "title": "Areas of application in BrainMessenger:",
            "points": [
              "Managing user lists in group chats (adding/removing participants).",
              "Tracking unique active sessions or WebSocket connections.",
              "Managing access rights (checking if a set of permissions is included in available ones).",
              "Synchronizing lists (e.g., contacts, chats) between client and server, identifying added/removed items."
            ]
          },
          "keys": {
            "title": "Key Methods (from ES2024):",
            "points": [
              "<code>union(iterable)</code>: Returns a new <code>Set</code> with all unique elements from the current <code>Set</code> and the passed iterable object.",
              "<code>intersection(iterable)</code>: Returns a new <code>Set</code> with elements present in <strong>both</strong> sets.",
              "<code>difference(iterable)</code>: Returns a new <code>Set</code> with elements present in the current <code>Set</code> but <strong>not</strong> in the passed iterable object.",
              "<code>symmetricDifference(iterable)</code>: Returns a new <code>Set</code> with elements that are in <strong>one</strong> but not in <strong>both</strong> sets.",
              "<code>isSubsetOf(iterable)</code>: Checks if all elements of the current <code>Set</code> are a subset of the passed iterable object (<code>true</code> or <code>false</code>).",
              "<code>isSupersetOf(iterable)</code>: Checks if the current <code>Set</code> contains all elements of the passed iterable object (<code>true</code> or <code>false</code>).",
              "<code>isDisjointFrom(iterable)</code>: Checks if the current <code>Set</code> and the passed iterable object have no common elements (<code>true</code> or <code>false</code>)."
            ]
          },
          "examples": {
            "title": "Examples of Usage in Code (TypeScript):",
            "code": "```typescript\n// backend/src/chat/chat.service.ts (example of group member management)\nasync updateGroupMembers(groupId: string, currentMemberIds: Set<string>, newMemberIds: Set<string>) {\n  // Principle 9: Optimization and clarity\n  const addedMembers = newMemberIds.difference(currentMemberIds);\n  const removedMembers = currentMemberIds.difference(newMemberIds);\n  const unchangedMembers = currentMemberIds.intersection(newMemberIds); // For verification\n\n  console.log('Added:', addedMembers);\n  console.log('Removed:', removedMembers);\n\n  // Perform add/remove operations in the database via Prisma\n  if (addedMembers.size > 0) {\n    await this.prisma.userChat.createMany({\n      data: Array.from(addedMembers).map(userId => ({ groupId, userId })),\n    });\n  }\n  if (removedMembers.size > 0) {\n    await this.prisma.userChat.deleteMany({\n      where: {\n        groupId: groupId,\n        userId: { in: Array.from(removedMembers) },\n      },\n    });\n  }\n\n  // Permissions check: Ensure the current user has permission to modify group membership\n  const requiredPermission = new Set(['manage_members']);\n  const userPermissions = new Set(await this.getUserPermissions(userId, groupId)); // Get user permissions\n  const hasPermission = requiredPermission.isSubsetOf(userPermissions); // Check using new method\n  if (!hasPermission) {\n      throw new ForbiddenException(\"Insufficient permissions to modify group membership.\");\n  }\n}\n\n// frontend/src/hooks/useChats.ts (example of chat list synchronization)\nfunction useSyncChats(localChats: Set<string>, serverChats: string[]) {\n    // Principle 9: Synchronization efficiency\n    const serverChatsSet = new Set(serverChats);\n    const newChats = serverChatsSet.difference(localChats);\n    const removedChats = localChats.difference(serverChatsSet);\n\n    console.log('New chats:', newChats);\n    console.log('Removed chats:', removedChats);\n\n    // Update local state/UI based on newChats and removedChats\n    // ...\n}\n",
            "recommendations": [
              "Apply them for operations with unique data sets. They are specifically designed for this and are often more performant than similar operations with arrays, especially for large datasets.",
              "Consider compatibility: New methods are available in Node.js 22+ and modern browsers. If you need to support older environments, use polyfills (core-js/proposals/set-methods-v2).",
              "TypeScript Typing: Always specify the type of elements in a Set (e.g., Set<string>, Set<number>) for better type checking and autocompletion."
            ]
          }
        }
      },
      "devProcess": {
        "title": "6. Development Process: Our Workflow System (Principle 9)",
        "intro": "A clear development process ensures systematization, quality, and predictability (Principle 9).",
        "envSetup": {
          "title": "6.1. Environment Setup: Preparing for Work",
          "intro": "Clone the repository:",
          "cloneRepo": {
            "title": "Clone the repository:",
            "code": "```bash\ngit clone <https://github.com/xAI/BrainMessenger.git> # Example\ncd BrainMessenger\n```"
          },
          "installDeps": {
            "title": "Install dependencies:",
            "code": "```bash\nnpm install\n```"
          },
          "envVars": {
            "title": "Configure environment variables:",
            "code": "```bash\ncp .env.example .env\n# Fill .env with data for Neon, R2, Redis, Kafka, API Gateways, Stripe, Firebase, Gmail API\n```",
            "note": "It is important to have working local or test instances of DB, Redis, Kafka or use their cloud versions for development."
          },
          "prismaClient": {
            "title": "Generate Prisma Client:",
            "code": "```bash\ncd backend\nnpx prisma generate\ncd ..\n```"
          },
          "localDb": {
            "title": "Set up local DB (if not using cloud):",
            "code": "```bash\ncd backend\nnpx prisma migrate dev --name initial_setup\ncd ..\n```"
          }
        },
        "localRun": {
          "title": "6.2. Local Run: Activating the System for Development",
          "intro": "Use turbo run commands or specific package commands.",
          "runAll": {
            "title": "Start all services (Backend, Web) for development:",
            "code": "```bash\nturbo run dev # Will start dev-servers for all packages with the 'dev' task in turbo.json\n```"
          },
          "runBackend": {
            "title": "Separate Backend run:",
            "code": "```bash\ncd backend\nnpm run start:dev # or npm run start:debug for debugging\n```"
          },
          "runMobileDesktop": {
            "title": "Separate Mobile-Desktop (React Native) run:",
            "code": "```bash\ncd packages/mobile-desktop\nnpm run android # to run on Android emulator/device\nnpm run windows # to run on Windows\n```"
          },
          "runWeb": {
            "title": "Separate Web (Next.js) run:",
            "code": "```bash\ncd packages/web\nnpm run dev\n```"
          }
        },
        "commitsBranches": {
          "title": "6.3. Commits and Branches: Code Evolution Structure (Principle 9)",
          "intro": "We use a clear branching strategy and commit standards to maintain order (Principle 9) and a clear change history (Principle 7).",
          "mainBranches": {
            "title": "Main development branch:",
            "points": [
              "<code>develop</code>. All new features and fixes are integrated here.",
              "Stable branch: <code>main</code>. Only verified code from <code>develop</code> (via release PRs)."
            ]
          },
          "workBranches": {
            "title": "Work branches:",
            "points": [
              "<code>feature/<feature_name></code>: For developing new functionality (e.g., <code>feature/graphql-auth</code>).",
              "<code>fix/<fix_name></code>: For bug fixes (e.g., <code>fix/chat-message-scroll</code>).",
              "<code>refactor/<name></code>: For code refactoring."
            ]
          },
          "commitFormat": {
            "title": "Commit format:",
            "example": "Use Conventional Commits. This simplifies changelog generation and understanding the purpose of each commit.\n\nExample:\n\n<code>feat(backend/auth): add JWT authentication</code> (new feature in backend authentication module)\n\n<code>fix(mobile/chat): resolve message display bug on scroll</code> (bug fix for message display in mobile chat)\n\n<code>docs(roadmap): update Q3 2025 plan</code> (documentation update)\n\n<code>chore(deps): update prisma to 5.x</code> (routine task, dependency update)",
            "structure": "Structure: <code>type(scope): description</code>\n\n<code>type</code>: <code>feat</code>, <code>fix</code>, <code>docs</code>, <code>chore</code>, <code>style</code>, <code>refactor</code>, <code>test</code>, <code>ci</code>, <code>perf</code>, <code>build</code>\n\n<code>scope</code>: Optional, indicates package or area (<code>backend</code>, <code>web</code>, <code>mobile-desktop</code>, <code>core</code>, <code>auth</code>, <code>chat</code>, <code>ui</code>, <code>infra</code>, etc.)."
          }
        },
        "prCodeReview": {
          "title": "6.4. Pull Request (PR) and Code Review: Collective Quality Assurance (Principle 3, 14)",
          "intro": "Every Pull Request is an opportunity to receive feedback (Principle 14), improve code, and ensure quality (Principle 3) before integrating into the main branch.",
          "prDescription": {
            "title": "PR Description:",
            "points": [
              "Clearly describe what problem the PR solves or what feature it adds.",
              "Reference the relevant Jira task (e.g., [BM-123]) or other task tracking location.",
              "Describe major changes and any potential risks or questions."
            ]
          },
          "prRequirements": {
            "title": "PR Requirements:",
            "points": [
              "Code must comply with coding standards (linter, formatter).",
              "All tests must pass (<code>npm test</code>). Configure checks in GitHub Actions.",
              "There must be at least 1 approval from another developer (or from yourself if working alone, but strive for ideal code review).",
              "Non-trivial changes may require review from a more experienced developer or architect."
            ]
          }
        },
        "testing": {
          "title": "6.5. Testing: System Reliability Verification (Principle 3)",
          "intro": "Testing is an integral part of the quality assurance process (Principle 3). We use a multi-level approach.",
          "runAllTests": {
            "title": "Run all tests:",
            "code": "```bash\nnpm run test # Will run tests for all packages (unit, integration)\n```"
          },
          "testTypes": {
            "title": "Types of tests:",
            "points": [
              "Unit Tests: Testing individual functions or classes in isolation (Jest). Focus: Correctness of small code parts.",
              "Integration Tests: Testing interaction between several components (e.g., service -> DB, API -> service) (Jest). Focus: Correctness of connections between system parts.",
              "E2E Tests (End-to-End Tests): Testing user scenarios in the application (Cypress for Web, Detox for React Native). Focus: Overall system operation from the user's perspective."
            ]
          },
          "ciCdTests": {
            "title": "Configure automatic test run in CI/CD (GitHub Actions) on every PR and push to develop.",
            "content": "Configure automatic test run in CI/CD (GitHub Actions) on every PR and push to develop."
          }
        }
      },
      "devRecommendations": {
        "title": "7. Development Recommendations: Best Practices for Building an Asset",
        "intro": "Apply these recommendations to create quality, maintainable code that will form the foundation of your digital Asset (Principle 3, 10).",
        "corePackage": {
          "title": "7.1. Core Package: Reuse for Efficiency",
          "points": [
            "API Client (<code>@apollo/client</code>): Use it for all GraphQL queries from the Frontend. Configure caching (InMemoryCache) and error handling. This reduces code duplication and provides a unified way to interact with the API.",
            "Common Hooks/Utilities: Extract logic here that is repeated across different platforms (data formatting, validation, token handling)."
          ]
        },
        "mobileDesktop": {
          "title": "7.2. Mobile-Desktop (React Native)",
          "points": [
            "Functional Components: Use React Hooks and functional components. Separate components into \"smart\" (with logic) and \"dumb\" (UI only).",
            "Styling: Use StyleSheet.create for performance or libraries like styled-components / NativeBase for consistency.",
            "Native Optimization: Study the specifics of RNW and RN (e.g., working with native modules to improve performance of critical sections, animations on native thread with Reanimated)."
          ]
        },
        "web": {
          "title": "7.3. Web (Next.js)",
          "points": [
            "Routing and Fetching: Use Next.js capabilities (File-system routing, getStaticProps, getServerSideProps, getStaticPaths) to optimize page loading (SSR/SSG) and SEO (Principle 2).",
            "Styling: Tailwind CSS accelerates UI development. Follow principles from DocDesign.",
            "Image Optimization: Use next/image for automatic image optimization."
          ]
        },
        "backend": {
          "title": "7.4. Backend (NestJS)",
          "points": [
            "GraphQL API: Follow GraphQL principles (request only what's needed). Use DataLoader to solve the N+1 problem (see DocOptimizationIn).",
            "Prisma: Use ORM for all DB interactions. This ensures security (protection from SQL injections - Principle 3, 5) and typing.",
            "Services: Extract main business logic into services. Controllers/Resolvers should be thin (only request handling and service invocation).",
            "Integrations: Interaction with external services (R2, Firebase, Stripe, Gmail API) should be encapsulated in separate services (e.g., StorageService, NotificationService). This makes code more modular and testable (Principle 9).",
            "Error Handling: Use NestJS exception filters for centralized error handling and returning standardized API responses (see DocSpec). Log errors in detail (Winston, Sentry)."
          ]
        },
        "security": {
          "title": "7.5. Security: Protecting Your Asset (Principle 3, 5, 10)",
          "intro": "Security is not a feature, but a fundamental aspect of quality (Principle 3), directly related to system health (Principle 5) and digital asset protection (Principle 10: your product and user data).",
          "points": [
            "Authentication: Use JWT for stateless authentication with short-lived access tokens and refresh tokens. Securely store the JWT secret.",
            "Password Hashing: Never store passwords in plain text. Use strong hashing algorithms (bcrypt, argon2).",
            "Input Validation: Strictly validate all incoming data on the Backend (e.g., using class-validator and DTOs).",
            "Attack Protection: Implement Rate Limiting (<code>@nestjs/throttler</code>) to protect against brute-force attacks or DDoS at the API level. Use helmet for setting secure HTTP headers.",
            "Sensitive Data Encryption: Encrypt data before saving to R2 (see DocInt). Securely store the encryption key separately from the data.",
            "2FA: Implement two-factor authentication as an option for users."
          ]
        }
      },
      "optimization": {
        "title": "8. Project Optimization: Continuous Improvement (Principle 9, 1)",
        "content": "Optimization is an iterative process (Principle 9: Kaizen), based on measurement and learning (Principle 1). See detailed BrainMessenger Optimization Guide."
      },
      "deployProcess": {
        "title": "9. Deployment Process: Delivering the System to Users (Principle 9)",
        "intro": "The deployment process must be automated, reliable, and predictable (Principle 9, 3).",
        "points": [
          "Containerization (Docker): Create Docker images for the Backend and other services. Use multi-stage builds to optimize image size (see CI/CD Optimization Guide).",
          "Orchestration (Kubernetes): Deploy containers to Kubernetes. Use manifests in the <code>infrastructure/k8s</code> folder. K8s provides automatic scaling, self-healing, and load management.",
          "Infrastructure as Code (Terraform): Manage cloud resources (K8s cluster, networks) using Terraform (<code>infrastructure/main.tf</code>). This makes the infrastructure versionable and reproducible.",
          "CI/CD (GitHub Actions): Configure automatic pipelines for building, testing, and deploying (see CI/CD Optimization Guide)."
        ],
        "process": "Process: Code is pushed to <code>develop</code> → CI/CD runs tests and builds → After successful tests and review, PR is merged into <code>develop</code> → (optional) automatic deployment of dev/staging environment → Release PR from <code>develop</code> to <code>main</code> → Production deployment."
      },
      "devCommands": {
        "title": "10. Useful Developer Commands: System Toolkit",
        "table": [
          ["Command", "Description", "Location"],
          ["<code>npm install</code>", "Installs dependencies for all packages (Turborepo).", "Root"],
          ["<code>turbo run <task></code>", "Runs a task (build, test, lint, dev) for all packages or by filter.", "Root"],
          ["<code>npm run lint</code>", "Runs linters for all packages.", "Root"],
          ["<code>npm run format</code>", "Formats code for all packages (Prettier).", "Root"],
          ["<code>npm run build</code>", "Builds production versions of all packages.", "Root"],
          ["<code>npm run test</code>", "Runs tests for all packages.", "Root"],
          ["<code>cd backend && npx prisma migrate dev --name <name></code>", "Creates and applies a new DB migration.", "Root/backend"],
          ["<code>cd backend && npx prisma studio</code>", "Launches a graphical interface for viewing the DB.", "Root/backend"],
          ["<code>cd backend && npm run start:dev</code>", "Starts backend in development mode.", "Root/backend"],
          ["<code>cd packages/web && npm run dev</code>", "Starts web application in development mode.", "Root/packages/web"],
          ["<code>cd packages/mobile-desktop && npm run android</code>", "Starts mobile application on Android.", "Root/packages/mobile-desktop"],
          ["<code>cd packages/mobile-desktop && npm run windows</code>", "Starts desktop on Windows.", "Root/packages/mobile-desktop"],
          ["<code>cd infrastructure && terraform plan</code>", "Shows infrastructure change plan.", "Root/infrastructure"],
          ["<code>cd infrastructure && terraform apply</code>", "Applies infrastructure changes.", "Root/infrastructure"]
        ]
      },
      "notes": {
        "title": "11. Notes: Continuous Learning and Kaizen",
        "points": [
          "Onboarding: New developers should start by studying this documentation, as well as the Technical Documentation (general overview), Design Documentation (visual standards), and Optimization Guide (how to write performant code).",
          "Living Document: This documentation is a living document. It will be updated as the project evolves, new technologies are learned, and processes improve. Your suggestions for improvement are welcome! (Principle 1, 14).",
          "ECMAScript 2024 Compatibility: Ensure you are using Node.js 22+ (for backend) and up-to-date browser/React Native versions (for frontend) for full support of new Set methods. Use polyfills if necessary.",
          "Questions and Feedback: If anything is unclear, or you see an opportunity to improve the process — ask questions in the team chat (#dev-team in Slack or another tool) and propose changes. This is part of the Power of Interaction and Collaboration (Margulan) that makes the system stronger."
        ]
      }
    },
    "integrationsGuide": {
      "title": "BrainMessenger Integrations Documentation",
      "subtitle": "Building a Robust System with External Levers",
      "introduction": {
        "title": "1. Introduction: Integrations as Part of the System Foundation",
        "description": "This document describes how BrainMessenger integrates with key external services. We select these integrations <strong>pragmatically</strong> (Principle 12), viewing them as <strong>levers</strong> (Margulan's principle) that allow us to avoid reinventing the wheel and instead use <strong>reliable and scalable</strong> (Principle 8, 9) third-party solutions to accelerate development and ensure the <strong>quality</strong> (Principle 3) of our product. These integrations are an integral part of our <strong>technological foundation</strong> (Principle 8).",
        "principlesTitle": "Principles guiding the selection and configuration of integrations:",
        "principles": [
          "<strong>System and Optimization (Principle 9):</strong> Integrations must be part of a unified, well-thought-out system where each component performs its role efficiently.",
          "<strong>Pragmatism and Realism (Principle 12):</strong> Selecting services based on current needs, budget (free/affordable tiers at launch), and ease of integration.",
          "<strong>Long-term Thinking (Principle 8):</strong> Choosing services capable of scaling with project growth.",
          "<strong>Quality > Quantity (Principle 3):</strong> Focusing on the reliability and performance of integrations, even if their initial list is small.",
          "<strong>Value Creation (Principle 2):</strong> Each integration should add real value for the end-user (e.g., reliable file storage, instant notifications)."
        ]
      },
      "overview": {
        "title": "2. Overview of Key Integrations: Our External System Components",
        "table": [
          ["Service", "Purpose", "Role in BrainMessenger", "Key Functions", "Connection to Principles"],
          ["<strong>Neon</strong>", "Managed PostgreSQL DB", "Storing all <strong>structured data</strong> (users, chats, messages, file metadata). Data foundation.", "PostgreSQL hosting, scaling, connection string access.", "P8 (Long-term), P9 (System), P12 (Pragmatism - free tier)."],
          ["<strong>Cloudflare R2</strong>", "Cloud Storage (S3-compatible)", "Storing all <strong>unstructured data</strong> (user files, avatars, call recordings, encrypted metadata). Asset storage.", "Reliable object storage, CDN delivery, no egress fees.", "P8 (Long-term), P10 (Assets), P12 (Pragmatism - free tier, no traffic fees), P3 (Quality - CDN)."],
          ["<strong>Firebase</strong>", "Push Notifications", "Instant delivery of notifications to users on mobile devices.", "Sending push notifications (FCM).", "P2 (Value - informing), P9 (System - reliable delivery), P12 (Pragmatism - ready-made solution)."],
          ["<strong>Stripe</strong>", "Payment System", "Processing payments for Premium subscription. Access to payments as a lever for Value/Wealth creation.", "Accepting payments, subscription management.", "P2 (Value - premium), P10 (Wealth/Assets), P9 (System - payment automation)."],
          ["<strong>Gmail API</strong>", "Email Sending Service", "Sending critical emails (verification codes for registration and 2FA).", "Sending transactional emails.", "P3 (Quality - reliable email delivery), P9 (System - part of authentication), P5 (Health - user security)."]
        ]
      },
      "neonIntegration": {
        "title": "3. Integration with Neon: Foundation for Structured Data",
        "generalInfo": {
          "title": "3.1. General Information",
          "description": "Neon provides a managed PostgreSQL service. We use it as the <strong>primary storage for structured data</strong>, such as user information, chats, messages, and file metadata.",
          "advantages": [
            "<strong>Pragmatism (P12):</strong> The free tier (30 GB) at launch fully covers initial needs.",
            "<strong>System and Long-term Thinking (P9, P8):</strong> Managed service reduces operational overhead; automatic scaling and replication are available on paid plans, ensuring readiness for growth.",
            "<strong>Quality (P3):</strong> Reliability and performance of PostgreSQL as a proven DBMS."
          ],
          "role": "Role: The core to which the Backend accesses for all CRUD operations on metadata."
        },
        "configuration": {
          "title": "3.2. Configuration: Connecting to the Data System",
          "steps": [
            "1. <strong>Registration and Project Creation:</strong>",
            "Create an account on `https://neon.tech`.",
            "Create a new project (e.g., `brainmessenger-prod`) in the Neon console.",
            "2. <strong>Database Setup:</strong>",
            "Neon automatically provides a PostgreSQL instance.",
            "<strong>Apply the database schema:</strong> Use Prisma Migrate to initialize table structure (see `database/schema.prisma` and Development Guide).",
            "3. <strong>Environment Variables:</strong>",
            "Obtain the <strong>connection string</strong> (Connection Details) from the Neon console (Settings → Connection Details).",
            "Add to your `.env` file:"
          ],
          "envExample": "```env\n# Neon Database Connection String\nDATABASE_URL=postgresql://<user>:<password>@<neon-host>/<dbname>?sslmode=require\n```",
          "note1": "*Note:* Use `sslmode=require` for a secure connection.",
          "backendCode": "4. <strong>Backend Connection (NestJS + Prisma):</strong>\nPrisma uses `DATABASE_URL` for connection. Ensure Prisma Client is generated (`npx prisma generate`).\nUse `PrismaService` (from `nestjs-prisma`) for all DB operations.\n```typescript\n// backend/src/app.module.ts (or db.module.ts)\nimport { Module } from '@nestjs/common';\nimport { PrismaService } from 'nestjs-prisma'; // Ensure PrismaModule is imported in app.module\n\n@Module({\n  providers: [PrismaService], // PrismaService is available for injection\n  exports: [PrismaService],\n})\nexport class DbModule {}\n```"
        },
        "interactionScenarios": {
          "title": "3.3. Interaction Methods and Scenarios: Data API",
          "description": "All interactions with Neon occur via Prisma ORM in the Backend, ensuring <strong>typing, security, and systemic consistency</strong> (Principle 3, 9).",
          "signup": {
            "title": "Scenario: User Registration:",
            "interaction": "<strong>Interaction:</strong> Backend receives user data → Uses `PrismaService` to create a new record in the `users` table.",
            "code": "<strong>Example Code (Backend Service):</strong>\n```typescript\n// backend/src/auth/auth.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { PrismaService } from 'nestjs-prisma';\nimport { Prisma } from '@prisma/client'; // Import Prisma types\n\n@Injectable()\nexport class AuthService {\n  constructor(private prisma: PrismaService) {}\n\n  async signUp(data: Prisma.UserCreateInput) {\n    // Example: password must be hashed BEFORE saving\n    const hashedPassword = await hashPassword(data.password); // Using a hashing utility\n    return this.prisma.user.create({\n      data: {\n        email: data.email,\n        name: data.name,\n        password: hashedPassword, // Store the hashed password\n        // ... other fields as per schema\n      },\n    });\n  }\n}\n```",
            "result": "<strong>Result:</strong> User data is securely stored in Neon."
          },
          "getChats": {
            "title": "Scenario: Retrieving User Chat List:",
            "interaction": "<strong>Interaction:</strong> Frontend requests chats via GraphQL API → Backend uses `PrismaService` to execute a query to the `chats` table (possibly with `userId` filtering and `include` for metadata).",
            "code": "<strong>Example Code (Backend Service):</strong>\n```typescript\n// backend/src/chat/chat.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { PrismaService } from 'nestjs-prisma';\n\n@Injectable()\nexport class ChatService {\n  constructor(private prisma: PrismaService) {}\n\n  async getUserChats(userId: string) {\n    // Use @@index([userId]) for optimization (Principle 9, Optimization)\n    return this.prisma.chat.findMany({\n      where: {\n        users: { // Assumes Many-to-Many relationship with UserChat table\n          some: {\n            userId: userId,\n          },\n        },\n      },\n      select: { // Select only necessary fields (Principle 9, Optimization)\n        id: true,\n        name: true,\n        type: true,\n        // ... other required fields\n      },\n      orderBy: { // Sort by last message date for relevance (Principle 2, Value)\n        lastMessageAt: 'desc',\n      },\n    });\n  }\n}\n```"
          },
          "saveMessage": {
            "title": "Scenario: Saving a Message:",
            "interaction": "<strong>Interaction:</strong> User sends a message → Frontend sends it via GraphQL API → Backend uses `PrismaService` to create a new record in the `messages` table, linking it to `chatId` and `userId`.",
            "code": "<strong>Example Code (Backend Service):</strong>\n```typescript\n// backend/src/message/message.nmessage.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { PrismaService } from 'nestjs-prisma';\nimport { Prisma } from '@prisma/client';\n\n@Injectable()\nexport class MessageService {\n  constructor(private prisma: PrismaService) {}\n\n  async createMessage(data: Prisma.MessageCreateInput) {\n    // Use a transaction if you need to update the last message date in the chat\n    return this.prisma.$transaction(async (tx) => {\n      const message = await tx.message.create({ data });\n      await tx.chat.update({\n        where: { id: data.chatId },\n        data: { lastMessageAt: message.createdAt }, // Update last message time\n      });\n      return message;\n    });\n  }\n}\n```"
          }
        },
        "errorHandling": {
          "title": "3.4. Integration Error Handling: Maintaining System Quality",
          "description": "A reliable system must be able to handle errors from external dependencies (Principle 3: Quality).",
          "connectionError": {
            "title": "Connection Error:",
            "cause": "Cause: Unable to establish connection with Neon. Incorrect connection string (`DATABASE_URL`), network issues, Neon service unavailability.",
            "solution": "Solution: Check the `DATABASE_URL` environment variable, Neon service status. Log the error on the Backend (Sentry/Winston)."
          },
          "queryError": {
            "title": "Database Query Error:",
            "cause": "Cause: Error executing a DB query (e.g., uniqueness violation, incorrect data type). Backend logic error, schema mismatch.",
            "solution": "Solution: Debug the query in the Backend, check Prisma logs. Log the error."
          },
          "rateLimitError": {
            "title": "Rate Limit Exceeded (on paid tiers):",
            "cause": "Cause: Exceeded request limits or computational resources in Neon. High load, unoptimized queries, insufficient pricing plan.",
            "solution": "Solution: Optimize queries (see Optimization Guide), consider upgrading to a higher Neon pricing plan."
          }
        }
      },
      "r2Integration": {
        "title": "4. Integration with Cloudflare R2: Digital Asset Storage",
        "generalInfo": {
          "title": "4.1. General Information",
          "description": "Cloudflare R2 is an S3-compatible object storage service. We use it to store <strong>all user files</strong>, such as images, videos, documents, and encrypted data.",
          "advantages": [
            "<strong>Pragmatism (P12), Wealth/Asset Creation (P10):</strong> <strong>No egress fees</strong> — a critically important advantage for a messenger where users actively exchange files. Free 10 GB tier at launch.",
            "<strong>Quality (P3):</strong> High performance and reliability due to Cloudflare's global network.",
            "<strong>Long-term Thinking (P8), System (P9):</strong> S3-compatible API allows easy use of standard libraries and tools, ensuring future flexibility."
          ],
          "role": "Role: Decentralized storage for large binary objects, reducing load on the primary database."
        },
        "configuration": {
          "title": "4.2. Configuration: Connecting to Asset Storage",
          "steps": [
            "1. <strong>Bucket Creation:</strong>",
            "Log in to Cloudflare Dashboard → R2.",
            "Click <strong>\"Create Bucket\"</strong>.",
            "Name the bucket (e.g., `brainmessenger-files`). The name must be unique across all Cloudflare accounts.",
            "<strong>Settings:</strong> Enable Encryption at rest — this is part of our <strong>security system</strong> (Principle 3, 5). Restrict public access to the bucket; access will be via signed URLs (if required) or through the Backend.",
            "2. <strong>Access Keys:</strong>",
            "In Cloudflare Dashboard, go to R2 → Manage R2 API Tokens.",
            "Create a new API token. Grant it the minimum necessary permissions (e.g., Read and Write to specific buckets).",
            "Copy `Access Key ID` and `Secret Access Key`.",
            "3. <strong>Environment Variables:</strong>",
            "Add to your `.env` file:"
          ],
          "envExample": "```env\n# Cloudflare R2 Credentials\nR2_ENDPOINT=<Your R2 Endpoint> # Format: https://<account-id>.r2.cloudflarestorage.com\nR2_ACCESS_KEY=<Your Access Key ID>\nR2_SECRET_KEY=<Your Secret Access Key>\nR2_BUCKET=brainmessenger-files # Your bucket name\n\n# Encryption key for confidential data (important for P3, P5, P10)\nENCRYPTION_KEY=<Your 32-byte (256-bit) hex or base64 encryption key> # Generate a strong key!\n```",
          "note": "*Note:* <strong>Do not commit these keys to Git!</strong> (Principle 3, 5, 6). Use `.env.example` without sensitive data. <strong>ENCRYPTION_KEY</strong> must be securely generated and stored safely.",
          "backendCode": "4. <strong>Backend Connection (`@aws-sdk/client-s3`):</strong>\nR2 is S3-compatible, so you can use the standard AWS SDK for S3.\nInstall SDK: `npm install @aws-sdk/client-s3`.\nInitialize S3 Client in your Backend service (e.g., `StorageService`).\n```typescript\n// backend/src/storage/storage.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3';\nimport { getSignedUrl } from '@aws-sdk/s3-request-presigner'; // For signed URLs\nimport { createCipheriv, randomBytes, createDecipheriv } from 'crypto'; // For encryption\n\n@Injectable()\nexport class StorageService {\n  private r2: S3Client;\n  private encryptionKey: Buffer; // Key for encryption\n\n  constructor() {\n    this.r2 = new S3Client({\n      region: 'auto', // R2 does not use regions in the classical sense\n      endpoint: process.env.R2_ENDPOINT,\n      credentials: {\n        accessKeyId: process.env.R2_ACCESS_KEY,\n        secretAccessKey: process.env.R2_SECRET_KEY,\n      },\n    });\n    // Important: ENCRYPTION_KEY must be a 32-byte Buffer for aes-256-cbc\n    this.encryptionKey = Buffer.from(process.env.ENCRYPTION_KEY, 'hex'); // Or 'base64'\n    if (this.encryptionKey.length !== 32) {\n         // Log error or throw exception - key has incorrect length\n         console.error(\"Invalid ENCRYPTION_KEY length. Must be 32 bytes for aes-256-cbc.\");\n         // process.exit(1); // Possibly, should stop the application\n    }\n  }\n\n  // Utility for encryption (part of security system - P3, P5)\n  private encrypt(data: string): { encrypted: string, iv: string } {\n    const iv = randomBytes(16); // Initialization Vector, 16 bytes for aes-256-cbc\n    const cipher = createCipheriv('aes-256-cbc', this.encryptionKey, iv);\n    let encrypted = cipher.update(data, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    return { encrypted, iv: iv.toString('hex') };\n  }\n\n  // Utility for decryption\n  private decrypt(encrypted: string, iv: string): string {\n      const decipher = createDecipheriv('aes-256-cbc', this.encryptionKey, Buffer.from(iv, 'hex'));\n      let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n      decrypted += decipher.final('utf8');\n      return decrypted;\n  }\n\n  // ... methods for working with R2 (upload, download, delete)\n}\n```"
        },
        "interactionScenarios": {
          "title": "4.3. Interaction Methods and Scenarios: Storage API",
          "description": "Interaction with R2 is done via the Backend, which allows controlling access, processing files (e.g., image optimization before upload), and managing metadata in the DB (Principle 9: System).",
          "uploadFile": {
            "title": "Scenario: User File Upload:",
            "interaction": "<strong>Interaction:</strong> User attaches a file in chat → Frontend sends the file to Backend → Backend (`StorageService`) uploads the file to R2 → Backend saves file metadata (URL, type, size) in Neon → Backend sends a message to the chat with the file link.",
            "code": "<strong>Example Code (Backend Service):</strong>\n```typescript\n// backend/src/storage/storage.service.ts (continued)\n// ... S3Client and encryptionKey initialization ...\n\nasync uploadFile(fileBuffer: Buffer, fileName: string, mimeType: string): Promise<string> {\n  const key = `uploads/${Date.now()}-${fileName}`; // Unique file key\n  const params = {\n    Bucket: process.env.R2_BUCKET,\n    Key: key,\n    Body: fileBuffer,\n    ContentType: mimeType, // Important for file delivery\n  };\n  const command = new PutObjectCommand(params);\n  await this.r2.send(command); // Asynchronous upload\n\n  // Return URL for saving to DB. R2 allows direct links if a public domain is configured.\n  // OR generate a signed URL for restricted access (more secure).\n  // Example direct link (requires Public Access URL setup in CF Dashboard):\n  // const publicUrl = `${process.env.R2_ENDPOINT.replace('.r2.cloudflarestorage.com', '.r2.dev')}/${process.env.R2_BUCKET}/${key}`;\n  // For your own domain (preferable):\n  const fileUrl = `https://r2.brainmessenger.com/${key}`; // Your configured Cloudflare Workers/Pages domain\n\n  return fileUrl;\n}\n\n//backend/src/chat/chat.service.ts (uploadFile integration)\n// ... constructor with StorageService ...\nasync sendFileMessage(chatId: string, userId: string, file: Express.Multer.File): Promise<Message> {\n   // Optional: image processing before upload (see DocOptimizationIn)\n   // const processedFileBuffer = await this.imageProcessingService.processImage(file.buffer, 800, 600); // Example\n   const fileUrl = await this.storageService.uploadFile(file.buffer, file.originalname, file.mimetype);\n\n   // Create message in DB with file link\n   return this.prisma.message.create({\n     data: {\n       chatId,\n       userId,\n       content: '[File]', // Or another file designation\n       fileUrl: fileUrl, // Save file link to DB\n       // fileMetadata: { type: file.mimetype, size: file.size }, // Optional: save metadata in JSON field or separate table\n     },\n   });\n}\n```",
            "result": "<strong>Result:</strong> File is securely stored in R2, its link is available in the DB for display in chat."
          },
          "sensitiveData": {
            "title": "Scenario: Storing Confidential Data (e.g., encrypted metadata):",
            "interaction": "<strong>Interaction:</strong> During registration or profile update, Backend encrypts sensitive data (e.g., backup emails, security questions) and saves it to R2 in a separate bucket or folder.",
            "code": "<strong>Example Code (Backend Service):</strong>\n```typescript\n// backend/src/storage/storage.service.ts (continued)\n// ... encrypt/decrypt methods ...\n\nasync storeSensitiveData(userId: string, sensitiveInfo: any): Promise<string> {\n   const encryptedData = {};\n   for (const key in sensitiveInfo) {\n       if (sensitiveInfo.hasOwnProperty(key)) {\n           const { encrypted, iv } = this.encrypt(JSON.stringify(sensitiveInfo[key])); // Encrypt each field or the entire object\n           encryptedData[key] = { encrypted, iv };\n       }\n   }\n\n   const key = `sensitive/${userId}/metadata.json`;\n   const params = {\n       Bucket: process.env.R2_BUCKET, // Or a separate bucket for sensitive data\n       Key: key,\n       Body: JSON.stringify(encryptedData),\n       ContentType: 'application/json',\n   };\n   const command = new PutObjectCommand(params);\n   await this.r2.send(command);\n   return `https://r2.brainmessenger.com/${key}`; // Link for internal use\n}\n\n// backend/src/user/user.service.ts (storeSensitiveData integration)\n// ... constructor with StorageService ...\nasync createUserWithSensitiveData(userData: any, sensitiveData: any) {\n    // Create user in DB\n    const user = await this.prisma.user.create({ data: userData });\n    // Save encrypted data to R2\n    const sensitiveDataUrl = await this.storageService.storeSensitiveData(user.id, sensitiveData);\n    // Save link to encrypted data in DB (optional)\n    await this.prisma.user.update({\n        where: { id: user.id },\n        data: { sensitiveDataUrl: sensitiveDataUrl } // Add sensitiveDataUrl field to Prisma schema\n    });\n    return user;\n}\n```",
            "result": "<strong>Result:</strong> Confidential data is securely encrypted and stored separately from the main DB in R2. Access is only possible via the Backend using the encryption key."
          },
          "getFile": {
            "title": "Scenario: Retrieving a File (for display or download):",
            "interaction": "<strong>Interaction:</strong> Frontend retrieves file URL from message metadata (from Neon) → Frontend (or Backend, if authentication/signed URLs are required) uses this URL to download the file directly from R2.",
            "code": "<strong>Implementation:</strong> If the R2 bucket is configured with a Public Access URL (via Cloudflare Workers/Pages), the Frontend can access it directly. If access is restricted, the Backend can generate temporary signed URLs via `@aws-sdk/s3-request-presigner`.\n```typescript\n// backend/src/storage/storage.service.ts (continued)\n// ... S3Client initialization ...\n\n// Method to generate a signed URL (more secure approach for private files)\nasync getSignedFileUrl(fileKey: string): Promise<string> {\n    const command = new GetObjectCommand({\n        Bucket: process.env.R2_BUCKET,\n        Key: fileKey,\n    });\n    // Generate a signed URL, valid for, e.g., 60 seconds\n    const signedUrl = await getSignedUrl(this.r2, command, { expiresIn: 60 });\n    return signedUrl;\n}\n```"
          }
        },
        "errorHandling": {
          "title": "4.4. Integration Error Handling: Asset Storage",
          "forbidden": {
            "title": "403 Forbidden:",
            "cause": "Cause: R2 bucket access error. Incorrect access keys (`R2_ACCESS_KEY`, `R2_SECRET_KEY`), incorrect token permissions, attempt to access a private file without authentication/signed URL.",
            "solution": "Solution: Check environment variables, R2 token permissions. Ensure correct access logic (public URL vs signed URL) is implemented. Log the error."
          },
          "notFound": {
            "title": "404 Not Found:",
            "cause": "Cause: File missing in R2. Incorrect file key (`Key`), file has been deleted.",
            "solution": "Solution: Check the file key that was saved in Neon. Confirm the file was indeed uploaded. Log the error."
          },
          "tooManyRequests": {
            "title": "429 Too Many Requests:",
            "cause": "Cause: R2 API request limit exceeded. High frequency of upload/download requests.",
            "solution": "Solution: Implement Rate Limiting on the Backend (see Optimization Guide). Optimize file interaction logic."
          },
          "encryptionError": {
            "title": "Encryption/Decryption Error:",
            "cause": "Cause: Encryption/decryption error. Incorrect encryption key (`ENCRYPTION_KEY`), corrupted IV, corrupted encrypted data.",
            "solution": "Solution: Ensure the correct key (`ENCRYPTION_KEY`) is used and matches the key used during encryption. Check data integrity and IV. Log critical error."
          }
        }
      },
      "neonR2Interaction": {
        "title": "5. Neon and Cloudflare R2 Interaction: Data Storage Optimization (Principle 9, 12)",
        "description": "We use Neon and R2 together to create an optimized data storage system where each service performs its best function (Principle 9).",
        "scenario": [
          "<strong>Neon (PostgreSQL):</strong> Stores <strong>structured metadata</strong> that is frequently queried and requires complex queries (users, chats, text messages, file links).",
          "<strong>Cloudflare R2:</strong> Stores <strong>unstructured binary data</strong> of large size (files) that are less frequently queried and do not require complex content-based retrieval logic.",
          "<strong>Complex Interaction Scenario:</strong>",
          "1. User sends a file via chat (Frontend -> Backend).",
          "2. Backend (`StorageService`) <strong>uploads the file to Cloudflare R2</strong> (using S3 API). Obtains the file URL (or key).",
          "3. Backend (`ChatService`) <strong>saves message metadata to Neon via Prisma</strong>, including the obtained file URL/key.",
          "4. When another user opens a chat, Backend (`ChatService`) <strong>retrieves the list of messages from Neon via Prisma</strong>, including file URLs/keys.",
          "5. Frontend displays the list of messages and uses the URLs/keys to <strong>download files directly from R2</strong> (or via Backend, if authentication is required)."
        ],
        "advantagesTitle": "Advantages of this separation:",
        "advantages": [
          "<strong>DB Performance Optimization:</strong> PostgreSQL is not \"clogged\" with large binary data, which improves the speed of text-based queries (Principle 9).",
          "<strong>Cost Reduction:</strong> R2 offers very favorable rates for storing large volumes of data with no egress fees, which is <strong>pragmatic</strong> (Principle 12) and contributes to <strong>asset creation</strong> (Principle 10).",
          "<strong>Scalability:</strong> Each service scales independently according to its load type (Neon for transactions, R2 for volume/file traffic).",
          "<strong>Reliability:</strong> Separating responsibilities among services increases the overall fault tolerance of the system."
        ]
      },
      "otherIntegrations": {
        "title": "6. Other Integrations: Expanding System Functionality (Principle 2, 12)",
        "description": "These integrations add <strong>value</strong> (Principle 2) and utilize <strong>pragmatic, ready-made solutions</strong> (Principle 12).",
        "firebase": {
          "title": "6.1. Firebase (Push Notifications)",
          "purpose": "Purpose: Instant delivery of notifications about new messages, calls, and system events to mobile application users.",
          "role": "Role: <strong>Critically important component of the notification system</strong> (Principle 9) for maintaining user engagement and timely information delivery (Principle 2).",
          "configuration": "Configuration: Environment variable: `FIREBASE_CREDENTIALS_PATH` (path to the Firebase service account JSON credentials file). <strong>Store this file securely!</strong>",
          "example": "Uses `firebase-admin` library in NestJS Backend. Example usage: Sending a notification upon receiving a new message (see Optimization Guide for batching and topics)."
        },
        "stripe": {
          "title": "6.2. Stripe (Payments)",
          "purpose": "Purpose: Processing subscriptions for BrainMessenger's Premium features.",
          "role": "Role: <strong>Financial lever</strong> to support project development (Principle 10: Wealth Creation) and provide additional <strong>value</strong> (Principle 2) to premium users.",
          "configuration": "Configuration: Environment variable: `STRIPE_SECRET_KEY`.",
          "example": "Uses `stripe` library in NestJS Backend. Example usage: Creating a checkout session when attempting to subscribe. Handling webhooks to confirm successful payment."
        },
        "gmailApi": {
          "title": "6.3. Gmail API (Email Sending)",
          "purpose": "Purpose: Sending transactional emails, such as verification codes for registration and two-factor authentication (2FA), password reset notifications.",
          "role": "Role: <strong>Critically important component of the authentication and security system</strong> (Principle 9, 5).",
          "configuration": "Configuration: Requires Google Cloud service account setup and credential retrieval (see Technical Documentation, section 10.1). Environment variables for service account credentials or API keys.",
          "example": "Example usage: Calling the API to send an email with a verification code after entering email during registration or enabling 2FA (see API Specification, section 2.4)."
        }
      },
      "recommendations": {
        "title": "7. Integration Recommendations: Maintaining System Health (Principle 3, 5, 9)",
        "intro": "To ensure integrations remain <strong>reliable, secure, and effective</strong> (Principle 3, 9), follow these recommendations related to maintaining system \"health\" (Principle 5, as applied to technology):",
        "security": {
          "title": "Security:",
          "points": [
            "<strong>Never commit keys and secrets to Git.</strong> Use environment variables and secret management systems in production environments (e.g., Kubernetes Secrets, HashiCorp Vault).",
            "Regularly perform <strong>API token rotation</strong> (R2, Firebase, Gmail, Stripe) to enhance security.",
            "Apply the <strong>principle of least privilege</strong> when creating API tokens: grant them only the permissions that are strictly necessary."
          ]
        },
        "scaling": {
          "title": "Scaling:",
          "points": [
            "<strong>Monitor resource usage</strong> (Neon/R2 space, Firebase/Stripe API requests) via the respective service consoles. Be prepared to upgrade to a paid tier as load grows (Principle 8, 12).",
            "Employ <strong>optimization approaches</strong> (e.g., Firebase request batching, Neon indexing, see Optimization Guide) to defer the need for more expensive tiers."
          ]
        },
        "monitoring": {
          "title": "Monitoring and Logging:",
          "points": [
            "Configure <strong>integration error logging</strong> in NestJS (Winston, Sentry).",
            "Use <strong>monitoring systems</strong> (Prometheus/Grafana) to track metrics for external service requests (latencies, error counts) — this is part of <strong>Kaizen</strong> (Principle 9), allowing early problem detection."
          ]
        },
        "errorHandling": {
          "title": "Error Handling:",
          "points": [
            "Implement <strong>robust error handling</strong> for external services on the Backend. Log errors in detail.",
            "For critically important operations (e.g., registration, payments), provide mechanisms for <strong>retries</strong> or <strong>compensating actions</strong> (e.g., marking a payment as incomplete) in case of temporary external service failures."
          ]
        },
        "documentation": {
          "title": "Documentation:",
          "content": "Keep this documentation up-to-date, reflecting changes in used services or the addition of new integrations (Principle 1: Learning, Principle 9: System)."
        }
      }
    },
    "optimizationGuide": {
      "title": "Руководство по Оптимизации BrainMessenger (Принцип Кайдзен в Действии)",
      "subtitle": "Введение: Оптимизация как Непрерывный Процесс Улучшения",
      "introduction": {
        "title": "1. Введение: Оптимизация как Непрерывный Процесс Улучшения",
        "description": "Этот документ подробно описывает подходы, инструменты и техники, которые мы используем для оптимизации производительности BrainMessenger. Оптимизация — это не одноразовая задача, а <strong>непрерывный процесс улучшения</strong> (Принцип 1, 9: Кайдзен), который позволяет нам обеспечить <strong>высокое качество, надежность и масштабируемость</strong> (Принцип 3, 8) приложения.",
        "goalTitle": "Цель:",
        "goalContent": "Идентифицировать и устранять узкие места в производительности на всех уровнях системы (Frontend, Backend, База данных, Инфраструктура), чтобы BrainMessenger оставался <strong>быстрым, отзывчивым и эффективным</strong> (Принцип 2) даже при значительной нагрузке (цель — 1 миллион активных пользователей), поддерживая <strong>здоровье системы</strong> (Принцип 5, применительно к технике).",
        "audienceTitle": "Аудитория:",
        "audienceContent": "Backend, Frontend, Mobile, Desktop и DevOps разработчики, сфокусированные на производительности и масштабировании.",
        "principlesTitle": "Принципы, которыми руководствуется оптимизация:",
        "principles": [
          "<strong>Система и Оптимизация (Принцип 9: Кайдзен):</strong> Оптимизация является ключевым аспектом нашей системы разработки. Используется цикличный подход: Измерение → Анализ → Улучшение → Проверка.",
          "<strong>Качество > Количество (Принцип 3):</strong> Лучше иметь несколько критически важных оптимизаций, чем много мелких, не дающих значительного эффекта.",
          "<strong>Прагматизм и Реализм (Принцип 12):</strong> Оптимизируем то, что действительно влияет на производительность и пользовательский опыт, основываясь на реальных данных, а не на догадках.",
          "<strong>Постоянное Обучение (Принцип 1):</strong> Изучение новых техник и инструментов оптимизации, анализ результатов и уроков.",
          "<strong>Настойчивость (Принцип 13):</strong> Оптимизация может быть сложной. Требуется упорство для выявления и решения глубоких проблем производительности.",
          "<strong>Здоровье как Фундамент (Принцип 5):</strong> Оптимизация системы (например, снижение потребления памяти/CPU) напрямую влияет на \"здоровье\" серверов и устройств пользователей.",
          "<strong>Внешняя Экспертиза (Принцип 14):</strong> Использование стандартных инструментов (Prometheus, Grafana, V8 Profiler), изучение опыта других команд (Google, Next.js и т.д.)."
        ]
      },
      "generalPrinciple": {
        "title": "2. Общий Принцип Оптимизации (Цикл Кайдзен)",
        "intro": "Наш подход к оптимизации следует <strong>циклу Кайдзен (Принцип 9)</strong>:",
        "step1": {
          "title": "1. Измерение (Measure):",
          "content": "Соберите данные о производительности. Используйте инструменты мониторинга (Prometheus, Sentry), профилирования (V8 Profiler), анализа бандлов (Webpack Bundle Analyzer, `@next/bundle-analyzer`)."
        },
        "step2": {
          "title": "2. Анализ (Analyze):",
          "content": "Определите <strong>узкие места (bottlenecks)</strong> на основе собранных данных. Где система тратит больше всего времени или ресурсов?"
        },
        "step3": {
          "title": "3. Улучшение (Improve):",
          "content": "Примените конкретные техники оптимизации, описанные в этом руководстве, для устранения выявленных узких мест."
        },
        "step4": {
          "title": "4. Проверка (Verify):",
          "content": "Снова измерьте производительность после внесенных изменений. Убедитесь, что оптимизация дала ожидаемый эффект и не вызвала регрессий (не ухудшила другие аспекты)."
        },
        "step5": {
          "title": "5. Повторение:",
          "content": "Производительность может меняться с ростом нагрузки и функционала. Повторяйте цикл Кайдзен непрерывно."
        }
      },
      "imageProcessing": {
        "title": "3. Оптимизация Обработки Изображений: Эффективность и Скорость (Принцип 9, 2)",
        "intro": "Обработка изображений может быть ресурсоемкой. <strong>Оптимизация этого процесса напрямую влияет на скорость загрузки контента и отзывчивость приложения</strong> (Принцип 2: Ценность).",
        "libraryTitle": "Библиотека:",
        "libraryContent": "`sharp` (на базе `libvips`). Выбран как <strong>прагматичное</strong> (Принцип 12) и <strong>высокопроизводительное</strong> (Принцип 9) решение для Node.js.",
        "applicationAreasTitle": "Области применения:",
        "applicationAreasContent": "Изменение размера, сжатие, конвертация формата для аватаров, изображений в чатах.",
        "keyTechniqueTitle": "Ключевая техника:",
        "keyTechniqueContent": "<strong>Асинхронная обработка</strong> в фоновом режиме через Kafka.",
        "implementationStepsTitle": "Шаги по внедрению (Backend):",
        "step1": {
          "title": "1. Установите `sharp`:",
          "content": "Убедитесь, что `libvips` установлен в вашей операционной системе или Docker-образе.",
          "code": "```bash\\nnpm install sharp\\n```"
        },
        "step2": {
          "title": "2. Создайте сервис обработки изображений:",
          "content": "Инкапсулируйте логику в отдельном сервисе (часть <strong>системы</strong> - Принцип 9).",
          "code": "```typescript\\n// backend/src/image-processing/image-processing.service.ts\\nimport { Injectable } from '@nestjs/common';\\nimport sharp from 'sharp';\\n\\n@Injectable()\\nexport class ImageProcessingService {\\n  // Метод для изменения размера, сжатия и конвертации в WebP\\n  async processImage(buffer: Buffer, width: number, height?: number): Promise<Buffer> {\\n    // resize({ width, height, withoutEnlargement: true }) - избегаем увеличения, если исходник меньше\\n    // webp({ quality: 80 }) - сжатие в формат WebP (хорошее сжатие при сохранении качества)\\n    // withMetadata({ orientation: true }) - сохраняем ориентацию из EXIF, остальное удаляем (экономия размера - Принцип 9)\\n    return sharp(buffer)\\n      .resize(width, height, { withoutEnlargement: true })\\n      .webp({ quality: 80 })\\n      .withMetadata({ orientation: true })\\n      .toBuffer();\\n  }\\n\\n  // Метод для простого изменения размера\\n  async resizeImage(buffer: Buffer, width: number, height?: number): Promise<Buffer> {\\n       return sharp(buffer)\\n           .resize(width, height, { withoutEnlargement: true })\\n           .toBuffer();\\n  }\\n\\n   // Метод для конвертации в определенный формат\\n   async convertToFormat(buffer: Buffer, format: keyof sharp.Format): Promise<Buffer> {\\n       return sharp(buffer).toFormat(format).toBuffer();\\n   }\\n}\\n```"
        },
        "step3": {
          "title": "3. Интеграция с загрузкой файлов (Backend Controller/Service):",
          "content": "",
          "code": "```typescript\\n// backend/src/upload/upload.controller.ts (пример обработки загрузки аватара)\\nimport { Controller, Post, UploadedFile, UseInterceptors, Body, Inject } from '@nestjs/common';\\nimport { FileInterceptor } from '@nestjs/platform-express';\\nimport { ImageProcessingService } from '../image-processing/image-processing.service';\\nimport { StorageService } from '../storage/storage.service';\\nimport { UserService } from '../user/user.service';\\n\\n@Controller('upload')\\nexport class UploadController {\\n  constructor(\\n    private imageProcessingService: ImageProcessingService,\\n    private storageService: StorageService,\\n    private userService: UserService,\\n    // ... инъекция Kafka продюсера для асинхронной обработки\\n  ) {}\\n\\n  @Post('avatar')\\n  @UseInterceptors(FileInterceptor('file')) // 'file' - имя поля формы\\n  async uploadAvatar(@UploadedFile() file: Express.Multer.File, @Body('userId') userId: string) {\\n    // Оптимизация: Обработка изображения перед загрузкой в R2\\n    const processedImageBuffer = await this.imageProcessingService.processImage(file.buffer, 300, 300); // Изменить размер и сжать\\n    const fileName = `avatars/${userId}-${Date.now()}.webp`; // Уникальное имя файла в папке avatars\\n    const mimeType = 'image/webp'; // Соответствует формату WebP\\n\\n    // Загрузка обработанного файла в Cloudflare R2\\n    const avatarUrl = await this.storageService.uploadFile(processedImageBuffer, fileName, mimeType);\\n\\n    // Обновление ссылки на аватар в профиле пользователя в Neon\\n    await this.userService.updateUserAvatar(userId, avatarUrl);\\n\\n    // Возвращаем URL аватара клиенту\\n    return { avatarUrl };\\n  }\\n\\n  @Post('chat-image')\\n  @UseInterceptors(FileInterceptor('file'))\\n  async uploadChatImage(@UploadedFile() file: Express.Multer.File, @Body('chatId') chatId: string, @Body('userId') userId: string) {\\n      // Отправка задачи на обработку изображения в Kafka для асинхронной обработки (Принцип 9)\\n      const taskPayload = { fileBuffer: file.buffer.toString('base64'), fileName: file.originalname, mimeType: file.mimetype, chatId, userId };\\n      // Предполагается, что у вас есть Kafka продюсер сервис\\n      // await this.kafkaProducerService.sendMessage('image-processing-topic', JSON.stringify(taskPayload));\\n\\n      // Немедленный ответ клиенту, что файл принят в обработку\\n      return { status: 'processing', originalFileName: file.originalname };\\n\\n      // ИЛИ, если синхронная обработка приемлема для небольших файлов:\\n      /*\\n      const processedImageBuffer = await this.imageProcessingService.processImage(file.buffer, 800); // Изменить размер\\n      const fileName = `chat-images/${chatId}-${Date.now()}.webp`;\\n      const mimeType = 'image/webp';\\n      const imageUrl = await this.storageService.uploadFile(processedImageBuffer, fileName, mimeType);\\n\\n      // Создание сообщения типа 'image' в чате\\n      // await this.chatService.sendImageMessage(chatId, userId, imageUrl);\\n\\n      return { imageUrl };\\n      */\\n  }\\n}\\n```"
        },
        "step4": {
          "title": "4. Асинхронность через Kafka (для тяжелых задач):",
          "content": "Для обработки изображений в чатах (которые могут быть большими) используйте <strong>Kafka</strong> (см. раздел 8) для <strong>асинхронной обработки</strong>. Backend быстро принимает файл от клиента и ставит задачу в очередь Kafka. Отдельный воркер (consumer Kafka) забирает задачу, обрабатывает изображение с помощью `sharp`, загружает в R2 и только после этого создает сообщение в чате через API. Это <strong>снижает время ответа API</strong> (Принцип 9) и улучшает пользовательский опыт."
        }
      },
      "dbOptimization": {
        "title": "4. Оптимизация Базы Данных (Neon/PostgreSQL): Ускорение Доступа к Данным (Принцип 9, 8)",
        "intro": "База данных часто становится узким местом. Оптимизация запросов и структуры БД критически важна для <strong>долгосрочной производительности</strong> (Принцип 8) и <strong>эффективности системы</strong> (Принцип 9).",
        "platformTitle": "Платформа:",
        "platformContent": "Neon (управляемый PostgreSQL).",
        "toolTitle": "Инструмент:",
        "toolContent": "Prisma ORM.",
        "analysisToolTitle": "Инструмент анализа:",
        "analysisToolContent": "`EXPLAIN ANALYZE` в SQL-клиенте Neon или `prisma.queryRaw` с `EXPLAIN ANALYZE`.",
        "monitoringToolTitle": "Инструмент мониторинга:",
        "monitoringToolContent": "Prometheus + `postgres_exporter` (см. раздел 14).",
        "indexing": {
          "title": "4.1. Индексация: Ускорение Поиска и Фильтрации",
          "intro": "Индексы позволяют базе данных быстрее находить нужные строки.",
          "whenTitle": "Когда использовать:",
          "whenContent": "На полях, которые часто используются в `WHERE`, `JOIN`, `ORDER BY`.",
          "applicationAreasTitle": "Области применения в BrainMessenger:",
          "applicationAreasContent": "`userId`, `chatId`, `createdAt` (в таблице `Message`), `email` (в таблице `User`), поля для поиска.",
          "prismaTitle": "Реализация (Prisma):",
          "prismaContent": "Добавляйте `@index` в `schema.prisma`.",
          "prismaCode": "```prisma\\n// schema.prisma\\nmodel Message {\\n  id        String   @id @default(cuid())\\n  content   String\\n  createdAt DateTime @default(now()) @map(\\\"created_at\\\") // Пример @map для snake_case в БД\\n  chatId    String @map(\\\"chat_id\\\")\\n  userId    String @map(\\\"user_id\\\")\\n  chat      Chat     @relation(fields: [chatId], references: [id])\\n  user      User     @relation(fields: [userId], references: [id])\\n\\n  // Комбинированный индекс для быстрых запросов сообщений в чате по времени\\n  @@index([chatId, createdAt])\\n  // Индекс для быстрого получения сообщений по пользователю (например, для статистики)\\n  @@index([userId])\\n  // Индекс для поиска по содержимому (если требуется полнотекстовый поиск - рассмотреть tsearch)\\n  // @@index([content]) // Только для простых фильтров LIKE\\n}\\n\\nmodel User {\\n    id    String @id @default(cuid())\\n    email String @unique // Уникальный индекс для быстрого поиска по email (логин, регистрация)\\n    name  String\\n    // ... другие поля\\n}\\n\\nmodel Chat {\\n   id          String @id @default(cuid())\\n   lastMessageAt DateTime? @map(\\\"last_message_at\\\") // Для сортировки чатов (нужен индекс)\\n   // ... другие поля\\n   @@index([lastMessageAt]) // Индекс для сортировки списка чатов\\n}\\n```",
          "applicationTitle": "Применение:",
          "applicationContent": "После изменения `schema.prisma` выполните миграцию (`npx prisma migrate dev`)."
        },
        "queryOptimization": {
          "title": "4.2. Оптимизация Запросов (Prisma): Пишем Эффективный Код Взаимодействия с БД",
          "intro": "",
          "selectFieldsTitle": "Выбирайте только нужные поля (`select`):",
          "selectFieldsContent": "Не запрашивайте `SELECT *`. Указывайте поля, которые вам действительно нужны. Это уменьшает объем данных, передаваемых по сети и обрабатываемых БД.",
          "selectFieldsCode": "```typescript\\n// Плохо\\nconst user = await prisma.user.findUnique({ where: { id: userId } }); // Выберет все поля\\n\\n// Хорошо (если нужен только email и name)\\nconst user = await prisma.user.findUnique({\\n  where: { id: userId },\\n  select: {\\n    email: true,\\n    name: true,\\n  },\\n});\\n```",
          "nPlus1Title": "Избегайте N+1 проблем (`include`):",
          "nPlus1Content": "Если вам нужны связанные данные (например, автор сообщения при получении списка сообщений), используйте `include` или `select` со вложенными полями вместо выполнения отдельного запроса для каждого элемента.",
          "nPlus1Code": "```typescript\\n// Плохо (N+1 проблема - отдельный запрос за каждым пользователем)\\nconst messages = await prisma.message.findMany({ where: { chatId: chatId } });\\nfor (const message of messages) {\\n  const sender = await prisma.user.findUnique({ where: { id: message.userId } });\\n  // ... использовать sender\\n}\\n\\n// Хорошо (используем include для получения автора сообщения одним запросом)\\nconst messagesWithSender = await prisma.message.findMany({\\n  where: { chatId: chatId },\\n  include: {\\n    user: { // Включаем данные пользователя, связанного с сообщением через поле 'user' в модели Message\\n      select: { id: true, name: true, avatarUrl: true } // Выбираем только нужные поля пользователя\\n    },\\n  },\\n  orderBy: { createdAt: 'asc' }, // Пример: сообщения в хронологическом порядке\\n  take: 50, // Пример: пагинация\\n});\\n```",
          "paginationTitle": "Пагинация (`skip`, `take`, `cursor`):",
          "paginationContent": "Для получения больших списков (сообщения в чате, список чатов) используйте пагинацию, чтобы не загружать все данные сразу. `cursor`-пагинация предпочтительнее для бесконечной прокрутки.",
          "paginationCode": "```typescript\\n// Пример пагинации с take и skip\\nconst messages = await prisma.message.findMany({\\n    where: { chatId: chatId },\\n    orderBy: { createdAt: 'asc' },\\n    skip: (page - 1) * pageSize, // Пропустить N сообщений\\n    take: pageSize, // Взять M сообщений\\n});\\n\\n// Пример Cursor-based пагинации (для \\\"показать еще\\\")\\nconst messages = await prisma.message.findMany({\\n    where: { chatId: chatId },\\n    orderBy: { createdAt: 'asc' },\\n    cursor: { id: lastMessageId }, // Начать после последнего сообщения\\n    skip: 1, // Пропустить само последнее сообщение\\n    take: pageSize,\\n});\\n```"
        },
        "prismaAccelerate": {
          "title": "4.3. Prisma Accelerate: Глобальный Кэш и Пул Соединений",
          "intro": "Prisma Accelerate предоставляет глобальную сеть серверов (Edge locations), которые кэшируют результаты запросов и управляют пулом соединений к вашей БД Neon.",
          "whenTitle": "Когда использовать:",
          "whenContent": "Для снижения задержки запросов (latency) для пользователей по всему миру и оптимизации использования пула соединений БД.",
          "implementationTitle": "Реализация:",
          "implementationContent": "Настраивается в консоли Prisma. Ваша `DATABASE_URL` заменяется на URL Prisma Accelerate."
        },
        "materializedViews": {
          "title": "4.4. Материализованные Представления: Кэширование Сложных Агрегаций",
          "intro": "Материализованные представления — это по сути кэшированные результаты сложных запросов или агрегаций (например, количество сообщений в чате, последние активные пользователи в группе). Они хранятся на диске и могут быть быстро прочитаны.",
          "whenTitle": "Когда использовать:",
          "whenContent": "Для запросов, которые выполняются часто, но требуют сложных вычислений (JOINs, GROUP BY, агрегатные функции) над большими таблицами, и данные в которых не должны быть абсолютно актуальными каждую миллисекунду.",
          "applicationAreasTitle": "Области применения:",
          "applicationAreasContent": "Статистика чатов (общее количество сообщений, участников), списки \"топ\" пользователей (например, по количеству отправленных сообщений).",
          "implementationTitle": "Реализация (SQL, через Prisma `queryRaw` или SQL-клиент Neon):",
          "implementationContent": "```sql\\n-- Создать материализованное представление для подсчета сообщений в каждом чате\\nCREATE MATERIALIZED VIEW chat_message_counts AS\\nSELECT\\n    \\\"chatId\\\",\\n    COUNT(*) as \\\"messageCount\\\"\\nFROM \\\"Message\\\"\\nGROUP BY \\\"chatId\\\";\\n\\n-- Создать индекс на представлении для быстрого поиска по chatId (необязательно, но часто полезно)\\nCREATE INDEX idx_chat_message_counts_chat_id ON chat_message_counts (\\\"chatId\\\");\\n```",
          "updateTitle": "Обновление:",
          "updateContent": "Материализованные представления нужно <strong>периодически обновлять</strong>, чтобы отразить изменения в базовых таблицах. Это делается командой `REFRESH MATERIALIZED VIEW <view_name>;`. Частота обновления зависит от того, насколько актуальными должны быть данные (например, раз в час, раз в день).",
          "updateCode": "```sql\\n-- Обновить представление (может блокировать чтение во время выполнения)\\nREFRESH MATERIALIZED VIEW chat_message_counts;\\n\\n-- Обновить представление без блокировки чтения (для больших представлений)\\nREFRESH MATERIALIZED VIEW CONCURRENTLY chat_message_counts; -- Требует уникального индекса\\n```",
          "usageTitle": "Использование в Prisma:",
          "usageContent": "Запрашивайте как обычную таблицу.",
          "usageCode": "```typescript\\nconst chatStats = await prisma.chatMessageCounts.findMany({\\n  select: { chatId: true, messageCount: true },\\n  where: { chatId: 'some-chat-id' },\\n});\\n```"
        },
        "partitioning": {
          "title": "4.5. Партиционирование Таблиц: Разделение Больших Объемов Данных",
          "intro": "Партиционирование физически разделяет очень большие таблицы (например, `Message`) на более мелкие части (партиции) на основе значения в определенном столбце (например, `createdAt` или `chatId`).",
          "whenTitle": "Когда использовать:",
          "whenContent": "Когда таблица становится настолько большой (миллиарды строк), что индексы уже не справляются, и запросы начинают замедляться из-за необходимости сканировать слишком много данных.",
          "applicationAreasTitle": "Области применения:",
          "applicationAreasContent": "Таблица `Message` — идеальный кандидат для партиционирования по времени создания (`createdAt`) или по ID чата (`chatId`).",
          "implementationTitle": "Реализация (SQL, через Prisma `queryRaw` или SQL-клиент Neon):",
          "implementationContent": "PostgreSQL поддерживает нативное партиционирование.",
          "implementationCode": "```sql\\n-- Создать главную партиционированную таблицу по диапазону дат\\nCREATE TABLE messages (\\n    id TEXT NOT NULL,\\n    content TEXT NOT NULL,\\n    created_at TIMESTAMP WITH TIME ZONE NOT NULL,\\n    chat_id TEXT NOT NULL,\\n    user_id TEXT NOT NULL,\\n    PRIMARY KEY (id, created_at) -- Ключ партиционирования должен быть частью первичного ключа\\n) PARTITION BY RANGE (created_at); -- Партиционируем по диапазону поля created_at\\n\\n-- Создать партиции (например, по месяцам)\\nCREATE TABLE messages_2025_03 PARTITION OF messages\\n    FOR VALUES FROM ('2025-03-01 00:00:00+00') TO ('2025-04-01 00:00:00+00');\\n\\nCREATE TABLE messages_2025_04 PARTITION OF messages\\n    FOR VALUES FROM ('2025-04-01 00:00:00+00') TO ('2025-05-01 00:00:00+00');\\n\\n-- ... создавать новые партиции по мере необходимости (автоматически или вручную)\\n\\n-- Создать индексы для партиционированной таблицы (применяются ко всем партициям)\\nCREATE INDEX ON messages (\\\"chat_id\\\", \\\"created_at\\\");\\nCREATE INDEX ON messages (\\\"user_id\\\");\\n```",
          "advantagesTitle": "Преимущества:",
          "advantagesContent": "Запросы, включающие фильтр по ключу партиционирования (например, `WHERE created_at BETWEEN ...`), будут сканировать только нужные партиции, что значительно ускоряет их выполнение. Управление старыми данными (удаление) становится проще (можно просто удалить старые партиции).",
          "prismaRelationTitle": "Связь с Prisma:",
          "prismaRelationContent": "Prisma работает с партиционированной таблицей как с обычной."
        }
      },
      "graphqlOptimization": {
        "title": "5. Оптимизация GraphQL API (NestJS + Prisma): Эффективная Передача Данных",
        "intro": "GraphQL сам по себе является инструментом <strong>оптимизации</strong> (Принцип 9) по сравнению с REST (клиент запрашивает только нужные данные). Однако и его можно оптимизировать.",
        "analysisToolTitle": "Инструмент анализа:",
        "analysisToolContent": "`graphql-query-complexity` для защиты от сложных запросов.",
        "dataloader": {
          "title": "5.1. DataLoader: Решение Проблемы N+1 в GraphQL",
          "intro": "DataLoader — это утилита, которая помогает решить проблему N+1 запросов при работе с графами данных. Если у вас есть список объектов, и для каждого объекта нужно подтянуть связанный с ним объект (например, список сообщений и для каждого сообщения его автора), DataLoader соберет все ID связанных объектов и сделает один пакетный запрос к БД.",
          "whenTitle": "Когда использовать:",
          "whenContent": "В резолверах GraphQL, когда вам нужно получить связанные объекты для списка родительских объектов.",
          "applicationAreasTitle": "Области применения:",
          "applicationAreasContent": "Получение данных автора для каждого сообщения в чате, получение списка участников для каждого чата в списке чатов пользователя.",
          "implementationTitle": "Реализация:",
          "implementationContent": "Создайте отдельные DataLoader для каждого типа объекта, который нужно подтягивать. Интегрируйте их в контекст GraphQL запроса.",
          "implementationCode": "```typescript\\n// backend/src/graphql/loaders/user.loader.ts\\nimport { Injectable, Scope } from '@nestjs/common';\\nimport DataLoader from 'dataloader';\\nimport { PrismaService } from 'nestjs-prisma';\\nimport { User } from '@prisma/client'; // Импорт модели Prisma\\n\\n// Scope.REQUEST - важно, чтобы DataLoader был уникален для каждого запроса GraphQL\\n@Injectable({ scope: Scope.REQUEST })\\nexport class UserLoader {\\n  private loader: DataLoader<string, User>;\\n\\n  constructor(private prisma: PrismaService) {\\n    // Создаем новый DataLoader. Функция batchLoadFn принимает массив ключей (user IDs)\\n    this.loader = new DataLoader<string, User>(\\n      async (ids: readonly string[]) => {\\n        // Выполняем ОДИН запрос к БД, чтобы получить ВСЕх пользователей по их ID\\n        const users = await this.prisma.user.findMany({\\n          where: {\\n            id: { in: Array.from(ids) }, // Array.from(ids) для совместимости с Prisma\\n          },\\n        });\\n\\n        // Важно: Вернуть массив результатов, упорядоченный по исходному массиву ids\\n        const userMap = new Map(users.map(user => [user.id, user]));\\n        return ids.map(id => userMap.get(id)); // Возвращаем пользователей в том же порядке, что и запросили\\n      },\\n      { cache: true } // Включаем кэширование внутри запроса GraphQL\\n    );\\n  }\\n\\n  // Метод для загрузки одного пользователя по ID\\n  load(id: string): Promise<User> {\\n    return this.loader.load(id);\\n  }\\n\\n  // Метод для загрузки списка пользователей по ID\\n  loadMany(ids: string[]): Promise<(Error | User)[]> {\\n      return this.loader.loadMany(ids);\\n  }\\n}\\n```\\nИнтегрируйте лоадеры в контекст GraphQL (`backend/src/graphql/graphql.module.ts` или `app.module.ts`):\\n```typescript\\n// backend/src/graphql/graphql.module.ts\\nimport { Module } from '@nestjs/common';\\nimport { GraphQLModule } from '@nestjs/graphql';\\nimport { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';\\nimport { UserLoader } from './loaders/user.loader'; // Импорт лоадера\\n// ... другие импорты резолверов и модулей\\n\\n@Module({\\n  imports: [\\n    GraphQLModule.forRoot<ApolloDriverConfig>({\\n      driver: ApolloDriver,\\n      // ... другие настройки GraphQL (schema path, context, etc.)\\n      context: ({ req, connection }) => {\\n        // Создаем контекст для каждого запроса\\n        const context = { req }; // Добавляем объект запроса\\n         if (connection) {\\n           // Для WebSocket (подписки)\\n           // context.loaders = new Loaders(); // Если лоадеры создаются здесь\\n         } else {\\n           // Для HTTP запросов (queries/mutations)\\n           // Создаем лоадеры и добавляем их в контекст\\n           context.loaders = {\\n              userLoader: new UserLoader(/* зависимости */), // Нужно инжектить PrismaService\\n              // ... другие лоадеры\\n           };\\n           // Пример инъекции зависимостей в лоадер (может потребовать FactoryProvider)\\n           // context.loaders = {\\n           //     userLoader: req.loaders.userLoader, // Если используете Request-scoped провайдеры NestJS\\n           // };\\n         }\\n        return context;\\n      },\\n      // plugins: [complexityPlugin], // Плагин для анализа сложности запросов\\n    }),\\n    // ... импорт других модулей\\n  ],\\n   providers: [UserLoader], // Добавляем лоадер как провайдер (для Request scope)\\n})\\nexport class GraphqlModule {}\\n```",
          "usageTitle": "Используйте лоадеры в резолверах:",
          "usageContent": "",
          "usageCode": "```typescript\\n// backend/src/message/message.resolver.ts\\nimport { Resolver, ResolveField, Parent, Context } from '@nestjs/graphql';\\nimport { Message } from '@prisma/client'; // Импорт модели Prisma\\nimport { UserLoader } from '../graphql/loaders/user.loader'; // Импорт лоадера\\n\\n@Resolver('Message') // Указываем GraphQL тип, к которому относится резолвер\\nexport class MessageResolver {\\n  @ResolveField('user') // Определяем резолвер для поля 'user' в типе Message\\n  async resolveUser(@Parent() message: Message, @Context() context: any) {\\n    // Используем userLoader из контекста для загрузки пользователя по message.userId\\n    // DataLoader автоматически соберет все message.userId в текущем запросе и загрузит их батчем\\n    return context.loaders.userLoader.load(message.userId);\\n  }\\n}\\n```"
        },
        "queryComplexityAnalysis": {
          "title": "5.2. Анализ Сложности Запросов: Защита от \"Тяжелых\" Запросов",
          "intro": "GraphQL позволяет клиенту запрашивать данные произвольной вложенности, что может привести к очень \"тяжелым\" запросам, сильно нагружающим сервер и БД.",
          "toolTitle": "Инструмент:",
          "toolContent": "`graphql-query-complexity`.",
          "whenTitle": "Когда использовать:",
          "whenContent": "Всегда включайте защиту от сложности в продакшене.",
          "principleTitle": "Принцип работы:",
          "principleContent": "Плагин анализирует запрос до его выполнения и вычисляет его \"сложность\" (например, как сумму \"стоимости\" каждого поля). Если сложность превышает заданный порог, запрос отклоняется.",
          "implementationTitle": "Реализация:",
          "implementationContent": "Настройте плагин в NestJS GraphQLModule (см. Руководство по разработке)."
        },
        "persistedQueries": {
          "title": "5.3. Persisted Queries: Кэширование Запросов на Уровне Сети",
          "intro": "Persisted Queries позволяют клиенту отправлять на сервер не полный текст GraphQL запроса, а только его хэш. Сервер по этому хэшу находит полный запрос (если он ему знаком) и выполняет его.",
          "whyTitle": "Почему:",
          "whyContent": "Уменьшает объем данных, передаваемых по сети, что ускоряет запросы, особенно на мобильных устройствах. Улучшает эффективность кэширования на CDN.",
          "whenTitle": "Когда использовать:",
          "whenContent": "Для часто повторяющихся запросов из клиента.",
          "implementationTitle": "Реализация:",
          "implementationContent": "Требует поддержки как на стороне клиента (Apollo Client поддерживает), так и на стороне сервера (Apollo Server поддерживает). На сервере нужно хранить соответствие хэшей и запросов (например, в Redis)."
        }
      },
      "backendLogicOptimization": {
        "title": "6. Оптимизация Backend Логики (NestJS): Эффективность Кода",
        "intro": "",
        "toolsTitle": "Инструменты:",
        "toolsContent": "Профилирование Node.js (V8 Profiler), обнаружение утечек памяти (`heapdump`).",
        "whenTitle": "Когда использовать:",
        "whenContent": "Для выявления \"горячих\" участков кода, потребляющих много CPU или памяти, и диагностики проблем с памятью.",
        "processTitle": "Процесс:",
        "processContent": "Используйте инструменты профилирования для <strong>измерения</strong> (Шаг 1 Кайдзен). Анализируйте результаты (Шаг 2). Вносите изменения в код (Шаг 3). Повторите (Шаг 4).",
        "recommendationsTitle": "Рекомендации:",
        "recommendationsContent": "Избегайте синхронных операций, блокирующих основной поток Node.js. Используйте асинхронные API. Оптимизируйте циклы, работу с большими массивами/объектами."
      },
      "caching": {
        "title": "7. Кэширование (Redis): Снижение Нагрузки на БД и Ускорение (Принцип 9)",
        "intro": "Кэширование позволяет хранить часто запрашиваемые данные в быстрой памяти (Redis), чтобы не обращаться к более медленной БД (Neon) при каждом запросе. Это ключевой <strong>рычаг</strong> для повышения <strong>эффективности системы</strong> (Принцип 9).",
        "libraryTitle": "Библиотека:",
        "libraryContent": "`ioredis`, `@nestjs/cache-manager`, `cache-manager-redis-store`.",
        "patternTitle": "Pаттерн:",
        "patternContent": "Cache-Aside (чтение из кэша, если нет — чтение из БД и запись в кэш).",
        "applicationAreasTitle": "Области применения:",
        "applicationAreasContent": "Часто запрашиваемые, относительно редко изменяющиеся данные (профили пользователей, настройки приложения, результаты сложных запросов/агрегаций, материализованных представлений).",
        "implementationTitle": "Реализация:",
        "implementationContent": "Настройте Redis в NestJS и используйте его в сервисах.",
        "invalidationTitle": "Ключевой аспект:",
        "invalidationContent": "<strong>Инвалидация кэша</strong>. При изменении данных в БД, удаляйте соответствующие ключи из Redis, чтобы клиенты не получали устаревшие данные."
      },
      "asyncProcessing": {
        "title": "8. Асинхронная Обработка (Kafka): Надежность и Отзывчивость (Принцип 9, 2)",
        "intro": "Используйте <strong>Kafka</strong> для выполнения задач, которые не требуют немедленного ответа пользователю (отправка email, обработка изображений, нотификации, аналитика).",
        "libraryTitle": "Библиотека:",
        "libraryContent": "`kafkajs`.",
        "whyTitle": "Почему:",
        "whyContent": "Kafka — <strong>надежная распределенная система очередей</strong>, гарантирующая доставку сообщений и позволяющая масштабировать обработку задач независимо от основного API (воркеры-консьюмеры).",
        "applicationAreasTitle": "Области применения:",
        "applicationAreasContent": [
          "Обработка изображений/видео после загрузки.",
          "Отправка больших объемов push-уведомлений.",
          "Генерация отчетов или статистики.",
          "Архивирование старых сообщений/файлов."
        ],
        "patternTitle": "Паттерн:",
        "patternContent": "<strong>Producer-Consumer</strong>. Backend-API ставит задачи в топик Kafka (Producer). Отдельные сервисы/воркеры (Consumer) читают задачи из топика и выполняют их в фоновом режиме.",
        "partitioningTitle": "Партиционирование в Kafka:",
        "partitioningContent": "Используйте ключи сообщений (например, `userId`, `chatId`), чтобы сообщения, относящиеся к одному пользователю/чату, попадали в одну партицию. Это гарантирует порядок обработки внутри партиции, что может быть важно для некоторых задач.",
        "monitoringTitle": "Мониторинг:",
        "monitoringContent": "Используйте <strong>Kafdrop</strong> для визуального мониторинга топиков, сообщений и состояния консьюмер-групп."
      },
      "pushNotificationsOptimization": {
        "title": "9. Оптимизация Push-уведомлений (Firebase FCM): Эффективная Доставка Информации (Принцип 2)",
        "intro": "Push-уведомления — важный канал связи с пользователем (Принцип 2: Ценность). Оптимизация их доставки важна для пользовательского опыта.",
        "platformTitle": "Платформа:",
        "platformContent": "Firebase Cloud Messaging (FCM).",
        "techniquesTitle": "Техники:",
        "techniquesContent": [
          "<strong>Батчинг:</strong> Отправляйте несколько уведомлений одним вызовом API FCM (`sendMulticast`) для снижения сетевых накладных расходов.",
          "<strong>Темы (Topics):</strong> Используйте темы для массовых рассылок (например, уведомление о новом сообщении в канале), чтобы FCM управлял списком подписчиков.",
          "<strong>Data Messages:</strong> Используйте Data Messages для полного контроля над отображением уведомления на клиенте и возможности прикреплять кастомные данные."
        ]
      },
      "clientApiDbInteraction": {
        "title": "10. Оптимизация Взаимодействия Клиент-API-БД: Сокращение Пути Данных (Принцип 9)",
        "intro": "",
        "clientLevelTitle": "На Уровне Клиента:",
        "clientLevelContent": "Используйте библиотеки для управления состоянием и кэширования данных, полученных по сети (`@apollo/client`, `react-query`/`@tanstack/react-query`). Это позволяет избежать повторных запросов за одними и теми же данными и быстро показывать кэшированные данные.",
        "networkLevelTitle": "На Уровне Сети:",
        "networkLevelContent": "Включите современные протоколы (HTTP/2, HTTP/3) и сжатие (Gzip/Brotli) на вашем API Gateway или Backend сервере для уменьшения объема передаваемых данных и снижения задержки.",
        "backendLevelTitle": "На Уровне Backend:",
        "backendLevelContent": "Оптимизируйте взаимодействие с БД (раздел 4) и внешними сервисами (раздел 7)."
      },
      "authenticationOptimization": {
        "title": "11. Оптимизация Аутентификации: Быстрота и Безопасность",
        "intro": "",
        "statelessJwtTitle": "Stateless (JWT):",
        "statelessJwtContent": "Использование JWT снижает нагрузку на сервер, так как ему не нужно хранить состояние сессий пользователей.",
        "rateLimitingTitle": "Rate Limiting (`@nestjs/throttler`):",
        "rateLimitingContent": "Защита эндпоинтов аутентификации от Brute Force атак, что также снижает нагрузку.",
        "secureHeadersTitle": "Безопасные Заголовки (`helmet`):",
        "secureHeadersContent": "Добавление HTTP-заголовков для защиты от XSS, CSRF и других атак."
      },
      "chatWebSocketOptimization": {
        "title": "12. Оптимизация Чатов (WebSocket): Низкая Задержка и Масштабирование",
        "intro": "WebSocket используется для обмена сообщениями в реальном времени. <strong>Оптимизация WebSocket-соединений критична для отзывчивости чатов</strong> (Принцип 2).",
        "libraryTitle": "Библиотека:",
        "libraryContent": "NestJS Gateways (`@nestjs/websockets`), Socket.IO (если нужна кросс-браузерная совместимость и fallback).",
        "techniquesTitle": "Техники:",
        "techniquesContent": [
          "<strong>Бинарные Форматы:</strong> Передача сообщений в бинарном формате (например, MessagePack) вместо текстового JSON может уменьшить объем данных.",
          "<strong>Батчинг Сообщений:</strong> Буферизируйте сообщения на клиенте и сервере и отправляйте их пачками (например, каждые 50 мс), а не по одному. Снижает количество пакетов.",
          "<strong>Управление Присутствием:</strong> Используйте Redis для быстрого отслеживания статуса онлайн/офлайн пользователей. Heartbeats (пинг-понг) для поддержания соединения и обнаружения отключений.",
          "<strong>Вертикальное/Горизонтальное Масштабирование:</strong> NestJS Gateways могут работать в кластерном режиме. Используйте Redis или другой Pub/Sub механизм (например, Kafka) для обмена сообщениями между инстансами Backend, чтобы сообщения доставлялись всем подписчикам, независимо от того, к какому инстансу Backend они подключены."
        ]
      },
      "animationsOptimization": {
        "title": "13. Оптимизация Анимаций: Плавность и Производительность (Принцип 3, 5)",
        "intro": "Производительные анимации делают интерфейс <strong>качественным</strong> (Принцип 3) и снижают нагрузку на устройство (Принцип 5: Здоровье).",
        "mobileDesktopTitle": "Mobile-Desktop (React Native):",
        "mobileDesktopContent": "Используйте `react-native-reanimated` для анимаций, которые выполняются на нативном потоке, не блокируя поток JavaScript.",
        "webTitle": "Web (Next.js):",
        "webContent": "Используйте `framer-motion` для декларативного создания плавных анимаций.",
        "docDesignTitle": "DocDesign:",
        "docDesignContent": "В DocDesign описаны принципы и параметры анимаций, включая возможность их отключения пользователем (Принцип 12: Прагматизм)."
      },
      "monitoring": {
        "title": "14. Мониторинг с Prometheus и Grafana: Измерение как Основа Кайдзен (Принцип 9)",
        "intro": "Система мониторинга — это ваши <strong>глаза</strong> и <strong>измерительные инструменты</strong> (Шаг 1 Кайдзен).",
        "toolsTitle": "Инструменты:",
        "toolsContent": "Prometheus (сбор метрик), Grafana (визуализация), Alertmanager (уведомления об аномалиях).",
        "whenTitle": "Когда использовать:",
        "whenContent": "Всегда. Настройте мониторинг на всех уровнях: Backend (задержки API, ошибки), БД (время запросов, нагрузка), Redis (попадания в кэш, использование памяти), Kafka (количество сообщений в топиках, лаг консьюмеров), Инфраструктура (CPU, RAM, сеть).",
        "implementationTitle": "Реализация:",
        "implementationContent": "См. подробные шаги по настройке в Руководстве по разработке (раздел 14).",
        "principleTitle": "Принцип:",
        "principleContent": "Используйте метрики для <strong>выявления узких мест</strong> (Шаг 2 Кайдзен) и оценки <strong>эффективности</strong> (Принцип 9) ваших оптимизаций. Настройте <strong>алерты</strong> для проактивного обнаружения проблем."
      },
      "ciCdOptimization": {
        "title": "15. Оптимизация CI/CD: Ускорение Цикла Разработки (Принцип 9)",
        "intro": "Эффективный CI/CD пайплайн ускоряет доставку кода, что является частью <strong>оптимизации всего процесса разработки</strong> (Принцип 9).",
        "toolsTitle": "Инструменты:",
        "toolsContent": "Turborepo (кэширование, параллелизация), GitHub Actions (автоматизация).",
        "techniquesTitle": "Техники:",
        "techniquesContent": [
          "<strong>Кэширование с Turborepo:</strong> Кэшируйте результаты сборки и тестов между запусками в CI и локально.",
          "<strong>Параллельное выполнение:</strong> Запускайте задачи (lint, build, test) для разных пакетов или частей тестов параллельно.",
          "<strong>Оптимизация Docker-образов:</strong> Используйте многоступенчатую сборку и `.dockerignore` для уменьшения размера образов и ускорения сборки/деплоя."
        ]
      },
      "frontendOptimization": {
        "title": "16. Оптимизация Фронтенда: Быстрота и Отзывчивость для Пользователя (Принцип 2, 3)",
        "intro": "Фронтенд должен быть <strong>быстрым и отзывчивым</strong>, чтобы пользователь ощутил <strong>ценность</strong> (Принцип 2) продукта.",
        "webTechniquesTitle": "Техники (Web - Next.js):",
        "webTechniquesContent": [
          "<strong>Code Splitting / Dynamic Imports:</strong> Загружайте код только тогда, когда он нужен (`next/dynamic`).",
          "<strong>SSR/SSG:</strong> Используйте серверный рендеринг или генерацию статики для ускорения первой отрисовки и SEO (`getStaticProps`, `getServerSideProps`).",
          "<strong>Оптимизация Изображений:</strong> Используйте `next/image` или `<picture>` и современные форматы (WebP).",
          "<strong>Анализ Бандла:</strong> Используйте `@next/bundle-analyzer` для выявления самых тяжелых модулей."
        ],
        "reactNativeTechniquesTitle": "Техники (React Native):",
        "reactNativeTechniquesContent": [
          "<strong>Ленивая Загрузка:</strong> Используйте `React.lazy` и `Suspense` для экранов и компонентов, которые не нужны при старте.",
          "<strong>Производительные Списки:</strong> Используйте `FlatList` или `SectionList` с правильной настройкой (`getItemLayout`, `windowSize`) для больших списков сообщений или чатов.",
          "<strong>Оптимизация Изображений:</strong> Используйте `react-native-fast-image`.",
          "<strong>Профилирование:</strong> Используйте Performance Monitor в Debugger Menu React Native для выявления узких мест UI."
        ],
        "generalTechniquesTitle": "Общие техники:",
        "generalTechniquesContent": [
          "Удаление неиспользуемого кода (Tree Shaking), замена тяжелых библиотек на легкие аналоги (например, `dayjs` вместо `moment`), сжатие бандлов (Gzip/Brotli)."
        ]
      },
      "dbScaling": {
        "title": "17. Масштабирование Базы Данных (Репликация и Шардинг): Подготовка к Росту (Принцип 8)",
        "intro": "Эти техники становятся актуальными при значительном росте объема данных и нагрузки. Они являются частью <strong>долгосрочной стратегии масштабирования</strong> (Принцип 8).",
        "replicationTitle": "Репликация (Master-Slave):",
        "replicationContent": "Создание копий БД только для чтения (read replicas). Позволяет распределить нагрузку на чтение.",
        "shardingTitle": "Шардинг:",
        "shardingContent": "Разделение данных большой таблицы на части (шарды) по определенному ключу (`chatId`, `userId`), распределяя их по разным серверам. Позволяет масштабировать как чтение, так и запись. Реализуется логически (в приложении) или с помощью расширений (Citus для PostgreSQL).",
        "whenToApplyTitle": "Когда применять:",
        "whenToApplyContent": "Основываясь на <strong>измерениях</strong> нагрузки и производительности БД (Принцип 9), а не заранее."
      },
      "notes": {
        "title": "18. Примечания: Непрерывный Кайдзен в Оптимизации",
        "prioritizationTitle": "Приоритезация:",
        "prioritizationContent": "Начинайте оптимизацию с тех мест, которые приносят наибольший эффект на текущем этапе проекта (Принцип 12). Для MVP это может быть скорость загрузки Frontend, производительность основных API-запросов.",
        "automationTitle": "Автоматизация:",
        "automationContent": "Максимально автоматизируйте процессы измерения и проверки оптимизаций (CI/CD, алерты в мониторинге) — это часть <strong>Системы</strong> (Принцип 9).",
        "documentationNotesTitle": "Документирование:",
        "documentationNotesContent": "Фиксируйте проведенные оптимизации, их эффект и уроки в этой документации или в задачах/коммитах (Принцип 1: Обучение, Принцип 9: Кайдзен).",
        "cultureTitle": "Культура:",
        "cultureContent": "Создайте культуру, где каждый разработчик несет ответственность за производительность своего кода и активно участвует в поиске и устранении узких мест (Принцип 6)."
      }
    },
    "apiSpec": {
      "title": "BrainMessenger API Specification (System Interface)",
      "subtitle": "System Interface",
      "generalInfo": {
        "title": "1. General Information: API as a System Interaction Point",
        "description": "This document describes the BrainMessenger GraphQL API — the <strong>main interface</strong> (Principle 9) through which client applications (Web, Mobile, Desktop) interact with the server-side of the system and access data and functionality. GraphQL was chosen for its <strong>efficiency and flexibility</strong> (Principle 9, 2), allowing clients to request only the data they need.",
        "projectNameTitle": "Project Name:",
        "projectNameContent": "BrainMessenger",
        "apiPurposeTitle": "Purpose:",
        "apiPurposeContent": "To provide a clear and complete description of available queries (Queries) and mutations (Mutations), their input and output data, as well as authentication rules and error formats. This ensures <strong>systematicity</strong> (Principle 9) of interaction between Frontend and Backend and improves development <strong>quality</strong> (Principle 3).",
        "baseUrlTitle": "Base URL:",
        "baseUrlContent": "`https://api.brainmessenger.com/graphql` (API Gateway address that redirects requests to the Backend Service).",
        "requestFormatTitle": "Request Format:",
        "requestFormatContent": "GraphQL requests (POST requests with `Content-Type: application/json` and a GraphQL-formatted body).",
        "authenticationTitle": "Authentication:",
        "authenticationContent": "Most methods require passing a JWT token in the `Authorization: Bearer <token>` header. The token is obtained after successful login. This is part of our <strong>security system</strong> (Principle 3, 5).",
        "relatedDocsTitle": "Related Documents:",
        "relatedDocsContent": [
          "DocTech.md: Overall system architecture, including Backend and API Gateway.",
          "DocDevIn.md: Backend implementation details in NestJS and GraphQL.",
          "DocInt.md: Description of integrations that Backend uses (Neon, R2, Firebase, etc.).",
          "DocOptimizationIn.md: Approaches to API performance optimization."
        ]
      },
      "graphqlSchema": {
        "title": "2. GraphQL Schema: Structure of Available Data and Operations",
        "description": "The full GraphQL schema is available at the API address via introspection tools (e.g., GraphQL Playground, Apollo Studio). Below are the main types and operations.",
        "dataTypes": {
          "title": "2.1. Data Types (Schemas): Description of Information Structure",
          "user": {
            "title": "User:",
            "code": "type User {\n  id: ID!\n  email: String!\n  name: String!\n  avatarUrl: String # User avatar URL (stored in R2)\n  createdAt: DateTime!\n  updatedAt: DateTime!\n  # ... other fields (e.g., online/offline status)\n}"
          },
          "chat": {
            "title": "Chat:",
            "code": "type Chat {\n  id: ID!\n  name: String! # Chat name (for groups/channels)\n  type: String! # Chat type (\"personal\", \"group\", \"channel\")\n  users: [User!] # List of chat participants\n  messages(pagination: PaginationInput): [Message!] # Messages in chat (with pagination)\n  lastMessageAt: DateTime # Time of last message (for sorting chat list)\n  createdAt: DateTime!\n  updatedAt: DateTime!\n  # ... other fields (e.g., group/channel photo, description)\n}"
          },
          "message": {
            "title": "Message:",
            "code": "type Message {\n  id: ID!\n  content: String! # Message text (for text messages)\n  fileUrl: String # File URL if message is a file (stored in R2)\n  fileMetadata: JSON # File metadata (type, size, name) (stored in Neon/R2)\n  sender: User! # Message sender\n  chat: Chat! # Chat to which the message belongs\n  createdAt: DateTime! # Message sending time\n  updatedAt: DateTime!\n  # ... other fields (e.g., read status, reactions)\n}"
          },
          "paginationInput": {
            "title": "PaginationInput:",
            "code": "input PaginationInput {\n  take: Int # Maximum number of elements\n  skip: Int # Skip elements (for offset-based pagination)\n  cursor: String # Cursor (ID) for cursor-based pagination\n}"
          },
          "authPayload": {
            "title": "AuthPayload:",
            "code": "type AuthPayload {\n  token: String! # JWT access token\n  user: User! # Authenticated user data\n}"
          },
          "dateTimeJson": {
            "title": "DateTime, JSON:",
            "content": "Standard scalar types or custom scalars defined on the Backend."
          }
        },
        "operations": {
          "title": "2.2. Operations (Queries and Mutations): Access to System Functionality",
          "authentication": {
            "title": "2.2.1. Authentication",
            "registerUser": {
              "title": "`mutation registerUser(input: RegisterInput!): AuthPayload!`",
              "description": "Registers a new user in the system.",
              "input": "`RegisterInput`: `{ email: String!, password: String!, name: String! }` (password min 8 chars, digit, special char - see validation).",
              "authRequired": "Authentication required: No.",
              "scenario": "Scenario: User fills out the registration form.",
              "errors": "Errors: `400 Bad Request` (invalid data format/validation), `409 Conflict` (email already in use)."
            },
            "loginUser": {
              "title": "`mutation loginUser(input: LoginInput!): AuthPayload!`",
              "description": "Authenticates a user by email and password.",
              "input": "`LoginInput`: `{ email: String!, password: String! }`.",
              "authRequired": "Authentication required: No.",
              "scenario": "Scenario: User enters credentials to log in.",
              "errors": "Errors: `401 Unauthorized` (invalid email or password)."
            },
            "logoutUser": {
              "title": "`mutation logoutUser: Boolean!`",
              "description": "Invalidates the current JWT token on the server (if token storage or blacklisting is implemented).",
              "authRequired": "Authentication required: Yes (current token is used).",
              "scenario": "Scenario: User clicks \"Log Out\".",
              "returns": "Returns: `true` on successful logout.",
              "errors": "Errors: `401 Unauthorized` (invalid token)."
            }
          },
          "user": {
            "title": "2.2.2. User",
            "getUser": {
              "title": "`query getUser(id: ID!): User`",
              "description": "Retrieves user data by their unique ID.",
              "authRequired": "Authentication required: Yes (for accessing any user data, except possibly public profiles).",
              "scenario": "Scenario: Viewing a user's profile.",
              "errors": "Errors: `404 Not Found` (user with this ID not found)."
            },
            "getCurrentUser": {
              "title": "`query getCurrentUser: User!`",
              "description": "Retrieves data of the current authenticated user.",
              "authRequired": "Authentication required: Yes.",
              "scenario": "Scenario: Loading the current user's profile on app startup.",
              "errors": "Errors: `401 Unauthorized`."
            },
            "updateUser": {
              "title": "`mutation updateUser(id: ID!, input: UserInput!): User!`",
              "description": "Updates user profile data.",
              "input": "`UserInput`: `{ name: String, email: String, password: String, avatarUrl: String }`. Fields are optional.",
              "authRequired": "Authentication required: Yes (and the user must be the profile owner or have administrator rights).",
              "scenario": "Scenario: User edits their profile.",
              "errors": "Errors: `400 Bad Request` (invalid data format), `401 Unauthorized`, `403 Forbidden` (no rights to edit this user), `404 Not Found`."
            },
            "deleteUser": {
              "title": "`mutation deleteUser(id: ID!): Boolean!`",
              "description": "Deletes a user account.",
              "authRequired": "Authentication required: Yes (and the user must be the account owner).",
              "scenario": "Scenario: User decides to delete their account.",
              "returns": "Returns: `true` on successful deletion.",
              "errors": "Errors: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            }
          },
          "chats": {
            "title": "2.2.3. Chats",
            "getChats": {
              "title": "`query getChats: [Chat!]!`",
              "description": "Retrieves a list of all chats the current user participates in.",
              "authRequired": "Authentication required: Yes.",
              "scenario": "Scenario: Loading the chat list on the main screen.",
              "errors": "Errors: `401 Unauthorized`."
            },
            "getChat": {
              "title": "`query getChat(id: ID!): Chat`",
              "description": "Retrieves data of a specific chat by ID.",
              "authRequired": "Authentication required: Yes (and the user must be a participant of this chat).",
              "scenario": "Scenario: Opening a specific chat.",
              "errors": "Errors: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            },
            "createChat": {
              "title": "`mutation createChat(input: CreateChatInput!): Chat!`",
              "description": "Creates a new chat.",
              "input": "`CreateChatInput`: `{ type: String!, name: String, userIds: [ID!]! }`. `type` can be \"personal\", \"group\", \"channel\". `name` is required for \"group\" and \"channel\". `userIds` includes the creator's ID and other participants (for \"personal\" and \"group\").",
              "authRequired": "Authentication required: Yes.",
              "scenario": "Scenario: User creates a new chat or group.",
              "errors": "Errors: `400 Bad Request` (invalid type, missing userIds, etc.), `401 Unauthorized`, `403 Forbidden` (no rights to create this chat type)."
            },
            "getMessages": {
              "title": "`query getMessages(chatId: ID!, pagination: PaginationInput): [Message!]!`",
              "description": "Retrieves a list of messages for a given chat. Supports pagination.",
              "authRequired": "Authentication required: Yes (and the user must be a participant of the chat).",
              "scenario": "Scenario: Opening a chat, loading old messages on scroll.",
              "errors": "Errors: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            },
            "sendMessage": {
              "title": "`mutation sendMessage(chatId: ID!, content: String!, fileUrl: String, fileMetadata: JSON): Message!`",
              "description": "Sends a new message to a chat. Can contain text or a file link.",
              "input": "`chatId`: Chat ID. `content`: Message text. `fileUrl`: File URL in R2 (optional). `fileMetadata`: File metadata (optional).",
              "authRequired": "Authentication required: Yes (and the user must be a participant of the chat).",
              "scenario": "Scenario: User sends a text message or a file.",
              "errors": "Errors: `400 Bad Request`, `401 Unauthorized`, `403 Forbidden` (no rights to write to this chat), `404 Not Found` (chat not found)."
            },
            "deleteMessage": {
              "title": "`mutation deleteMessage(messageId: ID!): Boolean!`",
              "description": "Deletes a message.",
              "authRequired": "Authentication required: Yes (and the user must be the message sender or have chat administrator rights).",
              "scenario": "Scenario: User deletes their message.",
              "returns": "Returns: `true` on successful deletion.",
              "errors": "Errors: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`."
            }
          },
          "externalIntegrations": {
            "title": "2.2.4. External Integrations (via Backend API)",
            "sendVerificationCode": {
              "title": "`mutation sendVerificationCode(email: String!): Boolean!`",
              "description": "Initiates the process of sending a verification code to the specified email (using Gmail API). Used for registration or password reset.",
              "authRequired": "Authentication required: No.",
              "scenario": "Scenario: User enters email on the registration/password recovery screen.",
              "returns": "Returns: `true` if the sending task was successfully queued.",
              "errors": "Errors: `400 Bad Request` (invalid email format), `429 Too Many Requests` (spam protection)."
            },
            "verifyEmailCode": {
              "title": "`mutation verifyEmailCode(email: String!, code: String!): Boolean!`",
              "description": "Verifies the confirmation code received via email.",
              "authRequired": "Authentication required: No.",
              "scenario": "Scenario: User enters the code from email.",
              "returns": "Returns: `true` on successful verification.",
              "errors": "Errors: `400 Bad Request` (invalid code or email), `404 Not Found` (no active code for this email)."
            },
            "enableTwoFactorAuth": {
              "title": "`mutation enableTwoFactorAuth(userId: ID!): Boolean!`",
              "description": "Enables/disables two-factor authentication for a user. Requires prior email verification. The 2FA code is sent to email (Gmail API) with each login after activation.",
              "authRequired": "Authentication required: Yes (user must manage their account).",
              "scenario": "Scenario: User configures account security.",
              "errors": "Errors: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`, `400 Bad Request` (email not verified)."
            },
            "disableTwoFactorAuth": {
              "title": "`mutation disableTwoFactorAuth(userId: ID!): Boolean!`",
              "description": "Enables/disables two-factor authentication for a user. Requires prior email verification. The 2FA code is sent to email (Gmail API) with each login after activation.",
              "authRequired": "Authentication required: Yes (user must manage their account).",
              "scenario": "Scenario: User configures account security.",
              "errors": "Errors: `401 Unauthorized`, `403 Forbidden`, `404 Not Found`, `400 Bad Request` (email not verified)."
            },
            "sendTwoFactorCode": {
              "title": "`mutation sendTwoFactorCode(userId: ID!): Boolean!`",
              "description": "Sends a two-factor authentication code to the user's email.",
              "authRequired": "Authentication required: Partial (e.g., after password entry, but before 2FA code entry). Logic depends on the authentication flow.",
              "scenario": "Scenario: User logs into an account with 2FA enabled.",
              "errors": "Errors: `404 Not Found` (user not found or 2FA not enabled), `429 Too Many Requests`."
            },
            "createPaymentSession": {
              "title": "`mutation createPaymentSession(input: PaymentInput!): PaymentSessionPayload!`",
              "description": "Creates a payment session via Stripe for Premium subscription checkout.",
              "input": "`PaymentInput`: `{ planId: ID!, returnUrl: String! }` (ID of the selected tariff plan, URL for redirect after payment).",
              "authRequired": "Authentication required: Yes.",
              "scenario": "Scenario: User clicks \"Subscribe\" on the Premium screen.",
              "errors": "Errors: `400 Bad Request` (invalid planId), `401 Unauthorized`."
            }
          }
        }
      },
      "errorHandling": {
        "title": "3. API Error Handling: Clear Feedback (Principle 3, 14)",
        "description": "The API returns standardized errors for <strong>clear feedback</strong> (Principle 14) to the client and to maintain <strong>quality</strong> (Principle 3).",
        "errorFormatTitle": "Error format (according to GraphQL specification):",
        "errorFormatCode": "{\n  \"data\": null, // Usually null for top-level errors\n  \"errors\": [\n    {\n      \"message\": \"Error description (can be localized - see DocLocIn)\",\n      \"locations\": [...], // Error location in the query\n      \"path\": [...],      // Path to the field that caused the error\n      \"extensions\": {\n        \"code\": \"ERROR_CODE\", // Standardized error code (e.g., \"UNAUTHENTICATED\", \"FORBIDDEN\", \"BAD_USER_INPUT\", \"NOT_FOUND\")\n        \"http\": { // If applicable, HTTP status code\n          \"status\": 401,\n          \"headers\": {}\n        },\n         \"details\": {} // Additional error details (optional)\n      }\n    }\n    // ... other errors may exist\n  ]\n}",
        "keyErrorCodesTitle": "Key error codes (extensions.code):",
        "keyErrorCodesList": [
          "`UNAUTHENTICATED`: Authentication required, but token is missing or invalid (`HTTP 401`).",
          "`FORBIDDEN`: Authentication passed, but the user does not have rights to perform the operation (`HTTP 403`).",
          "`BAD_USER_INPUT`: Input data validation error (`HTTP 400`). Details can be in `extensions.details`.",
          "`NOT_FOUND`: The requested resource was not found (`HTTP 404`).",
          "`CONFLICT`: Data conflict (e.g., attempt to register an email that already exists) (`HTTP 409`).",
          "`INTERNAL_SERVER_ERROR`: Unexpected server error (`HTTP 500`).",
          "`RATE_LIMITED`: Request limit exceeded (`HTTP 429`)."
        ],
        "localizationErrorsTitle": "Error Localization:",
        "localizationErrorsContent": "Error messages (`message`) can be localized on the Backend side based on the `Accept-Language` header or user preferences (see DocLocIn)."
      },
      "notes": {
        "title": "4. Notes",
        "dataTypes": {
          "title": "Data Types:",
          "list": [
            "`ID`: Unique resource identifier (usually a string).",
            "`String`: Text string.",
            "`Int`, `Float`: Numbers.",
            "`Boolean`: Boolean value (`true`/`false`).",
            "`DateTime`: Date and time in ISO 8601 format (e.g., \"2025-03-14T10:30:00Z\").",
            "`JSON`: Custom scalar for passing arbitrary JSON objects (e.g., for `fileMetadata`).",
            "`!` at the end of a type means the field <strong>cannot be null</strong>."
          ]
        },
        "pagination": {
          "title": "Pagination:",
          "content": "For lists that can be long (`messages`), use pagination for efficient data loading (Principle 9)."
        },
        "validation": {
          "title": "Validation:",
          "content": "Backend performs strict validation of all input data (via DTO and `class-validator`), returning `BAD_USER_INPUT` errors if they are incorrect. This is part of the <strong>quality assurance system</strong> (Principle 3)."
        },
        "security": {
          "title": "Security:",
          "content": "All requests working with sensitive data or changing system state (except registration/login) require authentication."
        },
        "testingTools": {
          "title": "API Testing Tools:",
          "content": "Use GraphQL Playground (often available at `/graphql` in dev mode Backend), Postman, or Apollo Studio to send requests and test the API."
        }
      }
    },
    "technicalDocs": {
      "title": "BrainMessenger Technical Documentation (System and Foundation)",
      "subtitle": "General Information: Architecture of a Digital Asset",
      "generalInfo": {
        "title": "1. General Information: Architecture of a Digital Asset",
        "description": "BrainMessenger is a modern messenger built as a <strong>reliable, scalable, and secure system</strong> (Principle 9), which serves as a <strong>key digital ASSET</strong> (Principle 10). This document provides a high-level overview of the project's <strong>technical foundation</strong> (Principle 8), describing the main components, technologies, and their interaction.",
        "projectNameTitle": "Project Name:",
        "projectNameContent": "BrainMessenger",
        "purposeTitle": "Purpose:",
        "purposeContent": "To provide a general understanding of BrainMessenger's structure, the technology stack used, and the principles underlying its construction, for all team members and stakeholders.",
        "principlesTitle": "Principles reflected in the technical structure:",
        "principlesList": [
          "<strong>System and Optimization (Principle 9):</strong> The project is designed as a set of interconnected, optimized components.",
          "<strong>Long-Term Thinking (Principle 8):</strong> Selection of technologies and architecture considering future scaling and development needs.",
          "<strong>Quality > Quantity (Principle 3):</strong> Use of proven, reliable solutions and focus on code and infrastructure quality.",
          "<strong>Pragmatism and Realism (Principle 12):</strong> Use of ready-made services (Neon, R2, Firebase) where justified, instead of building everything from scratch.",
          "<strong>Value Creation (Principle 2):</strong> The technical structure aims to provide key messenger functions (communication, files, calls) at a high level."
        ]
      },
      "techStack": {
        "title": "2. Technology Stack: Tools for Building the System",
        "description": "We use a modern and flexible set of technologies, allowing us to effectively build and scale BrainMessenger.",
        "frontend": {
          "title": "Frontend (Client Applications):",
          "list": [
            "<strong>React Native (Android, Windows Desktop):</strong> A single codebase for mobile and desktop applications. Chosen for cross-platform compatibility and a large set of ready-made libraries.",
            "<strong>Next.js (Web):</strong> React-framework for web application with SSR/SSG support for performance and SEO.",
            "<strong>TypeScript:</strong> Strict typing for all Frontend code. Increases reliability and simplifies refactoring."
          ]
        },
        "backend": {
          "title": "Backend (Server Logic):",
          "list": [
            "<strong>Node.js:</strong> High-performance JavaScript/TypeScript runtime environment.",
            "<strong>NestJS:</strong> Modular framework for Node.js. Provides a structured architecture (modules, services, controllers/resolvers) and TypeScript support.",
            "<strong>GraphQL:</strong> API protocol. Allows clients to request exactly the data they need, reducing redundancy."
          ]
        },
        "databaseCaching": {
          "title": "Database and Caching:",
          "list": [
            "<strong>PostgreSQL (via Neon):</strong> Reliable relational DBMS. Used as the main storage for structured data (users, chats, messages, metadata). Neon provides a managed service with scaling and replication features.",
            "<strong>Prisma ORM:</strong> Tool for interacting with PostgreSQL from NestJS. Provides typing and query security.",
            "<strong>Redis:</strong> In-memory data store. Used for caching, Rate Limiting, managing WebSocket connection state (user presence)."
          ]
        },
        "fileStorage": {
          "title": "File Storage:",
          "list": [
            "<strong>Cloudflare R2:</strong> Object storage, compatible with S3 API. Used for storing user files (photos, videos, documents, avatars, call recordings), encrypted data. Chosen for low cost and no egress fees."
          ]
        },
        "asyncProcessing": {
          "title": "Asynchronous Processing:",
          "list": [
            "<strong>Kafka:</strong> Distributed message queue system. Used for reliable asynchronous task processing (e.g., image processing, sending notifications) outside the main API thread."
          ]
        },
        "infrastructureDeployment": {
          "title": "Infrastructure and Deployment:",
          "list": [
            "<strong>Docker:</strong> Application containerization. Provides isolation and portability.",
            "<strong>Kubernetes:</strong> Container orchestration. Manages deployment, scaling, and self-healing of services in a cluster.",
            "<strong>Terraform:</strong> Infrastructure as Code (IaC). Automates the creation and management of cloud resources."
          ]
        },
        "testingMonitoringLogging": {
          "title": "Testing, Monitoring, Logging:",
          "list": [
            "<strong>Jest, Cypress, Detox:</strong> Tools for unit, integration, and E2E testing.",
            "<strong>Prometheus, Grafana:</strong> Monitoring system. Collection and visualization of performance metrics and system status.",
            "<strong>Winston, Sentry:</strong> Logging and error tracking system."
          ]
        }
      },
      "architecture": {
        "title": "3. Project Architecture: Interconnection of System Components",
        "description": "BrainMessenger's architecture follows the principles of <strong>modularity and separation of concerns</strong> (Principle 9).",
        "clientApplications": {
          "title": "Client Applications (Frontend):",
          "list": [
            "Web (Next.js), Mobile & Desktop (React Native).",
            "Contain the user interface and user interaction logic.",
            "Interact with the Backend exclusively via <strong>GraphQL API</strong>.",
            "Can directly download files from Cloudflare R2 (if public access) or via Backend (if authentication or URL signing is required)."
          ]
        },
        "apiGateway": {
          "title": "API Gateway (In the future):",
          "content": "Single entry point for all client requests. Can perform authentication, Rate Limiting, routing to the necessary Backend services. At startup, the Backend itself acts as the Gateway."
        },
        "backendService": {
          "title": "Backend Service (NestJS):",
          "list": [
            "Main server component.",
            "Contains <strong>BrainMessenger's business logic</strong> (user management, chats, messages, calls, payments).",
            "Provides <strong>GraphQL API</strong> for client applications.",
            "Interacts with the <strong>Database (Neon/PostgreSQL via Prisma)</strong> for reading/writing structured data.",
            "Interacts with <strong>File Storage (Cloudflare R2)</strong> for uploading/retrieving files (via AWS SDK).",
            "Interacts with <strong>Cache (Redis)</strong> for fast operations.",
            "Queues tasks in <strong>Queue (Kafka)</strong> for asynchronous processing.",
            "Uses external services (Firebase, Stripe, Gmail API)."
          ]
        },
        "database": {
          "title": "Database (Neon/PostgreSQL):",
          "content": "Stores structured data. Scales independently."
        },
        "fileStorage": {
          "title": "File Storage (Cloudflare R2):",
          "content": "Stores unstructured binary data. Scales by volume."
        },
        "caching": {
          "title": "Caching (Redis):",
          "content": "Fast access to temporary data."
        },
        "messageQueue": {
          "title": "Message Queue (Kafka):",
          "content": "Buffering and reliable message delivery between services for asynchronous processing."
        },
        "workers": {
          "title": "Workers (Kafka Consumers):",
          "list": [
            "Separate services that read tasks from Kafka and perform heavy or long operations (image processing, sending large mailings).",
            "Scale independently."
          ]
        },
        "externalServices": {
          "title": "External Services (Firebase, Stripe, Gmail API):",
          "list": [
            "Provide specialized functionality (notifications, payments, email).",
            "Used by the Backend service."
          ]
        },
        "mermaidDiagram": {
          "title": "Architecture Diagram:",
          "code": "graph TD\n    A[Frontend Web (Next.js)] -->|GraphQL API| B(API Gateway / Backend);\n    A -->|Direct File Access (Opt.)| E(Cloudflare R2);\n    F[Frontend Mobile/Desktop (React Native)] -->|GraphQL API| B;\n    F -->|Direct File Access (Opt.)| E;\n    B -->|Prisma Queries/Mutations| C(Neon/PostgreSQL);\n    B -->|AWS SDK (S3 API)| E;\n    B -->|ioredis| D(Redis Cache);\n    B -->|kafkajs Producer| G(Kafka Queue);\n    B -->|Firebase Admin SDK| H(Firebase FCM);\n    B -->|Stripe SDK| I(Stripe);\n    B -->|Google APIs Client| J(Gmail API);\n    G -->|kafkajs Consumer| K(Kafka Workers);\n    K -->|sharp| K; % Image processing\n    K -->|AWS SDK (S3 API)| E;\n    K -->|GraphQL API / Other Service Calls| B; % Report completion, send chat message\n    C -->|Replication (for scaling)| C;\n    C -->|Partitioning/Sharding (for scaling)| C;\n    E -->|CDN| A; % File delivery to Frontend\n    Prometheus(Prometheus) -->|Scrape Metrics| B;\n    Prometheus -->|Scrape Metrics| C;\n    Prometheus -->|Scrape Metrics| D;\n    Prometheus -->|Scrape Metrics| G;\n    Grafana(Grafana) -->|Visualize Metrics| Prometheus;\n    Sentry(Sentry) -->|Error Reports| B;\n    Sentry -->|Error Reports| A;"
        }
      },
      "api": {
        "title": "4. API: Interaction Interface",
        "description": "BrainMessenger's API is implemented using GraphQL with NestJS.",
        "endpointTitle": "Endpoint:",
        "endpointContent": "`/graphql`",
        "structureTitle": "Structure:",
        "structureContent": "Defined by the GraphQL Schema (User, Chat, Message types, etc.) and a set of Queries (for data retrieval) and Mutations (for data modification).",
        "authenticationTitle": "Authentication:",
        "authenticationContent": "JWT tokens in the `Authorization: Bearer <token>` header.",
        "externalApiIntegrationsTitle": "External API Integrations:",
        "externalApiIntegrationsContent": "Interaction with external services (Gmail, Stripe) is done via the Backend, which provides corresponding Mutations in the GraphQL API (see API Specification).",
        "keyFunctionalAreas": {
          "title": "Key functional areas of the API:",
          "list": [
            "Authentication (registration, login, logout, 2FA).",
            "User management (get/update/delete profile).",
            "Chat management (create, get list, get chat data).",
            "Message handling (send text messages, send files, get history).",
            "Contact management.",
            "Application settings (theme, notifications, language).",
            "Premium subscription management.",
            "File management (upload to R2 via Backend).",
            "(In the future) Calls and video calls (call session management)."
          ]
        },
        "detailedSpecTitle": "Detailed API specification is described in:",
        "detailedSpecContent": "DocSpec.md"
      },
      "database": {
        "title": "5. Database (Neon/PostgreSQL): Main Data Storage",
        "description": "",
        "technologyTitle": "Technology:",
        "technologyContent": "PostgreSQL 15.x.",
        "hostingTitle": "Hosting:",
        "hostingContent": "Neon.",
        "roleTitle": "Role:",
        "roleContent": "Relational database for all structured data.",
        "keyTables": {
          "title": "Key tables (defined in backend/prisma/schema.prisma):",
          "list": [
            "User: User information (id, email, password_hash, name, avatarUrl, createdAt, updatedAt, is2FaEnabled).",
            "Chat: Chat information (id, type, name, createdAt, updatedAt, lastMessageAt).",
            "UserChat: Linking table for Many-to-Many relationship between User and Chat (userId, chatId, joinedAt, lastReadMessageId).",
            "Message: Messages in chats (id, chatId, senderId, content, fileUrl, fileMetadata (JSON), createdAt, updatedAt).",
            "Contact: User's contact list (id, userId, contactId).",
            "Transaction: Payment history (for Premium) (id, userId, amount, currency, status, provider, createdAt).",
            "Code: Temporary codes (for email verification, 2FA) (id, userId/email, code, type, expiresAt)."
          ]
        },
        "interactionTitle": "Interaction:",
        "interactionContent": "Backend only via Prisma ORM.",
        "optimizationScalingTitle": "Optimization and Scaling:",
        "optimizationScalingContent": "Indexes, Prisma query optimization, materialized views, partitioning, replication are used (see DocOptimizationIn)."
      },
      "fileStorage": {
        "title": "6. File Storage (Cloudflare R2): Storage for Media and Binary Assets",
        "description": "",
        "technologyTitle": "Technology:",
        "technologyContent": "Object storage, S3-compatible API.",
        "hostingTitle": "Hosting:",
        "hostingContent": "Cloudflare R2.",
        "roleTitle": "Role:",
        "roleContent": "Storage for all unstructured data (user files, avatars, call recordings).",
        "interactionTitle": "Interaction:",
        "interactionContent": "Backend uploads files, Backend or Frontend retrieves files (directly or via signed URLs).",
        "structureTitle": "Structure:",
        "structureContent": "Files are organized by folders/keys (e.g., `avatars/`, `chat-images/`, `sensitive-data/`).",
        "securityTitle": "Security:",
        "securityContent": "Encryption at rest, restricted access, encryption of sensitive data at the application level before upload (see DocInt, DocSecurity)."
      },
      "projectStructure": {
        "title": "7. Project Structure (Monorepository): Code Organization",
        "description": "The project is organized as a monorepository using Turborepo.",
        "purposeTitle": "Purpose:",
        "purposeContent": "To simplify managing multiple applications/packages (backend, web, mobile-desktop, core) and code reuse.",
        "packages": {
          "title": "Packages:",
          "list": [
            "core: Common code.",
            "backend: Server logic.",
            "web: Web application.",
            "mobile-desktop: Mobile/desktop application (React Native).",
            "Infrastructure: Configuration files for deployment (infrastructure/).",
            "Documentation: Project documentation (docs/)."
          ]
        },
        "detailedDescriptionTitle": "Detailed description of the monorepository structure can be found in:",
        "detailedDescriptionContent": "DocDevIn.md (section 2)."
      },
      "security": {
        "title": "8. Security: Fundamental Aspect of the System",
        "description": "Security is built in at all levels (see more in BrainMessenger Security Guide).",
        "authenticationTitle": "Authentication:",
        "authenticationContent": "JWT, 2FA via email.",
        "authorizationTitle": "Authorization:",
        "authorizationContent": "Access rights verification for resources on the Backend.",
        "encryptionTitle": "Encryption:",
        "encryptionContent": "TLS/SSL for data transfer, password hashing (bcrypt/argon2), encryption of sensitive data at the application level before storing in R2.",
        "validationTitle": "Validation:",
        "validationContent": "Strict input data validation on the Backend.",
        "attackProtectionTitle": "Protection against Attacks:",
        "attackProtectionContent": "Rate Limiting, secure HTTP headers.",
        "principleTitle": "Principle:",
        "principleContent": "Security is a continuous process of learning (Principle 1) and improvement (Principle 9), based on responsibility (Principle 6)."
      },
      "deployment": {
        "title": "9. Deployment: Delivering the System to Users",
        "description": "The deployment process is automated.",
        "containerizationTitle": "Containerization:",
        "containerizationContent": "Docker images for Backend, Kafka Consumers.",
        "orchestrationTitle": "Orchestration:",
        "orchestrationContent": "Kubernetes manages containers in the cloud.",
        "iacTitle": "Infrastructure as Code:",
        "iacContent": "Terraform (IaC). Automates the creation and management of cloud resources.",
        "ciCdTitle": "CI/CD:",
        "ciCdContent": "GitHub Actions automates build, testing, and deployment.",
        "webAppDeploymentTitle": "Web application can be deployed separately (e.g., on Vercel or Cloudflare Pages).",
        "webAppDeploymentContent": "",
        "detailedDescriptionTitle": "Detailed description of the deployment process can be found in:",
        "detailedDescriptionList": [
          "DocDevIn.md (section 9)",
          "Deployment Guide"
        ]
      },
      "monitoringLogging": {
        "title": "10. Monitoring and Logging: Visibility into System State",
        "description": "",
        "monitoringTitle": "Monitoring:",
        "monitoringList": [
          "Collection and visualization of performance and system health metrics (CPU, RAM, API/DB latencies, errors).",
          "Tools: Prometheus, Grafana. Allows early problem detection (Principle 9: Kaizen)."
        ],
        "loggingTitle": "Logging:",
        "loggingList": [
          "Collection of structured logs from all components (Backend, workers).",
          "Tools: Winston (for Node.js), Sentry (for error tracking)."
        ],
        "detailedDescriptionTitle": "Detailed description can be found in:",
        "detailedDescriptionList": [
          "BrainMessenger Optimization Guide (section 14)",
          "Monitoring Guide"
        ]
      },
      "externalApiIntegrations": {
        "title": "11. External API Integrations: Using External Levers",
        "description": "The Backend interacts with several external services via their APIs.",
        "gmailApiTitle": "Gmail API:",
        "gmailApiContent": "Sending transactional emails (confirmation, 2FA).",
        "stripeTitle": "Stripe:",
        "stripeContent": "Payment processing and subscriptions.",
        "firebaseFCMTitle": "Firebase FCM:",
        "firebaseFCMContent": "Sending push notifications to mobile devices.",
        "principleTitle": "Principle:",
        "principleContent": "Using these services is a pragmatic (Principle 12) way to quickly add functionality, using ready-made, reliable (Principle 3) solutions.",
        "detailedDescriptionTitle": "Detailed description of integrations can be found in:",
        "detailedDescriptionContent": "DocInt.md"
      },
      "notes": {
        "title": "12. Notes",
        "description": "This documentation provides a high-level overview of the BrainMessenger technical system. For a more detailed understanding of individual parts, refer to related documents:",
        "apiSpecLinkTitle": "API Specification:",
        "apiSpecLinkContent": "DocSpec.md",
        "devGuideLinkTitle": "Development Guide:",
        "devGuideLinkContent": "DocDevIn.md",
        "optimizationGuideLinkTitle": "Optimization Guide:",
        "optimizationGuideLinkContent": "DocOptimizationIn.md",
        "integrationsDocsLinkTitle": "Integrations Documentation:",
        "integrationsDocsLinkContent": "DocInt.md",
        "designDocsLinkTitle": "Design Documentation:",
        "designDocsLinkContent": "DocDesign.md",
        "userGuideLinkTitle": "User Guide:",
        "userGuideLinkContent": "DocUser.md",
        "longTermInvestmentTitle": "Development and maintenance of this technical system is a long-term investment (Principle 8) and a continuous process of learning and improvement (Principle 1, 9)."
      }
    }
  },
  "footer": {
    "sectionTitle": {
      "brand": "BrainMessenger"
    },
    "brandContent": "Your Smart Communication Platform",
    "copyright": "© 2025 BrainMessenger. All rights reserved."
  }
}
}
